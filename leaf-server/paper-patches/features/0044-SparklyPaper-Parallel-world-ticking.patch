From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrPowerGamerBR <git@mrpowergamerbr.com>
Date: Sun, 25 May 2025 21:39:32 -0300
Subject: [PATCH] SparklyPaper: Parallel world ticking

Original project: https://github.com/SparklyPower/SparklyPaper

Co-authored-by: Altiami <yoshimo.kristin@gmail.com>
Co-authored-by: Taiyou06 <kaandindar21@gmail.com>
Co-authored-by: MrlingXD <90316914+wling-art@users.noreply.github.com>

Commit: e2e154fb764650c90bbd23c9cede2b11ba1a08e2

diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
index 69cdd304d255d52c9b7dc9b6a33ffdb630b79abe..dd3c6019710651c3ca8426842e684f388d748fda 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/TickThread.java
@@ -14,6 +14,7 @@ import java.util.concurrent.atomic.AtomicInteger;
 public class TickThread extends Thread {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(TickThread.class);
+    private static final boolean HARD_THROW = !org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled || !org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.disableHardThrow; // Leaf - SparklyPaper - parallel world ticking - THIS SHOULD NOT BE DISABLED SINCE IT CAN CAUSE DATA CORRUPTION!!! Anyhow, for production servers, if you want to make a test run to see if the server could crash, you can test it with this disabled
 
     private static String getThreadContext() {
         return "thread=" + Thread.currentThread().getName();
@@ -26,6 +27,7 @@ public class TickThread extends Thread {
     public static void ensureTickThread(final String reason) {
         if (!isTickThread()) {
             LOGGER.error("Thread failed main thread check: " + reason + ", context=" + getThreadContext(), new Throwable());
+            if (HARD_THROW) // Leaf - SparklyPaper - parallel world ticking
             throw new IllegalStateException(reason);
         }
     }
@@ -34,8 +36,11 @@ public class TickThread extends Thread {
         if (!isTickThreadFor(world, pos)) {
             final String ex = "Thread failed main thread check: " +
                                reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + ", block_pos=" + pos;
-            LOGGER.error(ex, new Throwable());
-            throw new IllegalStateException(ex);
+            // Leaf start - SparklyPaper - parallel world ticking
+            final String threadInfo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? ex + " - " + getTickThreadInformation(world.getServer()) : ex;
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+            // Leaf end - SparklyPaper - parallel world ticking
         }
     }
 
@@ -43,8 +48,11 @@ public class TickThread extends Thread {
         if (!isTickThreadFor(world, pos, blockRadius)) {
             final String ex = "Thread failed main thread check: " +
                 reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + ", block_pos=" + pos + ", block_radius=" + blockRadius;
-            LOGGER.error(ex, new Throwable());
-            throw new IllegalStateException(ex);
+            // Leaf start - SparklyPaper - parallel world ticking
+            final String threadInfo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? ex + " - " + getTickThreadInformation(world.getServer()) : ex;
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+            // Leaf end - SparklyPaper - parallel world ticking
         }
     }
 
@@ -52,8 +60,11 @@ public class TickThread extends Thread {
         if (!isTickThreadFor(world, pos)) {
             final String ex = "Thread failed main thread check: " +
                 reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + ", chunk_pos=" + pos;
-            LOGGER.error(ex, new Throwable());
-            throw new IllegalStateException(ex);
+            // Leaf start - SparklyPaper - parallel world ticking
+            final String threadInfo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? ex + " - " + getTickThreadInformation(world.getServer()) : ex;
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+            // Leaf end - SparklyPaper - parallel world ticking
         }
     }
 
@@ -61,8 +72,11 @@ public class TickThread extends Thread {
         if (!isTickThreadFor(world, chunkX, chunkZ)) {
             final String ex = "Thread failed main thread check: " +
                 reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + ", chunk_pos=" + new ChunkPos(chunkX, chunkZ);
-            LOGGER.error(ex, new Throwable());
-            throw new IllegalStateException(ex);
+            // Leaf start - SparklyPaper - parallel world ticking
+            final String threadInfo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? ex + " - " + getTickThreadInformation(world.getServer()) : ex;
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+            // Leaf end - SparklyPaper - parallel world ticking
         }
     }
 
@@ -70,8 +84,11 @@ public class TickThread extends Thread {
         if (!isTickThreadFor(entity)) {
             final String ex = "Thread failed main thread check: " +
                 reason + ", context=" + getThreadContext() + ", entity=" + EntityUtil.dumpEntity(entity);
-            LOGGER.error(ex, new Throwable());
-            throw new IllegalStateException(ex);
+            // Leaf start - SparklyPaper - parallel world ticking
+            final String threadInfo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? ex + " - " + getTickThreadInformation(entity.level().getServer()) : ex;
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+            // Leaf end - SparklyPaper - parallel world ticking
         }
     }
 
@@ -79,8 +96,11 @@ public class TickThread extends Thread {
         if (!isTickThreadFor(world, aabb)) {
             final String ex = "Thread failed main thread check: " +
                 reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + ", aabb=" + aabb;
-            LOGGER.error(ex, new Throwable());
-            throw new IllegalStateException(ex);
+            // Leaf start - SparklyPaper - parallel world ticking
+            final String threadInfo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? ex + " - " + getTickThreadInformation(world.getServer()) : ex;
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+            // Leaf end - SparklyPaper - parallel world ticking
         }
     }
 
@@ -88,11 +108,67 @@ public class TickThread extends Thread {
         if (!isTickThreadFor(world, blockX, blockZ)) {
             final String ex = "Thread failed main thread check: " +
                 reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + ", block_pos=" + new Vec3(blockX, 0.0, blockZ);
-            LOGGER.error(ex, new Throwable());
-            throw new IllegalStateException(ex);
+            // Leaf start - SparklyPaper - parallel world ticking
+            final String threadInfo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? ex + " - " + getTickThreadInformation(world.getServer()) : ex;
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+            // Leaf end - SparklyPaper - parallel world ticking
         }
     }
 
+    // Leaf start - SparklyPaper - parallel world ticking
+    // Copied from `TickThread#ensureTickThread(final String reason)`
+    // This is an additional method to check if the tick thread is bound to a specific world because, by default, Paper's isTickThread methods do not provide this information
+    // Because we only tick worlds in parallel (instead of regions), we can use this for our checks
+    public static void ensureTickThread(final net.minecraft.server.level.ServerLevel world, final String reason) {
+        if (!isTickThreadFor(world)) {
+            final String threadInfo = "Thread failed main thread check: " + reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + " - " + getTickThreadInformation(world.getServer());
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+        }
+    }
+
+    // This is an additional method to check if it is a tick thread but ONLY a tick thread
+    public static void ensureOnlyTickThread(final String reason) {
+        if (!isTickThread() || isServerLevelTickThread()) {
+            final String threadInfo = "Thread failed tick-thread-only check: " + reason + ", context=" + getThreadContext();
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+        }
+    }
+
+    // This is an additional method to check if the tick thread is bound to a specific world or if it is an async thread.
+    public static void ensureTickThreadOrAsyncThread(final net.minecraft.server.level.ServerLevel world, final String reason) {
+        if (isTickThread() && !isTickThreadFor(world)) {
+            final String threadInfo = "Thread failed main thread or async thread check: " + reason + ", context=" + getThreadContext() + ", world=" + WorldUtil.getWorldName(world) + " - " + getTickThreadInformation(world.getServer());
+            LOGGER.error(threadInfo, new Throwable());
+            if (HARD_THROW) throw new IllegalStateException(threadInfo);
+        }
+    }
+
+    private static String getTickThreadInformation(net.minecraft.server.MinecraftServer minecraftServer) {
+        StringBuilder sb = new StringBuilder();
+        Thread currentThread = Thread.currentThread();
+        sb.append("Is tick thread? ");
+        sb.append(currentThread instanceof TickThread);
+        sb.append("; Is server level tick thread? ");
+        sb.append(currentThread instanceof ServerLevelTickThread);
+        if (currentThread instanceof ServerLevelTickThread serverLevelTickThread) {
+            sb.append("; Currently ticking level: ");
+            sb.append(serverLevelTickThread.currentTickingServerLevel != null ? serverLevelTickThread.currentTickingServerLevel.getWorld().getName() : "null");
+        }
+        sb.append("; Is iterating over levels? ");
+        sb.append(minecraftServer.isIteratingOverLevels);
+        sb.append("; Are we going to hard throw? ");
+        sb.append(HARD_THROW);
+        return sb.toString();
+    }
+
+    public static boolean isServerLevelTickThread() {
+        return Thread.currentThread() instanceof ServerLevelTickThread;
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
+
     public final int id; /* We don't override getId as the spec requires that it be unique (with respect to all other threads) */
 
     private static final AtomicInteger ID_GENERATOR = new AtomicInteger();
@@ -127,46 +203,70 @@ public class TickThread extends Thread {
     }
 
     public static boolean isTickThreadFor(final Level world, final BlockPos pos) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final BlockPos pos, final int blockRadius) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final ChunkPos pos) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final Vec3 pos) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final int chunkX, final int chunkZ) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final AABB aabb) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final double blockX, final double blockZ) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final Vec3 position, final Vec3 deltaMovement, final int buffer) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final int fromChunkX, final int fromChunkZ, final int toChunkX, final int toChunkZ) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Level world, final int chunkX, final int chunkZ, final int radius) {
-        return isTickThread();
+        return isTickThreadFor(world); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
     }
 
     public static boolean isTickThreadFor(final Entity entity) {
+        return isTickThreadFor(entity.level()); // Leaf - SparklyPaper - parallel world ticking - use methods for what they were made for
+    }
+
+    // Leaf start - SparklyPaper - parallel world ticking
+    // This is an additional method to check if the tick thread is bound to a specific world because, by default, Paper's isTickThread methods do not provide this information
+    // Because we only tick worlds in parallel (instead of regions), we can use this for our checks
+    public static boolean isTickThreadFor(final Level world) {
+        if (Thread.currentThread() instanceof ServerLevelTickThread serverLevelTickThread) {
+            return serverLevelTickThread.currentTickingServerLevel == world;
+        }
         return isTickThread();
     }
+
+    public static class ServerLevelTickThread extends TickThread {
+
+        public net.minecraft.server.level.ServerLevel currentTickingServerLevel;
+
+        public ServerLevelTickThread(String name) {
+            super(name);
+        }
+
+        public ServerLevelTickThread(Runnable run, String name) {
+            super(run, name);
+        }
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 01719a81cea75654a0d7eac52fd43ebf2d692b9c..e1638106d5e4ae9968599f7e908ac246d31fd970 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -458,7 +458,13 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
 
     private boolean unloadChunk0(int x, int z, boolean save) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk unload"); // Spigot
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot unload chunk asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
+        } else {
+            org.spigotmc.AsyncCatcher.catchOp("chunk unload"); // Spigot
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
         if (!this.isChunkLoaded(x, z)) {
             return true;
         }
@@ -475,6 +481,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean refreshChunk(int x, int z) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot refresh chunk asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         ChunkHolder playerChunk = this.world.getChunkSource().chunkMap.getVisibleChunkIfPresent(ChunkPos.asLong(x, z));
         if (playerChunk == null) return false;
 
@@ -525,7 +532,13 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean loadChunk(int x, int z, boolean generate) {
-        org.spigotmc.AsyncCatcher.catchOp("chunk load"); // Spigot
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.getHandle(), x, z, "May not sync load chunks asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
+        } else {
+            org.spigotmc.AsyncCatcher.catchOp("chunk load"); // Spigot
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
         warnUnsafeChunk("loading a faraway chunk", x, z); // Paper
         ChunkAccess chunk = this.world.getChunkSource().getChunk(x, z, generate || isChunkGenerated(x, z) ? ChunkStatus.FULL : ChunkStatus.EMPTY, true); // Paper
 
@@ -738,6 +751,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, loc.getX(), loc.getZ(), "Cannot generate tree asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.world.captureTreeGeneration = true;
         this.world.captureBlockStates = true;
         boolean grownTree = this.generateTree(loc, type);
@@ -839,6 +853,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     private boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks, Entity source, Consumer<net.minecraft.world.level.ServerExplosion> configurator) {
         // Paper end - expand explosion API
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x, z, "Cannot create explosion asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         net.minecraft.world.level.Level.ExplosionInteraction explosionType;
         if (!breakBlocks) {
             explosionType = net.minecraft.world.level.Level.ExplosionInteraction.NONE; // Don't break blocks
@@ -897,6 +912,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public int getHighestBlockYAt(int x, int z, org.bukkit.HeightMap heightMap) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, x >> 4, z >> 4, "Cannot retrieve chunk asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         warnUnsafeChunk("getting a faraway chunk", x >> 4, z >> 4); // Paper
         // Transient load for this tick
         return this.world.getChunk(x >> 4, z >> 4).getHeight(CraftHeightMap.toNMS(heightMap), x, z);
@@ -912,6 +928,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     @Override
     public void setBiome(int x, int y, int z, Holder<net.minecraft.world.level.biome.Biome> bb) {
         BlockPos pos = new BlockPos(x, 0, z);
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, pos, "Cannot retrieve chunk asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         if (this.world.hasChunkAt(pos)) {
             net.minecraft.world.level.chunk.LevelChunk chunk = this.world.getChunkAt(pos);
 
@@ -1874,6 +1891,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
 
     @Override
     public void sendGameEvent(Entity sourceEntity, org.bukkit.GameEvent gameEvent, Vector position) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.world, position.getX(), position.getZ(), "Cannot send game event asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         getHandle().gameEvent(sourceEntity != null ? ((CraftEntity) sourceEntity).getHandle(): null, net.minecraft.core.registries.BuiltInRegistries.GAME_EVENT.get(org.bukkit.craftbukkit.util.CraftNamespacedKey.toMinecraft(gameEvent.getKey())).orElseThrow(), org.bukkit.craftbukkit.util.CraftVector.toBlockPos(position));
     }
     // Paper end
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index 26feb76c52631e77b8529e4da1e54e1c703ea001..6dd4664a36ea993c36fad60ff0032c8c3f8a33f7 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -33,6 +33,33 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
     private final T snapshot;
     public boolean snapshotDisabled; // Paper
     public static boolean DISABLE_SNAPSHOT = false; // Paper
+    private static final ThreadLocal<Boolean> DISABLE_SNAPSHOT_TL = ThreadLocal.withInitial(() -> Boolean.FALSE); // Leaf - SparklyPaper - parallel world ticking
+
+    // Leaf start - SparklyPaper - parallel world ticking
+    // refer to original field in case plugins attempt to modify it
+    public static boolean getDisableSnapshotTL() {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            if (DISABLE_SNAPSHOT_TL.get()) return true;
+            synchronized (CraftBlockEntityState.class) {
+                return DISABLE_SNAPSHOT;
+            }
+        } else {
+            return DISABLE_SNAPSHOT;
+        }
+    }
+
+    // update original field in case plugins attempt to access it
+    public static void setDisableSnapshotTL(boolean value) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            DISABLE_SNAPSHOT_TL.set(value);
+            synchronized (CraftBlockEntityState.class) {
+                DISABLE_SNAPSHOT = value;
+            }
+        } else {
+            DISABLE_SNAPSHOT =  value;
+        }
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
 
     public CraftBlockEntityState(World world, T blockEntity) {
         super(world, blockEntity.getBlockPos(), blockEntity.getBlockState());
@@ -41,8 +68,8 @@ public abstract class CraftBlockEntityState<T extends BlockEntity> extends Craft
 
         try { // Paper - Show blockstate location if we failed to read it
         // Paper start
-        this.snapshotDisabled = DISABLE_SNAPSHOT;
-        if (DISABLE_SNAPSHOT) {
+        this.snapshotDisabled = getDisableSnapshotTL(); // Leaf - SparklyPaper - parallel world ticking
+        if (this.snapshotDisabled) { // Leaf - SparklyPaper - parallel world ticking
             this.snapshot = this.blockEntity;
         } else {
             this.snapshot = this.createSnapshot(blockEntity);
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
index 3036f3fa8b58607e2abbe1cbec065c7b78bdc025..402ddbd2c07634ff1551723089b5321d849c231f 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockState.java
@@ -219,6 +219,12 @@ public class CraftBlockState implements BlockState {
         LevelAccessor access = this.getWorldHandle();
         CraftBlock block = this.getBlock();
 
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && access instanceof net.minecraft.server.level.ServerLevel serverLevel) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverLevel, position, "Cannot modify world asynchronously");
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
+
         if (block.getType() != this.getType()) {
             if (!force) {
                 return false;
@@ -366,6 +372,7 @@ public class CraftBlockState implements BlockState {
 
     @Override
     public java.util.Collection<org.bukkit.inventory.ItemStack> getDrops(org.bukkit.inventory.ItemStack item, org.bukkit.entity.Entity entity) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(world.getHandle(), position, "Cannot modify world asynchronously"); // Leaf - SparklyPaper - parallel world ticking
         this.requirePlaced();
         net.minecraft.world.item.ItemStack nms = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(item);
 
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
index 53346c7364bbf507693cb769b2a49f77bb991f84..ac56dbb9db9b49cd856f2e2567a7ac1be55293ef 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockStates.java
@@ -196,14 +196,14 @@ public final class CraftBlockStates {
         BlockPos pos = craftBlock.getPosition();
         net.minecraft.world.level.block.state.BlockState state = craftBlock.getNMS();
         BlockEntity blockEntity = craftBlock.getHandle().getBlockEntity(pos);
-        boolean prev = CraftBlockEntityState.DISABLE_SNAPSHOT;
-        CraftBlockEntityState.DISABLE_SNAPSHOT = !useSnapshot;
+        boolean prev = CraftBlockEntityState.getDisableSnapshotTL(); // Leaf - SparklyPaper - parallel world ticking
+        CraftBlockEntityState.setDisableSnapshotTL(!useSnapshot); // Leaf - SparklyPaper - parallel world ticking
         try {
             CraftBlockState blockState = CraftBlockStates.getBlockState(world, pos, state, blockEntity);
             blockState.setWorldHandle(craftBlock.getHandle()); // Inject the block's generator access
             return blockState;
         } finally {
-            CraftBlockEntityState.DISABLE_SNAPSHOT = prev;
+            CraftBlockEntityState.setDisableSnapshotTL(prev); // Leaf - SparklyPaper - parallel world ticking
         }
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
index de1ffa1f2a8b8331f484a7a6546f4b29e2c853c6..138d8c1f78dea434cb7f1b8b1e39bdf38e55e58a 100644
--- a/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
+++ b/src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
@@ -947,6 +947,34 @@ public class CraftEventFactory {
     }
 
     public static BlockPos sourceBlockOverride = null; // SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPos up to five methods deep.
+    private static final ThreadLocal<BlockPos> SOURCE_BLOCK_OVERRIDE_RT = new ThreadLocal<>(); // Leaf - SparklyPaper - parallel world ticking (this is from Folia, fixes concurrency bugs with sculk catalysts)
+
+    // Leaf start - SparklyPaper - parallel world ticking
+    // refer to original field in case plugins attempt to modify it
+    public static BlockPos getSourceBlockOverrideRT() {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            final BlockPos sourceBlockOverrideRTCopy = SOURCE_BLOCK_OVERRIDE_RT.get();
+            if (sourceBlockOverrideRTCopy != null) return sourceBlockOverrideRTCopy;
+            synchronized (CraftEventFactory.class) {
+                return sourceBlockOverride;
+            }
+        } else {
+            return sourceBlockOverride;
+        }
+    }
+
+    // update original field in case plugins attempt to access it
+    public static void setSourceBlockOverrideRT(BlockPos value) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            SOURCE_BLOCK_OVERRIDE_RT.set(value);
+            synchronized (CraftEventFactory.class) {
+                sourceBlockOverride = value;
+            }
+        } else {
+            sourceBlockOverride = value;
+        }
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
 
     public static boolean handleBlockSpreadEvent(LevelAccessor world, BlockPos source, BlockPos target, net.minecraft.world.level.block.state.BlockState state, @net.minecraft.world.level.block.Block.UpdateFlags int flags) {
         return handleBlockSpreadEvent(world, source, target, state, flags, false);
@@ -962,7 +990,10 @@ public class CraftEventFactory {
         CraftBlockState snapshot = CraftBlockStates.getBlockState(world, target);
         snapshot.setData(state);
 
-        BlockSpreadEvent event = new BlockSpreadEvent(snapshot.getBlock(), CraftBlock.at(world, CraftEventFactory.sourceBlockOverride != null ? CraftEventFactory.sourceBlockOverride : source), snapshot);
+        // Leaf start - SparklyPaper parallel world ticking
+        final BlockPos sourceBlockOverrideRTSnap = getSourceBlockOverrideRT();
+        BlockSpreadEvent event = new BlockSpreadEvent(snapshot.getBlock(), CraftBlock.at(world, sourceBlockOverrideRTSnap != null ? sourceBlockOverrideRTSnap : source), snapshot);
+        // Leaf end - SparklyPaper parallel world ticking
         if (event.callEvent()) {
             boolean result = snapshot.place(flags);
             return !checkSetResult || result;
