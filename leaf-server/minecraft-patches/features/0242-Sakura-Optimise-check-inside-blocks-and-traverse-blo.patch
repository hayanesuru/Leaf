From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <kfian294ma4@gmail.com>
Date: Fri, 8 Nov 2024 19:35:49 +0000
Subject: [PATCH] Sakura: Optimise check inside blocks and traverse blocks

Dreeam TODO: refactor checkinsideblcoks

diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index 1db32873588673900a8afa9767c3af12c7b6742a..5d1027cb511be78b1e29d0e3bdc49cc9d6add346 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1697,6 +1697,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     private void checkInsideBlocks(List<Entity.Movement> movements, InsideBlockEffectApplier.StepBasedCollector stepBasedCollector) {
         if (this.isAffectedByBlocks()) {
             LongSet set = this.visitedBlocks;
+            final net.minecraft.world.level.chunk.ChunkAccess[] chunkCache = new net.minecraft.world.level.chunk.ChunkAccess[4]; // Sakura - optimise check inside blocks
 
             for (Entity.Movement movement : movements) {
                 Vec3 vec3 = movement.from();
@@ -1708,7 +1709,20 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                     aabb,
                     (pos, step) -> {
                         if (this.isAlive()) {
-                            BlockState blockState = this.level().getBlockState(pos);
+                            // Sakura start - optimise check inside blocks
+                            final int chunkX = pos.getX() >> 4;
+                            final int chunkZ = pos.getZ() >> 4;
+                            final int chunkKey = ((chunkX << 2) | chunkZ) & 3;
+                            net.minecraft.world.level.chunk.ChunkAccess chunk = chunkCache[chunkKey];
+                            if (chunk == null || chunk.locX != chunkX || chunk.locZ != chunkZ) {
+                                chunk = this.level().getChunkIfLoadedImmediately(chunkX, chunkZ);
+                                if (chunk == null) {
+                                    return;
+                                }
+                                chunkCache[chunkKey] = chunk;
+                            }
+                            final BlockState blockState = chunk.getBlockState(pos);
+                            // Sakura end - optimise check inside blocks
                             if (!blockState.isAir()) {
                                 if (set.add(pos.asLong())) {
                                     VoxelShape entityInsideCollisionShape = blockState.getEntityInsideCollisionShape(this.level(), pos, this);
diff --git a/net/minecraft/world/level/BlockGetter.java b/net/minecraft/world/level/BlockGetter.java
index dd7e32b8b176c0f4c13e50aeed33c2c9ccba4b53..ee514d457b5c2df912daeebb5fb8b824b5496b0e 100644
--- a/net/minecraft/world/level/BlockGetter.java
+++ b/net/minecraft/world/level/BlockGetter.java
@@ -215,18 +215,30 @@ public interface BlockGetter extends LevelHeightAccessor {
     static void forEachBlockIntersectedBetween(Vec3 from, Vec3 to, AABB boundingBox, BlockGetter.BlockStepVisitor stepVisitor) {
         Vec3 vec3 = to.subtract(from);
         if (!(vec3.lengthSqr() < Mth.square(0.99999F))) {
+            // Sakura start - optimise check inside blocks
+            final boolean xZero = vec3.x() == 0.0;
+            final boolean yZero = vec3.y() == 0.0;
+            final boolean zZero = vec3.z() == 0.0;
+            if (xZero && yZero || yZero && zZero || xZero && zZero) {
+                int blockIndex = 0;
+                for (BlockPos blockPos : org.dreeam.leaf.util.map.BlockPosIterator.traverseArea(vec3, boundingBox)) {
+                    stepVisitor.visit(blockPos, blockIndex++);
+                }
+                return;
+            }
+            // Sakura end - optimise check inside blocks
             LongSet set = new LongOpenHashSet();
             Vec3 minPosition = boundingBox.getMinPosition();
             Vec3 vec31 = minPosition.subtract(vec3);
             int i = addCollisionsAlongTravel(set, vec31, minPosition, boundingBox, stepVisitor);
 
-            for (BlockPos blockPos1 : BlockPos.betweenClosed(boundingBox)) {
+            for (BlockPos blockPos1 : org.dreeam.leaf.util.map.BlockPosIterator.iterable(boundingBox)) { // Sakura - optimise check inside blocks
                 if (!set.contains(blockPos1.asLong())) {
                     stepVisitor.visit(blockPos1, i + 1);
                 }
             }
         } else {
-            for (BlockPos blockPos : BlockPos.betweenClosed(boundingBox)) {
+            for (BlockPos blockPos : org.dreeam.leaf.util.map.BlockPosIterator.iterable(boundingBox)) { // Sakura - optimise check inside blocks
                 stepVisitor.visit(blockPos, 0);
             }
         }
