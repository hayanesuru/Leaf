From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Github Actions <no-reply@github.com>
Date: Wed, 7 Jan 2026 23:55:32 +0000
Subject: [PATCH] Purpur Server Minecraft Changes

Original license: MIT
Original project: https://github.com/PurpurMC/Purpur

Commit: d0b1b32e6f97c7a69bcebe04544589078133f0a9

Patches listed below are removed in this patch, They exists in Gale or Leaf:
* "net/minecraft/CrashReport.java.patch"
    - Rebrand
* "net/minecraft/commands/Commands.java.patch"
    - Skip events if there's no listeners
* "net/minecraft/network/chat/SignedMessageChain.java.patch"
    - Option to disable kick for out of order chat
* "net/minecraft/server/MinecraftServer.java.patch"
    - Add 5 second tps average in /tps
    - Configurable server mod name
* "net/minecraft/server/PlayerAdvancements.java.patch"
    - Logger settings (suppressing pointless logs)
* "net/minecraft/server/gui/StatsComponent.java.patch"
    - Add 5 second tps average in /tps
* "net/minecraft/server/level/WorldGenRegion.java.patch"
    - Logger settings (suppressing pointless logs)
* "net/minecraft/server/network/ServerCommonPacketListenerImpl.java.patch"
    - Alternative Keepalive Handling
* "net/minecraft/server/network/ServerStatusPacketListenerImpl.java.patch"
    - Fix 'outdated server' showing in ping before server fully boots
* "net/minecraft/stats/ServerRecipeBook.java.patch"
    - Logger settings (suppressing pointless logs)
* "net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java.patch"
    - MC-121706 - Fix mobs not looking up and down when strafing
* "net/minecraft/world/entity/animal/cow/MushroomCow.java.patch"
    - Fix cow rotation when shearing mooshroom
* "net/minecraft/world/entity/animal/fish/WaterAnimal.java.patch"
    - MC-238526 - Fix spawner not spawning water animals correctly
* "net/minecraft/world/level/chunk/storage/RegionFileStorage.java.patch"
    - Rebrand
* "org/purpurmc/purpur/PurpurVersionFetcher.java"

diff --git a/io/papermc/paper/entity/activation/ActivationRange.java b/io/papermc/paper/entity/activation/ActivationRange.java
index c18823746ab2edcab536cb1589b7720e3af07e0f..bc62da127a01b33ce8fc0f958bc232d6287d57ec 100644
--- a/io/papermc/paper/entity/activation/ActivationRange.java
+++ b/io/papermc/paper/entity/activation/ActivationRange.java
@@ -147,6 +147,8 @@ public final class ActivationRange {
                 continue;
             }
 
+            if (!player.level().purpurConfig.idleTimeoutTickNearbyEntities && player.isAfk()) continue; // Purpur - AFK API
+
             final int worldHeight = world.getHeight();
             ActivationRange.maxBB = player.getBoundingBox().inflate(maxRange, worldHeight, maxRange);
             ActivationType.MISC.boundingBox = player.getBoundingBox().inflate(miscActivationRange, worldHeight, miscActivationRange);
@@ -288,6 +290,7 @@ public final class ActivationRange {
      * @return
      */
     public static boolean checkIfActive(final Entity entity) {
+        if (entity.level().purpurConfig.squidImmuneToEAR && entity instanceof net.minecraft.world.entity.animal.squid.Squid) return true; // Purpur - Squid EAR immunity
         // Never safe to skip fireworks or item gravity
         if (entity instanceof FireworkRocketEntity || (entity instanceof ItemEntity && (entity.tickCount + entity.getId()) % 4 == 0)) { // Needed for item gravity, see ItemEntity tick
             return true;
diff --git a/net/minecraft/commands/CommandSourceStack.java b/net/minecraft/commands/CommandSourceStack.java
index 566304106fd4f1c677a56e7c66282d1570e7b974..21d135189a4d67605e0dfb991283d48268ce5d5c 100644
--- a/net/minecraft/commands/CommandSourceStack.java
+++ b/net/minecraft/commands/CommandSourceStack.java
@@ -430,6 +430,19 @@ public class CommandSourceStack implements ExecutionCommandSource<CommandSourceS
     }
     // CraftBukkit end
 
+    // Purpur start - Gamemode extra permissions
+    public boolean testPermission(net.minecraft.server.permissions.Permission permission, String bukkitPermission) {
+        if (hasPermission(permission, bukkitPermission)) {
+            return true;
+        }
+        net.kyori.adventure.text.Component permissionMessage = getLevel().getServer().server.permissionMessage();
+        if (!permissionMessage.equals(net.kyori.adventure.text.Component.empty())) {
+            sendFailure(io.papermc.paper.adventure.PaperAdventure.asVanilla(permissionMessage.replaceText(net.kyori.adventure.text.TextReplacementConfig.builder().matchLiteral("<permission>").replacement(bukkitPermission).build())));
+        }
+        return false;
+    }
+    // Purpur end - Gamemode extra permissions
+
     public Vec3 getPosition() {
         return this.worldPosition;
     }
@@ -513,6 +526,30 @@ public class CommandSourceStack implements ExecutionCommandSource<CommandSourceS
         }
     }
 
+    // Purpur start - Purpur config files
+    public void sendSuccess(@Nullable String message) {
+        sendSuccess(message, false);
+    }
+
+    public void sendSuccess(@Nullable String message, boolean broadcastToOps) {
+        if (message == null) {
+            return;
+        }
+        sendSuccess(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message), broadcastToOps);
+    }
+
+    public void sendSuccess(net.kyori.adventure.text.@Nullable Component message) {
+        sendSuccess(message, false);
+    }
+
+    public void sendSuccess(net.kyori.adventure.text.@Nullable Component message, boolean broadcastToOps) {
+        if (message == null) {
+            return;
+        }
+        sendSuccess(() -> io.papermc.paper.adventure.PaperAdventure.asVanilla(message), broadcastToOps);
+    }
+    // Purpur end - Purpur config files
+
     public void sendSuccess(Supplier<Component> messageSupplier, boolean allowLogging) {
         boolean flag = this.source.acceptsSuccess() && !this.silent;
         boolean flag1 = allowLogging && this.source.shouldInformAdmins() && !this.silent;
diff --git a/net/minecraft/commands/Commands.java b/net/minecraft/commands/Commands.java
index 668eb52d71d77f75c24d4840be9a6c49d96dfc34..de5b9c69ee6579c963bb00a3f2628247af9951e8 100644
--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -265,11 +265,11 @@ public class Commands {
             JfrCommand.register(this.dispatcher);
         }
 
-        if (SharedConstants.DEBUG_CHASE_COMMAND) {
+        if (org.purpurmc.purpur.PurpurConfig.registerMinecraftDisabledCommands || SharedConstants.DEBUG_CHASE_COMMAND) { // Purpur - register disabled minecraft commands
             ChaseCommand.register(this.dispatcher);
         }
 
-        if (SharedConstants.DEBUG_DEV_COMMANDS || SharedConstants.IS_RUNNING_IN_IDE) {
+        if (org.purpurmc.purpur.PurpurConfig.registerMinecraftDebugCommands || SharedConstants.DEBUG_DEV_COMMANDS || SharedConstants.IS_RUNNING_IN_IDE) {  // Purpur - register minecraft debug commands
             RaidCommand.register(this.dispatcher, context);
             DebugPathCommand.register(this.dispatcher);
             DebugMobSpawningCommand.register(this.dispatcher);
@@ -297,6 +297,14 @@ public class Commands {
             StopCommand.register(this.dispatcher);
             TransferCommand.register(this.dispatcher);
             WhitelistCommand.register(this.dispatcher);
+            org.purpurmc.purpur.command.CreditsCommand.register(this.dispatcher); // Purpur - Add credits command
+            org.purpurmc.purpur.command.DemoCommand.register(this.dispatcher); // Purpur - Add demo command
+            org.purpurmc.purpur.command.PingCommand.register(this.dispatcher); // Purpur - Add ping command
+            org.purpurmc.purpur.command.UptimeCommand.register(this.dispatcher); // Purpur - Add uptime command
+            org.purpurmc.purpur.command.TPSBarCommand.register(this.dispatcher); // Purpur - Implement TPSBar
+            org.purpurmc.purpur.command.CompassCommand.register(this.dispatcher); // Purpur - Add compass command
+            org.purpurmc.purpur.command.RamBarCommand.register(this.dispatcher); // Purpur - Add rambar command
+            org.purpurmc.purpur.command.RamCommand.register(this.dispatcher); // Purpur - Add ram command
         }
 
         if (selection.includeIntegrated) {
diff --git a/net/minecraft/commands/arguments/selector/EntitySelector.java b/net/minecraft/commands/arguments/selector/EntitySelector.java
index af71e0e1eb1c93745f3e4954ecc8fbd2ad4808a3..fbab3e2f4e3a9cdc1c148fc794036c5655368666 100644
--- a/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -190,26 +190,27 @@ public class EntitySelector {
         this.checkPermissions(source);
         if (this.playerName != null) {
             ServerPlayer playerByName = source.getServer().getPlayerList().getPlayerByName(this.playerName);
-            return playerByName == null ? List.of() : List.of(playerByName);
+            return playerByName == null || !canSee(source, playerByName) ? List.of() : List.of(playerByName); // Purpur - Hide hidden players from entity selector
         } else if (this.entityUUID != null) {
             ServerPlayer playerByName = source.getServer().getPlayerList().getPlayer(this.entityUUID);
-            return playerByName == null ? List.of() : List.of(playerByName);
+            return playerByName == null || !canSee(source, playerByName) ? List.of() : List.of(playerByName); // Purpur - Hide hidden players from entity selector
         } else {
             Vec3 vec3 = this.position.apply(source.getPosition());
             AABB absoluteAabb = this.getAbsoluteAabb(vec3);
             Predicate<Entity> predicate = this.getPredicate(vec3, absoluteAabb, null);
             if (this.currentEntity) {
-                return source.getEntity() instanceof ServerPlayer serverPlayer && predicate.test(serverPlayer) ? List.of(serverPlayer) : List.of();
+                return source.getEntity() instanceof ServerPlayer serverPlayer && predicate.test(serverPlayer) && canSee(source, serverPlayer) ? List.of(serverPlayer) : List.of(); // Purpur - Hide hidden players from entity selector
             } else {
                 int resultLimit = this.getResultLimit();
                 List<ServerPlayer> players;
                 if (this.isWorldLimited()) {
                     players = source.getLevel().getPlayers(predicate, resultLimit);
+                    players.removeIf(entityplayer3 -> !canSee(source, entityplayer3)); // Purpur - Hide hidden players from entity selector
                 } else {
                     players = new ObjectArrayList<>();
 
                     for (ServerPlayer serverPlayer1 : source.getServer().getPlayerList().getPlayers()) {
-                        if (predicate.test(serverPlayer1)) {
+                        if (predicate.test(serverPlayer1) && canSee(source, serverPlayer1)) { // Purpur - Hide hidden players from entity selector
                             players.add(serverPlayer1);
                             if (players.size() >= resultLimit) {
                                 return players;
@@ -267,4 +268,10 @@ public class EntitySelector {
     public static Component joinNames(List<? extends Entity> names) {
         return ComponentUtils.formatList(names, Entity::getDisplayName);
     }
+
+    // Purpur start - Hide hidden players from entity selector
+    private boolean canSee(CommandSourceStack sender, ServerPlayer target) {
+        return !org.purpurmc.purpur.PurpurConfig.hideHiddenPlayersFromEntitySelector || !(sender.getEntity() instanceof ServerPlayer player) || player.getBukkitEntity().canSee(target.getBukkitEntity());
+    }
+    // Purpur end - Hide hidden players from entity selector
 }
diff --git a/net/minecraft/core/BlockPos.java b/net/minecraft/core/BlockPos.java
index e87473fcb36e18d960ef3e4082995785d64b9c0f..e4dee5426e186d44d4d929967c65710848ace11d 100644
--- a/net/minecraft/core/BlockPos.java
+++ b/net/minecraft/core/BlockPos.java
@@ -61,6 +61,12 @@ public class BlockPos extends Vec3i {
     public static final int MAX_HORIZONTAL_COORDINATE = 33554431;
     // Paper end - Optimize Bit Operations by inlining
 
+    // Purpur start - Ridables
+    public BlockPos(net.minecraft.world.entity.Entity entity) {
+        super(entity.getBlockX(), entity.getBlockY(), entity.getBlockZ());
+    }
+    // Purpur end - Ridables
+
     public BlockPos(int x, int y, int z) {
         super(x, y, z);
     }
diff --git a/net/minecraft/core/dispenser/DispenseItemBehavior.java b/net/minecraft/core/dispenser/DispenseItemBehavior.java
index bfefb5031544caa59230f0073e8880c2b39ebf4d..ff32a89a720676c5a9f34ea7c859f03d47545b72 100644
--- a/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -750,5 +750,22 @@ public interface DispenseItemBehavior {
         DispenserBlock.registerBehavior(Items.TNT_MINECART, new MinecartDispenseItemBehavior(EntityType.TNT_MINECART));
         DispenserBlock.registerBehavior(Items.HOPPER_MINECART, new MinecartDispenseItemBehavior(EntityType.HOPPER_MINECART));
         DispenserBlock.registerBehavior(Items.COMMAND_BLOCK_MINECART, new MinecartDispenseItemBehavior(EntityType.COMMAND_BLOCK_MINECART));
+        // Purpur start - Dispensers place anvils option
+        DispenserBlock.registerBehavior(Items.ANVIL, (new OptionalDispenseItemBehavior() {
+            @Override
+            public ItemStack execute(BlockSource dispenser, ItemStack stack) {
+                net.minecraft.world.level.Level level = dispenser.level();
+                if (!level.purpurConfig.dispenserPlaceAnvils) return super.execute(dispenser, stack);
+                Direction facing = dispenser.blockEntity().getBlockState().getValue(DispenserBlock.FACING);
+                BlockPos pos = dispenser.pos().relative(facing);
+                BlockState state = level.getBlockState(pos);
+                if (state.isAir()) {
+                    level.setBlockAndUpdate(pos, Blocks.ANVIL.defaultBlockState().setValue(net.minecraft.world.level.block.AnvilBlock.FACING, facing.getAxis() == Direction.Axis.Y ? Direction.NORTH : facing.getClockWise()));
+                    stack.shrink(1);
+                }
+                return stack;
+            }
+        }));
+        // Purpur end - Dispensers place anvils option
     }
 }
diff --git a/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java b/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
index e2d169b45f1dba6559ca337b07a110f79d3db504..727d04a442053f6d0c4df3e744554e2866fa38cd 100644
--- a/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
@@ -32,7 +32,7 @@ public class EquipmentDispenseItemBehavior extends DefaultDispenseItemBehavior {
             return false;
         } else {
             LivingEntity livingEntity = entitiesOfClass.getFirst();
-            EquipmentSlot equipmentSlotForItem = livingEntity.getEquipmentSlotForItem(item);
+            EquipmentSlot equipmentSlotForItem = blockSource.level().purpurConfig.dispenserApplyCursedArmor ? livingEntity.getEquipmentSlotForItem(item) : livingEntity.getEquipmentSlotForDispenserItem(item); if (equipmentSlotForItem == null) return false; // Purpur - Dispenser curse of binding protection
             ItemStack itemStack = item.copyWithCount(1); // Paper - shrink below and single item in event
             // CraftBukkit start
             net.minecraft.world.level.Level world = blockSource.level();
diff --git a/net/minecraft/gametest/framework/GameTestHelper.java b/net/minecraft/gametest/framework/GameTestHelper.java
index 2a1aef6bfa15882748b98b5257baaced107ba194..49d3154afe2ca5789e63bdf972c791969405c16d 100644
--- a/net/minecraft/gametest/framework/GameTestHelper.java
+++ b/net/minecraft/gametest/framework/GameTestHelper.java
@@ -322,6 +322,10 @@ public class GameTestHelper {
                 return gameType;
             }
 
+            public void setAfk(final boolean afk) {} // Purpur - AFK API
+
+            public void resetLastActionTime() {} // Purpur - Ridables
+
             @Override
             public boolean isClientAuthoritative() {
                 return false;
diff --git a/net/minecraft/gametest/framework/TestCommand.java b/net/minecraft/gametest/framework/TestCommand.java
index 4a06b20b60f67a2d383dbd09b3bad713155dc81e..63e0294f5624643b6d37983f523bf2434cbe47e2 100644
--- a/net/minecraft/gametest/framework/TestCommand.java
+++ b/net/minecraft/gametest/framework/TestCommand.java
@@ -443,7 +443,7 @@ public class TestCommand {
                             )
                     )
             );
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (org.purpurmc.purpur.PurpurConfig.registerMinecraftDebugCommands || SharedConstants.IS_RUNNING_IN_IDE) { // Purpur - register minecraft debug commands
             literalArgumentBuilder = literalArgumentBuilder.then(
                     Commands.literal("export")
                         .then(
diff --git a/net/minecraft/network/Connection.java b/net/minecraft/network/Connection.java
index 19ec939529eb638bdc4d7fd9260f161fae118314..21e891ecdb90a1828428441aef9c2593253751f8 100644
--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -554,11 +554,20 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static final int MAX_PER_TICK = io.papermc.paper.configuration.GlobalConfiguration.get().misc.maxJoinsPerTick; // Paper - Buffer joins to world
     private static int joinAttemptsThisTick; // Paper - Buffer joins to world
     private static int currTick; // Paper - Buffer joins to world
+    private static int tickSecond; // Purpur - Max joins per second
     public void tick() {
         this.flushQueue();
         // Paper start - Buffer joins to world
         if (Connection.currTick != net.minecraft.server.MinecraftServer.currentTick) {
             Connection.currTick = net.minecraft.server.MinecraftServer.currentTick;
+            // Purpur start - Max joins per second
+            if (org.purpurmc.purpur.PurpurConfig.maxJoinsPerSecond) {
+                if (++Connection.tickSecond > 20) {
+                    Connection.tickSecond = 0;
+                    Connection.joinAttemptsThisTick = 0;
+                }
+            } else
+            // Purpur end - Max joins per second
             Connection.joinAttemptsThisTick = 0;
         }
         // Paper end - Buffer joins to world
diff --git a/net/minecraft/server/Main.java b/net/minecraft/server/Main.java
index 094d2d528cb74b8f1d277cd780bba7f438dbe764..272e2871aca8d283229cc5618e3051146db56681 100644
--- a/net/minecraft/server/Main.java
+++ b/net/minecraft/server/Main.java
@@ -105,6 +105,13 @@ public class Main {
                 JvmProfiler.INSTANCE.start(Environment.SERVER);
             }
 
+            // Purpur start - Add toggle for enchant level clamping - load config files early
+            org.bukkit.configuration.file.YamlConfiguration purpurConfiguration = io.papermc.paper.configuration.PaperConfigurations.loadLegacyConfigFile((File) optionSet.valueOf("purpur-settings"));
+            org.purpurmc.purpur.PurpurConfig.clampEnchantLevels = purpurConfiguration.getBoolean("settings.enchantment.clamp-levels", true);
+            org.purpurmc.purpur.PurpurConfig.registerMinecraftDebugCommands = purpurConfiguration.getBoolean("settings.register-minecraft-debug-commands"); // Purpur - register minecraft debug commands
+            org.purpurmc.purpur.PurpurConfig.registerMinecraftDisabledCommands = purpurConfiguration.getBoolean("settings.register-minecraft-disabled-commands"); // Purpur - register disabled minecraft commands
+            // Purpur end - Add toggle for enchant level clamping - load config files early
+
             io.papermc.paper.plugin.PluginInitializerManager.load(optionSet); // Paper
             Bootstrap.bootStrap();
             Bootstrap.validate();
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index c2227d57ea2e2da537a313d4bfd2f8c7f776be64..e236ca37a855918040d23e6659145659f58b4f04 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -290,6 +290,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public joptsimple.OptionSet options;
     public org.bukkit.command.ConsoleCommandSender console;
     public static int currentTick; // Paper - improve tick loop
+    public static final long startTimeMillis = System.currentTimeMillis(); // Purpur - Add uptime command
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     // Paper - don't store the vanilla dispatcher
@@ -306,6 +307,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
     private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
+    public boolean lagging = false; // Purpur - Lagging threshold
+    protected boolean upnp = false; // Purpur - UPnP Port Forwarding
     // Paper start - improve tick loop
     public final ca.spottedleaf.moonrise.common.time.TickData tickTimes1s  = new ca.spottedleaf.moonrise.common.time.TickData(java.util.concurrent.TimeUnit.SECONDS.toNanos(1L));
     public final ca.spottedleaf.moonrise.common.time.TickData tickTimes5s  = new ca.spottedleaf.moonrise.common.time.TickData(java.util.concurrent.TimeUnit.SECONDS.toNanos(5L));
@@ -1014,6 +1017,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         LOGGER.info("Stopping server");
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
+        // Purpur start - UPnP Port Forwarding
+        if (upnp) {
+            if (dev.omega24.upnp4j.UPnP4J.close(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
+                LOGGER.info("[UPnP] Port {} closed", this.getPort());
+            } else {
+                LOGGER.error("[UPnP] Failed to close port {}", this.getPort());
+            }
+        }
+        // Purpur end - UPnP Port Forwarding
         // CraftBukkit start
         if (this.server != null) {
             this.server.spark.disable(); // Paper - spark
@@ -1112,6 +1124,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.safeShutdown(waitForShutdown, false);
     }
     public void safeShutdown(boolean waitForShutdown, boolean isRestarting) {
+        org.purpurmc.purpur.task.BossBarTask.stopAll(); // Purpur - Implement TPSBar
+        org.purpurmc.purpur.task.BeehiveTask.instance().unregister(); // Purpur - Give bee counts in beehives to Purpur clients
         this.isRestarting = isRestarting;
         this.hasLoggedStop = true; // Paper - Debugging
         if (isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
@@ -1289,11 +1303,30 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
             // Paper end - Add onboarding message for initial server start
             // Paper start - Improve outdated version checking
-            if (System.getProperty("paper.disableStartupVersionCheck") == null && io.papermc.paper.configuration.GlobalConfiguration.get().updateChecker.enabled) {
+            if (false && System.getProperty("paper.disableStartupVersionCheck") == null && io.papermc.paper.configuration.GlobalConfiguration.get().updateChecker.enabled) { // Purpur - disable paper startup check
                 CompletableFuture.runAsync(com.destroystokyo.paper.PaperVersionFetcher::getUpdateStatusStartupMessage, io.papermc.paper.util.MCUtil.ASYNC_EXECUTOR);
             }
             // Paper end - Improve outdated version checking
 
+            // Purpur start - config for startup commands
+            if (!Boolean.getBoolean("Purpur.IReallyDontWantStartupCommands") && !org.purpurmc.purpur.PurpurConfig.startupCommands.isEmpty()) {
+                LOGGER.info("Purpur: Running startup commands specified in purpur.yml.");
+                for (final String startupCommand : org.purpurmc.purpur.PurpurConfig.startupCommands) {
+                    LOGGER.info("Purpur: Running the following command: \"{}\"", startupCommand);
+                    ((net.minecraft.server.dedicated.DedicatedServer) this).handleConsoleInput(startupCommand, this.createCommandSourceStack());
+                }
+            }
+            // Purpur end - config for startup commands
+            // Purpur start - Migrate Setting to reintroduce end void rings
+            if (org.purpurmc.purpur.configuration.transformation.FarEndTerrainGenerationMigration.HAS_BEEN_REGISTERED) {
+                try {
+                    org.purpurmc.purpur.PurpurConfig.config.save((java.io.File) this.options.valueOf("purpur-settings"));
+                } catch (IOException ex) {
+                    org.bukkit.Bukkit.getLogger().log(java.util.logging.Level.SEVERE, "Could not save " + this.options.valueOf("purpur-settings"), ex);
+                }
+            }
+            // Purpur end - Migrate Setting to reintroduce end void rings
+
             while (this.running) {
                 final long tickStart = System.nanoTime(); // Paper - improve tick loop
                 long l; // Paper - improve tick loop - diff on change, expect this to be tick interval
@@ -1307,9 +1340,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     final long ticksBehind = Math.max(1L, this.tickSchedule.getPeriodsAhead(l, tickStart));
                     final long catchup = (long)Math.max(
                         1,
-                        5 //ConfigHolder.getConfig().tickLoop.catchupTicks.getOrDefault(MoonriseConfig.TickLoop.DEFAULT_CATCHUP_TICKS).intValue()
+                        org.purpurmc.purpur.PurpurConfig.tpsCatchup ? 5 : 1 //ConfigHolder.getConfig().tickLoop.catchupTicks.getOrDefault(MoonriseConfig.TickLoop.DEFAULT_CATCHUP_TICKS).intValue() // Purpur - Configurable TPS Catchup
                     );
 
+                    lagging = getTPS()[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold; // Purpur - Lagging threshold
+
                     // adjust ticksBehind so that it is not greater-than catchup
                     if (ticksBehind > catchup) {
                         final long difference = ticksBehind - catchup;
@@ -1790,7 +1825,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             long worldTime = level.getGameTime();
             final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
             for (Player entityhuman : level.players()) {
-                if (!(entityhuman instanceof ServerPlayer) || (tickCount + entityhuman.getId()) % 20 != 0) {
+                if (!(entityhuman instanceof ServerPlayer) || (!level.isForceTime() && (tickCount + entityhuman.getId()) % 20 != 0)) { // Purpur - Configurable daylight cycle
                     continue;
                 }
                 ServerPlayer entityplayer = (ServerPlayer) entityhuman;
@@ -1809,6 +1844,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
             serverLevel.updateLagCompensationTick(); // Paper - lag compensation
             net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = serverLevel.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+            serverLevel.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur - Ridables
             profilerFiller.push(() -> serverLevel + " " + serverLevel.dimension().identifier());
             /* Drop global time updates
             if (this.tickCount % 20 == 0) {
diff --git a/net/minecraft/server/PlayerAdvancements.java b/net/minecraft/server/PlayerAdvancements.java
index 98004b77b7f40d315f41be82105df6d4b9000e33..c63b5b32cff9aff2a50ca29a44bfcefe1d8848ec 100644
--- a/net/minecraft/server/PlayerAdvancements.java
+++ b/net/minecraft/server/PlayerAdvancements.java
@@ -193,6 +193,7 @@ public class PlayerAdvancements {
                 advancement.value().display().ifPresent(displayInfo -> {
                     // Paper start - Add Adventure message to PlayerAdvancementDoneEvent
                     if (event.message() != null && this.player.level().getGameRules().get(GameRules.SHOW_ADVANCEMENT_MESSAGES)) {
+                        if (org.purpurmc.purpur.PurpurConfig.advancementOnlyBroadcastToAffectedPlayer) this.player.sendMessage(message); else // Purpur - Configurable broadcast settings
                         this.playerList.broadcastSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.message()), false);
                         // Paper end
                     }
diff --git a/net/minecraft/server/commands/EnchantCommand.java b/net/minecraft/server/commands/EnchantCommand.java
index 21548995eb278236946b6e495d27f6261e24f7a2..1735a87a974028779cc64cbeb39ff2eeb16034b1 100644
--- a/net/minecraft/server/commands/EnchantCommand.java
+++ b/net/minecraft/server/commands/EnchantCommand.java
@@ -70,7 +70,7 @@ public class EnchantCommand {
 
     private static int enchant(CommandSourceStack source, Collection<? extends Entity> targets, Holder<Enchantment> enchantment, int level) throws CommandSyntaxException {
         Enchantment enchantment1 = enchantment.value();
-        if (level > enchantment1.getMaxLevel()) {
+        if (!org.purpurmc.purpur.PurpurConfig.allowUnsafeEnchantCommand && level > enchantment1.getMaxLevel()) { // Purpur - Config to allow unsafe enchants
             throw ERROR_LEVEL_TOO_HIGH.create(level, enchantment1.getMaxLevel());
         } else {
             int i = 0;
@@ -80,7 +80,7 @@ public class EnchantCommand {
                     ItemStack mainHandItem = livingEntity.getMainHandItem();
                     if (!mainHandItem.isEmpty()) {
                         if (enchantment1.canEnchant(mainHandItem)
-                            && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantmentsForCrafting(mainHandItem).keySet(), enchantment)) {
+                            && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantmentsForCrafting(mainHandItem).keySet(), enchantment) || (org.purpurmc.purpur.PurpurConfig.allowUnsafeEnchantCommand && !mainHandItem.hasEnchantment(enchantment))) { // Purpur - Config to allow unsafe enchants
                             mainHandItem.enchant(enchantment, level);
                             i++;
                         } else if (targets.size() == 1) {
diff --git a/net/minecraft/server/commands/GameModeCommand.java b/net/minecraft/server/commands/GameModeCommand.java
index 503447fbb54bed493f1d867c75ef3f344fe7b81b..a601df223c685f435241cd193a912898e60bab03 100644
--- a/net/minecraft/server/commands/GameModeCommand.java
+++ b/net/minecraft/server/commands/GameModeCommand.java
@@ -53,6 +53,18 @@ public class GameModeCommand {
     }
 
     private static int setMode(CommandContext<CommandSourceStack> context, Collection<ServerPlayer> players, GameType gameType) {
+        // Purpur start - Gamemode extra permissions
+        if (org.purpurmc.purpur.PurpurConfig.commandGamemodeRequiresPermission) {
+            String gamemode = gameType.getName();
+            CommandSourceStack sender = context.getSource();
+            if (!sender.testPermission(Permissions.COMMANDS_GAMEMASTER, "minecraft.command.gamemode." + gamemode)) {
+                return 0;
+            }
+            if (sender.getEntity() instanceof ServerPlayer player && (players.size() > 1 || !players.contains(player)) && !sender.testPermission(Permissions.COMMANDS_GAMEMASTER, "minecraft.command.gamemode." + gamemode + ".other")) {
+                return 0;
+            }
+        }
+        // Purpur end - Gamemode extra permissions
         int i = 0;
 
         for (ServerPlayer serverPlayer : players) {
diff --git a/net/minecraft/server/commands/GiveCommand.java b/net/minecraft/server/commands/GiveCommand.java
index 0fc63717af24ca37497db8ea5a2395548d9d8491..2f8fd2240d603346e751a5f7afb91121065423d6 100644
--- a/net/minecraft/server/commands/GiveCommand.java
+++ b/net/minecraft/server/commands/GiveCommand.java
@@ -68,6 +68,7 @@ public class GiveCommand {
                     i1 -= min;
                     ItemStack itemStack1 = item.createItemStack(min, false);
                     boolean flag = serverPlayer.getInventory().add(itemStack1);
+                    if (org.purpurmc.purpur.PurpurConfig.disableGiveCommandDrops) continue; // Purpur - add config option for toggling give command dropping
                     if (flag && itemStack1.isEmpty()) {
                         ItemEntity itemEntity = serverPlayer.drop(itemStack, false, false, false, null); // Paper - do not fire PlayerDropItemEvent for /give command
                         if (itemEntity != null) {
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index eb06d8f012684845146429832e977e6c1ddcd62b..19a25ee84a4211256a1dbb614db9ebf2ce53182f 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -195,6 +195,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             public void run() {
                 if (!org.bukkit.craftbukkit.Main.useConsole) return; // CraftBukkit
                 // Paper start - Use TerminalConsoleAppender
+                if (DedicatedServer.this.gui == null || System.console() != null) // Purpur - GUI Improvements - has no GUI or has console (did not double-click)
                 new com.destroystokyo.paper.console.PaperConsole(DedicatedServer.this).start();
                 /*
                 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in, StandardCharsets.UTF_8));
@@ -257,6 +258,15 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.spigotmc.SpigotConfig.registerCommands();
         // Spigot end
         io.papermc.paper.util.ObfHelper.INSTANCE.getClass(); // Paper - load mappings for stacktrace deobf and etc.
+        // Purpur start - Migrate Setting to reintroduce end void rings
+        try {
+            org.purpurmc.purpur.PurpurConfig.init((java.io.File) options.valueOf("purpur-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        org.purpurmc.purpur.PurpurConfig.registerCommands();
+        // Purpur end - Migrate Setting to reintroduce end void rings
         // Paper start - initialize global and world-defaults configuration
         this.paperConfigurations.initializeGlobalConfiguration(this.registryAccess());
         this.paperConfigurations.initializeWorldDefaultsConfiguration(this.registryAccess());
@@ -273,6 +283,15 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         io.papermc.paper.command.PaperCommands.registerCommands(this); // Paper - setup /paper command
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
+        /*// Purpur start - Purpur config files // Purpur start - Migrate Setting to reintroduce end void rings
+        try {
+            org.purpurmc.purpur.PurpurConfig.init((java.io.File) options.valueOf("purpur-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        org.purpurmc.purpur.PurpurConfig.registerCommands();
+        */// Purpur end - Purpur config files // Purpur end - Migrate Setting to reintroduce end void rings
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
 
         // this.worldData.setGameType(properties.gameMode.get()); // CraftBukkit - moved to world loading
@@ -315,6 +334,30 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             if (true) throw new IllegalStateException("Failed to bind to port", var11); // Paper - Propagate failed to bind to port error
             return false;
         }
+        // Purpur start - UPnP Port Forwarding
+        if (org.purpurmc.purpur.PurpurConfig.useUPnP) {
+            LOGGER.info("[UPnP] Attempting to start UPnP port forwarding service...");
+            if (dev.omega24.upnp4j.UPnP4J.isUPnPAvailable()) {
+                if (dev.omega24.upnp4j.UPnP4J.isOpen(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
+                    this.upnp = false;
+                    LOGGER.info("[UPnP] Port {} is already open", this.getPort());
+                } else if (dev.omega24.upnp4j.UPnP4J.open(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
+                    this.upnp = true;
+                    LOGGER.info("[UPnP] Successfully opened port {}", this.getPort());
+                } else {
+                    this.upnp = false;
+                    LOGGER.info("[UPnP] Failed to open port {}", this.getPort());
+                }
+
+                if (upnp) {
+                    LOGGER.info("[UPnP] {}:{}", dev.omega24.upnp4j.UPnP4J.getExternalIP(), this.getPort());
+                }
+            } else {
+                this.upnp = false;
+                LOGGER.error("[UPnP] Service is unavailable");
+            }
+        }
+        // Purpur end - UPnP Port Forwarding
 
         // CraftBukkit start
         this.server.loadPlugins();
@@ -390,6 +433,9 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 LOGGER.info("JMX monitoring enabled");
             }
 
+            org.purpurmc.purpur.task.BossBarTask.startAll(); // Purpur - Implement TPSBar
+            if (org.purpurmc.purpur.PurpurConfig.beeCountPayload) org.purpurmc.purpur.task.BeehiveTask.instance().register(); // Purpur - Give bee counts in beehives to Purpur clients
+
             this.notificationManager().serverStarted();
             return true;
         }
diff --git a/net/minecraft/server/dedicated/DedicatedServerProperties.java b/net/minecraft/server/dedicated/DedicatedServerProperties.java
index bbd8f68d166ebd0370f4b39362468fdc7d70f7f0..2a3b10c5e031ef44a2b53bc4fdc6e86c917f75d4 100644
--- a/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -57,6 +57,7 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
     public final boolean onlineMode = this.get("online-mode", true);
     public final boolean preventProxyConnections = this.get("prevent-proxy-connections", false);
     public final String serverIp = this.get("server-ip", "");
+    public final String serverName = this.get("server-name", "Unknown Server"); // Purpur - Bring back server name
     public final Settings<DedicatedServerProperties>.MutableValue<Boolean> allowFlight = this.getMutable("allow-flight", false);
     public final Settings<DedicatedServerProperties>.MutableValue<String> motd = this.getMutable("motd", "A Minecraft Server");
     public final boolean codeOfConduct = this.get("enable-code-of-conduct", false);
diff --git a/net/minecraft/server/gui/MinecraftServerGui.java b/net/minecraft/server/gui/MinecraftServerGui.java
index f262a7c5ae4e7d56f16f5c0f4f145a2e428abbe4..614c7d9f673c926562acc8fa3b3788623900db41 100644
--- a/net/minecraft/server/gui/MinecraftServerGui.java
+++ b/net/minecraft/server/gui/MinecraftServerGui.java
@@ -39,6 +39,11 @@ public class MinecraftServerGui extends JComponent {
     private Thread logAppenderThread;
     private final Collection<Runnable> finalizers = Lists.newArrayList();
     final AtomicBoolean isClosing = new AtomicBoolean();
+    // Purpur start - GUI Improvements
+    private final CommandHistory history = new CommandHistory();
+    private String currentCommand = "";
+    private int historyIndex = 0;
+    // Purpur end - GUI Improvements
 
     public static MinecraftServerGui showFrameFor(final DedicatedServer server) {
         try {
@@ -46,7 +51,7 @@ public class MinecraftServerGui extends JComponent {
         } catch (Exception var3) {
         }
 
-        final JFrame jFrame = new JFrame("Minecraft server");
+        final JFrame jFrame = new JFrame("Purpur Minecraft server"); // Purpur - Improve GUI
         final MinecraftServerGui minecraftServerGui = new MinecraftServerGui(server);
         jFrame.setDefaultCloseOperation(2);
         jFrame.add(minecraftServerGui);
@@ -54,7 +59,7 @@ public class MinecraftServerGui extends JComponent {
         jFrame.setLocationRelativeTo(null);
         jFrame.setVisible(true);
         // Paper start - Improve ServerGUI
-        jFrame.setName("Minecraft server");
+        jFrame.setName("Purpur Minecraft server"); // Purpur - Improve GUI
         try {
             jFrame.setIconImage(javax.imageio.ImageIO.read(java.util.Objects.requireNonNull(MinecraftServerGui.class.getClassLoader().getResourceAsStream("logo.png"))));
         } catch (java.io.IOException ignore) {
@@ -64,7 +69,7 @@ public class MinecraftServerGui extends JComponent {
             @Override
             public void windowClosing(WindowEvent event) {
                 if (!minecraftServerGui.isClosing.getAndSet(true)) {
-                    jFrame.setTitle("Minecraft server - shutting down!");
+                    jFrame.setTitle("Purpur Minecraft server - shutting down!"); // Purpur - Improve GUI
                     server.halt(true);
                     minecraftServerGui.runFinalizers();
                 }
@@ -112,7 +117,7 @@ public class MinecraftServerGui extends JComponent {
 
     private JComponent buildChatPanel() {
         JPanel jPanel = new JPanel(new BorderLayout());
-        JTextArea jTextArea = new JTextArea();
+        org.purpurmc.purpur.gui.JColorTextPane jTextArea = new org.purpurmc.purpur.gui.JColorTextPane(); // Purpur - GUI Improvements
         JScrollPane jScrollPane = new JScrollPane(jTextArea, 22, 30);
         jTextArea.setEditable(false);
         jTextArea.setFont(MONOSPACED);
@@ -121,10 +126,43 @@ public class MinecraftServerGui extends JComponent {
             String trimmed = jTextField.getText().trim();
             if (!trimmed.isEmpty()) {
                 this.server.handleConsoleInput(trimmed, this.server.createCommandSourceStack());
+                // Purpur start - GUI Improvements
+                history.add(trimmed);
+                historyIndex = -1;
+                // Purpur end - GUI Improvements
             }
 
             jTextField.setText("");
         });
+        // Purpur start - GUI Improvements
+        jTextField.getInputMap().put(javax.swing.KeyStroke.getKeyStroke("UP"), "up");
+        jTextField.getInputMap().put(javax.swing.KeyStroke.getKeyStroke("DOWN"), "down");
+        jTextField.getActionMap().put("up", new javax.swing.AbstractAction() {
+            @Override
+            public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
+                if (historyIndex < 0) {
+                    currentCommand = jTextField.getText();
+                }
+                if (historyIndex < history.size() - 1) {
+                    jTextField.setText(history.get(++historyIndex));
+                }
+            }
+        });
+        jTextField.getActionMap().put("down", new javax.swing.AbstractAction() {
+            @Override
+            public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
+                if (historyIndex >= 0) {
+                    if (historyIndex == 0) {
+                        --historyIndex;
+                        jTextField.setText(currentCommand);
+                    } else {
+                        --historyIndex;
+                        jTextField.setText(history.get(historyIndex));
+                    }
+                }
+            }
+        });
+        // Purpur end - GUI Improvements
         jTextArea.addFocusListener(new FocusAdapter() {
             @Override
             public void focusGained(FocusEvent event) {
@@ -159,7 +197,7 @@ public class MinecraftServerGui extends JComponent {
     }
 
     private static final java.util.regex.Pattern ANSI = java.util.regex.Pattern.compile("\\e\\[[\\d;]*[^\\d;]"); // CraftBukkit // Paper
-    public void print(JTextArea textArea, JScrollPane scrollPane, String line) {
+    public void print(org.purpurmc.purpur.gui.JColorTextPane textArea, JScrollPane scrollPane, String line) { // Purpur - GUI Improvements
         if (!SwingUtilities.isEventDispatchThread()) {
             SwingUtilities.invokeLater(() -> this.print(textArea, scrollPane, line));
         } else {
@@ -170,10 +208,11 @@ public class MinecraftServerGui extends JComponent {
                 flag = verticalScrollBar.getValue() + verticalScrollBar.getSize().getHeight() + MONOSPACED.getSize() * 4 > verticalScrollBar.getMaximum();
             }
 
-            try {
+            /*try { // Purpur - GUI Improvements
                 document.insertString(document.getLength(), MinecraftServerGui.ANSI.matcher(line).replaceAll(""), null); // CraftBukkit
             } catch (BadLocationException var8) {
-            }
+            }*/ // Purpur - GUI Improvements
+            textArea.append(line); // Purpur - GUI Improvements
 
             if (flag) {
                 verticalScrollBar.setValue(Integer.MAX_VALUE);
@@ -181,6 +220,18 @@ public class MinecraftServerGui extends JComponent {
         }
     }
 
+    // Purpur start - GUI Improvements
+    public static class CommandHistory extends java.util.LinkedList<String> {
+        @Override
+        public boolean add(String command) {
+            if (size() > 1000) {
+                remove();
+            }
+            return super.offerFirst(command);
+        }
+    }
+    // Purpur end - GUI Improvements
+
     // Paper start - Add onboarding message for initial server start
     private JComponent buildOnboardingPanel() {
         String onboardingLink = "https://docs.papermc.io/paper/next-steps";
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index dc65503a2d785d64d37b76b0303f51cf66d9769a..853bb92c034b6361ff8c55daf52f38a226fdae2c 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -218,6 +218,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     private final boolean tickTime;
+    private double preciseTime; // Purpur - Configurable daylight cycle
+    private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
     final LevelDebugSynchronizers debugSynchronizers = new LevelDebugSynchronizers(this);
 
@@ -228,6 +230,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public boolean hasPhysicsEvent = true; // Paper - BlockPhysicsEvent
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
+    public boolean hasRidableMoveEvent = false; // Purpur - Ridables
 
     @Override
     public @Nullable LevelChunk getChunkIfLoaded(int x, int z) {
@@ -622,8 +625,25 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // CraftBukkit end
         this.tickTime = tickTime;
         this.server = server;
-        this.customSpawners = customSpawners;
+        this.customSpawners = new ArrayList<>(); // Purpur - Allow toggling special MobSpawners per world
         this.serverLevelData = serverLevelData;
+        // Purpur start - Allow toggling special MobSpawners per world
+        if (purpurConfig.phantomSpawning) {
+            this.customSpawners.add(new net.minecraft.world.level.levelgen.PhantomSpawner());
+        }
+        if (purpurConfig.patrolSpawning) {
+            this.customSpawners.add(new net.minecraft.world.level.levelgen.PatrolSpawner());
+        }
+        if (purpurConfig.catSpawning) {
+            this.customSpawners.add(new net.minecraft.world.entity.npc.CatSpawner());
+        }
+        if (purpurConfig.villageSiegeSpawning) {
+            this.customSpawners.add(new net.minecraft.world.entity.ai.village.VillageSiege());
+        }
+        if (purpurConfig.villagerTraderSpawning) {
+            this.customSpawners.add(new net.minecraft.world.entity.npc.wanderingtrader.WanderingTraderSpawner(serverLevelData));
+        }
+        // Purpur end - Allow toggling special MobSpawners per world
         ChunkGenerator chunkGenerator = levelStem.generator();
         // CraftBukkit start
         this.serverLevelData.setWorld(this);
@@ -709,6 +729,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.chunkDataController = new ca.spottedleaf.moonrise.patches.chunk_system.io.datacontroller.ChunkDataController((ServerLevel)(Object)this, this.chunkTaskScheduler);
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
+        this.preciseTime = this.serverLevelData.getDayTime(); // Purpur - Configurable daylight cycle
     }
 
     // Paper start
@@ -760,7 +781,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         }
 
         int i = this.getGameRules().get(GameRules.PLAYERS_SLEEPING_PERCENTAGE);
-        if (this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) {
+        if (this.purpurConfig.playersSkipNight && this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) { // Purpur - Config for skipping night
             // Paper start - create time skip event - move up calculations
             final long newDayTime = this.levelData.getDayTime() + 24000L;
             org.bukkit.event.world.TimeSkipEvent event = new org.bukkit.event.world.TimeSkipEvent(
@@ -895,6 +916,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.serverLevelData.getScheduledEvents().tick(this.server, l);
             Profiler.get().pop();
             if (this.getGameRules().get(GameRules.ADVANCE_TIME)) {
+                // Purpur start - Configurable daylight cycle
+                int incrementTicks = isBrightOutside() ? this.purpurConfig.daytimeTicks : this.purpurConfig.nighttimeTicks;
+                if (incrementTicks != 12000) {
+                    this.preciseTime += 12000 / (double) incrementTicks;
+                    this.setDayTime(this.preciseTime);
+                } else
+                // Purpur end - Configurable daylight cycle
                 this.setDayTime(this.levelData.getDayTime() + 1L);
             }
         }
@@ -902,6 +930,20 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     public void setDayTime(long time) {
         this.serverLevelData.setDayTime(time);
+        // Purpur start - Configurable daylight cycle
+        this.preciseTime = time;
+        this.forceTime = false;
+    }
+    public void setDayTime(double i) {
+        this.serverLevelData.setDayTime((long) i);
+        this.forceTime = true;
+        // Purpur end - Configurable daylight cycle
+    }
+
+    // Purpur start - Configurable daylight cycle
+    public boolean isForceTime() {
+        return this.forceTime;
+    // Purpur end - Configurable daylight cycle
     }
 
     public long getDayCount() {
@@ -1010,9 +1052,17 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                     && this.random.nextDouble() < currentDifficultyAt.getEffectiveDifficulty() * this.paperConfig().entities.spawning.skeletonHorseThunderSpawnChance.or(0.01) // Paper - Configurable spawn chances for skeleton horses
                     && !this.getBlockState(blockPos.below()).is(BlockTags.LIGHTNING_RODS);
                 if (flag) {
-                    SkeletonHorse skeletonHorse = EntityType.SKELETON_HORSE.create(this, EntitySpawnReason.EVENT);
+                    // Purpur start - Special mobs naturally spawn
+                    net.minecraft.world.entity.animal.equine.AbstractHorse skeletonHorse;
+                    if (purpurConfig.zombieHorseSpawnChance > 0D && random.nextDouble() <= purpurConfig.zombieHorseSpawnChance) {
+                        skeletonHorse = EntityType.ZOMBIE_HORSE.create(this, EntitySpawnReason.EVENT);
+                    } else {
+                        skeletonHorse = EntityType.SKELETON_HORSE.create(this, EntitySpawnReason.EVENT);
+                        if (skeletonHorse != null) ((SkeletonHorse) skeletonHorse).setTrap(true);
+                    }
+                    // Purpur end - Special mobs naturally spawn
                     if (skeletonHorse != null) {
-                        skeletonHorse.setTrap(true);
+                        //skeletonHorse.setTrap(true); // Purpur - Special mobs naturally spawn - moved up
                         skeletonHorse.setAge(0);
                         skeletonHorse.setPos(blockPos.getX(), blockPos.getY(), blockPos.getZ());
                         this.addFreshEntity(skeletonHorse, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING); // CraftBukkit
@@ -1047,9 +1097,35 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 if (blockState.is(Blocks.SNOW)) {
                     int layersValue = blockState.getValue(SnowLayerBlock.LAYERS);
                     if (layersValue < Math.min(i, 8)) {
+                        // Purpur start - Smooth snow accumulation
+                        boolean canSnow = true;
+                        // Ensure snow doesn't get more than N layers taller than its neighbors
+                        // We only need to check blocks that are taller than the minimum step height
+                        if (org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep > 0 && layersValue >= org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep) {
+                            int layersValueMin = layersValue - org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep;
+                            for (Direction direction : Direction.Plane.HORIZONTAL) {
+                                BlockPos blockPosNeighbor = heightmapPos.relative(direction);
+                                BlockState blockStateNeighbor = this.getBlockState(blockPosNeighbor);
+                                if (blockStateNeighbor.is(Blocks.SNOW)) {
+                                    // Special check for snow layers, if neighbors are too short, don't accumulate
+                                    int layersValueNeighbor = blockStateNeighbor.getValue(SnowLayerBlock.LAYERS);
+                                    if (layersValueNeighbor <= layersValueMin) {
+                                        canSnow = false;
+                                        break;
+                                    }
+                                } else if (!Block.isFaceFull(blockStateNeighbor.getCollisionShape(this, blockPosNeighbor), direction.getOpposite())) {
+                                    // Since our layer is tall enough already, if we have a non-full neighbor block, don't accumulate
+                                    canSnow = false;
+                                    break;
+                                }
+                            }
+                        }
+                        if (canSnow) {
+                        // Purpur end - Smooth snow accumulation
                         BlockState blockState1 = blockState.setValue(SnowLayerBlock.LAYERS, layersValue + 1);
                         Block.pushEntitiesUp(blockState, blockState1, this, heightmapPos);
                         org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(this, heightmapPos, blockState1, Block.UPDATE_ALL, null); // CraftBukkit
+                        } // Purpur - Smooth snow accumulation
                     }
                 } else {
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(this, heightmapPos, Blocks.SNOW.defaultBlockState(), Block.UPDATE_ALL, null); // CraftBukkit
@@ -1070,7 +1146,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 poiType -> poiType.is(PoiTypes.LIGHTNING_ROD),
                 blockPos -> blockPos.getY() == this.getHeight(Heightmap.Types.WORLD_SURFACE, blockPos.getX(), blockPos.getZ()) - 1,
                 pos,
-                128,
+                org.purpurmc.purpur.PurpurConfig.lightningRodRange, // Purpur - Make lightning rod range configurable
                 PoiManager.Occupancy.ANY
             );
         return optional.map(blockPos -> blockPos.above(1));
@@ -1119,8 +1195,26 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 int i = this.getGameRules().get(GameRules.PLAYERS_SLEEPING_PERCENTAGE);
                 Component component;
                 if (this.sleepStatus.areEnoughSleeping(i)) {
+                    // Purpur start - Customizable sleeping actionbar messages
+                    if (org.purpurmc.purpur.PurpurConfig.sleepSkippingNight.isBlank()) {
+                        return;
+                    }
+                    if (!org.purpurmc.purpur.PurpurConfig.sleepSkippingNight.equalsIgnoreCase("default")) {
+                        component = io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.sleepSkippingNight));
+                    } else
+                    // Purpur end - Customizable sleeping actionbar messages
                     component = Component.translatable("sleep.skipping_night");
                 } else {
+                    // Purpur start - Customizable sleeping actionbar messages
+                    if (org.purpurmc.purpur.PurpurConfig.sleepingPlayersPercent.isBlank()) {
+                        return;
+                    }
+                    if (!org.purpurmc.purpur.PurpurConfig.sleepingPlayersPercent.equalsIgnoreCase("default")) {
+                        component = io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.sleepingPlayersPercent,
+                            net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.parsed("count", Integer.toString(this.sleepStatus.amountSleeping())),
+                            net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.parsed("total", Integer.toString(this.sleepStatus.sleepersNeeded(i)))));
+                    } else
+                    // Purpur end - Customizable sleeping actionbar messages
                     component = Component.translatable("sleep.players_sleeping", this.sleepStatus.amountSleeping(), this.sleepStatus.sleepersNeeded(i));
                 }
 
@@ -1275,6 +1369,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     @VisibleForTesting
     public void resetWeatherCycle() {
         // CraftBukkit start
+        if (this.purpurConfig.rainStopsAfterSleep) // Purpur - Option for if rain and thunder should stop on sleep
         this.serverLevelData.setRaining(false, org.bukkit.event.weather.WeatherChangeEvent.Cause.SLEEP); // Paper - Add cause to Weather/ThunderChangeEvents
         // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
         // Not that everyone ever manages to get the whole server to sleep at the same time....
@@ -1282,6 +1377,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.serverLevelData.setRainTime(0);
         }
         // CraftBukkit end
+        if (this.purpurConfig.thunderStopsAfterSleep) // Purpur - Option for if rain and thunder should stop on sleep
         this.serverLevelData.setThundering(false, org.bukkit.event.weather.ThunderChangeEvent.Cause.SLEEP); // Paper - Add cause to Weather/ThunderChangeEvents
         // CraftBukkit start
         // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
@@ -1954,7 +2050,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         Explosion.BlockInteraction blockInteraction = switch (explosionInteraction) {
             case NONE -> Explosion.BlockInteraction.KEEP;
             case BLOCK -> this.getDestroyType(GameRules.BLOCK_EXPLOSION_DROP_DECAY);
-            case MOB -> this.getGameRules().get(GameRules.MOB_GRIEFING)
+            case MOB -> ((source instanceof net.minecraft.world.entity.projectile.hurtingprojectile.LargeFireball) ? this.getGameRules().get(GameRules.MOB_GRIEFING, this.purpurConfig.fireballsMobGriefingOverride) : this.getGameRules().get(GameRules.MOB_GRIEFING)) // Purpur - Add mobGriefing override to everything affected
                 ? this.getDestroyType(GameRules.MOB_EXPLOSION_DROP_DECAY)
                 : Explosion.BlockInteraction.KEEP;
             case TNT -> this.getDestroyType(GameRules.TNT_EXPLOSION_DROP_DECAY);
@@ -2846,7 +2942,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             // Spigot start
             if (entity.getBukkitEntity() instanceof org.bukkit.inventory.InventoryHolder && (!(entity instanceof ServerPlayer) || entity.getRemovalReason() != Entity.RemovalReason.KILLED)) { // SPIGOT-6876: closeInventory clears death message
                 // Paper start - Fix merchant inventory not closing on entity removal
-                if (entity.getBukkitEntity() instanceof org.bukkit.inventory.Merchant merchant && merchant.getTrader() != null) {
+                if (!entity.level().purpurConfig.playerVoidTrading && entity.getBukkitEntity() instanceof org.bukkit.inventory.Merchant merchant && merchant.getTrader() != null) { // Purpur - Allow void trading
                     merchant.getTrader().closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNLOADED);
                 }
                 // Paper end - Fix merchant inventory not closing on entity removal
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index fc3b8c999e6b75c94b58b342de063a342f4f84d1..9f27cda78f5a7f01cdf95e4ff2d693b4f40a0bad 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -433,6 +433,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
     public boolean isRealPlayer; // Paper
     public com.destroystokyo.paper.event.entity.@Nullable PlayerNaturallySpawnCreaturesEvent playerNaturallySpawnedEvent; // Paper - PlayerNaturallySpawnCreaturesEvent
     public org.bukkit.event.player.PlayerQuitEvent.@Nullable QuitReason quitReason = null; // Paper - Add API for quit reason; there are a lot of changes to do if we change all methods leading to the event
+    private boolean tpsBar = false; // Purpur - Implement TPSBar
+    private boolean compassBar = false; // Purpur - Add compass command
+    private boolean ramBar = false; // Purpur - Implement rambar commands
 
     // Paper start - rewrite chunk system
     private ca.spottedleaf.moonrise.patches.chunk_system.player.RegionizedPlayerChunkLoader.PlayerChunkLoaderData chunkLoader;
@@ -506,6 +509,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.respawnConfig = input.read("respawn", ServerPlayer.RespawnConfig.CODEC).orElse(null);
         this.spawnExtraParticlesOnFall = input.getBooleanOr("spawn_extra_particles_on_fall", false);
         this.raidOmenPosition = input.read("raid_omen_position", BlockPos.CODEC).orElse(null);
+        this.tpsBar = input.getBooleanOr("Purpur.TPSBar", false); // Purpur - Implement TPSBar
+        this.compassBar = input.getBooleanOr("Purpur.CompassBar", false); // Purpur - Add compass command
+        this.ramBar = input.getBooleanOr("Purpur.RamBar", false); // Purpur - Implement rambar command
         // Paper start - Expand PlayerGameModeChangeEvent
         this.loadGameTypes(input);
     }
@@ -547,6 +553,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
             output.store("ShoulderEntityRight", CompoundTag.CODEC, this.getShoulderEntityRight());
         }
         this.getBukkitEntity().setExtraData(output); // CraftBukkit
+        output.putBoolean("Purpur.TPSBar", this.tpsBar); // Purpur - Implement TPSBar
+        output.putBoolean("Purpur.CompassBar", this.compassBar); // Purpur - Add compass command
+        output.putBoolean("Purpur.RamBar", this.ramBar); // Purpur - Add rambar command
     }
 
     private void saveParentVehicle(ValueOutput output) {
@@ -763,6 +772,15 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.trackEnteredOrExitedLavaOnVehicle();
         this.updatePlayerAttributes();
         this.advancements.flushDirty(this, true);
+
+        // Purpur start - Ridables
+        if (this.level().purpurConfig.useNightVisionWhenRiding && this.getVehicle() != null && this.getVehicle().getRider() == this && this.level().getGameTime() % 100 == 0) { // 5 seconds
+            MobEffectInstance nightVision = this.getEffect(MobEffects.NIGHT_VISION);
+            if (nightVision == null || nightVision.getDuration() <= 300) { // 15 seconds
+                this.addEffect(new MobEffectInstance(MobEffects.NIGHT_VISION, 400, 0)); // 20 seconds
+            }
+        }
+        // Purpur end - Ridables
     }
 
     private void updatePlayerAttributes() {
@@ -1183,6 +1201,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
             // Paper - moved up to sendClientboundPlayerCombatKillPacket()
             sendClientboundPlayerCombatKillPacket(event.getShowDeathMessages(), deathScreenMessage); // Paper - Expand PlayerDeathEvent
             Team team = this.getTeam();
+            if (org.purpurmc.purpur.PurpurConfig.deathMessageOnlyBroadcastToAffectedPlayer) this.sendSystemMessage(deathMessage); else // Purpur - Configurable broadcast settings
             if (team == null || team.getDeathMessageVisibility() == Team.Visibility.ALWAYS) {
                 this.server.getPlayerList().broadcastSystemMessage(deathMessage, false);
             } else if (team.getDeathMessageVisibility() == Team.Visibility.HIDE_FOR_OTHER_TEAMS) {
@@ -1290,6 +1309,18 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         if (this.isInvulnerableTo(level, damageSource)) {
             return false;
         } else {
+            // Purpur start - Add boat fall damage config
+            if (damageSource.is(net.minecraft.tags.DamageTypeTags.IS_FALL)) {
+                // Purpur start - Minecart settings and WASD controls
+                if (getRootVehicle() instanceof AbstractMinecart && level().purpurConfig.minecartControllable && !level().purpurConfig.minecartControllableFallDamage) {
+                    return false;
+                }
+                // Purpur end - Minecart settings and WASD controls
+                if (getRootVehicle() instanceof net.minecraft.world.entity.vehicle.boat.Boat && !level().purpurConfig.boatsDoFallDamage) {
+                    return false;
+                }
+            }
+            // Purpur end - Add boat fall damage config
             Entity entity = damageSource.getEntity();
             if (!( // Paper - split the if statement. If below statement is false, hurtServer would not have been evaluated. Return false.
              !(entity instanceof Player player && !this.canHarmPlayer(player))
@@ -1544,6 +1575,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
                 profilerFiller.pop();
                 profilerFiller.push("placing");
+                this.portalPos = org.bukkit.craftbukkit.util.CraftLocation.toBlockPosition(exit); // Purpur - Fix stuck in portals
                 this.setServerLevel(level);
                 this.connection.internalTeleport(PositionMoveRotation.of(teleportTransition), teleportTransition.relatives()); // CraftBukkit - use internal teleport without event
                 this.connection.resetPosition();
@@ -1652,7 +1684,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                                 new AABB(vec3.x() - 8.0, vec3.y() - 5.0, vec3.z() - 8.0, vec3.x() + 8.0, vec3.y() + 5.0, vec3.z() + 8.0),
                                 monster -> monster.isPreventingPlayerRest(this.level(), this)
                             );
-                        if (!entitiesOfClass.isEmpty()) {
+                        if (!this.level().purpurConfig.playerSleepNearMonsters && !entitiesOfClass.isEmpty()) { // Purpur - Config to ignore nearby mobs when sleeping
                             return Either.left(Player.BedSleepingProblem.NOT_SAFE);
                         }
                     }
@@ -1692,8 +1724,19 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                         CriteriaTriggers.SLEPT_IN_BED.trigger(this);
                     });
                     if (!this.level().canSleepThroughNights()) {
-                        this.displayClientMessage(Component.translatable("sleep.not_possible"), true);
+                        // Purpur start - Customizable sleeping actionbar messages
+                    Component clientMessage;
+                    if (org.purpurmc.purpur.PurpurConfig.sleepNotPossible.isBlank()) {
+                        clientMessage = null;
+                    } else if (!org.purpurmc.purpur.PurpurConfig.sleepNotPossible.equalsIgnoreCase("default")) {
+                        clientMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.sleepNotPossible));
+                    } else {
+                        clientMessage = Component.translatable("sleep.not_possible");
                     }
+                    if (clientMessage != null) {
+                        this.displayClientMessage(clientMessage, true);
+                    }// Purpur end - Customizable sleeping actionbar messages
+                }
 
                     this.level().updateSleepingPlayerList();
                     return either;
@@ -1784,6 +1827,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
     @Override
     public void openTextEdit(SignBlockEntity signEntity, boolean isFrontText) {
+        if (level().purpurConfig.signAllowColors) this.connection.send(signEntity.getTranslatedUpdatePacket(textFilteringEnabled, isFrontText)); // Purpur - Signs allow color codes
         this.connection.send(new ClientboundBlockUpdatePacket(this.level(), signEntity.getBlockPos()));
         this.connection.send(new ClientboundOpenSignEditorPacket(signEntity.getBlockPos(), isFrontText));
     }
@@ -2121,6 +2165,26 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.lastSentExp = -1; // CraftBukkit - Added to reset
     }
 
+    // Purpur start - Component related conveniences
+    public void sendActionBarMessage(@Nullable String message) {
+        if (message != null && !message.isEmpty()) {
+            sendActionBarMessage(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message));
+        }
+    }
+
+    public void sendActionBarMessage(net.kyori.adventure.text.@Nullable Component message) {
+        if (message != null) {
+            sendActionBarMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message));
+        }
+    }
+
+    public void sendActionBarMessage(@Nullable Component message) {
+        if (message != null) {
+            displayClientMessage(message, true);
+        }
+    }
+    // Purpur end - Component related conveniences
+
     @Override
     public void displayClientMessage(Component message, boolean overlay) {
         this.sendSystemMessage(message, overlay);
@@ -2355,6 +2419,20 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         );
     }
 
+    // Purpur start - Component related conveniences
+    public void sendMiniMessage(@Nullable String message) {
+        if (message != null && !message.isEmpty()) {
+            this.sendMessage(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message));
+        }
+    }
+
+    public void sendMessage(net.kyori.adventure.text.@Nullable Component message) {
+        if (message != null) {
+            this.sendSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message));
+        }
+    }
+    // Purpur end - Component related conveniences
+
     public void sendSystemMessage(Component message) {
         this.sendSystemMessage(message, false);
     }
@@ -2492,8 +2570,68 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
     public void resetLastActionTime() {
         this.lastActionTime = Util.getMillis();
+        this.setAfk(false); // Purpur - AFK API
     }
 
+    // Purpur start - AFK API
+    private boolean isAfk = false;
+
+    @Override
+    public void setAfk(boolean afk) {
+        if (this.isAfk == afk) {
+            return;
+        }
+
+        String msg = afk ? org.purpurmc.purpur.PurpurConfig.afkBroadcastAway : org.purpurmc.purpur.PurpurConfig.afkBroadcastBack;
+
+        org.purpurmc.purpur.event.PlayerAFKEvent event = new org.purpurmc.purpur.event.PlayerAFKEvent(this.getBukkitEntity(), afk, this.level().purpurConfig.idleTimeoutKick, msg, !org.bukkit.Bukkit.isPrimaryThread());
+        if (!event.callEvent() || event.shouldKick()) {
+            return;
+        }
+
+        this.isAfk = afk;
+
+        if (!afk) {
+            resetLastActionTime();
+        }
+
+        msg = event.getBroadcastMsg();
+        if (msg != null && !msg.isEmpty()) {
+            String playerName = this.getGameProfile().name();
+            if (org.purpurmc.purpur.PurpurConfig.afkBroadcastUseDisplayName) {
+                net.kyori.adventure.text.Component playerDisplayNameComponent = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(this.getBukkitEntity().getDisplayName());
+                playerName = net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer.plainText().serialize(playerDisplayNameComponent);
+            }
+            server.getPlayerList().broadcastMiniMessage(String.format(msg, playerName), false);
+        }
+
+        if (this.level().purpurConfig.idleTimeoutUpdateTabList) {
+            String scoreboardName = getScoreboardName();
+            String playerListName = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().serialize(getBukkitEntity().playerListName());
+            String[] split = playerListName.split(scoreboardName);
+            String prefix = (split.length > 0 ? split[0] : "").replace(org.purpurmc.purpur.PurpurConfig.afkTabListPrefix, "");
+            String suffix = (split.length > 1 ? split[1] : "").replace(org.purpurmc.purpur.PurpurConfig.afkTabListSuffix, "");
+            if (afk) {
+                getBukkitEntity().setPlayerListName(org.purpurmc.purpur.PurpurConfig.afkTabListPrefix + prefix + scoreboardName + suffix + org.purpurmc.purpur.PurpurConfig.afkTabListSuffix, true);
+            } else {
+                getBukkitEntity().setPlayerListName(prefix + scoreboardName + suffix, true);
+            }
+        }
+
+        ((ServerLevel) this.level()).updateSleepingPlayerList();
+    }
+
+    @Override
+    public boolean isAfk() {
+        return this.isAfk;
+    }
+
+    @Override
+    public boolean canBeCollidedWith(Entity entity) {
+        return !this.isAfk() && super.canBeCollidedWith(entity);
+    }
+    // Purpur end - AFK API
+
     public ServerStatsCounter getStats() {
         return this.stats;
     }
@@ -3126,4 +3264,65 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         return (org.bukkit.craftbukkit.entity.CraftPlayer) super.getBukkitEntity();
     }
     // CraftBukkit end
+
+    // Purpur start - Add option to teleport to spawn if outside world border
+    public void teleport(org.bukkit.Location to) {
+        this.ejectPassengers();
+        this.stopRiding(true);
+
+        if (this.isSleeping()) {
+            this.stopSleepInBed(true, false);
+        }
+
+        if (this.containerMenu != this.inventoryMenu) {
+            this.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.TELEPORT);
+        }
+
+        ServerLevel toLevel = ((org.bukkit.craftbukkit.CraftWorld) to.getWorld()).getHandle();
+        if (this.level() == toLevel) {
+            this.connection.internalTeleport(to);
+        } else {
+            this.teleport(new TeleportTransition(
+                toLevel,
+                org.bukkit.craftbukkit.util.CraftLocation.toVec3(to),
+                Vec3.ZERO,
+                to.getYaw(),
+                to.getPitch(),
+                net.minecraft.world.entity.Relative.ALL,
+                TeleportTransition.DO_NOTHING,
+                org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN
+            ));
+        }
+    }
+    // Purpur end - Add option to teleport to spawn if outside world border
+
+    // Purpur start - Implement TPSBar
+    public boolean tpsBar() {
+        return this.tpsBar;
+    }
+
+    public void tpsBar(boolean tpsBar) {
+        this.tpsBar = tpsBar;
+    }
+    // Purpur end - Implement TPSBar
+
+    // Purpur start - Add compass command
+    public boolean compassBar() {
+        return this.compassBar;
+    }
+
+    public void compassBar(boolean compassBar) {
+        this.compassBar = compassBar;
+    }
+    // Purpur end - Add compass command
+
+    // Purpur start - Add rambar command
+    public boolean ramBar() {
+        return this.ramBar;
+    }
+
+    public void ramBar(boolean ramBar) {
+        this.ramBar = ramBar;
+    }
+    // Purpur end - Add rambar command
 }
diff --git a/net/minecraft/server/level/ServerPlayerGameMode.java b/net/minecraft/server/level/ServerPlayerGameMode.java
index 84d19d79e77cec6a5d64f59fbcce703e467b2407..9b9cdb23a55b82efbeea3ba68b8144c15791dff0 100644
--- a/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -365,6 +365,7 @@ public class ServerPlayerGameMode {
                 }
                 return false;
             }
+            if (this.player.level().purpurConfig.slabHalfBreak && this.player.isShiftKeyDown() && blockState.getBlock() instanceof net.minecraft.world.level.block.SlabBlock && ((net.minecraft.world.level.block.SlabBlock) blockState.getBlock()).halfBreak(blockState, pos, this.player)) return true; // Purpur - Break individual slabs when sneaking
         }
         // CraftBukkit end
 
@@ -490,6 +491,7 @@ public class ServerPlayerGameMode {
     public InteractionHand interactHand;
     public ItemStack interactItemStack;
     public InteractionResult useItemOn(ServerPlayer player, Level level, ItemStack stack, InteractionHand hand, BlockHitResult hitResult) {
+        if (shiftClickMended(stack)) return InteractionResult.SUCCESS; // Purpur - Shift right click to use exp for mending
         BlockPos blockPos = hitResult.getBlockPos();
         BlockState blockState = level.getBlockState(blockPos);
         boolean cancelledBlock = false;
@@ -538,7 +540,7 @@ public class ServerPlayerGameMode {
             boolean flag = !player.getMainHandItem().isEmpty() || !player.getOffhandItem().isEmpty();
             boolean flag1 = player.isSecondaryUseActive() && flag;
             ItemStack itemStack = stack.copy();
-            if (!flag1) {
+            if (!flag1 || (player.level().purpurConfig.composterBulkProcess && blockState.is(net.minecraft.world.level.block.Blocks.COMPOSTER))) { // Purpur - Sneak to bulk process composter
                 InteractionResult interactionResult = blockState.useItemOn(player.getItemInHand(hand), level, player, hand, hitResult);
                 if (interactionResult.consumesAction()) {
                     CriteriaTriggers.ITEM_USED_ON_BLOCK.trigger(player, blockPos, itemStack);
@@ -584,4 +586,18 @@ public class ServerPlayerGameMode {
     public void setLevel(ServerLevel level) {
         this.level = level;
     }
+
+    // Purpur start - Shift right click to use exp for mending
+    public boolean shiftClickMended(ItemStack itemstack) {
+        if (this.player.level().purpurConfig.shiftRightClickRepairsMendingPoints > 0 && this.player.isShiftKeyDown() && this.player.getBukkitEntity().hasPermission("purpur.mending_shift_click")) {
+            int points = Math.min(this.player.totalExperience, this.player.level().purpurConfig.shiftRightClickRepairsMendingPoints);
+            if (points > 0 && itemstack.isDamaged() && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.MENDING, itemstack) > 0) {
+                this.player.giveExperiencePoints(itemstack.getDamageValue() == 1 ? -2 : -points);
+                this.player.level().addFreshEntity(new net.minecraft.world.entity.ExperienceOrb(this.player.level(), this.player.getX(), this.player.getY(), this.player.getZ(), itemstack.getDamageValue() == 1 ? 1 : points, org.bukkit.entity.ExperienceOrb.SpawnReason.UNKNOWN, this.player, this.player));
+                return true;
+            }
+        }
+        return false;
+    }
+    // Purpur end - Shift right click to use exp for mending
 }
diff --git a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index b8a4b4cc02a2fc6b70f4b840796eed501aad6239..d5bf3b49d34a04294c92a5b5b5d2de290642fc5e 100644
--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -54,6 +54,10 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     public final java.util.Map<java.util.UUID, net.kyori.adventure.resource.ResourcePackCallback> packCallbacks = new java.util.concurrent.ConcurrentHashMap<>(); // Paper - adventure resource pack callbacks
     private static final long KEEPALIVE_LIMIT = Long.getLong("paper.playerconnection.keepalive", 30) * 1000; // Paper - provide property to set keepalive limit
     protected static final net.minecraft.resources.Identifier MINECRAFT_BRAND = net.minecraft.resources.Identifier.withDefaultNamespace("brand"); // Paper - Brand support
+    // Purpur start - Purpur client support
+    protected static final net.minecraft.resources.Identifier PURPUR_CLIENT = net.minecraft.resources.Identifier.fromNamespaceAndPath("purpur", "client");
+    public boolean purpurClient;
+    // Purpur end - Purpur client support
     // Paper start - retain certain values
     public @Nullable String playerBrand;
     public final java.util.Set<String> pluginMessagerChannels;
@@ -179,6 +183,12 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
                 return;
             }
 
+            // Purpur start - Purpur client support
+            if (identifier.equals(PURPUR_CLIENT)) {
+                this.purpurClient = true;
+            }
+            // Purpur end - Purpur client support
+
             if (identifier.equals(MINECRAFT_BRAND)) {
                 this.playerBrand = new net.minecraft.network.FriendlyByteBuf(io.netty.buffer.Unpooled.wrappedBuffer(data)).readUtf(256);
             }
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 3c2e9e6a1218d38573405a2747bee2fd66dc12fc..386334cadc176c25f4f1aa8952c70edc31e9f02f 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -346,6 +346,20 @@ public class ServerGamePacketListenerImpl
     }
     // Paper end - configuration phase API
 
+    // Purpur start - AFK API
+    private final com.google.common.cache.LoadingCache<org.bukkit.craftbukkit.entity.CraftPlayer, Boolean> kickPermissionCache = com.google.common.cache.CacheBuilder.newBuilder()
+        .maximumSize(1000)
+        .expireAfterWrite(1, java.util.concurrent.TimeUnit.MINUTES)
+        .build(
+            new com.google.common.cache.CacheLoader<>() {
+                @Override
+                public Boolean load(org.bukkit.craftbukkit.entity.CraftPlayer player) {
+                    return player.hasPermission("purpur.bypassIdleKick");
+                }
+            }
+        );
+    // Purpur end - AFK API
+
     @Override
     public void tick() {
         if (this.ackBlockChangesUpTo > -1) {
@@ -363,6 +377,12 @@ public class ServerGamePacketListenerImpl
                 && this.server.playerIdleTimeout() > 0
                 && Util.getMillis() - this.player.getLastActionTime() > TimeUnit.MINUTES.toMillis(this.server.playerIdleTimeout())
                 && !this.player.wonGame) {
+                // Purpur start - AFK API
+                this.player.setAfk(true);
+                if (!this.player.level().purpurConfig.idleTimeoutKick || (!Boolean.parseBoolean(System.getenv("PURPUR_FORCE_IDLE_KICK")) && kickPermissionCache.getUnchecked(this.player.getBukkitEntity()))) {
+                    return;
+                }
+                // Purpur end - AFK API
                 this.disconnect(Component.translatable("multiplayer.disconnect.idling"), org.bukkit.event.player.PlayerKickEvent.Cause.IDLING); // Paper - kick event cause
             }
         }
@@ -682,6 +702,8 @@ public class ServerGamePacketListenerImpl
                     this.lastYaw = to.getYaw();
                     this.lastPitch = to.getPitch();
 
+                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur - AFK API
+
                     Location oldTo = to.clone();
                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                     this.cserver.getPluginManager().callEvent(event);
@@ -761,6 +783,7 @@ public class ServerGamePacketListenerImpl
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
         if (packet.getId() == this.awaitingTeleport) {
             if (this.awaitingPositionFromClient == null) {
+                ServerGamePacketListenerImpl.LOGGER.warn("Disconnected on accept teleport packet. Was not expecting position data from client at this time"); // Purpur - Add more logger output for invalid movement kicks
                 this.disconnect(Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
                 return;
             }
@@ -1301,6 +1324,10 @@ public class ServerGamePacketListenerImpl
             final int maxBookPageSize = pageMax.intValue();
             final double multiplier = Math.clamp(io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.bookSize.totalMultiplier, 0.3D, 1D);
             long byteAllowed = maxBookPageSize;
+            // Purpur start - PlayerBookTooLargeEvent
+            int slot = packet.slot();
+            ItemStack itemstack = Inventory.isHotbarSlot(slot) || slot == Inventory.SLOT_OFFHAND ? this.player.getInventory().getItem(slot) : ItemStack.EMPTY;
+            // Purpur end - PlayerBookTooLargeEvent
             for (final String page : pageList) {
                 final int byteLength = page.getBytes(java.nio.charset.StandardCharsets.UTF_8).length;
                 byteTotal += byteLength;
@@ -1325,7 +1352,8 @@ public class ServerGamePacketListenerImpl
             }
 
             if (byteTotal > byteAllowed) {
-                ServerGamePacketListenerImpl.LOGGER.warn("{} tried to send a book too large. Book size: {} - Allowed: {} - Pages: {}", this.player.getScoreboardName(), byteTotal, byteAllowed, pageList.size());
+                ServerGamePacketListenerImpl.LOGGER.warn("{} tried to send too large of a book. Book size: {} - Allowed: {} - Pages: {}", this.player.getScoreboardName(), byteTotal, byteAllowed, pageList.size());
+                org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent event = new org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent(player.getBukkitEntity(), itemstack.asBukkitCopy()); if (event.shouldKickPlayer()) // Purpur - PlayerBookTooLargeEvent
                 this.disconnectAsync(Component.literal("Book too large!"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause // Paper - add proper async disconnect
                 return;
             }
@@ -1344,31 +1372,45 @@ public class ServerGamePacketListenerImpl
             Optional<String> optional = packet.title();
             optional.ifPresent(list::add);
             list.addAll(packet.pages());
+            // Purpur start - Allow color codes in books
+            boolean hasEditPerm = getCraftPlayer().hasPermission("purpur.book.color.edit");
+            boolean hasSignPerm = hasEditPerm || getCraftPlayer().hasPermission("purpur.book.color.sign");
+            // Purpur end - Allow color codes in books
             Consumer<List<FilteredText>> consumer = optional.isPresent()
-                ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot)
-                : list1 -> this.updateBookContents(list1, slot);
+                ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot, hasSignPerm) // Purpur - Allow color codes in books
+                : list1 -> this.updateBookContents(list1, slot, hasEditPerm); // Purpur - Allow color codes in books
             this.filterTextPacket(list).thenAcceptAsync(consumer, this.server);
         }
     }
 
     private void updateBookContents(List<FilteredText> pages, int index) {
+    // Purpur start - Allow color codes in books
+        updateBookContents(pages, index, false);
+    }
+    private void updateBookContents(List<FilteredText> pages, int index, boolean hasPerm) {
+    // Purpur end - Allow color codes in books
         // CraftBukkit start
         ItemStack handItem = this.player.getInventory().getItem(index);
         ItemStack item = handItem.copy();
         // CraftBukkit end
         if (item.has(DataComponents.WRITABLE_BOOK_CONTENT)) {
-            List<Filterable<String>> list = pages.stream().map(this::filterableFromOutgoing).toList();
+            List<Filterable<String>> list = pages.stream().map(filteredText -> filterableFromOutgoing(filteredText).map(s -> color(s, hasPerm))).toList(); // Purpur - Allow color codes in books
             item.set(DataComponents.WRITABLE_BOOK_CONTENT, new WritableBookContent(list));
             this.player.getInventory().setItem(index, CraftEventFactory.handleEditBookEvent(this.player, index, handItem, item)); // CraftBukkit // Paper - Don't ignore result (see other callsite for handleEditBookEvent)
         }
     }
 
     private void signBook(FilteredText title, List<FilteredText> pages, int index) {
+        // Purpur start - Allow color codes in books
+        signBook(title, pages, index, false);
+    }
+    private void signBook(FilteredText title, List<FilteredText> pages, int index, boolean hasPerm) {
+        // Purpur end - Allow color codes in books
         ItemStack item = this.player.getInventory().getItem(index);
         if (item.has(DataComponents.WRITABLE_BOOK_CONTENT)) {
             ItemStack itemStack = item.transmuteCopy(Items.WRITTEN_BOOK);
             itemStack.remove(DataComponents.WRITABLE_BOOK_CONTENT);
-            List<Filterable<Component>> list = pages.stream().map(filteredText -> this.filterableFromOutgoing(filteredText).<Component>map(Component::literal)).toList();
+            List<Filterable<Component>> list = pages.stream().map((filteredText) -> this.filterableFromOutgoing(filteredText).map(s -> hexColor(s, hasPerm))).toList(); // Purpur - Allow color codes in books
             itemStack.set(
                 DataComponents.WRITTEN_BOOK_CONTENT, new WrittenBookContent(this.filterableFromOutgoing(title), this.player.getPlainTextName(), 0, list, true)
             );
@@ -1381,6 +1423,16 @@ public class ServerGamePacketListenerImpl
         return this.player.isTextFilteringEnabled() ? Filterable.passThrough(filteredText.filteredOrEmpty()) : Filterable.from(filteredText);
     }
 
+    // Purpur start - Allow color codes in books
+    private Component hexColor(String str, boolean hasPerm) {
+        return hasPerm ? PaperAdventure.asVanilla(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacyAmpersand().deserialize(str)) : Component.literal(str);
+    }
+
+    private String color(String str, boolean hasPerm) {
+        return hasPerm ? org.bukkit.ChatColor.color(str, false) : str;
+    }
+    // Purpur end - Allow color codes in books
+
     @Override
     public void handleEntityTagQuery(ServerboundEntityTagQueryPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
@@ -1420,7 +1472,15 @@ public class ServerGamePacketListenerImpl
     @Override
     public void handleMovePlayer(ServerboundMovePlayerPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
-        if (containsInvalidValues(packet.getX(0.0), packet.getY(0.0), packet.getZ(0.0), packet.getYRot(0.0F), packet.getXRot(0.0F))) {
+        // Purpur start - Add more logger output for invalid movement kicks
+        boolean invalidX = Double.isNaN(packet.getX(0.0));
+        boolean invalidY = Double.isNaN(packet.getY(0.0));
+        boolean invalidZ = Double.isNaN(packet.getZ(0.0));
+        boolean invalidYaw = !Floats.isFinite(packet.getYRot(0.0F));
+        boolean invalidPitch = !Floats.isFinite(packet.getXRot(0.0F));
+        if (invalidX || invalidY || invalidZ || invalidYaw || invalidPitch) {
+            ServerGamePacketListenerImpl.LOGGER.warn(String.format("Disconnected on move player packet. Invalid data: x=%b, y=%b, z=%b, yaw=%b, pitch=%b", invalidX, invalidY, invalidZ, invalidYaw, invalidPitch));
+        // Purpur end - Add more logger output for invalid movement kicks
             this.disconnect(Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
         } else {
             ServerLevel serverLevel = this.player.level();
@@ -1603,7 +1663,7 @@ public class ServerGamePacketListenerImpl
                                         movedWrongly = true;
                                         if (event.getLogWarning())
                                      // Paper end
-                                    LOGGER.warn("{} moved wrongly!", this.player.getPlainTextName());
+                                    LOGGER.warn("{} moved wrongly!, ({})", this.player.getPlainTextName(), verticalDelta); // Purpur - AFK API
                                     } // Paper
                                 }
 
@@ -1668,6 +1728,8 @@ public class ServerGamePacketListenerImpl
                                         this.lastYaw = to.getYaw();
                                         this.lastPitch = to.getPitch();
 
+                                        if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur - AFK API
+
                                         Location oldTo = to.clone();
                                         PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                                         this.cserver.getPluginManager().callEvent(event);
@@ -1723,6 +1785,13 @@ public class ServerGamePacketListenerImpl
                                         this.player.tryResetCurrentImpulseContext();
                                     }
 
+                                    // Purpur start - Dont run with scissors!
+                                    if (this.player.level().purpurConfig.dontRunWithScissors && this.player.isSprinting() && !(this.player.level().purpurConfig.ignoreScissorsInWater && this.player.isInWater()) && !(this.player.level().purpurConfig.ignoreScissorsInLava && this.player.isInLava()) && (isScissors(this.player.getItemInHand(InteractionHand.MAIN_HAND)) || isScissors(this.player.getItemInHand(InteractionHand.OFF_HAND))) && (int) (Math.random() * 10) == 0) {
+                                        this.player.hurtServer(this.player.level(), this.player.damageSources().scissors(), (float) this.player.level().purpurConfig.scissorsRunningDamage);
+                                        if (!org.purpurmc.purpur.PurpurConfig.dontRunWithScissors.isBlank()) this.player.sendActionBarMessage(org.purpurmc.purpur.PurpurConfig.dontRunWithScissors);
+                                    }
+                                    // Purpur end - Dont run with scissors!
+
                                     this.player.checkMovementStatistics(this.player.getX() - x, this.player.getY() - y, this.player.getZ() - z);
                                     this.lastGoodX = this.player.getX();
                                     this.lastGoodY = this.player.getY();
@@ -1740,6 +1809,17 @@ public class ServerGamePacketListenerImpl
         }
     }
 
+    // Purpur start - Dont run with scissors!
+    public boolean isScissors(ItemStack stack) {
+        if (!stack.is(Items.SHEARS)) return false;
+
+        Identifier itemModelReference = stack.get(net.minecraft.core.component.DataComponents.ITEM_MODEL);
+        if (itemModelReference != null && itemModelReference.equals(this.player.level().purpurConfig.dontRunWithScissorsItemModelReference)) return true;
+
+        return stack.getOrDefault(DataComponents.CUSTOM_MODEL_DATA, net.minecraft.world.item.component.CustomModelData.EMPTY).equals(net.minecraft.world.item.component.CustomModelData.EMPTY);
+    }
+    // Purpur end - Dont run with scissors!
+
     private boolean shouldCheckPlayerMovement(boolean isElytraMovement) {
         if (this.isSingleplayerOwner()) {
             return false;
@@ -2168,6 +2248,7 @@ public class ServerGamePacketListenerImpl
 
                 boolean cancelled;
                 if (hitResult == null || hitResult.getType() != HitResult.Type.BLOCK) {
+                    if (this.player.gameMode.shiftClickMended(itemInHand)) return; // Purpur - Shift right click to use exp for mending
                     org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_AIR, itemInHand, hand);
                     cancelled = event.useItemInHand() == Event.Result.DENY;
                 } else {
@@ -2820,6 +2901,7 @@ public class ServerGamePacketListenerImpl
 
                 AABB boundingBox = target.getBoundingBox();
                 if (packet.isWithinRange(this.player, boundingBox, io.papermc.paper.configuration.GlobalConfiguration.get().misc.clientInteractionLeniencyDistance.or(3.0))) { // Paper - configurable lenience value for interact range
+                    if (target instanceof net.minecraft.world.entity.Mob mob) mob.ticksSinceLastInteraction = 0; // Purpur - Entity lifespan
                     packet.dispatch(
                         new ServerboundInteractPacket.Handler() {
                             private void performInteraction(InteractionHand hand, ServerGamePacketListenerImpl.EntityInteraction entityInteraction, PlayerInteractEntityEvent event) { // CraftBukkit
@@ -2833,6 +2915,8 @@ public class ServerGamePacketListenerImpl
                                     ServerGamePacketListenerImpl.this.cserver.getPluginManager().callEvent(event);
                                     final boolean resendData = event.isCancelled() || !ServerGamePacketListenerImpl.this.player.getItemInHand(hand).is(itemType);
 
+                                    player.processClick(hand); // Purpur - Ridables
+
                                     // Entity in bucket - SPIGOT-4048 and SPIGOT-6859
                                     if (itemType == Items.WATER_BUCKET && target instanceof net.minecraft.world.entity.animal.Bucketable && target instanceof LivingEntity && resendData) {
                                         target.resendPossiblyDesyncedEntityData(ServerGamePacketListenerImpl.this.player); // Paper - The entire mob gets deleted, so resend it
@@ -3580,7 +3664,7 @@ public class ServerGamePacketListenerImpl
     @Override
     public void handleChangeGameMode(ServerboundChangeGameModePacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
-        if (!GameModeCommand.PERMISSION_CHECK.check(this.player.permissions())) {
+        if (!GameModeCommand.PERMISSION_CHECK.check(this.player.permissions()) && !player.getBukkitEntity().hasPermission("purpur.debug.f3n")) { // Purpur - Add permission for F3+N debug
             LOGGER.warn(
                 "Player {} tried to change game mode to {} without required permissions",
                 this.player.getGameProfile().name(),
diff --git a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 51a29ab542136e67741be10bbc5c6377715a207c..e16bb386ae500bc290970f8cba33c5999cf0a58d 100644
--- a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -278,7 +278,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                         ServerLoginPacketListenerImpl.LOGGER.warn("Failed to verify username but will let them in anyway!");
                         ServerLoginPacketListenerImpl.this.startClientVerification(ServerLoginPacketListenerImpl.this.createOfflineProfile(string1)); // Spigot
                     } else {
-                        ServerLoginPacketListenerImpl.this.disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
+                        ServerLoginPacketListenerImpl.this.disconnect(org.purpurmc.purpur.PurpurConfig.unverifiedUsername.equals("default") ? Component.translatable("multiplayer.disconnect.unverified_username") : io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.unverifiedUsername))); // Purpur - Config for unverified username message
                         ServerLoginPacketListenerImpl.LOGGER.error("Username '{}' tried to join with an invalid session", string1);
                     }
                 } catch (AuthenticationUnavailableException var4) {
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index 79d31be804aa2780e96ff7d38e0b7a015fcd3b82..c8de21af40c435eb9410cf668ec2a3ac163237f5 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -311,6 +311,7 @@ public abstract class PlayerList {
             scoreboard.addPlayerToTeam(player.getScoreboardName(), collideRuleTeam);
         }
         // Paper end - Configurable player collision
+        org.purpurmc.purpur.task.BossBarTask.addToAll(player); // Purpur - Implement TPSBar
         // CraftBukkit start - moved down
         LOGGER.info(
             "{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", // CraftBukkit - add world name
@@ -431,6 +432,7 @@ public abstract class PlayerList {
     }
     public net.kyori.adventure.text.@Nullable Component remove(ServerPlayer player, net.kyori.adventure.text.Component leaveMessage) {
         // Paper end - Fix kick event leave message not being sent
+        org.purpurmc.purpur.task.BossBarTask.removeFromAll(player.getBukkitEntity()); // Purpur - Implement TPSBar
         ServerLevel serverLevel = player.level();
         player.awardStat(Stats.LEAVE_GAME);
         // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
@@ -770,6 +772,20 @@ public abstract class PlayerList {
         }
     }
 
+    // Purpur start - Component related conveniences
+    public void broadcastMiniMessage(@Nullable String message, boolean overlay) {
+        if (message != null && !message.isEmpty()) {
+            this.broadcastMessage(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message), overlay);
+        }
+    }
+
+    public void broadcastMessage(net.kyori.adventure.text.@Nullable Component message, boolean overlay) {
+        if (message != null) {
+            this.broadcastSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message), overlay);
+        }
+    }
+    // Purpur end - Component related conveniences
+
     public void broadcastAll(Packet<?> packet, ResourceKey<Level> dimension) {
         for (ServerPlayer serverPlayer : this.players) {
             if (serverPlayer.level().dimension() == dimension) {
@@ -863,6 +879,7 @@ public abstract class PlayerList {
                 case ADMINS -> EntityEvent.PERMISSION_LEVEL_ADMINS;
                 case OWNERS -> EntityEvent.PERMISSION_LEVEL_OWNERS;
             };
+            if (b < EntityEvent.PERMISSION_LEVEL_OWNERS && player.getBukkitEntity().hasPermission("purpur.debug.f3n")) b = EntityEvent.PERMISSION_LEVEL_OWNERS; // Purpur - Add permission for F3+N debug
             player.connection.send(new ClientboundEntityEventPacket(player, b));
         }
 
@@ -870,11 +887,32 @@ public abstract class PlayerList {
         player.getBukkitEntity().recalculatePermissions(); // CraftBukkit
         this.server.getCommands().sendCommands(player);
         } // Paper - Add sendOpLevel API
+
+        // Purpur start - Barrels and enderchests 6 rows
+        if (org.purpurmc.purpur.PurpurConfig.enderChestSixRows && org.purpurmc.purpur.PurpurConfig.enderChestPermissionRows) {
+            org.bukkit.craftbukkit.entity.CraftHumanEntity bukkit = player.getBukkitEntity();
+            if (bukkit.hasPermission("purpur.enderchest.rows.six")) {
+                player.sixRowEnderchestSlotCount = 54;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.five")) {
+                player.sixRowEnderchestSlotCount = 45;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.four")) {
+                player.sixRowEnderchestSlotCount = 36;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.three")) {
+                player.sixRowEnderchestSlotCount = 27;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.two")) {
+                player.sixRowEnderchestSlotCount = 18;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.one")) {
+                player.sixRowEnderchestSlotCount = 9;
+            }
+        } else {
+            player.sixRowEnderchestSlotCount = -1;
+        }
+        // Purpur end - Barrels and enderchests 6 rows
     }
 
     // Paper start - whitelist verify event / login event
     public LoginResult canBypassFullServerLogin(final NameAndId nameAndId, final LoginResult currentResult) {
-        final boolean shouldKick = this.players.size() >= this.getMaxPlayers() && !this.canBypassPlayerLimit(nameAndId);
+        final boolean shouldKick = this.players.size() >= this.getMaxPlayers() && !(/*player.hasPermission("purpur.joinfullserver") || */this.canBypassPlayerLimit(nameAndId)); // Purpur - Allow player join full server by permission TODO: this hasn't worked for a while, so comment it out until we can reliably check perms of the player joining
         final io.papermc.paper.event.player.PlayerServerFullCheckEvent fullCheckEvent = new io.papermc.paper.event.player.PlayerServerFullCheckEvent(
             new com.destroystokyo.paper.profile.CraftPlayerProfile(nameAndId),
             io.papermc.paper.adventure.PaperAdventure.asAdventure(currentResult.message),
diff --git a/net/minecraft/server/players/SleepStatus.java b/net/minecraft/server/players/SleepStatus.java
index 2a7ae521654ad5c9f392baa5562e64bb71b13097..3a3e6992563236141db687084aeec9684437a7db 100644
--- a/net/minecraft/server/players/SleepStatus.java
+++ b/net/minecraft/server/players/SleepStatus.java
@@ -15,7 +15,7 @@ public class SleepStatus {
 
     public boolean areEnoughDeepSleeping(int requiredSleepPercentage, List<ServerPlayer> sleepingPlayers) {
         // CraftBukkit start
-        int i = (int) sleepingPlayers.stream().filter(player -> player.isSleepingLongEnough() || player.fauxSleeping).count();
+        int i = (int) sleepingPlayers.stream().filter(player -> player.isSleepingLongEnough() || player.fauxSleeping || (player.level().purpurConfig.idleTimeoutCountAsSleeping && player.isAfk())).count(); // Purpur - AFK API
         boolean anyDeepSleep = sleepingPlayers.stream().anyMatch(Player::isSleepingLongEnough);
         return anyDeepSleep && i >= this.sleepersNeeded(requiredSleepPercentage);
         // CraftBukkit end
@@ -43,7 +43,7 @@ public class SleepStatus {
         for (ServerPlayer serverPlayer : players) {
             if (!serverPlayer.isSpectator()) {
                 this.activePlayers++;
-                if (serverPlayer.isSleeping() || serverPlayer.fauxSleeping) { // CraftBukkit
+                if (serverPlayer.isSleeping() || serverPlayer.fauxSleeping || (serverPlayer.level().purpurConfig.idleTimeoutCountAsSleeping && serverPlayer.isAfk())) { // CraftBukkit // Purpur - AFK API
                     this.sleepingPlayers++;
                 }
                 // CraftBukkit start
diff --git a/net/minecraft/util/StringUtil.java b/net/minecraft/util/StringUtil.java
index bd57f9a4224fc236cccecfd13b03f27d20ed15e9..da0018214439511288a43ca665abec6f01441f47 100644
--- a/net/minecraft/util/StringUtil.java
+++ b/net/minecraft/util/StringUtil.java
@@ -87,6 +87,7 @@ public class StringUtil {
 
     // Paper start - Username validation
     public static boolean isReasonablePlayerName(final String name) {
+        if (true) return org.purpurmc.purpur.PurpurConfig.usernameValidCharactersPattern.matcher(name).matches(); // Purpur - Configurable valid characters for usernames
         if (name.isEmpty() || name.length() > 16) {
             return false;
         }
diff --git a/net/minecraft/world/damagesource/CombatRules.java b/net/minecraft/world/damagesource/CombatRules.java
index 5f8637dfe4703cb78f486fe49d2e81518cf48715..d27215349f63e73198d23e107a6b634ddef8f7ca 100644
--- a/net/minecraft/world/damagesource/CombatRules.java
+++ b/net/minecraft/world/damagesource/CombatRules.java
@@ -15,7 +15,7 @@ public class CombatRules {
 
     public static float getDamageAfterAbsorb(LivingEntity entity, float damageAmount, DamageSource damageSource, float armorValue, float armorToughness) {
         float f = 2.0F + armorToughness / 4.0F;
-        float f1 = Mth.clamp(armorValue - damageAmount / f, armorValue * 0.2F, 20.0F);
+        float f1 = Mth.clamp(armorValue - damageAmount / f, armorValue * 0.2F, org.purpurmc.purpur.PurpurConfig.limitArmor ? 20F : Float.MAX_VALUE); // Purpur - Add attribute clamping and armor limit config
         float f2 = f1 / 25.0F;
         ItemStack weaponItem = damageSource.getWeaponItem();
         float f3;
@@ -30,7 +30,7 @@ public class CombatRules {
     }
 
     public static float getDamageAfterMagicAbsorb(float damageAmount, float enchantModifiers) {
-        float f = Mth.clamp(enchantModifiers, 0.0F, 20.0F);
+        float f = Mth.clamp(enchantModifiers, 0.0F, org.purpurmc.purpur.PurpurConfig.limitArmor ? 20F : Float.MAX_VALUE); // Purpur - Add attribute clamping and armor limit config
         return damageAmount * (1.0F - f / 25.0F);
     }
 }
diff --git a/net/minecraft/world/damagesource/CombatTracker.java b/net/minecraft/world/damagesource/CombatTracker.java
index ffdfb4c4e3d6496ebdba6e4bad7146a9cbdcf5ec..30d0807d7adf46a6cd23b81b979e06f943a2bca1 100644
--- a/net/minecraft/world/damagesource/CombatTracker.java
+++ b/net/minecraft/world/damagesource/CombatTracker.java
@@ -64,7 +64,7 @@ public class CombatTracker {
 
     private Component getMessageForAssistedFall(Entity entity, Component entityDisplayName, String hasWeaponTranslationKey, String noWeaponTranslationKey) {
         ItemStack itemStack = entity instanceof LivingEntity livingEntity ? livingEntity.getMainHandItem() : ItemStack.EMPTY;
-        return !itemStack.isEmpty() && itemStack.has(DataComponents.CUSTOM_NAME)
+        return !itemStack.isEmpty() && (org.purpurmc.purpur.PurpurConfig.playerDeathsAlwaysShowItem || itemStack.has(DataComponents.CUSTOM_NAME)) // Purpur - always show item in player death messages
             ? Component.translatable(hasWeaponTranslationKey, this.mob.getDisplayName(), entityDisplayName, itemStack.getDisplayName())
             : Component.translatable(noWeaponTranslationKey, this.mob.getDisplayName(), entityDisplayName);
     }
@@ -107,6 +107,15 @@ public class CombatTracker {
                 Component component = ComponentUtils.wrapInSquareBrackets(Component.translatable(string + ".link")).withStyle(INTENTIONAL_GAME_DESIGN_STYLE);
                 return Component.translatable(string + ".message", this.mob.getDisplayName(), component);
             } else {
+                // Purpur start - Dont run with scissors!
+                if (damageSource.isScissors()) {
+                    return damageSource.getLocalizedDeathMessage(org.purpurmc.purpur.PurpurConfig.deathMsgRunWithScissors, this.mob);
+                // Purpur start - Stonecutter damage
+                } else if (damageSource.isStonecutter()) {
+                    return damageSource.getLocalizedDeathMessage(org.purpurmc.purpur.PurpurConfig.deathMsgStonecutter, this.mob);
+                // Purpur end - Stonecutter damage
+                }
+                // Purpur end - Dont run with scissors!
                 return damageSource.getLocalizedDeathMessage(this.mob);
             }
         }
diff --git a/net/minecraft/world/damagesource/DamageSource.java b/net/minecraft/world/damagesource/DamageSource.java
index 4df37fcd42b8edf789ee8e99d61ee1fa6471288b..67318e32fa58a89ba9321a36627af07697aacea4 100644
--- a/net/minecraft/world/damagesource/DamageSource.java
+++ b/net/minecraft/world/damagesource/DamageSource.java
@@ -24,6 +24,8 @@ public class DamageSource {
     private org.bukkit.block.@Nullable Block eventBlockDamager; // Relevant block set. damageSourcePosition is only used for bad respawn point explosion or custom damage
     private org.bukkit.block.@Nullable BlockState fromBlockSnapshot; // Captured block snapshot when the eventBlockDamager is not relevant (e.g. for bad respawn point explosions the block is already removed)
     private boolean critical; // Supports arrows and sweeping damage
+    private boolean scissors = false; // Purpur - Dont run with scissors!
+    private boolean stonecutter = false; // Purpur - Stonecutter damage
 
     public DamageSource knownCause(final org.bukkit.event.entity.EntityDamageEvent.DamageCause cause) {
         final DamageSource damageSource = this.copy();
@@ -35,6 +37,30 @@ public class DamageSource {
         return this.knownCause;
     }
 
+    // Purpur start - Dont run with scissors!
+    public DamageSource scissors() {
+        this.knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.SUICIDE);
+        this.scissors = true;
+        return this;
+    }
+
+    public boolean isScissors() {
+        return this.scissors;
+    }
+    // Purpur end - Dont run with scissors!
+
+    // Purpur start -  - Stonecutter damage
+    public DamageSource stonecutter() {
+        this.knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.CONTACT);
+        this.stonecutter = true;
+        return this;
+    }
+
+    public boolean isStonecutter() {
+        return this.stonecutter;
+    }
+    // Purpur end - Stonecutter damage
+
     @Nullable
     public Entity eventEntityDamager() {
         return this.eventEntityDamager;
@@ -94,6 +120,8 @@ public class DamageSource {
         damageSource.eventBlockDamager = this.eventBlockDamager;
         damageSource.fromBlockSnapshot = this.fromBlockSnapshot;
         damageSource.critical = this.critical;
+        damageSource.scissors = this.isScissors(); // Purpur - Dont run with scissors!
+        damageSource.stonecutter = this.isStonecutter(); // Purpur - Stonecutter damage
         return damageSource;
     }
     // CraftBukkit end
@@ -157,12 +185,21 @@ public class DamageSource {
         } else {
             Component component = this.causingEntity == null ? this.directEntity.getDisplayName() : this.causingEntity.getDisplayName();
             ItemStack itemStack = this.causingEntity instanceof LivingEntity livingEntity1 ? livingEntity1.getMainHandItem() : ItemStack.EMPTY;
-            return !itemStack.isEmpty() && itemStack.has(DataComponents.CUSTOM_NAME)
+            return !itemStack.isEmpty() && (org.purpurmc.purpur.PurpurConfig.playerDeathsAlwaysShowItem || itemStack.has(DataComponents.CUSTOM_NAME)) // Purpur - always show item in player death messages
                 ? Component.translatable(string + ".item", livingEntity.getDisplayName(), component, itemStack.getDisplayName())
                 : Component.translatable(string, livingEntity.getDisplayName(), component);
         }
     }
 
+    // Purpur start - Component related conveniences
+    public Component getLocalizedDeathMessage(String str, LivingEntity entity) {
+        net.kyori.adventure.text.Component name = io.papermc.paper.adventure.PaperAdventure.asAdventure(entity.getDisplayName());
+        net.kyori.adventure.text.minimessage.tag.resolver.TagResolver template = net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.component("player", name);
+        net.kyori.adventure.text.Component component = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(str, template);
+        return io.papermc.paper.adventure.PaperAdventure.asVanilla(component);
+    }
+    // Purpur end - Component related conveniences
+
     public String getMsgId() {
         return this.type().msgId();
     }
diff --git a/net/minecraft/world/damagesource/DamageSources.java b/net/minecraft/world/damagesource/DamageSources.java
index e45891d10dfab44d3aa584cc7db3fbc3c7654af5..1e1b773d88917b251d71aad40b85fbc5fffce8c8 100644
--- a/net/minecraft/world/damagesource/DamageSources.java
+++ b/net/minecraft/world/damagesource/DamageSources.java
@@ -42,6 +42,8 @@ public class DamageSources {
     private final DamageSource stalagmite;
     private final DamageSource outsideBorder;
     private final DamageSource genericKill;
+    private final DamageSource scissors; // Purpur - Dont run with scissors!
+    private final DamageSource stonecutter; // Purpur - Stonecutter damage
 
     public DamageSources(RegistryAccess registry) {
         this.damageTypes = registry.lookupOrThrow(Registries.DAMAGE_TYPE);
@@ -70,6 +72,8 @@ public class DamageSources {
         this.stalagmite = this.source(DamageTypes.STALAGMITE);
         this.outsideBorder = this.source(DamageTypes.OUTSIDE_BORDER);
         this.genericKill = this.source(DamageTypes.GENERIC_KILL);
+        this.scissors = this.source(DamageTypes.MAGIC).scissors(); // Purpur - Dont run with scissors!
+        this.stonecutter = this.source(DamageTypes.MAGIC).stonecutter(); // Purpur - Stonecutter damage
     }
 
     private DamageSource source(ResourceKey<DamageType> damageTypeKey) {
@@ -84,6 +88,18 @@ public class DamageSources {
         return new DamageSource(this.damageTypes.getOrThrow(damageTypeKey), causingEntity, directEntity);
     }
 
+    // Purpur start - Dont run with scissor
+    public DamageSource scissors() {
+        return this.scissors;
+    }
+    // Purpur end - Dont run with scissors!
+
+    // Purpur start - Stonecutter damage
+    public DamageSource stonecutter() {
+        return this.stonecutter;
+    }
+    // Purpur end - Stonecutter damage
+
     public DamageSource inFire() {
         return this.inFire;
     }
diff --git a/net/minecraft/world/effect/HungerMobEffect.java b/net/minecraft/world/effect/HungerMobEffect.java
index 0890694ae96b6cd60079c34066e7a6e288f038e8..6c0e6bd2a171edc57dec71af178764454de73313 100644
--- a/net/minecraft/world/effect/HungerMobEffect.java
+++ b/net/minecraft/world/effect/HungerMobEffect.java
@@ -12,7 +12,7 @@ class HungerMobEffect extends MobEffect {
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
         if (entity instanceof Player player) {
-            player.causeFoodExhaustion(0.005F * (amplifier + 1), org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.HUNGER_EFFECT); // CraftBukkit - EntityExhaustionEvent
+            player.causeFoodExhaustion(entity.level().purpurConfig.humanHungerExhaustionAmount * (amplifier + 1), org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.HUNGER_EFFECT); // CraftBukkit - EntityExhaustionEvent // Purpur - Config MobEffect by world
         }
 
         return true;
diff --git a/net/minecraft/world/effect/PoisonMobEffect.java b/net/minecraft/world/effect/PoisonMobEffect.java
index 75327fd96858fd508ea63a6983e5cbc655a8800f..73cfc61ac3f8e33e6b9f4fd08a292266c0adb535 100644
--- a/net/minecraft/world/effect/PoisonMobEffect.java
+++ b/net/minecraft/world/effect/PoisonMobEffect.java
@@ -12,8 +12,8 @@ public class PoisonMobEffect extends MobEffect {
 
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
-        if (entity.getHealth() > 1.0F) {
-            entity.hurtServer(level, entity.damageSources().magic().knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.POISON), 1.0F); // CraftBukkit
+        if (entity.getHealth() > entity.level().purpurConfig.entityMinimalHealthPoison) { // Purpur
+            entity.hurtServer(level, entity.damageSources().magic().knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.POISON), entity.level().purpurConfig.entityPoisonDegenerationAmount); // CraftBukkit // Purpur - Config MobEffect by world
         }
 
         return true;
diff --git a/net/minecraft/world/effect/RegenerationMobEffect.java b/net/minecraft/world/effect/RegenerationMobEffect.java
index 76cffa4d4d18d6c04749d941dbdf5eb60aed4095..81481267a1577721dcc405f39a4c350bd59ac9a2 100644
--- a/net/minecraft/world/effect/RegenerationMobEffect.java
+++ b/net/minecraft/world/effect/RegenerationMobEffect.java
@@ -11,7 +11,7 @@ class RegenerationMobEffect extends MobEffect {
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
         if (entity.getHealth() < entity.getMaxHealth()) {
-            entity.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.MAGIC_REGEN); // CraftBukkit
+            entity.heal(entity.level().purpurConfig.entityHealthRegenAmount, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.MAGIC_REGEN); // CraftBukkit // Purpur - Config MobEffect by world
         }
 
         return true;
diff --git a/net/minecraft/world/effect/SaturationMobEffect.java b/net/minecraft/world/effect/SaturationMobEffect.java
index c192165910f6b139df6f604d0bce989061efa9cb..622c23f4570d07de8bee9623bf900aabb3331ded 100644
--- a/net/minecraft/world/effect/SaturationMobEffect.java
+++ b/net/minecraft/world/effect/SaturationMobEffect.java
@@ -16,7 +16,8 @@ class SaturationMobEffect extends InstantenousMobEffect {
             int oldFoodLevel = player.getFoodData().foodLevel;
             org.bukkit.event.entity.FoodLevelChangeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callFoodLevelChangeEvent(player, amplifier + 1 + oldFoodLevel);
             if (!event.isCancelled()) {
-                player.getFoodData().eat(event.getFoodLevel() - oldFoodLevel, 1.0F);
+                if (player.level().purpurConfig.playerBurpWhenFull && event.getFoodLevel() == 20 && oldFoodLevel < 20) player.burpDelay = player.level().purpurConfig.playerBurpDelay; // Purpur - Burp delay
+                player.getFoodData().eat(event.getFoodLevel() - oldFoodLevel, entity.level().purpurConfig.humanSaturationRegenAmount); // Purpur - Config MobEffect by world
             }
 
             ((org.bukkit.craftbukkit.entity.CraftPlayer) player.getBukkitEntity()).sendHealthUpdate();
diff --git a/net/minecraft/world/effect/WitherMobEffect.java b/net/minecraft/world/effect/WitherMobEffect.java
index 1fc9e1ad541c46124183a401b2a7d99aea69cecf..881271f0bc77a8a8a7d31daad9a8188bebaca67b 100644
--- a/net/minecraft/world/effect/WitherMobEffect.java
+++ b/net/minecraft/world/effect/WitherMobEffect.java
@@ -12,7 +12,7 @@ public class WitherMobEffect extends MobEffect {
 
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
-        entity.hurtServer(level, entity.damageSources().wither(), 1.0F);
+        entity.hurtServer(level, entity.damageSources().wither(), entity.level().purpurConfig.entityWitherDegenerationAmount); // Purpur - Config MobEffect by world
         return true;
     }
 
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index a3bcbf1051bb87e993be8c232c09031968b407d5..9be26e2b9bf764c629d059d9435c4b3be5c9ef36 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -153,6 +153,7 @@ import org.jspecify.annotations.Nullable;
 import org.slf4j.Logger;
 
 public abstract class Entity implements SyncedDataHolder, DebugValueSource, Nameable, ItemOwner, SlotProvider, EntityAccess, ScoreHolder, DataComponentGetter, ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity, ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity { // Paper - rewrite chunk system // Paper - optimise entity tracker
+    public static javax.script.ScriptEngine scriptEngine = new javax.script.ScriptEngineManager().getEngineByName("rhino"); // Purpur - Configurable entity base attributes
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
     static boolean isLevelAtLeast(ValueInput input, int level) {
@@ -282,8 +283,9 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     public double xOld;
     public double yOld;
     public double zOld;
+    public float maxUpStep; // Purpur - Add option to set armorstand step height
     public boolean noPhysics;
-    public final RandomSource random = SHARED_RANDOM; // Paper - Share random for entities to make them more random
+    public final RandomSource random; // Paper - Share random for entities to make them more random // Add toggle for RNG manipulation
     public int tickCount;
     private int remainingFireTicks;
     public boolean wasTouchingWater;
@@ -316,8 +318,8 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     public @Nullable PortalProcessor portalProcess;
     public int portalCooldown;
     private boolean invulnerable;
-    protected UUID uuid = Mth.createInsecureUUID(this.random);
-    protected String stringUUID = this.uuid.toString();
+    protected UUID uuid; // Purpur - Add toggle for RNG manipulation
+    protected String stringUUID; // Purpur - Add toggle for RNG manipulation
     private boolean hasGlowingTag;
     private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
     private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
@@ -373,6 +375,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     public long activatedTick = Integer.MIN_VALUE;
     public boolean isTemporarilyActive;
     public long activatedImmunityTick = Integer.MIN_VALUE;
+    public @Nullable Boolean immuneToFire = null; // Purpur - Fire immune API
 
     public void inactiveTick() {
     }
@@ -535,10 +538,40 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
     // Paper end - optimise entity tracker
 
+    // Purpur start - Add canSaveToDisk to Entity
+    public boolean canSaveToDisk() {
+        return true;
+    }
+    // Purpur end - Add canSaveToDisk to Entity
+
+    // Purpur start - copied from Mob - API for any mob to burn daylight
+    public boolean isSunBurnTick() {
+        if (!this.level().isClientSide() && this.level().environmentAttributes().getValue(EnvironmentAttributes.MONSTERS_BURN, this.position())) {
+            float lightLevelDependentMagicValue = this.getLightLevelDependentMagicValue();
+            BlockPos blockPos = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+            boolean flag = this.isInWater() || this.isInPowderSnow || this.wasInPowderSnow;
+            if (lightLevelDependentMagicValue > 0.5F
+                && this.random.nextFloat() * 30.0F < (lightLevelDependentMagicValue - 0.4F) * 2.0F
+                && !flag
+                && this.level().canSeeSky(blockPos)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+    // Purpur end - copied from Mob - API for any mob to burn daylight
+
     public Entity(EntityType<?> type, Level level) {
         this.type = type;
         this.level = level;
         this.dimensions = type.getDimensions();
+        this.maxAirTicks = level == null ? Entity.TOTAL_AIR_SUPPLY : this.level.purpurConfig.drowningAirTicks; // Purpur - Drowning Settings
+        // Purpur start - Add toggle for RNG manipulation
+        this.random = level == null || level.purpurConfig.entitySharedRandom ? SHARED_RANDOM : RandomSource.create();
+        this.uuid = Mth.createInsecureUUID(this.random);
+        this.stringUUID = this.uuid.toString();
+        // Purpur end - Add toggle for RNG manipulation
         this.position = Vec3.ZERO;
         this.blockPosition = BlockPos.ZERO;
         this.chunkPosition = ChunkPos.ZERO;
@@ -931,6 +964,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             && this.level.paperConfig().environment.netherCeilingVoidDamageHeight.test(v -> this.getY() >= v)
             && (!(this instanceof Player player) || !player.getAbilities().invulnerable))) {
             // Paper end - Configurable nether ceiling damage
+            if (this.level.purpurConfig.teleportOnNetherCeilingDamage && this.level.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this instanceof ServerPlayer player) player.teleport(org.bukkit.craftbukkit.util.CraftLocation.toBukkit(this.level.levelData.getRespawnData().pos(), this.level)); else // Purpur - Add option to teleport to spawn on nether ceiling damage
             this.onBelowWorld();
         }
     }
@@ -1960,7 +1994,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
 
     public boolean fireImmune() {
-        return this.getType().fireImmune();
+        return this.immuneToFire != null ? immuneToFire : this.getType().fireImmune(); // Purpur - add fire immune API
     }
 
     public boolean causeFallDamage(double fallDistance, float damageMultiplier, DamageSource damageSource) {
@@ -2572,7 +2606,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                 output.putBoolean("Bukkit.invisible", this.persistentInvisibility);
             }
             // SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
-            if (this.maxAirTicks != this.getDefaultMaxAirSupply()) {
+            if (this.maxAirTicks != this.getDefaultMaxAirSupply() && this.getDefaultMaxAirSupply() != this.level().purpurConfig.drowningAirTicks) { // Purpur - Drowning Settings
                 output.putInt("Bukkit.MaxAirSupply", this.getMaxAirSupply());
             }
             output.putInt("Spigot.ticksLived", this.totalEntityAge); // Paper
@@ -2659,6 +2693,11 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                 output.putBoolean("Paper.FreezeLock", true);
             }
             // Paper end
+            // Purpur start - Fire immune API
+            if (immuneToFire != null) {
+                output.putBoolean("Purpur.FireImmune", immuneToFire);
+            }
+            // Purpur end - Fire immune API
         } catch (Throwable var7) {
             CrashReport crashReport = CrashReport.forThrowable(var7, "Saving entity NBT");
             CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being saved");
@@ -2779,6 +2818,9 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             }
             freezeLocked = input.getBooleanOr("Paper.FreezeLock", false);
             // Paper end
+
+            immuneToFire = input.read("Purpur.FireImmune", com.mojang.serialization.Codec.BOOL).orElse(null); // Purpur - Fire immune API
+
         } catch (Throwable var7) {
             CrashReport crashReport = CrashReport.forThrowable(var7, "Loading entity NBT");
             CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being loaded");
@@ -3042,6 +3084,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
             if (this.isAlive() && this instanceof Leashable leashable2) {
                 if (leashable2.getLeashHolder() == player) {
                     if (!this.level().isClientSide()) {
+                        if (hand == InteractionHand.OFF_HAND && (level().purpurConfig.villagerCanBeLeashed || level().purpurConfig.wanderingTraderCanBeLeashed) && this instanceof net.minecraft.world.entity.npc.villager.AbstractVillager) return InteractionResult.CONSUME; // Purpur - Allow leashing villagers
                         // Paper start - EntityUnleashEvent
                         if (!org.bukkit.craftbukkit.event.CraftEventFactory.handlePlayerUnleashEntityEvent(
                             leashable2, player, hand, !player.hasInfiniteMaterials(), true
@@ -3348,6 +3391,13 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
 
                 this.passengers = ImmutableList.copyOf(list);
             }
+
+            // Purpur start - Ridables
+            if (isRidable() && this.passengers.get(0) == passenger && passenger instanceof Player player) {
+                onMount(player);
+                this.rider = player;
+            }
+            // Purpur end - Ridables
         }
     }
 
@@ -3388,6 +3438,14 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                 return false;
             }
             // CraftBukkit end
+
+            // Purpur start - Ridables
+            if (this.rider != null && this.passengers.get(0) == this.rider) {
+                onDismount(this.rider);
+                this.rider = null;
+            }
+            // Purpur end - Ridables
+
             if (this.passengers.size() == 1 && this.passengers.get(0) == passenger) {
                 this.passengers = ImmutableList.of();
             } else {
@@ -3472,15 +3530,18 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         return Vec3.directionFromRotation(this.getRotationVector());
     }
 
+    public BlockPos portalPos = BlockPos.ZERO; // Purpur - Fix stuck in portals
     public void setAsInsidePortal(Portal portal, BlockPos pos) {
         if (this.isOnPortalCooldown()) {
+            if (!(level().purpurConfig.playerFixStuckPortal && this instanceof Player && !pos.equals(this.portalPos))) // Purpur - Fix stuck in portals
             this.setPortalCooldown();
-        } else {
+        } else if (this.level.purpurConfig.entitiesCanUsePortals || this instanceof ServerPlayer) { // Purpur - Entities can use portals
             if (this.portalProcess == null || !this.portalProcess.isSamePortal(portal)) {
                 this.portalProcess = new PortalProcessor(portal, pos.immutable());
             } else if (!this.portalProcess.isInsidePortalThisTick()) {
                 this.portalProcess.updateEntryPosition(pos.immutable());
                 this.portalProcess.setAsInsidePortalThisTick(true);
+                this.portalPos = BlockPos.ZERO; // Purpur - Fix stuck in portals
             }
         }
     }
@@ -4220,7 +4281,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
 
     public boolean canUsePortal(boolean allowPassengers) {
-        return (allowPassengers || !this.isPassenger()) && this.isAlive();
+        return (allowPassengers || !this.isPassenger()) && this.isAlive() && (this.level.purpurConfig.entitiesCanUsePortals || this instanceof ServerPlayer); // Purpur - Entities can use portals
     }
 
     public boolean canTeleport(Level fromLevel, Level toLevel) {
@@ -4739,6 +4800,12 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         return Mth.lerp(partialTick, this.yRotO, this.yRot);
     }
 
+    // Purpur start - Stop squids floating on top of water
+    public AABB getAxisForFluidCheck() {
+        return this.getBoundingBox().deflate(0.001D);
+    }
+    // Purpur end - Stop squids floating on top of water
+
     // Paper start - optimise collisions
     public boolean updateFluidHeightAndDoFluidPushing(final TagKey<Fluid> fluid, final double flowScale) {
         if (this.touchingUnloadedChunk()) {
@@ -5159,7 +5226,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
 
     public float maxUpStep() {
-        return 0.0F;
+        return maxUpStep; // Purpur - Add option to set armorstand step height
     }
 
     public void onExplosionHit(@Nullable Entity entity) {
@@ -5429,4 +5496,44 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         return ((ServerLevel) this.level()).isPositionEntityTicking(this.blockPosition());
     }
     // Paper end - Expose entity id counter
+    // Purpur start - Ridables
+    @Nullable
+    private Player rider = null;
+
+    @Nullable
+    public Player getRider() {
+        return rider;
+    }
+
+    public boolean isRidable() {
+        return false;
+    }
+
+    public boolean isControllable() {
+        return true;
+    }
+
+    public void onMount(Player rider) {
+        if (this instanceof Mob) {
+            ((Mob) this).setTarget(null, null);
+            ((Mob) this).getNavigation().stop();
+        }
+        rider.setJumping(false); // fixes jump on mount
+    }
+
+    public void onDismount(Player player) {
+    }
+
+    public boolean onSpacebar() {
+        return false;
+    }
+
+    public boolean onClick(InteractionHand hand) {
+        return false;
+    }
+
+    public boolean processClick(InteractionHand hand) {
+        return false;
+    }
+    // Purpur end - Ridables
 }
diff --git a/net/minecraft/world/entity/EntitySelector.java b/net/minecraft/world/entity/EntitySelector.java
index b9ca072041f5fec0010017877a2821cd650023c5..cd8e22171449049b23823da9b5be6ede2c3f38d0 100644
--- a/net/minecraft/world/entity/EntitySelector.java
+++ b/net/minecraft/world/entity/EntitySelector.java
@@ -28,6 +28,8 @@ public final class EntitySelector {
         return net.minecraft.util.Mth.clamp(serverPlayer.getStats().getValue(net.minecraft.stats.Stats.CUSTOM.get(net.minecraft.stats.Stats.TIME_SINCE_REST)), 1, Integer.MAX_VALUE) >= playerInsomniaTicks;
     };
     // Paper end - Ability to control player's insomnia and phantoms
+    public static Predicate<Player> notAfk = (player) -> !player.isAfk(); // Purpur - AFK API
+
     // Paper start - Affects Spawning API
     public static final Predicate<Entity> PLAYER_AFFECTS_SPAWNING = (entity) -> {
         return !entity.isSpectator() && entity.isAlive() && entity instanceof Player player && player.affectsSpawning;
diff --git a/net/minecraft/world/entity/EntityType.java b/net/minecraft/world/entity/EntityType.java
index a3cba4a65687c61fefbfcf3c35625ceed2e50bfb..f0731609fbfb06ea23baba2a8b3694003a470b7d 100644
--- a/net/minecraft/world/entity/EntityType.java
+++ b/net/minecraft/world/entity/EntityType.java
@@ -1240,6 +1240,16 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
         return register(vanillaEntityId(key), builder);
     }
 
+    // Purpur start - PlayerSetSpawnerTypeWithEggEvent
+    public static EntityType<?> getFromBukkitType(org.bukkit.entity.EntityType bukkitType) {
+        return getFromKey(Identifier.parse(bukkitType.getKey().toString()));
+    }
+
+    public static EntityType<?> getFromKey(Identifier location) {
+        return BuiltInRegistries.ENTITY_TYPE.getValue(location);
+    }
+    // Purpur end - PlayerSetSpawnerTypeWithEggEvent
+
     public static Identifier getKey(EntityType<?> entityType) {
         return BuiltInRegistries.ENTITY_TYPE.getKey(entityType);
     }
@@ -1467,6 +1477,16 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
         return this.category;
     }
 
+    // Purpur start - PlayerSetSpawnerTypeWithEggEvent
+    public String getName() {
+        return BuiltInRegistries.ENTITY_TYPE.getKey(this).getPath();
+    }
+
+    public String getTranslatedName() {
+        return getDescription().getString();
+    }
+    // Purpur end - PlayerSetSpawnerTypeWithEggEvent
+
     public String getDescriptionId() {
         return this.descriptionId;
     }
@@ -1528,6 +1548,7 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
             // Paper start - Add logging for debugging entity tags with invalid ids
             () -> {
                 LOGGER.warn("Skipping Entity with id {}", input.getStringOr("id", "[invalid]"));
+                LOGGER.warn("Location: {} {}", level.getWorld().getName(), input.read("Pos", net.minecraft.world.phys.Vec3.CODEC).orElse(net.minecraft.world.phys.Vec3.ZERO)); // Purpur - log skipped entity's position
                 if ((DEBUG_ENTITIES_WITH_INVALID_IDS || level.getCraftServer().getServer().isDebugging()) && input instanceof TagValueInput tagInput) {
                     LOGGER.warn("Skipped entity tag: {}", tagInput.input);
                 }
diff --git a/net/minecraft/world/entity/ExperienceOrb.java b/net/minecraft/world/entity/ExperienceOrb.java
index f2ec0bd8cca3c08d558790537e17a8a2f95f1953..c655689cdd2d4e655dfc872edd231dcdfb7c0995 100644
--- a/net/minecraft/world/entity/ExperienceOrb.java
+++ b/net/minecraft/world/entity/ExperienceOrb.java
@@ -355,7 +355,7 @@ public class ExperienceOrb extends Entity {
     public void playerTouch(Player entity) {
         if (entity instanceof ServerPlayer serverPlayer) {
             if (entity.takeXpDelay == 0 && new com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent(serverPlayer.getBukkitEntity(), (org.bukkit.entity.ExperienceOrb) this.getBukkitEntity()).callEvent()) { // Paper - PlayerPickupExperienceEvent
-                entity.takeXpDelay = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerXpCooldownEvent(entity, 2, org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entity.takeXpDelay = 2;
+                entity.takeXpDelay = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerXpCooldownEvent(entity, this.level().purpurConfig.playerExpPickupDelay, org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entity.takeXpDelay = 2; // Purpur - Configurable player pickup exp delay
                 entity.take(this, 1);
                 int i = this.repairPlayerItems(serverPlayer, this.getValue());
                 if (i > 0) {
@@ -371,7 +371,7 @@ public class ExperienceOrb extends Entity {
     }
 
     private int repairPlayerItems(ServerPlayer player, int value) {
-        Optional<EnchantedItemInUse> randomItemWith = EnchantmentHelper.getRandomItemWith(
+        Optional<EnchantedItemInUse> randomItemWith = level().purpurConfig.useBetterMending ? EnchantmentHelper.getMostDamagedItemWith(EnchantmentEffectComponents.REPAIR_WITH_XP, player) : EnchantmentHelper.getRandomItemWith( // Purpur - Add option to mend the most damaged equipment first
             EnchantmentEffectComponents.REPAIR_WITH_XP, player, ItemStack::isDamaged
         );
         if (randomItemWith.isPresent()) {
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index 472d9ba3f41307aac8f4a8e6600434b481398d24..5bf420db36270330e5dc2e983c8e22966b476694 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -244,9 +244,9 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     public int noActionTime;
     public float lastHurt;
     public boolean jumping;
-    public float xxa;
-    public float yya;
-    public float zza;
+    public float xxa; public float getStrafeMot() { return xxa; } public void setStrafeMot(float strafe) { xxa = strafe; } // Purpur - OBFHELPER
+    public float yya; public float getVerticalMot() { return yya; } public void setVerticalMot(float vertical) { yya = vertical; } // Purpur - OBFHELPER
+    public float zza; public float getForwardMot() { return zza; } public void setForwardMot(float forward) { zza = forward; } // Purpur - OBFHELPER
     protected InterpolationHandler interpolation = new InterpolationHandler(this);
     protected double lerpYHeadRot;
     protected int lerpHeadSteps;
@@ -290,11 +290,13 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     public boolean silentDeath = false; // Paper - mark entity as dying silently for cancellable death event
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
     public int invulnerableDuration = LivingEntity.INVULNERABLE_DURATION; // Paper - configurable invulnerable duration
+    protected boolean shouldBurnInDay = false; public boolean shouldBurnInDay() { return this.shouldBurnInDay; } public void setShouldBurnInDay(boolean shouldBurnInDay) { this.shouldBurnInDay = shouldBurnInDay; } // Purpur - API for any mob to burn daylight
     // CraftBukkit end
 
     protected LivingEntity(EntityType<? extends LivingEntity> type, Level level) {
         super(type, level);
-        this.attributes = new AttributeMap(DefaultAttributes.getSupplier(type));
+        this.attributes = new AttributeMap(DefaultAttributes.getSupplier(type), this); // Purpur - Ridables
+        this.initAttributes(); // Purpur - Configurable entity base attributes
         this.craftAttributes = new org.bukkit.craftbukkit.attribute.CraftAttributeMap(this.attributes); // CraftBukkit
         // CraftBukkit - this.setHealth(this.getMaxHealth()) inlined and simplified to skip the instanceof check for Player, as getBukkitEntity() is not initialized in constructor
         this.entityData.set(LivingEntity.DATA_HEALTH_ID, this.getMaxHealth());
@@ -316,6 +318,8 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         return new EntityEquipment();
     }
 
+    protected void initAttributes() {}// Purpur - Configurable entity base attributes
+
     public Brain<?> getBrain() {
         return this.brain;
     }
@@ -371,6 +375,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             .add(Attributes.CAMERA_DISTANCE)
             .add(Attributes.WAYPOINT_TRANSMIT_RANGE);
     }
+    public boolean shouldSendAttribute(Attribute attribute) { return true; } // Purpur - Ridables
 
     @Override
     protected void checkFallDamage(double y, boolean onGround, BlockState state, BlockPos pos) {
@@ -447,6 +452,12 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                 if (d < 0.0) {
                     double damagePerBlock = serverLevel1.getWorldBorder().getDamagePerBlock();
                     if (damagePerBlock > 0.0) {
+                        // Purpur start - Add option to teleport to spawn if outside world border
+                        if (this.level().purpurConfig.teleportIfOutsideBorder && this instanceof ServerPlayer serverPlayer) {
+                            serverPlayer.teleport(org.bukkit.craftbukkit.util.CraftLocation.toBukkit(this.level().levelData.getRespawnData().pos(), this.level()));
+                            return;
+                        }
+                        // Purpur end - Add option to teleport to spawn if outside world border
                         this.hurtServer(serverLevel1, this.damageSources().outOfBorder(), Math.max(1, Mth.floor(-d * damagePerBlock)));
                     }
                 }
@@ -462,7 +473,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                     if (this.shouldTakeDrowningDamage()) {
                         this.setAirSupply(0);
                         serverLevel1.broadcastEntityEvent(this, EntityEvent.DROWN_PARTICLES);
-                        this.hurtServer(serverLevel1, this.damageSources().drown(), 2.0F);
+                        this.hurtServer(serverLevel1, this.damageSources().drown(), (float) this.level().purpurConfig.damageFromDrowning); // Purpur - Drowning Settings
                     }
                 } else if (this.getAirSupply() < this.getMaxAirSupply() && MobEffectUtil.shouldEffectsRefillAirsupply(this)) {
                     this.setAirSupply(this.increaseAirSupply(this.getAirSupply()));
@@ -522,7 +533,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     }
 
     protected boolean shouldTakeDrowningDamage() {
-        return this.getAirSupply() <= -20;
+        return this.getAirSupply() <= -this.level().purpurConfig.drowningDamageInterval; // Purpur - Drowning Settings
     }
 
     @Override
@@ -783,6 +794,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         this.getSleepingPos().ifPresent(blockPos -> output.store("sleeping_pos", BlockPos.CODEC, blockPos));
         DataResult<Dynamic<?>> dataResult = this.brain.serializeStart(NbtOps.INSTANCE).map(tag -> new Dynamic<>(NbtOps.INSTANCE, tag));
         dataResult.resultOrPartial(LOGGER::error).ifPresent(dynamic -> output.store("Brain", Codec.PASSTHROUGH, (Dynamic<?>)dynamic));
+        output.putBoolean("Purpur.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - API for any mob to burn daylight
         if (this.lastHurtByPlayer != null) {
             this.lastHurtByPlayer.store(output, "last_hurt_by_player");
             output.putInt("last_hurt_by_player_memory_time", this.lastHurtByPlayerMemoryTime);
@@ -907,6 +919,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             } // Paper - The sleeping pos will always also set the actual pos, so a desync suggests something is wrong
         }, this::clearSleepingPos);
         input.read("Brain", Codec.PASSTHROUGH).ifPresent(dynamic -> this.brain = this.makeBrain((Dynamic<?>)dynamic));
+        this.shouldBurnInDay = input.getBooleanOr("Purpur.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - API for any mob to burn daylight
         this.lastHurtByPlayer = EntityReference.read(input, "last_hurt_by_player");
         this.lastHurtByPlayerMemoryTime = input.getIntOr("last_hurt_by_player_memory_time", 0);
         this.lastHurtByMob = EntityReference.read(input, "last_hurt_by_mob");
@@ -1050,14 +1063,32 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         if (lookingEntity != null) {
             ItemStack itemBySlot = this.getItemBySlot(EquipmentSlot.HEAD);
             EntityType<?> type = lookingEntity.getType();
-            if (type == EntityType.SKELETON && itemBySlot.is(Items.SKELETON_SKULL)
-                || type == EntityType.ZOMBIE && itemBySlot.is(Items.ZOMBIE_HEAD)
-                || type == EntityType.PIGLIN && itemBySlot.is(Items.PIGLIN_HEAD)
-                || type == EntityType.PIGLIN_BRUTE && itemBySlot.is(Items.PIGLIN_HEAD)
-                || type == EntityType.CREEPER && itemBySlot.is(Items.CREEPER_HEAD)) {
-                d *= 0.5;
+            // Purpur start - Mob head visibility percent
+            if (type == EntityType.SKELETON && itemBySlot.is(Items.SKELETON_SKULL)) {
+                d *= lookingEntity.level().purpurConfig.skeletonHeadVisibilityPercent;
+            }
+            else if (type == EntityType.ZOMBIE && itemBySlot.is(Items.ZOMBIE_HEAD)) {
+                d *= lookingEntity.level().purpurConfig.zombieHeadVisibilityPercent;
+            }
+            else if ((type == EntityType.PIGLIN || type == EntityType.PIGLIN_BRUTE) && itemBySlot.is(Items.PIGLIN_HEAD)) {
+                d *= lookingEntity.level().purpurConfig.piglinHeadVisibilityPercent;
+            }
+            else if (type == EntityType.CREEPER && itemBySlot.is(Items.CREEPER_HEAD)) {
+                d *= lookingEntity.level().purpurConfig.creeperHeadVisibilityPercent;
+            }
+            // Purpur end - Mob head visibility percent
+        }
+
+        // Purpur start - Configurable mob blindness
+        if (lookingEntity instanceof LivingEntity entityliving) {
+            if (entityliving.hasEffect(MobEffects.BLINDNESS)) {
+                int amplifier = entityliving.getEffect(MobEffects.BLINDNESS).getAmplifier();
+                for (int i = 0; i < amplifier; i++) {
+                    d *= this.level().purpurConfig.mobsBlindnessMultiplier;
+                }
             }
         }
+        // Purpur end - Configurable mob blindness
 
         return d;
     }
@@ -1104,6 +1135,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             Iterator<MobEffectInstance> iterator = this.activeEffects.values().iterator();
             while (iterator.hasNext()) {
                 MobEffectInstance effect = iterator.next();
+                if (cause == EntityPotionEffectEvent.Cause.MILK && !this.level().purpurConfig.milkClearsBeneficialEffects && effect.getEffect().value().isBeneficial()) continue; // Purpur - Milk Keeps Beneficial Effects
                 EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, effect, null, cause, EntityPotionEffectEvent.Action.CLEARED);
                 if (event.isCancelled()) {
                     continue;
@@ -1436,6 +1468,24 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                 this.stopSleeping();
             }
 
+            // Purpur start - One Punch Man!
+            if (damageSource.getEntity() instanceof net.minecraft.world.entity.player.Player player && damageSource.getEntity().level().purpurConfig.creativeOnePunch && !damageSource.is(DamageTypeTags.IS_PROJECTILE)) {
+                if (player.isCreative()) {
+                    org.apache.commons.lang3.mutable.MutableDouble attackDamage = new org.apache.commons.lang3.mutable.MutableDouble();
+                    player.getMainHandItem().forEachModifier(EquipmentSlot.MAINHAND, (attributeHolder, attributeModifier) -> {
+                        if (attributeModifier.operation() == AttributeModifier.Operation.ADD_VALUE) {
+                            attackDamage.addAndGet(attributeModifier.amount());
+                        }
+                    });
+
+                    if (attackDamage.doubleValue() == 0.0D) {
+                        // One punch!
+                        amount = 9999F;
+                    }
+                }
+            }
+            // Purpur end - One Punch Man!
+
             this.noActionTime = 0;
             if (amount < 0.0F) {
                 amount = 0.0F;
@@ -1697,10 +1747,10 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     protected @Nullable Player resolvePlayerResponsibleForDamage(DamageSource damageSource) {
         Entity entity = damageSource.getEntity();
         if (entity instanceof Player player) {
-            this.setLastHurtByPlayer(player, 100);
+            this.setLastHurtByPlayer(player, this.level().purpurConfig.mobLastHurtByPlayerTime); // Purpur - Config for mob last hurt by player time
         } else if (entity instanceof Wolf wolf && wolf.isTame()) {
             if (wolf.getOwnerReference() != null) {
-                this.setLastHurtByPlayer(wolf.getOwnerReference().getUUID(), 100);
+                this.setLastHurtByPlayer(wolf.getOwnerReference().getUUID(), this.level().purpurConfig.mobLastHurtByPlayerTime); // Purpur - Config for mob last hurt by player time
             } else {
                 this.lastHurtByPlayer = null;
                 this.lastHurtByPlayerMemoryTime = 0;
@@ -1751,6 +1801,30 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                 }
             }
 
+            // Purpur start - Totems work in inventory
+            if (level().purpurConfig.totemOfUndyingWorksInInventory && this instanceof ServerPlayer player && (itemStack == null || itemStack.getItem() != Items.TOTEM_OF_UNDYING) && player.getBukkitEntity().hasPermission("purpur.inventory_totem")) {
+                for (ItemStack item : player.getInventory().getNonEquipmentItems()) {
+                    if (item.getItem() == Items.TOTEM_OF_UNDYING) {
+                        itemInHand = item;
+                        itemStack = item.copy();
+                        break;
+                    }
+                }
+            }
+            // Purpur end - Totems work in inventory
+
+            // Purpur start - Totems work in inventory
+            if (level().purpurConfig.totemOfUndyingWorksInInventory && this instanceof ServerPlayer player && (itemStack == null || itemStack.getItem() != Items.TOTEM_OF_UNDYING) && player.getBukkitEntity().hasPermission("purpur.inventory_totem")) {
+                for (ItemStack item : player.getInventory().getNonEquipmentItems()) {
+                    if (item.getItem() == Items.TOTEM_OF_UNDYING) {
+                        itemInHand = item;
+                        itemStack = item.copy();
+                        break;
+                    }
+                }
+            }
+            // Purpur end - Totems work in inventory
+
             final org.bukkit.inventory.EquipmentSlot handSlot = (hand != null) ? org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand) : null;
             final EntityResurrectEvent event = new EntityResurrectEvent((org.bukkit.entity.LivingEntity) this.getBukkitEntity(), handSlot);
             event.setCancelled(itemStack == null);
@@ -1902,7 +1976,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         if (this.level() instanceof ServerLevel serverLevel) {
             boolean var6 = false;
             if (this.dead && entitySource instanceof WitherBoss) { // Paper
-                if (serverLevel.getGameRules().get(GameRules.MOB_GRIEFING)) {
+                if (serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.witherMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     BlockPos blockPos = this.blockPosition();
                     BlockState blockState = Blocks.WITHER_ROSE.defaultBlockState();
                     if (this.level().getBlockState(blockPos).isAir() && blockState.canSurvive(this.level(), blockPos)) {
@@ -1932,6 +2006,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         boolean flag = this.lastHurtByPlayerMemoryTime > 0;
         this.dropEquipment(level); // CraftBukkit - from below
         if (this.shouldDropLoot(level)) {
+            if (!(damageSource.is(net.minecraft.world.damagesource.DamageTypes.CRAMMING) && level().purpurConfig.disableDropsOnCrammingDeath)) { // Purpur - Disable loot drops on death by cramming
             this.dropFromLootTable(level, damageSource, flag);
             // Paper start
             final boolean prev = this.clearEquipmentSlots;
@@ -1940,6 +2015,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             // Paper end
             this.dropCustomDeathLoot(level, damageSource, flag);
             this.clearEquipmentSlots = prev; // Paper
+            } // Purpur - Disable loot drops on death by cramming
         }
 
         // CraftBukkit start - Call death event // Paper start - call advancement triggers with correct entity equipment
@@ -3054,6 +3130,20 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             this.move(MoverType.SELF, this.getDeltaMovement());
             this.setDeltaMovement(this.getDeltaMovement().scale(0.5));
         } else {
+            // Purpur start - Ridables
+            if (this.getRider() != null && this.isControllable()) {
+                float friction = 0.91F;
+                if (this.onGround()) {
+                    friction = this.level().getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).getBlock().getFriction() * 0.91F;
+                }
+
+                float frictionCompensation = 0.16277137F / (friction * friction * friction);
+                this.moveRelative(this.onGround() ? 0.1F * frictionCompensation : 0.02F, relative);
+                this.move(MoverType.SELF, this.getDeltaMovement());
+                this.setDeltaMovement(this.getDeltaMovement().scale(friction));
+                return;
+            }
+            // Purpur end - Ridables
             this.moveRelative(amount, relative);
             this.move(MoverType.SELF, this.getDeltaMovement());
             this.setDeltaMovement(this.getDeltaMovement().scale(0.91F));
@@ -3214,6 +3304,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             float f = (float)(d * 10.0 - 3.0);
             if (f > 0.0F) {
                 this.playSound(this.getFallDamageSound((int)f), 1.0F, 1.0F);
+                if (level().purpurConfig.elytraKineticDamage) // Purpur - Toggle for kinetic damage
                 this.hurt(this.damageSources().flyIntoWall(), f);
             }
         }
@@ -3741,8 +3832,10 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         this.pushEntities();
         profilerFiller.pop();
         // Paper start - Add EntityMoveEvent
-        if (((ServerLevel) this.level()).hasEntityMoveEvent && !(this instanceof Player)) {
-            if (this.xo != this.getX() || this.yo != this.getY() || this.zo != this.getZ() || this.yRotO != this.getYRot() || this.xRotO != this.getXRot()) {
+        // Purpur start - Ridables
+        if (this.xo != this.getX() || this.yo != this.getY() || this.zo != this.getZ() || this.yRotO != this.getYRot() || this.xRotO != this.getXRot()) {
+            if (((ServerLevel) this.level()).hasEntityMoveEvent && !(this instanceof Player)) {
+                // Purpur end - Ridables
                 Location from = new Location(this.level().getWorld(), this.xo, this.yo, this.zo, this.yRotO, this.xRotO);
                 Location to = new Location(this.level().getWorld(), this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
                 io.papermc.paper.event.entity.EntityMoveEvent event = new io.papermc.paper.event.entity.EntityMoveEvent(this.getBukkitLivingEntity(), from, to.clone());
@@ -3752,11 +3845,57 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                     this.absSnapTo(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ(), event.getTo().getYaw(), event.getTo().getPitch());
                 }
             }
+            // Purpur start - Ridables
+            if (getRider() != null) {
+                getRider().resetLastActionTime();
+                if (((ServerLevel) level()).hasRidableMoveEvent && this instanceof Mob) {
+                    Location from = new Location(level().getWorld(), xo, yo, zo, this.yRotO, this.xRotO);
+                    Location to = new Location(level().getWorld(), getX(), getY(), getZ(), this.getYRot(), this.getXRot());
+                    org.purpurmc.purpur.event.entity.RidableMoveEvent event = new org.purpurmc.purpur.event.entity.RidableMoveEvent((org.bukkit.entity.Mob) getBukkitLivingEntity(), (org.bukkit.entity.Player) getRider().getBukkitEntity(), from, to.clone());
+                    if (!event.callEvent()) {
+                        this.absSnapTo(from.getX(), from.getY(), from.getZ(), from.getYaw(), from.getPitch());
+                    } else if (!to.equals(event.getTo())) {
+                        this.absSnapTo(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ(), event.getTo().getYaw(), event.getTo().getPitch());
+                    }
+                }
+            }
+            // Purpur end - Ridables
         }
         // Paper end - Add EntityMoveEvent
         if (this.level() instanceof ServerLevel serverLevel && this.isSensitiveToWater() && this.isInWaterOrRain()) {
             this.hurtServer(serverLevel, this.damageSources().drown(), 1.0F);
         }
+
+        // Purpur start - copied from Mob - API for any mob to burn daylight
+        if (this.getType().is(EntityTypeTags.BURN_IN_DAYLIGHT) && this.isAlive()) {
+            boolean flag = this.shouldBurnInDay() && this.isSunBurnTick(); // Paper - shouldBurnInDay API // Purpur - use shouldBurnInDay() method to handle Phantoms properly - API for any mob to burn daylight
+            if (flag) {
+                EquipmentSlot equipmentSlot = this.sunProtectionSlot();
+                ItemStack itemBySlot = this.getItemBySlot(equipmentSlot);
+                if (!itemBySlot.isEmpty()) {
+                    if (itemBySlot.isDamageableItem()) {
+                        Item item = itemBySlot.getItem();
+                        itemBySlot.setDamageValue(itemBySlot.getDamageValue() + this.random.nextInt(2));
+                        if (itemBySlot.getDamageValue() >= itemBySlot.getMaxDamage()) {
+                            this.onEquippedItemBroken(item, equipmentSlot);
+                            this.setItemSlot(equipmentSlot, ItemStack.EMPTY);
+                        }
+                    }
+
+                    flag = false;
+                }
+
+                if (flag) {
+                    if (getRider() == null || !this.isControllable()) // Purpur - ignore mobs which are uncontrollable or without rider - API for any mob to burn daylight
+                        this.igniteForSeconds(8.0F);
+                }
+            }
+        }
+    }
+
+    protected EquipmentSlot sunProtectionSlot() {
+        return net.minecraft.world.entity.EquipmentSlot.HEAD;
+        // Purpur end - copied from Mob - API for any mob to burn daylight
     }
 
     protected void applyInput() {
@@ -3790,7 +3929,18 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                         .filter(equipmentSlot1 -> canGlideUsing(this.getItemBySlot(equipmentSlot1), equipmentSlot1))
                         .toList();
                     EquipmentSlot equipmentSlot = Util.getRandom(list, this.random);
-                    this.getItemBySlot(equipmentSlot).hurtAndBreak(1, this, equipmentSlot);
+
+                    // Purpur start - Implement elytra settings
+                    int damage = level().purpurConfig.elytraDamagePerSecond;
+                    if (level().purpurConfig.elytraDamageMultiplyBySpeed > 0) {
+                        double speed = getDeltaMovement().lengthSqr();
+                        if (speed > level().purpurConfig.elytraDamageMultiplyBySpeed) {
+                            damage *= (int) speed;
+                        }
+                    }
+
+                    this.getItemBySlot(equipmentSlot).hurtAndBreak(damage, this, equipmentSlot);
+                    // Purpur end - Implement elytra settings
                 }
 
                 this.gameEvent(GameEvent.ELYTRA_GLIDE);
@@ -4680,6 +4830,12 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             : slot == equippable.slot() && this.canUseSlot(equippable.slot()) && equippable.canBeEquippedBy(this.getType());
     }
 
+    // Purpur start - Dispenser curse of binding protection
+    public @Nullable EquipmentSlot getEquipmentSlotForDispenserItem(ItemStack itemstack) {
+        return EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.BINDING_CURSE, itemstack) > 0 ? null : this.getEquipmentSlotForItem(itemstack);
+    }
+    // Purpur end - Dispenser curse of binding protection
+
     private static SlotAccess createEquipmentSlotAccess(LivingEntity entity, EquipmentSlot slot) {
         return slot != EquipmentSlot.HEAD && slot != EquipmentSlot.MAINHAND && slot != EquipmentSlot.OFFHAND
             ? SlotAccess.forEquipmentSlot(entity, slot, itemStack -> itemStack.isEmpty() || entity.getEquipmentSlotForItem(itemStack) == slot)
diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index 92175cc019750e829fcad7691a937024c2649882..0ae6b98b71d2d1bf1cefd1b54d5402493343e0a8 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -150,13 +150,14 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     private int homeRadius = -1;
     public boolean aware = true; // CraftBukkit
     public net.kyori.adventure.util.TriState despawnInPeacefulOverride = net.kyori.adventure.util.TriState.NOT_SET; // Paper - allow changing despawnInPeaceful
+    public int ticksSinceLastInteraction; // Purpur - Entity lifespan
 
     protected Mob(EntityType<? extends Mob> type, Level level) {
         super(type, level);
         this.goalSelector = new GoalSelector();
         this.targetSelector = new GoalSelector();
-        this.lookControl = new LookControl(this);
-        this.moveControl = new MoveControl(this);
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this); // Purpur - Ridables
+        this.moveControl = new org.purpurmc.purpur.controller.MoveControllerWASD(this); // Purpur - Ridables
         this.jumpControl = new JumpControl(this);
         this.bodyRotationControl = this.createBodyControl();
         this.navigation = this.createNavigation(level);
@@ -292,6 +293,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
                 target = null;
             }
         }
+        if (target instanceof net.minecraft.server.level.ServerPlayer) this.ticksSinceLastInteraction = 0; // Purpur - Entity lifespan
         this.target = target;
         return true;
         // CraftBukkit end
@@ -335,8 +337,28 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         }
 
         profilerFiller.pop();
+        incrementTicksSinceLastInteraction(); // Purpur - Entity lifespan
     }
 
+    // Purpur start - Entity lifespan
+    private void incrementTicksSinceLastInteraction() {
+        ++this.ticksSinceLastInteraction;
+        if (getRider() != null) {
+            this.ticksSinceLastInteraction = 0;
+            return;
+        }
+        if (this.level().purpurConfig.entityLifeSpan <= 0) {
+            return; // feature disabled
+        }
+        if (!this.removeWhenFarAway(0) || isPersistenceRequired() || requiresCustomPersistence() || hasCustomName()) {
+            return; // mob persistent
+        }
+        if (this.ticksSinceLastInteraction > this.level().purpurConfig.entityLifeSpan) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        }
+    }
+    // Purpur end - Entity lifespan
+
     @Override
     protected void playHurtSound(DamageSource damageSource) {
         this.resetAmbientSoundTime();
@@ -439,6 +461,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             output.putString("Paper.DespawnInPeacefulOverride", this.despawnInPeacefulOverride.name());
         }
         // Paper end - allow changing despawnInPeaceful
+        output.putInt("Purpur.ticksSinceLastInteraction", this.ticksSinceLastInteraction); // Purpur - Entity lifespan
     }
 
     @Override
@@ -466,6 +489,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         this.lootTableSeed = input.getLongOr("DeathLootTableSeed", 0L);
         this.setNoAi(input.getBooleanOr("NoAI", false));
         this.aware = input.getBooleanOr("Bukkit.Aware", true); // CraftBukkit
+        this.ticksSinceLastInteraction = input.getIntOr("Purpur.ticksSinceLastInteraction", 0); // Purpur- Entity lifespan
         // Paper start - allow changing despawnInPeaceful
         this.despawnInPeacefulOverride = readDespawnInPeacefulOverride(input);
     }
@@ -520,9 +544,9 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     @Override
     public void aiStep() {
         super.aiStep();
-        if (this.getType().is(EntityTypeTags.BURN_IN_DAYLIGHT)) {
+        /*if (this.getType().is(EntityTypeTags.BURN_IN_DAYLIGHT)) { // Purpur start - implemented in LivingEntity - API for any mob to burn daylight
             this.burnUndead();
-        }
+        }*/ // Purpur end - implemented in LivingEntity - API for any mob to burn daylight
 
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("looting");
@@ -530,7 +554,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             && this.canPickUpLoot()
             && this.isAlive()
             && !this.dead
-            && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING)) {
+            && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, checkEntityPickUpLootOverride())) { // Purpur - Check mobGriefing Overrides
             Vec3i pickupReach = this.getPickupReach();
 
             for (ItemEntity itemEntity : this.level()
@@ -552,6 +576,12 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         profilerFiller.pop();
     }
 
+    // Purpur start - Check mobGriefing Overrides
+    protected @Nullable Boolean checkEntityPickUpLootOverride() {
+        return null;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     protected EquipmentSlot sunProtectionSlot() {
         return EquipmentSlot.HEAD;
     }
@@ -570,25 +600,15 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
                     }
                 }
             } else {
+                if (getRider() == null || !this.isControllable()) // Purpur - Ridables
                 this.igniteForSeconds(8.0F);
             }
         }
     }
 
     public boolean isSunBurnTick() {
-        if (!this.level().isClientSide() && this.level().environmentAttributes().getValue(EnvironmentAttributes.MONSTERS_BURN, this.position())) {
-            float lightLevelDependentMagicValue = this.getLightLevelDependentMagicValue();
-            BlockPos blockPos = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
-            boolean flag = this.isInWaterOrRain() || this.isInPowderSnow || this.wasInPowderSnow;
-            if (lightLevelDependentMagicValue > 0.5F
-                && this.random.nextFloat() * 30.0F < (lightLevelDependentMagicValue - 0.4F) * 2.0F
-                && !flag
-                && this.level().canSeeSky(blockPos)) {
-                return true;
-            }
-        }
-
-        return false;
+        // Purpur - implemented in Entity - API for any mob to burn daylight
+        return super.isSunBurnTick();
     }
 
     protected Vec3i getPickupReach() {
@@ -1246,7 +1266,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             );
         }
 
-        this.setLeftHanded(random.nextFloat() < 0.05F);
+        this.setLeftHanded(random.nextFloat() < level.getLevel().purpurConfig.entityLeftHandedChance); // Purpur - Changeable Mob Left Handed Chance
         return spawnGroupData;
     }
 
@@ -1333,7 +1353,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     }
 
     protected InteractionResult mobInteract(Player player, InteractionHand hand) {
-        return InteractionResult.PASS;
+        return tryRide(player, hand); // Purpur - Ridables
     }
 
     protected void usePlayerItem(Player player, InteractionHand hand, ItemStack stack) {
@@ -1597,6 +1617,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         }
 
         this.lungeForwardMaybe();
+        if (target instanceof net.minecraft.server.level.ServerPlayer) this.ticksSinceLastInteraction = 0; // Purpur - Entity lifespan
         return flag;
     }
 
@@ -1672,4 +1693,58 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     public float chargeSpeedModifier() {
         return 1.0F;
     }
+
+    // Purpur start - Ridables
+    public double getMaxY() {
+        return level().getHeight();
+    }
+
+    public InteractionResult tryRide(Player player, InteractionHand hand) {
+        return tryRide(player, hand, InteractionResult.PASS);
+    }
+
+    public InteractionResult tryRide(Player player, InteractionHand hand, InteractionResult result) {
+        if (!isRidable()) {
+            return result;
+        }
+        if (hand != InteractionHand.MAIN_HAND) {
+            return InteractionResult.PASS;
+        }
+        if (player.isShiftKeyDown()) {
+            return InteractionResult.PASS;
+        }
+        if (!player.getItemInHand(hand).isEmpty()) {
+            return InteractionResult.PASS;
+        }
+        if (!passengers.isEmpty() || player.isPassenger()) {
+            return InteractionResult.PASS;
+        }
+        if (this instanceof TamableAnimal tamable) {
+            if (tamable.isTame() && !tamable.isOwnedBy(player)) {
+                return InteractionResult.PASS;
+            }
+            if (!tamable.isTame() && !level().purpurConfig.untamedTamablesAreRidable) {
+                return InteractionResult.PASS;
+            }
+        }
+        if (this instanceof AgeableMob ageable) {
+            if (ageable.isBaby() && !level().purpurConfig.babiesAreRidable) {
+                return InteractionResult.PASS;
+            }
+        }
+        if (!player.getBukkitEntity().hasPermission("allow.ride." + net.minecraft.core.registries.BuiltInRegistries.ENTITY_TYPE.getKey(getType()).getPath())) {
+            if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer) {
+                serverPlayer.sendMiniMessage(org.purpurmc.purpur.PurpurConfig.cannotRideMob);
+            }
+            return InteractionResult.PASS;
+        }
+        player.setYRot(this.getYRot());
+        player.setXRot(this.getXRot());
+        if (player.startRiding(this)) {
+            return InteractionResult.SUCCESS;
+        } else {
+            return InteractionResult.PASS;
+        }
+    }
+    // Purpur end - Ridables
 }
diff --git a/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index f699ab1d81199d0d25c1c32a0359a6c9b7639712..852f53a4705c3fa201135a89a2803f45f283fc08 100644
--- a/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -18,14 +18,21 @@ public class AttributeMap {
     private final Set<AttributeInstance> attributesToSync = new ObjectOpenHashSet<>();
     private final Set<AttributeInstance> attributesToUpdate = new ObjectOpenHashSet<>();
     private final AttributeSupplier supplier;
+    private final net.minecraft.world.entity.LivingEntity entity; // Purpur - Ridables
 
     public AttributeMap(AttributeSupplier supplier) {
-        this.supplier = supplier;
+        // Purpur start - Ridables
+        this(supplier, null);
+    }
+    public AttributeMap(AttributeSupplier defaultAttributes, net.minecraft.world.entity.LivingEntity entity) {
+        this.entity = entity;
+        // Purpur end - Ridables
+        this.supplier = defaultAttributes;
     }
 
     private void onAttributeModified(AttributeInstance instance) {
         this.attributesToUpdate.add(instance);
-        if (instance.getAttribute().value().isClientSyncable()) {
+        if (instance.getAttribute().value().isClientSyncable() && (entity == null || entity.shouldSendAttribute(instance.getAttribute().value()))) { // Purpur - Ridables
             this.attributesToSync.add(instance);
         }
     }
@@ -39,7 +46,7 @@ public class AttributeMap {
     }
 
     public Collection<AttributeInstance> getSyncableAttributes() {
-        return this.attributes.values().stream().filter(instance -> instance.getAttribute().value().isClientSyncable()).collect(Collectors.toList());
+        return this.attributes.values().stream().filter(instance -> instance.getAttribute().value().isClientSyncable() && (entity == null || entity.shouldSendAttribute(instance.getAttribute().value()))).collect(Collectors.toList()); // Purpur - Ridables
     }
 
     public @Nullable AttributeInstance getInstance(Holder<Attribute> attribute) {
diff --git a/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java b/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java
index 6cf01fe1aac41af171b444ac737816a06bd80d6f..49292ae53f2b4554064daa4953a8cec00aa1fa98 100644
--- a/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java
+++ b/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java
@@ -135,14 +135,14 @@ public class DefaultAttributes {
         .put(EntityType.LLAMA, Llama.createAttributes().build())
         .put(EntityType.MAGMA_CUBE, MagmaCube.createAttributes().build())
         .put(EntityType.MANNEQUIN, LivingEntity.createLivingAttributes().build())
-        .put(EntityType.MOOSHROOM, Cow.createAttributes().build())
+        .put(EntityType.MOOSHROOM, net.minecraft.world.entity.animal.cow.AbstractCow.createAttributes().build()) // Purpur - Cows naturally aggressive to players chance
         .put(EntityType.MULE, AbstractChestedHorse.createBaseChestedHorseAttributes().build())
         .put(EntityType.NAUTILUS, Nautilus.createAttributes().build())
         .put(EntityType.OCELOT, Ocelot.createAttributes().build())
         .put(EntityType.PANDA, Panda.createAttributes().build())
         .put(EntityType.PARCHED, Parched.createAttributes().build())
         .put(EntityType.PARROT, Parrot.createAttributes().build())
-        .put(EntityType.PHANTOM, Monster.createMonsterAttributes().build())
+        .put(EntityType.PHANTOM, net.minecraft.world.entity.monster.Phantom.createAttributes().build()) // Purpur - Ridables
         .put(EntityType.PIG, Pig.createAttributes().build())
         .put(EntityType.PIGLIN, Piglin.createAttributes().build())
         .put(EntityType.PIGLIN_BRUTE, PiglinBrute.createAttributes().build())
@@ -173,7 +173,7 @@ public class DefaultAttributes {
         .put(EntityType.VILLAGER, Villager.createAttributes().build())
         .put(EntityType.VINDICATOR, Vindicator.createAttributes().build())
         .put(EntityType.WARDEN, Warden.createAttributes().build())
-        .put(EntityType.WANDERING_TRADER, Mob.createMobAttributes().build())
+        .put(EntityType.WANDERING_TRADER, net.minecraft.world.entity.npc.wanderingtrader.WanderingTrader.createAttributes().build()) // Purpur - Villagers follow emerald blocks
         .put(EntityType.WITCH, Witch.createAttributes().build())
         .put(EntityType.WITHER, WitherBoss.createAttributes().build())
         .put(EntityType.WITHER_SKELETON, AbstractSkeleton.createAttributes().build())
diff --git a/net/minecraft/world/entity/ai/attributes/RangedAttribute.java b/net/minecraft/world/entity/ai/attributes/RangedAttribute.java
index 0a0e5d9fd64182c1bed4c0aa6a40d8b2cdf8bc9d..353d571b4a2bf18414a08239abe2b079e3750d89 100644
--- a/net/minecraft/world/entity/ai/attributes/RangedAttribute.java
+++ b/net/minecraft/world/entity/ai/attributes/RangedAttribute.java
@@ -29,6 +29,7 @@ public class RangedAttribute extends Attribute {
 
     @Override
     public double sanitizeValue(double value) {
+        if (!org.purpurmc.purpur.PurpurConfig.clampAttributes) return Double.isNaN(value) ? this.minValue : value; // Purpur - Add attribute clamping and armor limit config
         return Double.isNaN(value) ? this.minValue : Mth.clamp(value, this.minValue, this.maxValue);
     }
 }
diff --git a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
index 278addb7dbe4f57e99fb91ce1cd1bf3559e239a3..3e0fd09a0c0047cfe100e878186471090f8909a0 100644
--- a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
+++ b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
@@ -85,7 +85,7 @@ public class AcquirePoi {
                             };
                             // Paper start - optimise POI access
                             final java.util.List<Pair<Holder<PoiType>, BlockPos>> poiposes = new java.util.ArrayList<>();
-                            io.papermc.paper.util.PoiAccess.findNearestPoiPositions(poiManager, acquirablePois, predicate1, mob.blockPosition(), 48, 48*48, PoiManager.Occupancy.HAS_SPACE, false, 5, poiposes);
+                            io.papermc.paper.util.PoiAccess.findNearestPoiPositions(poiManager, acquirablePois, predicate1, mob.blockPosition(), level.purpurConfig.villagerAcquirePoiSearchRadius, level.purpurConfig.villagerAcquirePoiSearchRadius*level.purpurConfig.villagerAcquirePoiSearchRadius, PoiManager.Occupancy.HAS_SPACE, false, 5, poiposes); // Purpur - Configurable villager search radius
                             final Set<Pair<Holder<PoiType>, BlockPos>> set = new java.util.HashSet<>(poiposes.size());
                             for (final Pair<Holder<PoiType>, BlockPos> poiPose : poiposes) {
                                 if (predicate.test(level, poiPose.getSecond())) {
diff --git a/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java b/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
index 23c9363f03a74a2ddd15ffa1da4e0910dcfe2eb4..c68399986583a215da156b9057a61f22cbf6143d 100644
--- a/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
+++ b/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
@@ -31,6 +31,7 @@ public class HarvestFarmland extends Behavior<Villager> {
     private long nextOkStartTime;
     private int timeWorkedSoFar;
     private final List<BlockPos> validFarmlandAroundVillager = Lists.newArrayList();
+    private boolean clericWartFarmer = false; // Purpur - Option for Villager Clerics to farm Nether Wart
 
     public HarvestFarmland() {
         super(
@@ -47,11 +48,12 @@ public class HarvestFarmland extends Behavior<Villager> {
 
     @Override
     protected boolean checkExtraStartConditions(ServerLevel level, Villager owner) {
-        if (!level.getGameRules().get(GameRules.MOB_GRIEFING)) {
+        if (!level.getGameRules().get(GameRules.MOB_GRIEFING, level.purpurConfig.villagerMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
             return false;
-        } else if (!owner.getVillagerData().profession().is(VillagerProfession.FARMER)) {
+        } else if (!owner.getVillagerData().profession().is(VillagerProfession.FARMER) && !(level.purpurConfig.villagerClericsFarmWarts && owner.getVillagerData().profession().is(VillagerProfession.CLERIC))) { // Purpur - Option for Villager Clerics to farm Nether Wart
             return false;
         } else {
+            if (!this.clericWartFarmer && owner.getVillagerData().profession().is(VillagerProfession.CLERIC)) this.clericWartFarmer = true; // Purpur - Option for Villager Clerics to farm Nether Wart
             BlockPos.MutableBlockPos mutableBlockPos = owner.blockPosition().mutable();
             this.validFarmlandAroundVillager.clear();
 
@@ -81,6 +83,7 @@ public class HarvestFarmland extends Behavior<Villager> {
         BlockState blockState = level.getBlockState(pos);
         Block block = blockState.getBlock();
         Block block1 = level.getBlockState(pos.below()).getBlock();
+        if (this.clericWartFarmer) return block == net.minecraft.world.level.block.Blocks.NETHER_WART && blockState.getValue(net.minecraft.world.level.block.NetherWartBlock.AGE) == 3 || blockState.isAir() && block1 == net.minecraft.world.level.block.Blocks.SOUL_SAND; // Purpur - Option for Villager Clerics to farm Nether Wart
         return block instanceof CropBlock && ((CropBlock)block).isMaxAge(blockState) || blockState.isAir() && block1 instanceof FarmBlock;
     }
 
@@ -107,19 +110,19 @@ public class HarvestFarmland extends Behavior<Villager> {
                 BlockState blockState = level.getBlockState(this.aboveFarmlandPos);
                 Block block = blockState.getBlock();
                 Block block1 = level.getBlockState(this.aboveFarmlandPos.below()).getBlock();
-                if (block instanceof CropBlock && ((CropBlock)block).isMaxAge(blockState)) {
+                if (block instanceof CropBlock && ((CropBlock)block).isMaxAge(blockState) && !this.clericWartFarmer || this.clericWartFarmer && block == net.minecraft.world.level.block.Blocks.NETHER_WART && blockState.getValue(net.minecraft.world.level.block.NetherWartBlock.AGE) == 3) { // Purpur - Option for Villager Clerics to farm Nether Wart
                     if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(owner, this.aboveFarmlandPos, blockState.getFluidState().createLegacyBlock())) { // CraftBukkit // Paper - fix wrong block state
                     level.destroyBlock(this.aboveFarmlandPos, true, owner);
                     } // CraftBukkit
                 }
 
-                if (blockState.isAir() && block1 instanceof FarmBlock && owner.hasFarmSeeds()) {
+                if (blockState.isAir() && block1 instanceof FarmBlock && !this.clericWartFarmer || this.clericWartFarmer && block1 == net.minecraft.world.level.block.Blocks.SOUL_SAND && owner.hasFarmSeeds()) { // Purpur - Option for Villager Clerics to farm Nether Wart
                     SimpleContainer inventory = owner.getInventory();
 
                     for (int i = 0; i < inventory.getContainerSize(); i++) {
                         ItemStack item = inventory.getItem(i);
                         boolean flag = false;
-                        if (!item.isEmpty() && item.is(ItemTags.VILLAGER_PLANTABLE_SEEDS) && item.getItem() instanceof BlockItem blockItem) {
+                        if (!item.isEmpty() && (item.is(ItemTags.VILLAGER_PLANTABLE_SEEDS) || this.clericWartFarmer && item.getItem() == net.minecraft.world.item.Items.NETHER_WART) && item.getItem() instanceof BlockItem blockItem) { // Purpur - Option for Villager Clerics to farm Nether Wart
                             BlockState blockState1 = blockItem.getBlock().defaultBlockState();
                             if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(owner, this.aboveFarmlandPos, blockState1)) { // CraftBukkit
                             level.setBlockAndUpdate(this.aboveFarmlandPos, blockState1);
@@ -134,7 +137,7 @@ public class HarvestFarmland extends Behavior<Villager> {
                                 this.aboveFarmlandPos.getX(),
                                 this.aboveFarmlandPos.getY(),
                                 this.aboveFarmlandPos.getZ(),
-                                SoundEvents.CROP_PLANTED,
+                                this.clericWartFarmer ? SoundEvents.NETHER_WART_PLANTED : SoundEvents.CROP_PLANTED, // Purpur - Option for Villager Clerics to farm Nether Wart
                                 SoundSource.BLOCKS,
                                 1.0F,
                                 1.0F
diff --git a/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java b/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
index df185d375658d765b07648dfb42ea56c84be671e..5c845d78e8baee41809e0678e3d99523368a2882 100644
--- a/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
+++ b/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
@@ -55,7 +55,7 @@ public class InteractWithDoor {
                             Node nextNode = path.getNextNode();
                             BlockPos blockPos = previousNode.asBlockPos();
                             BlockState blockState = level.getBlockState(blockPos);
-                            if (blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
+                            if (blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)&& !DoorBlock.requiresRedstone(entity.level(), blockState, blockPos)) { // Purpur - Option to make doors require redstone
                                 DoorBlock doorBlock = (DoorBlock)blockState.getBlock();
                                 if (!doorBlock.isOpen(blockState)) {
                                     // CraftBukkit start - entities opening doors
@@ -72,7 +72,7 @@ public class InteractWithDoor {
 
                             BlockPos blockPos1 = nextNode.asBlockPos();
                             BlockState blockState1 = level.getBlockState(blockPos1);
-                            if (blockState1.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
+                            if (blockState1.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock) && !DoorBlock.requiresRedstone(entity.level(), blockState1, blockPos1)) { // Purpur - Option to make doors require redstone
                                 DoorBlock doorBlock1 = (DoorBlock)blockState1.getBlock();
                                 if (!doorBlock1.isOpen(blockState1)) {
                                     // CraftBukkit start - entities opening doors
@@ -118,7 +118,7 @@ public class InteractWithDoor {
                     iterator.remove();
                 } else {
                     BlockState blockState = level.getBlockState(blockPos);
-                    if (!blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
+                    if (!blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock) || DoorBlock.requiresRedstone(entity.level(), blockState, blockPos)) { // Purpur - Option to make doors require redstone
                         iterator.remove();
                     } else {
                         DoorBlock doorBlock = (DoorBlock)blockState.getBlock();
diff --git a/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java b/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
index 338f9850a9ee968ade1a5554936a10b8a3786fe5..8cac46b6fd025f7f10b17903579f021482ed4b18 100644
--- a/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
+++ b/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
@@ -45,6 +45,7 @@ public class ShowTradesToPlayer extends Behavior<Villager> {
 
     @Override
     public boolean canStillUse(ServerLevel level, Villager entity, long gameTime) {
+        if (!entity.level().purpurConfig.villagerDisplayTradeItem) return false; // Purpur - Option for villager display trade item
         return this.checkExtraStartConditions(level, entity)
             && this.lookTime > 0
             && entity.getBrain().getMemory(MemoryModuleType.INTERACTION_TARGET).isPresent();
diff --git a/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java b/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
index 256fb863683d66235db4fb2b65fb1495672a67bf..81145178ba1ef75c441a09ab5f376d0528299ad3 100644
--- a/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
+++ b/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
@@ -59,6 +59,12 @@ public class TradeWithVillager extends Behavior<Villager> {
                 throwHalfStack(owner, ImmutableSet.of(Items.WHEAT), villager);
             }
 
+            // Purpur start - Option for Villager Clerics to farm Nether Wart
+            if (level.purpurConfig.villagerClericsFarmWarts && level.purpurConfig.villagerClericFarmersThrowWarts && owner.getVillagerData().profession().is(VillagerProfession.CLERIC) && owner.getInventory().countItem(Items.NETHER_WART) > Items.NETHER_WART.getDefaultMaxStackSize() / 2) {
+                throwHalfStack(owner, ImmutableSet.of(Items.NETHER_WART), villager);
+            }
+            // Purpur end - Option for Villager Clerics to farm Nether Wart
+
             if (!this.trades.isEmpty() && owner.getInventory().hasAnyOf(this.trades)) {
                 throwHalfStack(owner, this.trades, villager);
             }
diff --git a/net/minecraft/world/entity/ai/behavior/TransportItemsBetweenContainers.java b/net/minecraft/world/entity/ai/behavior/TransportItemsBetweenContainers.java
index 3741e32fa1aa85e3b5b45c3b05fcb3a0a807a6e7..b7cf1cb13e55fbc3fb09baf5e40cb351bd68f70c 100644
--- a/net/minecraft/world/entity/ai/behavior/TransportItemsBetweenContainers.java
+++ b/net/minecraft/world/entity/ai/behavior/TransportItemsBetweenContainers.java
@@ -285,7 +285,7 @@ public class TransportItemsBetweenContainers extends Behavior<PathfinderMob> {
             LevelChunk chunkNow = level.getChunkSource().getChunkNow(chunkPos.x, chunkPos.z);
             if (chunkNow != null) {
                 for (BlockEntity blockEntity : chunkNow.getBlockEntities().values()) {
-                    if (blockEntity instanceof ChestBlockEntity chestBlockEntity) {
+                    if (blockEntity instanceof net.minecraft.world.level.block.entity.BaseContainerBlockEntity chestBlockEntity) { // Purpur - copper golem can place items in barrels or shulkers option
                         double d1 = chestBlockEntity.getBlockPos().distToCenterSqr(mob.position());
                         if (d1 < d) {
                             TransportItemsBetweenContainers.TransportItemTarget transportItemTarget1 = this.isTargetValidToPick(
@@ -369,7 +369,11 @@ public class TransportItemsBetweenContainers extends Behavior<PathfinderMob> {
     }
 
     private boolean isTargetBlocked(Level level, TransportItemsBetweenContainers.TransportItemTarget target) {
-        return ChestBlock.isChestBlockedAt(level, target.pos);
+        // Purpur start - copper golem can place items in barrels or shulkers option
+        boolean isBarrelBlocked = !level.purpurConfig.copperGolemCanOpenBarrel && target.state.is(net.minecraft.world.level.block.Blocks.BARREL);
+        boolean isShulkerBlocked = !level.purpurConfig.copperGolemCanOpenShulker && target.blockEntity instanceof net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity shulkerBoxBlockEntity && !net.minecraft.world.level.block.ShulkerBoxBlock.canOpen(target.state, level, target.pos, shulkerBoxBlockEntity);
+        return target.state.is(net.minecraft.world.level.block.Blocks.BARREL) ? isBarrelBlocked : isShulkerBlocked || net.minecraft.world.level.block.ChestBlock.isChestBlockedAt(level, target.pos);
+        // Purpur end - copper golem can place items in barrels or shulkers option
     }
 
     private boolean targetHasNotChanged(Level level, TransportItemsBetweenContainers.TransportItemTarget target) {
@@ -446,7 +450,7 @@ public class TransportItemsBetweenContainers extends Behavior<PathfinderMob> {
     }
 
     private boolean isWantedBlock(PathfinderMob mob, BlockState state) {
-        return isPickingUpItems(mob) ? this.sourceBlockType.test(state) : this.destinationBlockType.test(state);
+        return isPickingUpItems(mob) ? this.sourceBlockType.test(state) : (mob.level().purpurConfig.copperGolemCanOpenBarrel && state.is(net.minecraft.world.level.block.Blocks.BARREL)) || (mob.level().purpurConfig.copperGolemCanOpenShulker && state.is(net.minecraft.tags.BlockTags.SHULKER_BOXES)) || this.destinationBlockType.test(state); // Purpur - copper golem can place items in barrels or shulkers option
     }
 
     private static double getInteractionRange(PathfinderMob mob) {
@@ -525,7 +529,7 @@ public class TransportItemsBetweenContainers extends Behavior<PathfinderMob> {
         int i = 0;
 
         for (ItemStack itemStack : container) {
-            if (!itemStack.isEmpty()) {
+            if (!itemStack.isEmpty() && (!(container instanceof net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity) || !itemStack.is(net.minecraft.tags.ItemTags.SHULKER_BOXES))) { // Purpur - copper golem can place items in barrels or shulkers option
                 int min = Math.min(itemStack.getCount(), 16);
                 return container.removeItem(i, min);
             }
diff --git a/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java b/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java
index bb3ac5297860c8af6e213d10fdf5144086e9474b..0e72601781235119d62fe74420153b98edb5ce23 100644
--- a/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java
+++ b/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java
@@ -79,8 +79,13 @@ public class VillagerGoalPackages {
     public static ImmutableList<Pair<Integer, ? extends BehaviorControl<? super Villager>>> getWorkPackage(
         Holder<VillagerProfession> profession, float speedModifier
     ) {
+        // Purpur start - Option for Villager Clerics to farm Nether Wart
+        return getWorkPackage(profession, speedModifier, false);
+    }
+    public static ImmutableList<Pair<Integer, ? extends BehaviorControl<? super Villager>>> getWorkPackage(Holder<VillagerProfession> profession, float speedModifier, boolean clericsFarmWarts) {
+        // Purpur end - Option for Villager Clerics to farm Nether Wart
         WorkAtPoi workAtPoi;
-        if (profession.is(VillagerProfession.FARMER)) {
+        if (profession.is(VillagerProfession.FARMER) || (clericsFarmWarts && profession.is(VillagerProfession.CLERIC))) { // Purpur - Option for Villager Clerics to farm Nether Wart
             workAtPoi = new WorkAtComposter();
         } else {
             workAtPoi = new WorkAtPoi();
diff --git a/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java b/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
index 35aec6c3aa2f09f13954fda67902b3c975f566e3..fff139abc9341f3ab2dac568a922235dc5e81b3e 100644
--- a/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
+++ b/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
@@ -118,8 +118,10 @@ public class VillagerMakeLove extends Behavior<Villager> {
             if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityBreedEvent(breedOffspring, parent, partner, null, null, 0).isCancelled()) {
                 return Optional.empty();
             }
-            parent.setAge(6000);
-            partner.setAge(6000);
+            // Purpur start - Make entity breeding times configurable
+            parent.setAge(level.purpurConfig.villagerBreedingTicks);
+            partner.setAge(level.purpurConfig.villagerBreedingTicks);
+            // Purpur end - Make entity breeding times configurable
             level.addFreshEntityWithPassengers(breedOffspring, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BREEDING);
             // CraftBukkit end - call EntityBreedEvent
             level.broadcastEntityEvent(breedOffspring, EntityEvent.LOVE_HEARTS);
diff --git a/net/minecraft/world/entity/ai/control/MoveControl.java b/net/minecraft/world/entity/ai/control/MoveControl.java
index b7a4b5ad718e8f4ea108f606669d4fcaf5219e6f..0604fca0687e02e75c097ff864b13e2763bfeb76 100644
--- a/net/minecraft/world/entity/ai/control/MoveControl.java
+++ b/net/minecraft/world/entity/ai/control/MoveControl.java
@@ -29,6 +29,20 @@ public class MoveControl implements Control {
         this.mob = mob;
     }
 
+    // Purpur start - Ridables
+    public void setSpeedModifier(double speed) {
+        this.speedModifier = speed;
+    }
+
+    public void setForward(float forward) {
+        this.strafeForwards = forward;
+    }
+
+    public void setStrafe(float strafe) {
+        this.strafeRight = strafe;
+    }
+    // Purpur end - Ridables
+
     public boolean hasWanted() {
         return this.operation == MoveControl.Operation.MOVE_TO;
     }
diff --git a/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java b/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
index d7f9b3b2b1077ea10e8f64b87c8f4c4354e90858..713f62b34a91fa76f40e49a5e390145f70755e58 100644
--- a/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
+++ b/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
@@ -3,7 +3,7 @@ package net.minecraft.world.entity.ai.control;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Mob;
 
-public class SmoothSwimmingLookControl extends LookControl {
+public class SmoothSwimmingLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
     private final int maxYRotFromCenter;
     private static final int HEAD_TILT_X = 10;
     private static final int HEAD_TILT_Y = 20;
@@ -14,7 +14,7 @@ public class SmoothSwimmingLookControl extends LookControl {
     }
 
     @Override
-    public void tick() {
+    public void vanillaTick() { // Purpur - Ridables
         if (this.lookAtCooldown > 0) {
             this.lookAtCooldown--;
             this.getYRotD().ifPresent(rotationWanted -> this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, rotationWanted + 20.0F, this.yMaxRotSpeed));
diff --git a/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java b/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java
index 272335ec91615e2619ce95f47dbf228d180239c3..23ba4af0b6785057cfd2a996aebcbcf89697c12f 100644
--- a/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java
+++ b/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java
@@ -31,7 +31,7 @@ public class BreakDoorGoal extends DoorInteractGoal {
     @Override
     public boolean canUse() {
         return super.canUse()
-            && getServerLevel(this.mob).getGameRules().get(GameRules.MOB_GRIEFING)
+            && getServerLevel(this.mob).getGameRules().get(GameRules.MOB_GRIEFING, this.mob.level().purpurConfig.zombieMobGriefingOverride) // Purpur - Add mobGriefing override to everything affected
             && this.isValidDifficulty(this.mob.level().getDifficulty())
             && !this.isOpen();
     }
diff --git a/net/minecraft/world/entity/ai/goal/EatBlockGoal.java b/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
index 087861886eeb55324ffe54bda78e19f83bf33e72..0f0311eb836b8da39651ece499fe4bda44bce178 100644
--- a/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
+++ b/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
@@ -64,7 +64,7 @@ public class EatBlockGoal extends Goal {
             BlockPos blockPos = this.mob.blockPosition();
             final BlockState blockState = this.level.getBlockState(blockPos); // Paper - fix wrong block state
             if (IS_EDIBLE.test(blockState)) { // Paper - fix wrong block state
-                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos, blockState.getFluidState().createLegacyBlock(), !getServerLevel(this.level).getGameRules().get(GameRules.MOB_GRIEFING))) { // CraftBukkit // Paper - fix wrong block state
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos, blockState.getFluidState().createLegacyBlock(), !getServerLevel(this.level).getGameRules().get(GameRules.MOB_GRIEFING, getServerLevel(this.level).purpurConfig.sheepMobGriefingOverride))) { // CraftBukkit // Paper - fix wrong block state // Purpur - Add mobGriefing override to everything affected
                     this.level.destroyBlock(blockPos, false);
                 }
 
@@ -72,7 +72,7 @@ public class EatBlockGoal extends Goal {
             } else {
                 BlockPos blockPos1 = blockPos.below();
                 if (this.level.getBlockState(blockPos1).is(Blocks.GRASS_BLOCK)) {
-                    if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos1, Blocks.DIRT.defaultBlockState(), !getServerLevel(this.level).getGameRules().get(GameRules.MOB_GRIEFING))) { // CraftBukkit // Paper - Fix wrong block state
+                    if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos1, Blocks.DIRT.defaultBlockState(), !getServerLevel(this.level).getGameRules().get(GameRules.MOB_GRIEFING, getServerLevel(this.level).purpurConfig.sheepMobGriefingOverride))) { // CraftBukkit // Paper - Fix wrong block state // Purpur - Add mobGriefing override to everything affected
                         this.level.levelEvent(LevelEvent.PARTICLES_DESTROY_BLOCK, blockPos1, Block.getId(Blocks.GRASS_BLOCK.defaultBlockState()));
                         this.level.setBlock(blockPos1, Blocks.DIRT.defaultBlockState(), Block.UPDATE_CLIENTS);
                     }
diff --git a/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java b/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java
index 12a8326af5100d243983c101c5ba9e5f30fb0811..2a7c913aadd839ca90edaed4254d5ced260700ac 100644
--- a/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java
+++ b/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java
@@ -22,6 +22,7 @@ public class LlamaFollowCaravanGoal extends Goal {
 
     @Override
     public boolean canUse() {
+        if (!this.llama.level().purpurConfig.llamaJoinCaravans || !this.llama.shouldJoinCaravan) return false; // Purpur - Llama API // Purpur - Config to disable Llama caravans
         if (!this.llama.isLeashed() && !this.llama.inCaravan()) {
             List<Entity> entities = this.llama.level().getEntities(this.llama, this.llama.getBoundingBox().inflate(9.0, 4.0, 9.0), entity1 -> {
                 EntityType<?> type = entity1.getType();
@@ -71,6 +72,7 @@ public class LlamaFollowCaravanGoal extends Goal {
 
     @Override
     public boolean canContinueToUse() {
+        if (!this.llama.shouldJoinCaravan) return false; // Purpur - Llama API
         if (this.llama.inCaravan() && this.llama.getCaravanHead().isAlive() && this.firstIsLeashed(this.llama, 0)) {
             double d = this.llama.distanceToSqr(this.llama.getCaravanHead());
             if (d > 676.0) {
diff --git a/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java b/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
index 50cc4c462640a9d40abef6245439d71e8c593ae6..83be00350765db043b6bf32e7814d9c7119eacc5 100644
--- a/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
+++ b/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
@@ -35,7 +35,7 @@ public class RemoveBlockGoal extends MoveToBlockGoal {
 
     @Override
     public boolean canUse() {
-        if (!getServerLevel(this.removerMob).getGameRules().get(GameRules.MOB_GRIEFING)) {
+        if (!getServerLevel(this.removerMob).getGameRules().get(GameRules.MOB_GRIEFING, getServerLevel(this.removerMob).purpurConfig.zombieMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
             return false;
         } else if (this.nextStartTick > 0) {
             this.nextStartTick--;
diff --git a/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java b/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java
index 5360b2137116ff76361dab29a4ef2a0bc0228a02..f67e762a50b85a95a3d466aff7572b48d0338e72 100644
--- a/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java
+++ b/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java
@@ -59,7 +59,7 @@ public class RunAroundLikeCrazyGoal extends Goal {
             if (firstPassenger instanceof Player player) {
                 int temper = this.horse.getTemper();
                 int maxTemper = this.horse.getMaxTemper();
-                if (maxTemper > 0 && this.horse.getRandom().nextInt(maxTemper) < temper && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this.horse, ((org.bukkit.craftbukkit.entity.CraftHumanEntity) this.horse.getBukkitEntity().getPassenger()).getHandle()).isCancelled()) { // CraftBukkit - fire EntityTameEvent
+                if (((this.horse.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || (maxTemper > 0 && this.horse.getRandom().nextInt(maxTemper) < temper)) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this.horse, ((org.bukkit.craftbukkit.entity.CraftHumanEntity) this.horse.getBukkitEntity().getPassenger()).getHandle()).isCancelled()) { // CraftBukkit - fire EntityTameEvent // Purpur - Config to always tame in Creative
                     this.horse.tameWithName(player);
                     return;
                 }
diff --git a/net/minecraft/world/entity/ai/goal/SwellGoal.java b/net/minecraft/world/entity/ai/goal/SwellGoal.java
index 2bc0c7f5973d5d5695ec291f404a836a78e8348e..ccbd344a49a568e97606c364082ab3f74ad5e6ed 100644
--- a/net/minecraft/world/entity/ai/goal/SwellGoal.java
+++ b/net/minecraft/world/entity/ai/goal/SwellGoal.java
@@ -47,6 +47,14 @@ public class SwellGoal extends Goal {
             this.creeper.setSwellDir(-1);
         } else {
             this.creeper.setSwellDir(1);
+            // Purpur start - option to allow creeper to encircle target when fusing
+            if (this.creeper.level().purpurConfig.creeperEncircleTarget) {
+                net.minecraft.world.phys.Vec3 relative = this.creeper.position().subtract(this.target.position());
+                relative = relative.yRot((float) Math.PI / 3).normalize().multiply(2, 2, 2);
+                net.minecraft.world.phys.Vec3 destination = this.target.position().add(relative);
+                this.creeper.getNavigation().moveTo(destination.x, destination.y, destination.z, 1);
+            }
+            // Purpur end - option to allow creeper to encircle target when fusing
         }
     }
 }
diff --git a/net/minecraft/world/entity/ai/goal/TemptGoal.java b/net/minecraft/world/entity/ai/goal/TemptGoal.java
index 18030dc04eb7d7971e457637b5320b1e41665658..60ebd57de496eba6ad307195ffacd3b7fc4149ff 100644
--- a/net/minecraft/world/entity/ai/goal/TemptGoal.java
+++ b/net/minecraft/world/entity/ai/goal/TemptGoal.java
@@ -70,7 +70,7 @@ public class TemptGoal extends Goal {
     }
 
     private boolean shouldFollow(LivingEntity entity) {
-        return this.items.test(entity.getMainHandItem()) || this.items.test(entity.getOffhandItem());
+        return (this.items.test(entity.getMainHandItem()) || this.items.test(entity.getOffhandItem())) && (!(this.mob instanceof net.minecraft.world.entity.npc.villager.Villager villager) || !villager.isSleeping()); // Purpur - Villagers follow emerald blocks
     }
 
     @Override
diff --git a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
index 066faa704338c573472381e1ebd063e0d52aaaa4..1f96fd5085bacb4c584576c7cb9f51e7898e9b03 100644
--- a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
+++ b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
@@ -56,7 +56,7 @@ public class NearestBedSensor extends Sensor<Mob> {
             // Paper start - optimise POI access
             java.util.List<Pair<Holder<PoiType>, BlockPos>> poiposes = new java.util.ArrayList<>();
             // don't ask me why it's unbounded. ask mojang.
-            io.papermc.paper.util.PoiAccess.findAnyPoiPositions(poiManager, type -> type.is(PoiTypes.HOME), predicate, entity.blockPosition(), 48, PoiManager.Occupancy.ANY, false, Integer.MAX_VALUE, poiposes);
+            io.papermc.paper.util.PoiAccess.findAnyPoiPositions(poiManager, type -> type.is(PoiTypes.HOME), predicate, entity.blockPosition(), level.purpurConfig.villagerNearestBedSensorSearchRadius, PoiManager.Occupancy.ANY, false, Integer.MAX_VALUE, poiposes); // Purpur - Configurable villager search radius
             Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
             // Paper end - optimise POI access
             if (path != null && path.canReach()) {
diff --git a/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java b/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
index 39a9e9a6f6dfddbf47a7f96150ef832efe61f89e..c268817b170bd54898bb5f8c2e2e12c0faa7eb1e 100644
--- a/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
+++ b/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
@@ -22,6 +22,13 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
 
     @Override
     protected void doTick(ServerLevel level, Villager entity) {
+        // Purpur start - Option for Villager Clerics to farm Nether Wart - make sure clerics don't wander to soul sand when the option is off
+        Brain<?> brain = entity.getBrain();
+        if (!level.purpurConfig.villagerClericsFarmWarts && entity.getVillagerData().profession().is(net.minecraft.world.entity.npc.villager.VillagerProfession.CLERIC)) {
+            brain.eraseMemory(MemoryModuleType.SECONDARY_JOB_SITE);
+            return;
+        }
+        // Purpur end - Option for Villager Clerics to farm Nether Wart
         ResourceKey<Level> resourceKey = level.dimension();
         BlockPos blockPos = entity.blockPosition();
         List<GlobalPos> list = Lists.newArrayList();
@@ -38,7 +45,7 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
             }
         }
 
-        Brain<?> brain = entity.getBrain();
+        //Brain<?> brain = entity.getBrain(); // Purpur - Option for Villager Clerics to farm Nether Wart - moved up
         if (!list.isEmpty()) {
             brain.setMemory(MemoryModuleType.SECONDARY_JOB_SITE, list);
         } else {
diff --git a/net/minecraft/world/entity/ai/targeting/TargetingConditions.java b/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
index e4beea8dcf9db2211ae838470daf060074dd8ec2..8307ed8d1c86ed0243c038420d2c44b02df21fe3 100644
--- a/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
+++ b/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
@@ -63,6 +63,10 @@ public class TargetingConditions {
             return false;
         } else if (this.selector != null && !this.selector.test(target, level)) {
             return false;
+        // Purpur start - AFK API
+        } else if (!level.purpurConfig.idleTimeoutTargetPlayer && target instanceof net.minecraft.server.level.ServerPlayer player && player.isAfk()) {
+            return false;
+        // Purpur end - AFK API
         } else {
             if (entity == null) {
                 if (this.isCombat && (!target.canBeSeenAsEnemy() || level.getDifficulty() == Difficulty.PEACEFUL)) {
diff --git a/net/minecraft/world/entity/ambient/Bat.java b/net/minecraft/world/entity/ambient/Bat.java
index ca68d356e892e0ac8a651ced92aab7dbfd4699b4..b642f71d282773afb9fe273cbe65765afa2d5868 100644
--- a/net/minecraft/world/entity/ambient/Bat.java
+++ b/net/minecraft/world/entity/ambient/Bat.java
@@ -42,11 +42,87 @@ public class Bat extends AmbientCreature {
 
     public Bat(EntityType<? extends Bat> type, Level level) {
         super(type, level);
+        this.moveControl = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.075F); // Purpur - Ridables
         if (!level.isClientSide()) {
             this.setResting(true);
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean shouldSendAttribute(net.minecraft.world.entity.ai.attributes.Attribute attribute) { return attribute != Attributes.FLYING_SPEED.value(); } // Fixes log spam on clients
+
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.batRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.batRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.batControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.batMaxY;
+    }
+
+    @Override
+    public void onMount(net.minecraft.world.entity.player.Player rider) {
+        super.onMount(rider);
+        if (isResting()) {
+            setResting(false);
+            level().levelEvent(null, 1025, new BlockPos(this).above(), 0);
+        }
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 2;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 0.25, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.batMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.batScale);
+        this.getAttribute(Attributes.FOLLOW_RANGE).setBaseValue(this.level().purpurConfig.batFollowRange);
+        this.getAttribute(Attributes.KNOCKBACK_RESISTANCE).setBaseValue(this.level().purpurConfig.batKnockbackResistance);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.batMovementSpeed);
+        this.getAttribute(Attributes.FLYING_SPEED).setBaseValue(this.level().purpurConfig.batFlyingSpeed);
+        this.getAttribute(Attributes.ARMOR).setBaseValue(this.level().purpurConfig.batArmor);
+        this.getAttribute(Attributes.ARMOR_TOUGHNESS).setBaseValue(this.level().purpurConfig.batArmorToughness);
+        this.getAttribute(Attributes.ATTACK_KNOCKBACK).setBaseValue(this.level().purpurConfig.batAttackKnockback);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.batTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.batAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isFlapping() {
         return !this.isResting() && this.tickCount % 10.0F == 0.0F;
@@ -97,7 +173,7 @@ public class Bat extends AmbientCreature {
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Mob.createMobAttributes().add(Attributes.MAX_HEALTH, 6.0);
+        return Mob.createMobAttributes().add(Attributes.MAX_HEALTH, 6.0).add(Attributes.FLYING_SPEED, 0.6D); // Purpur - Ridables
     }
 
     public boolean isResting() {
@@ -128,6 +204,14 @@ public class Bat extends AmbientCreature {
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot.x(), mot.y() + (getVerticalMot() > 0 ? 0.07D : 0.0D), mot.z());
+            return;
+        }
+        // Purpur end - Ridables
+
         super.customServerAiStep(level);
         BlockPos blockPos = this.blockPosition();
         BlockPos blockPos1 = blockPos.above();
diff --git a/net/minecraft/world/entity/animal/Animal.java b/net/minecraft/world/entity/animal/Animal.java
index 023b68549e3b185d8ad2f505f34bb59556bbf961..53d04c412d36015a30ae2680f61651db6acbf2f2 100644
--- a/net/minecraft/world/entity/animal/Animal.java
+++ b/net/minecraft/world/entity/animal/Animal.java
@@ -46,6 +46,7 @@ public abstract class Animal extends AgeableMob {
     public int inLove = 0;
     public @Nullable EntityReference<ServerPlayer> loveCause;
     public @Nullable ItemStack breedItem; // CraftBukkit - Add breedItem variable
+    public abstract int getPurpurBreedTime(); // Purpur - Make entity breeding times configurable
 
     protected Animal(EntityType<? extends Animal> type, Level level) {
         super(type, level);
@@ -146,7 +147,7 @@ public abstract class Animal extends AgeableMob {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (this.isFood(itemInHand)) {
             int age = this.getAge();
-            if (player instanceof ServerPlayer serverPlayer && age == 0 && this.canFallInLove()) {
+            if (player instanceof ServerPlayer serverPlayer && age == 0 && this.canFallInLove() && (this.level().purpurConfig.animalBreedingCooldownSeconds <= 0 || !this.level().hasBreedingCooldown(player.getUUID(), this.getClass()))) { // Purpur - Add adjustable breeding cooldown to config
                 final ItemStack breedCopy = itemInHand.copy(); // Paper - Fix EntityBreedEvent copying
                 this.usePlayerItem(player, hand, itemInHand);
                 this.setInLove(serverPlayer, breedCopy); // Paper - Fix EntityBreedEvent copying
@@ -227,10 +228,20 @@ public abstract class Animal extends AgeableMob {
     public void spawnChildFromBreeding(ServerLevel level, Animal partner) {
         AgeableMob breedOffspring = this.getBreedOffspring(level, partner);
         if (breedOffspring != null) {
-            breedOffspring.setBaby(true);
-            breedOffspring.snapTo(this.getX(), this.getY(), this.getZ(), 0.0F, 0.0F);
+            //breedOffspring.setBaby(true); // Purpur - Add adjustable breeding cooldown to config - moved down
+            //breedOffspring.snapTo(this.getX(), this.getY(), this.getZ(), 0.0F, 0.0F); // Purpur - Add adjustable breeding cooldown to config - moved down
             // CraftBukkit start - Call EntityBreedEvent
             ServerPlayer breeder = Optional.ofNullable(this.getLoveCause()).or(() -> Optional.ofNullable(partner.getLoveCause())).orElse(null);
+            // Purpur start - Add adjustable breeding cooldown to config
+            if (breeder != null && level.purpurConfig.animalBreedingCooldownSeconds > 0) {
+                if (level.hasBreedingCooldown(breeder.getUUID(), this.getClass())) {
+                    return;
+                }
+                level.addBreedingCooldown(breeder.getUUID(), this.getClass());
+            }
+            breedOffspring.setBaby(true);
+            breedOffspring.snapTo(this.getX(), this.getY(), this.getZ(), 0.0F, 0.0F);
+            // Purpur end - Add adjustable breeding cooldown to config
             int experience = this.getRandom().nextInt(7) + 1;
             org.bukkit.event.entity.EntityBreedEvent entityBreedEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callEntityBreedEvent(breedOffspring, this, partner, breeder, this.breedItem, experience);
             if (entityBreedEvent.isCancelled()) {
@@ -261,8 +272,10 @@ public abstract class Animal extends AgeableMob {
             player.awardStat(Stats.ANIMALS_BRED);
             CriteriaTriggers.BRED_ANIMALS.trigger(player, this, animal, baby);
         } // Paper - Call EntityBreedEvent
-        this.setAge(6000);
-        animal.setAge(6000);
+        // Purpur start - Make entity breeding times configurable
+        this.setAge(this.getPurpurBreedTime());
+        animal.setAge(animal.getPurpurBreedTime());
+        // Purpur end - Make entity breeding times configurable
         this.resetLove();
         animal.resetLove();
         level.broadcastEntityEvent(this, EntityEvent.IN_LOVE_HEARTS);
diff --git a/net/minecraft/world/entity/animal/allay/Allay.java b/net/minecraft/world/entity/animal/allay/Allay.java
index 0591dc9c39f94768c5ebf74cad7bae98921ff66c..8635ecfa49e2504c981dd48acbfbca5303a37611 100644
--- a/net/minecraft/world/entity/animal/allay/Allay.java
+++ b/net/minecraft/world/entity/animal/allay/Allay.java
@@ -113,10 +113,23 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
     private float spinningAnimationTicks;
     private float spinningAnimationTicks0;
     public boolean forceDancing = false; // CraftBukkit
+    private org.purpurmc.purpur.controller.FlyingMoveControllerWASD purpurController; // Purpur - Ridables
 
     public Allay(EntityType<? extends Allay> type, Level level) {
         super(type, level);
-        this.moveControl = new FlyingMoveControl(this, 20, true);
+        // Purpur start - Ridables
+        this.purpurController = new org.purpurmc.purpur.controller.FlyingMoveControllerWASD(this, 0.1F, 0.5F);
+        this.moveControl = new FlyingMoveControl(this, 20, true) {
+            @Override
+            public void tick() {
+                if (mob.getRider() != null && mob.isControllable()) {
+                    purpurController.purpurTick(mob.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
         this.setCanPickUpLoot(this.canPickUpLoot());
         this.vibrationUser = new Allay.VibrationUser();
         this.vibrationData = new VibrationSystem.Data();
@@ -132,6 +145,43 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
     }
     // CraftBukkit end
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.allayRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.allayRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.allayControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.allayMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.allayScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.allayCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected Brain.Provider<Allay> brainProvider() {
         return Brain.provider(MEMORY_TYPES, SENSOR_TYPES);
@@ -227,6 +277,7 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("allayBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("allayActivityUpdate");
diff --git a/net/minecraft/world/entity/animal/armadillo/Armadillo.java b/net/minecraft/world/entity/animal/armadillo/Armadillo.java
index 901e4e9897e76cd4158d7f8bb8ec829df8ff8196..8ae1f8471f35028c1c469dc9cb9eac9b564a5c5e 100644
--- a/net/minecraft/world/entity/animal/armadillo/Armadillo.java
+++ b/net/minecraft/world/entity/animal/armadillo/Armadillo.java
@@ -82,6 +82,38 @@ public class Armadillo extends Animal {
         return Animal.createAnimalAttributes().add(Attributes.MAX_HEALTH, 12.0).add(Attributes.MOVEMENT_SPEED, 0.14);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.armadilloRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.armadilloRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.armadilloControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.armadilloMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.armadilloScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.armadilloBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
diff --git a/net/minecraft/world/entity/animal/axolotl/Axolotl.java b/net/minecraft/world/entity/animal/axolotl/Axolotl.java
index 2e5291af79a04ff7ebfc533596a008b404571214..e5ac43bf5631254c31d91abb1c5de408807429dd 100644
--- a/net/minecraft/world/entity/animal/axolotl/Axolotl.java
+++ b/net/minecraft/world/entity/animal/axolotl/Axolotl.java
@@ -121,6 +121,52 @@ public class Axolotl extends Animal implements Bucketable {
         this.lookControl = new Axolotl.AxolotlLookControl(this, 20);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.axolotlRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.axolotlControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.axolotlMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.axolotlScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.axolotlBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.axolotlTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.axolotlAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public float getWalkTargetValue(BlockPos pos, LevelReader level) {
         return 0.0F;
@@ -328,6 +374,7 @@ public class Axolotl extends Animal implements Bucketable {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("axolotlBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("axolotlActivityUpdate");
@@ -564,23 +611,31 @@ public class Axolotl extends Animal implements Bucketable {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (!Axolotl.this.isPlayingDead()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
 
     static class AxolotlMoveControl extends SmoothSwimmingMoveControl {
         private final Axolotl axolotl;
+        private final org.purpurmc.purpur.controller.WaterMoveControllerWASD waterController; // Purpur - Ridables
 
         public AxolotlMoveControl(Axolotl axolotl) {
             super(axolotl, 85, 10, 0.1F, 0.5F, false);
             this.axolotl = axolotl;
+            waterController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(axolotl, 0.5D); // Purpur - Ridables
         }
 
         @Override
         public void tick() {
+            // Purpur start - Ridables
+            if (axolotl.getRider() != null && axolotl.isControllable()) {
+                waterController.purpurTick(axolotl.getRider());
+                return;
+            }
+            // Purpur end - Ridables
             if (!this.axolotl.isPlayingDead()) {
                 super.tick();
             }
diff --git a/net/minecraft/world/entity/animal/bee/Bee.java b/net/minecraft/world/entity/animal/bee/Bee.java
index 0cbcf23b6edba2305dfbbc95abb06a90a6edd42b..10dfa28ec46727e60f8a9c90d7e8914aa8b96ea1 100644
--- a/net/minecraft/world/entity/animal/bee/Bee.java
+++ b/net/minecraft/world/entity/animal/bee/Bee.java
@@ -153,6 +153,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
     public Bee(EntityType<? extends Bee> type, Level level) {
         super(type, level);
+        final org.purpurmc.purpur.controller.FlyingMoveControllerWASD flyingController = new org.purpurmc.purpur.controller.FlyingMoveControllerWASD(this, 0.25F, 1.0F, false); // Purpur - Ridables
         // Paper start - Fix MC-167279
         class BeeFlyingMoveControl extends FlyingMoveControl {
             public BeeFlyingMoveControl(final Mob mob, final int maxTurn, final boolean hoversInPlace) {
@@ -161,22 +162,69 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
             @Override
             public void tick() {
+                // Purpur start - Ridables
+                if (mob.getRider() != null && mob.isControllable()) {
+                    flyingController.purpurTick(mob.getRider());
+                    return;
+                }
+                // Purpur end - Ridables
                 if (this.mob.getY() <= Bee.this.level().getMinY()) {
                     this.mob.setNoGravity(false);
                 }
                 super.tick();
             }
+
+            // Purpur start - Ridables
+            @Override
+            public boolean hasWanted() {
+                return mob.getRider() != null || !mob.isControllable() || super.hasWanted();
+            }
+            // Purpur end - Ridables
         }
         this.moveControl = new BeeFlyingMoveControl(this, 20, true);
         // Paper end - Fix MC-167279
         this.lookControl = new Bee.BeeLookControl(this);
         this.setPathfindingMalus(PathType.DANGER_FIRE, -1.0F);
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        if (this.level().purpurConfig.beeCanInstantlyStartDrowning || isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - bee can instantly start drowning in water option // Purpur - Toggle for water sensitive mob damage
         this.setPathfindingMalus(PathType.WATER_BORDER, 16.0F);
         this.setPathfindingMalus(PathType.COCOA, -1.0F);
         this.setPathfindingMalus(PathType.FENCE, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.beeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.beeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.beeControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.beeMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 2;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, speed, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -191,6 +239,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new Bee.BeeAttackGoal(this, 1.4F, true));
         this.goalSelector.addGoal(1, new Bee.BeeEnterHiveGoal());
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
@@ -208,6 +257,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         this.goalSelector.addGoal(7, new Bee.BeeGrowCropGoal());
         this.goalSelector.addGoal(8, new Bee.BeeWanderGoal());
         this.goalSelector.addGoal(9, new FloatGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Bee.BeeHurtByOtherGoal(this).setAlertOthers());
         this.targetSelector.addGoal(2, new Bee.BeeBecomeAngryTargetGoal(this));
         this.targetSelector.addGoal(3, new ResetUniversalAngerTargetGoal<>(this, true));
@@ -360,13 +410,19 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         if (this.stayOutOfHiveCountdown <= 0 && !this.beePollinateGoal.isPollinating() && !this.hasStung() && this.getTarget() == null) {
             boolean flag = this.hasNectar()
                 || this.isTiredOfLookingForNectar()
-                || this.level().environmentAttributes().getValue(EnvironmentAttributes.BEES_STAY_IN_HIVE, this.position());
+                || this.level().environmentAttributes().getValue(EnvironmentAttributes.BEES_STAY_IN_HIVE, this.position()) || isNightOrRaining(this.level()); // Purpur - Bee can work when raining or at night
             return flag && !this.isHiveNearFire();
         } else {
             return false;
         }
     }
 
+    // Purpur start - Bee can work when raining or at night
+    public static boolean isNightOrRaining(Level level) {
+        return level.dimensionType().hasSkyLight() && (level.isDarkOutside() && !level.purpurConfig.beeCanWorkAtNight || level.isRaining() && !level.purpurConfig.beeCanWorkInRain); // Purpur - Bee can work when raining or at night
+    }
+    // Purpur end - Bee can work when raining or at night
+
     public void setStayOutOfHiveCountdown(int stayOutOfHiveCountdown) {
         this.stayOutOfHiveCountdown = stayOutOfHiveCountdown;
     }
@@ -387,7 +443,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     @Override
     protected void customServerAiStep(ServerLevel level) {
         boolean hasStung = this.hasStung();
-        if (this.isInWater()) {
+        if (this.level().purpurConfig.beeCanInstantlyStartDrowning && this.isInWater()) { // Purpur - bee can instantly start drowning in water option
             this.underWaterTicks++;
         } else {
             this.underWaterTicks = 0;
@@ -397,6 +453,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
             this.hurtServer(level, this.damageSources().drown(), 1.0F);
         }
 
+        if (hasStung && !this.level().purpurConfig.beeDiesAfterSting) setHasStung(false); else // Purpur - Stop bees from dying after stinging
         if (hasStung) {
             this.timeSinceSting++;
             if (this.timeSinceSting % 5 == 0 && this.random.nextInt(Mth.clamp(1200 - this.timeSinceSting, 1, 1200)) == 0) {
@@ -420,6 +477,35 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         return beehiveBlockEntity != null && beehiveBlockEntity.isFireNearby();
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.beeMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.beeScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.beeBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.beeTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.beeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public long getPersistentAngerEndTime() {
         return this.entityData.get(DATA_ANGER_END_TIME);
@@ -1078,15 +1164,15 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         }
     }
 
-    class BeeLookControl extends LookControl {
+    class BeeLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         BeeLookControl(final Mob mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (!Bee.this.isAngry()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
 
@@ -1130,6 +1216,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                     Bee.this.savedFlowerPos = optional.get();
                     Bee.this.navigation
                         .moveTo(Bee.this.savedFlowerPos.getX() + 0.5, Bee.this.savedFlowerPos.getY() + 0.5, Bee.this.savedFlowerPos.getZ() + 0.5, 1.2F);
+                    new org.purpurmc.purpur.event.entity.BeeFoundFlowerEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftLocation.toBukkit(Bee.this.savedFlowerPos, Bee.this.level())).callEvent(); // Purpur - Bee API
                     return true;
                 } else {
                     Bee.this.remainingCooldownBeforeLocatingNewFlower = Mth.nextInt(Bee.this.random, 20, 60);
@@ -1176,6 +1263,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
             this.pollinating = false;
             Bee.this.navigation.stop();
             Bee.this.remainingCooldownBeforeLocatingNewFlower = 200;
+            new org.purpurmc.purpur.event.entity.BeeStopPollinatingEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), Bee.this.savedFlowerPos == null ? null : org.bukkit.craftbukkit.util.CraftLocation.toBukkit(Bee.this.savedFlowerPos, Bee.this.level()), Bee.this.hasNectar()).callEvent(); // Purpur - Bee API
         }
 
         @Override
@@ -1222,6 +1310,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                                 this.setWantedPos();
                             }
 
+                            if (this.successfulPollinatingTicks == 0) new org.purpurmc.purpur.event.entity.BeeStartedPollinatingEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftLocation.toBukkit(Bee.this.savedFlowerPos, Bee.this.level())).callEvent(); // Purpur - Bee API
                             this.successfulPollinatingTicks++;
                             if (Bee.this.random.nextFloat() < 0.05F && this.successfulPollinatingTicks > this.lastSoundPlayedTick + 60) {
                                 this.lastSoundPlayedTick = this.successfulPollinatingTicks;
diff --git a/net/minecraft/world/entity/animal/camel/Camel.java b/net/minecraft/world/entity/animal/camel/Camel.java
index 98721e4d406385108b3d63e9e811f730454090e7..842b20242c323572d4c04d3a2d5fe21a54d53ed4 100644
--- a/net/minecraft/world/entity/animal/camel/Camel.java
+++ b/net/minecraft/world/entity/animal/camel/Camel.java
@@ -90,6 +90,20 @@ public class Camel extends AbstractHorse {
         groundPathNavigation.setCanWalkOverFences(true);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.camelRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.camelBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
     @Override
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
@@ -336,6 +350,23 @@ public class Camel extends AbstractHorse {
         return this.dashCooldown;
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.camelMaxHealthMin, this.level().purpurConfig.camelMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.camelJumpStrengthMin, this.level().purpurConfig.camelJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.camelMovementSpeedMin, this.level().purpurConfig.camelMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     public SoundEvent getAmbientSound() {
         return SoundEvents.CAMEL_AMBIENT;
diff --git a/net/minecraft/world/entity/animal/chicken/Chicken.java b/net/minecraft/world/entity/animal/chicken/Chicken.java
index b44367e42793cec9af35f50dffff479b4be7b728..341d6ecefb126be61b5f43a73638847e2bf9f125 100644
--- a/net/minecraft/world/entity/animal/chicken/Chicken.java
+++ b/net/minecraft/world/entity/animal/chicken/Chicken.java
@@ -73,16 +73,76 @@ public class Chicken extends Animal {
         this.setPathfindingMalus(PathType.WATER, 0.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.chickenRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.chickenRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.chickenControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.chickenMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.chickenScale);
+        // Purpur start - Chickens can retaliate
+        if (level().purpurConfig.chickenRetaliate) {
+            this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(2.0D);
+        }
+        // Purpur end - Chickens can retaliate
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.chickenBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.chickenTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.chickenAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
-        this.goalSelector.addGoal(1, new PanicGoal(this, 1.4));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        //this.goalSelector.addGoal(1, new PanicGoal(this, 1.4)); // Purpur - Chickens can retaliate - moved down
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
         this.goalSelector.addGoal(3, new TemptGoal(this, 1.0, itemStack -> itemStack.is(ItemTags.CHICKEN_FOOD), false));
         this.goalSelector.addGoal(4, new FollowParentGoal(this, 1.1));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(7, new RandomLookAroundGoal(this));
+        // Purpur start - Chickens can retaliate
+        if (level().purpurConfig.chickenRetaliate) {
+            this.goalSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.MeleeAttackGoal(this, 1.0D, false));
+            this.targetSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.target.HurtByTargetGoal(this));
+        } else {
+            this.goalSelector.addGoal(1, new PanicGoal(this, 1.4D));
+        }
+        // Purpur end - Chickens can retaliate
     }
 
     @Override
@@ -91,7 +151,7 @@ public class Chicken extends Animal {
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Animal.createAnimalAttributes().add(Attributes.MAX_HEALTH, 4.0).add(Attributes.MOVEMENT_SPEED, 0.25);
+        return Animal.createAnimalAttributes().add(Attributes.MAX_HEALTH, 4.0).add(Attributes.MOVEMENT_SPEED, 0.25).add(Attributes.ATTACK_DAMAGE, 0.0D); // Purpur - Chickens can retaliate
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/cow/AbstractCow.java b/net/minecraft/world/entity/animal/cow/AbstractCow.java
index e10f7d1b264a85798de063b4387bab62621bf54b..a25ef3bc802759f61947ef8242c19e9320693d35 100644
--- a/net/minecraft/world/entity/animal/cow/AbstractCow.java
+++ b/net/minecraft/world/entity/animal/cow/AbstractCow.java
@@ -38,9 +38,10 @@ public abstract class AbstractCow extends Animal {
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PanicGoal(this, 2.0));
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
-        this.goalSelector.addGoal(3, new TemptGoal(this, 1.25, itemStack -> itemStack.is(ItemTags.COW_FOOD), false));
+        this.goalSelector.addGoal(3, new TemptGoal(this, 1.25, itemStack -> level().purpurConfig.cowFeedMushrooms > 0 && (itemStack.is(net.minecraft.world.level.block.Blocks.RED_MUSHROOM.asItem()) || itemStack.is(net.minecraft.world.level.block.Blocks.BROWN_MUSHROOM.asItem())) || itemStack.is(ItemTags.COW_FOOD), false)); // Purpur - Cows eat mushrooms
         this.goalSelector.addGoal(4, new FollowParentGoal(this, 1.25));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
@@ -83,19 +84,24 @@ public abstract class AbstractCow extends Animal {
 
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
+        if (getRider() != null) return InteractionResult.PASS; // Purpur - Ridables
         ItemStack itemInHand = player.getItemInHand(hand);
         if (itemInHand.is(Items.BUCKET) && !this.isBaby()) {
             // CraftBukkit start - Got milk?
             org.bukkit.event.player.PlayerBucketFillEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerBucketFillEvent(player.level(), player, this.blockPosition(), this.blockPosition(), null, itemInHand, Items.MILK_BUCKET, hand);
             if (event.isCancelled()) {
                 player.containerMenu.sendAllDataToRemote(); // Paper - Fix inventory desync
-                return InteractionResult.PASS;
+                return tryRide(player, hand); // Purpur - Ridables
             }
             // CraftBukkit end
             player.playSound(SoundEvents.COW_MILK, 1.0F, 1.0F);
             ItemStack itemStack = ItemUtils.createFilledResult(itemInHand, player, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItemStack())); // CraftBukkit
             player.setItemInHand(hand, itemStack);
             return InteractionResult.SUCCESS;
+        // Purpur start - Cows eat mushrooms - feed mushroom to change to mooshroom
+        } else if (level().purpurConfig.cowFeedMushrooms > 0 && this.getType() != EntityType.MOOSHROOM && isMushroom(itemInHand)) {
+            return this.feedMushroom(player, itemInHand);
+        // Purpur end - Cows eat mushrooms
         } else {
             return super.mobInteract(player, hand);
         }
@@ -105,4 +111,67 @@ public abstract class AbstractCow extends Animal {
     public EntityDimensions getDefaultDimensions(Pose pose) {
         return this.isBaby() ? BABY_DIMENSIONS : super.getDefaultDimensions(pose);
     }
+
+    // Purpur start - Cows eat mushrooms - feed mushroom to change to mooshroom
+    private int redMushroomsFed = 0;
+    private int brownMushroomsFed = 0;
+
+    private boolean isMushroom(ItemStack stack) {
+        return stack.getItem() == net.minecraft.world.level.block.Blocks.RED_MUSHROOM.asItem() || stack.getItem() == net.minecraft.world.level.block.Blocks.BROWN_MUSHROOM.asItem();
+    }
+
+    private int incrementFeedCount(ItemStack stack) {
+        if (stack.getItem() == net.minecraft.world.level.block.Blocks.RED_MUSHROOM.asItem()) {
+            return ++redMushroomsFed;
+        } else {
+            return ++brownMushroomsFed;
+        }
+    }
+
+    private InteractionResult feedMushroom(Player player, ItemStack stack) {
+        level().broadcastEntityEvent(this, (byte) 18); // hearts
+        playSound(SoundEvents.COW_MILK, 1.0F, 1.0F);
+        if (incrementFeedCount(stack) < level().purpurConfig.cowFeedMushrooms) {
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(1);
+            }
+            return InteractionResult.CONSUME; // require 5 mushrooms to transform (prevents mushroom duping)
+        }
+        MushroomCow mooshroom = EntityType.MOOSHROOM.create(level(), net.minecraft.world.entity.EntitySpawnReason.CONVERSION);
+        if (mooshroom == null) {
+            return InteractionResult.PASS;
+        }
+        if (stack.getItem() == net.minecraft.world.level.block.Blocks.BROWN_MUSHROOM.asItem()) {
+            mooshroom.setVariant(MushroomCow.Variant.BROWN);
+        } else {
+            mooshroom.setVariant(MushroomCow.Variant.RED);
+        }
+        mooshroom.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
+        mooshroom.setHealth(this.getHealth());
+        mooshroom.setAge(getAge());
+        mooshroom.copyPosition(this);
+        mooshroom.setYBodyRot(this.yBodyRot);
+        mooshroom.setYHeadRot(this.getYHeadRot());
+        mooshroom.yRotO = this.yRotO;
+        mooshroom.xRotO = this.xRotO;
+        if (this.hasCustomName()) {
+            mooshroom.setCustomName(this.getCustomName());
+        }
+        if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTransformEvent(this, mooshroom, org.bukkit.event.entity.EntityTransformEvent.TransformReason.INFECTION).isCancelled()) {
+            return InteractionResult.PASS;
+        }
+        this.level().addFreshEntity(mooshroom);
+        this.remove(RemovalReason.DISCARDED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        if (!player.getAbilities().instabuild) {
+            stack.shrink(1);
+        }
+        for (int i = 0; i < 15; ++i) {
+            ((net.minecraft.server.level.ServerLevel) level()).sendParticlesSource(((net.minecraft.server.level.ServerLevel) level()).players(), null, net.minecraft.core.particles.ParticleTypes.HAPPY_VILLAGER,
+                    false, true,
+                    getX() + random.nextFloat(), getY() + (random.nextFloat() * 2), getZ() + random.nextFloat(), 1,
+                    random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, 0);
+        }
+        return InteractionResult.SUCCESS;
+    }
+    // Purpur end - Cows eat mushrooms
 }
diff --git a/net/minecraft/world/entity/animal/cow/Cow.java b/net/minecraft/world/entity/animal/cow/Cow.java
index f37322e0d90ea055a643b144dd87578df6a0bcc9..1463e94d3851614caee216b50e90d1980de75298 100644
--- a/net/minecraft/world/entity/animal/cow/Cow.java
+++ b/net/minecraft/world/entity/animal/cow/Cow.java
@@ -23,12 +23,68 @@ import net.minecraft.world.level.storage.ValueOutput;
 import org.jspecify.annotations.Nullable;
 
 public class Cow extends AbstractCow {
+    private boolean isNaturallyAggressiveToPlayers; // Purpur - Cows naturally aggressive to players chance
+
     private static final EntityDataAccessor<Holder<CowVariant>> DATA_VARIANT_ID = SynchedEntityData.defineId(Cow.class, EntityDataSerializers.COW_VARIANT);
 
     public Cow(EntityType<? extends Cow> type, Level level) {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.cowRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.cowRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.cowControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.cowMaxHealth);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SCALE).setBaseValue(this.level().purpurConfig.cowScale);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.cowNaturallyAggressiveToPlayersDamage); // Purpur - Cows naturally aggressive to players chance
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.cowBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.cowTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.cowAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    @Override
+    protected void registerGoals() {
+        super.registerGoals();
+        this.goalSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.MeleeAttackGoal(this, 1.2000000476837158D, true)); // Purpur - Cows naturally aggressive to players chance
+        this.targetSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.player.Player.class, 10, true, false, (ignored, ignored2) -> isNaturallyAggressiveToPlayers)); // Purpur - Cows naturally aggressive to players chance
+    }
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -41,6 +97,12 @@ public class Cow extends AbstractCow {
         VariantUtils.writeVariant(output, this.getVariant());
     }
 
+    // Purpur start - Cows naturally aggressive to players chance
+    public static net.minecraft.world.entity.ai.attributes.AttributeSupplier.Builder createAttributes() {
+        return AbstractCow.createAttributes().add(net.minecraft.world.entity.ai.attributes.Attributes.ATTACK_DAMAGE, 0.0D);
+    }
+    // Purpur end - Cows naturally aggressive to players chance
+
     @Override
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
@@ -61,6 +123,7 @@ public class Cow extends AbstractCow {
     public SpawnGroupData finalizeSpawn(
         ServerLevelAccessor level, DifficultyInstance difficulty, EntitySpawnReason spawnReason, @Nullable SpawnGroupData spawnGroupData
     ) {
+        this.isNaturallyAggressiveToPlayers = level.getLevel().purpurConfig.cowNaturallyAggressiveToPlayersChance > 0.0D && random.nextDouble() <= level.getLevel().purpurConfig.cowNaturallyAggressiveToPlayersChance; // Purpur - Cows naturally aggressive to players chance
         VariantUtils.selectVariantToSpawn(SpawnContext.create(level, this.blockPosition()), Registries.COW_VARIANT).ifPresent(this::setVariant);
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
diff --git a/net/minecraft/world/entity/animal/cow/MushroomCow.java b/net/minecraft/world/entity/animal/cow/MushroomCow.java
index b4b59e3973f7a3fe8b94ff337e87cbe735b2285c..8019a13adaf4dcc71065a0949b29226dd66343d7 100644
--- a/net/minecraft/world/entity/animal/cow/MushroomCow.java
+++ b/net/minecraft/world/entity/animal/cow/MushroomCow.java
@@ -61,6 +61,51 @@ public class MushroomCow extends AbstractCow implements Shearable {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.mooshroomRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.mooshroomRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.mooshroomControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.mooshroomMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.mooshroomBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.mooshroomTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.mooshroomAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public float getWalkTargetValue(BlockPos pos, LevelReader level) {
         return level.getBlockState(pos.below()).is(Blocks.MYCELIUM) ? 10.0F : level.getPathfindingCostFromLightLevels(pos);
@@ -121,7 +166,7 @@ public class MushroomCow extends AbstractCow implements Shearable {
                 java.util.List<ItemStack> drops = this.generateDefaultDrops(serverLevel, itemInHand);
                 org.bukkit.event.player.PlayerShearEntityEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.handlePlayerShearEntityEvent(player, this, itemInHand, hand, drops);
                 if (event != null) {
-                    if (event.isCancelled()) return InteractionResult.PASS;
+                    if (event.isCancelled()) return tryRide(player, hand); // Purpur - Ridables
                     drops = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getDrops());
                     // Paper end - custom shear drops
                 }
diff --git a/net/minecraft/world/entity/animal/dolphin/Dolphin.java b/net/minecraft/world/entity/animal/dolphin/Dolphin.java
index 3a3c9694d3a704aaaa241bd8601c7fd2439436cc..ea3ccc1f39f70c8ce407ed94ab19a3caa3b90dc4 100644
--- a/net/minecraft/world/entity/animal/dolphin/Dolphin.java
+++ b/net/minecraft/world/entity/animal/dolphin/Dolphin.java
@@ -75,14 +75,105 @@ public class Dolphin extends AgeableWaterCreature {
     public static final float BABY_SCALE = 0.65F;
     private static final boolean DEFAULT_GOT_FISH = false;
     @Nullable public BlockPos treasurePos;
+    private boolean isNaturallyAggressiveToPlayers; // Purpur - Dolphins naturally aggressive to players chance
+    private int spitCooldown; // Purpur - Ridables
 
     public Dolphin(EntityType<? extends Dolphin> type, Level level) {
         super(type, level);
-        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur start - Ridables
+        class DolphinMoveControl extends SmoothSwimmingMoveControl {
+            private final org.purpurmc.purpur.controller.WaterMoveControllerWASD waterMoveControllerWASD;
+            private final Dolphin dolphin;
+
+            public DolphinMoveControl(Dolphin dolphin, int pitchChange, int yawChange, float speedInWater, float speedInAir, boolean buoyant) {
+                super(dolphin, pitchChange, yawChange, speedInWater, speedInAir, buoyant);
+                this.dolphin = dolphin;
+                this.waterMoveControllerWASD = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(dolphin);
+            }
+
+            @Override
+            public void tick() {
+                if (dolphin.getRider() != null && dolphin.isControllable()) {
+                    purpurTick(dolphin.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+
+            public void purpurTick(Player rider) {
+                if (dolphin.getAirSupply() < 150) {
+                    // if drowning override player WASD controls to find air
+                    super.tick();
+                } else {
+                    waterMoveControllerWASD.purpurTick(rider);
+                    dolphin.setDeltaMovement(dolphin.getDeltaMovement().add(0.0D, 0.005D, 0.0D));
+                }
+            }
+        };
+        this.moveControl = new DolphinMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur end - Ridables
         this.lookControl = new SmoothSwimmingLookControl(this, 10);
         this.setCanPickUpLoot(true);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.dolphinRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.dolphinControllable;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (spitCooldown == 0 && getRider() != null) {
+            spitCooldown = level().purpurConfig.dolphinSpitCooldown;
+
+            org.bukkit.craftbukkit.entity.CraftPlayer player = (org.bukkit.craftbukkit.entity.CraftPlayer) getRider().getBukkitEntity();
+            if (!player.hasPermission("allow.special.dolphin")) {
+                return false;
+            }
+
+            org.bukkit.Location loc = player.getEyeLocation();
+            loc.setPitch(loc.getPitch() - 10);
+            org.bukkit.util.Vector target = loc.getDirection().normalize().multiply(10).add(loc.toVector());
+
+            org.purpurmc.purpur.entity.projectile.DolphinSpit spit = new org.purpurmc.purpur.entity.projectile.DolphinSpit(level(), this);
+            spit.shoot(target.getX() - getX(), target.getY() - getY(), target.getZ() - getZ(), level().purpurConfig.dolphinSpitSpeed, 5.0F);
+
+            level().addFreshEntity(spit);
+            playSound(SoundEvents.DOLPHIN_ATTACK, 1.0F, 1.0F + (random.nextFloat() - random.nextFloat()) * 0.2F);
+            return true;
+        }
+        return false;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.dolphinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.dolphinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.dolphinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.dolphinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public @Nullable SpawnGroupData finalizeSpawn(
         ServerLevelAccessor level, DifficultyInstance difficulty, EntitySpawnReason spawnReason, @Nullable SpawnGroupData spawnGroupData
@@ -90,6 +181,7 @@ public class Dolphin extends AgeableWaterCreature {
         this.setAirSupply(this.getMaxAirSupply());
         this.setXRot(0.0F);
         SpawnGroupData spawnGroupData1 = Objects.requireNonNullElseGet(spawnGroupData, () -> new AgeableMob.AgeableMobGroupData(0.1F));
+        this.isNaturallyAggressiveToPlayers = level.getLevel().purpurConfig.dolphinNaturallyAggressiveToPlayersChance > 0.0D && random.nextDouble() <= level.getLevel().purpurConfig.dolphinNaturallyAggressiveToPlayersChance; // Purpur - Dolphins naturally aggressive to players chance
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData1);
     }
 
@@ -155,17 +247,21 @@ public class Dolphin extends AgeableWaterCreature {
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new BreathAirGoal(this));
         this.goalSelector.addGoal(0, new TryFindWaterGoal(this));
+        this.goalSelector.addGoal(1, new MeleeAttackGoal(this, 1.2000000476837158D, true)); // Purpur - Dolphins naturally aggressive to players chance
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Dolphin.DolphinSwimToTreasureGoal(this));
         this.goalSelector.addGoal(2, new Dolphin.DolphinSwimWithPlayerGoal(this, 4.0));
         this.goalSelector.addGoal(4, new RandomSwimmingGoal(this, 1.0, 10));
         this.goalSelector.addGoal(4, new RandomLookAroundGoal(this));
         this.goalSelector.addGoal(5, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(5, new DolphinJumpGoal(this, 10));
-        this.goalSelector.addGoal(6, new MeleeAttackGoal(this, 1.2F, true));
+        //this.goalSelector.addGoal(6, new MeleeAttackGoal(this, 1.2F, true)); // Purpur - moved up - Dolphins naturally aggressive to players chance
         this.goalSelector.addGoal(8, new Dolphin.PlayWithItemsGoal());
         this.goalSelector.addGoal(8, new FollowBoatGoal(this));
         this.goalSelector.addGoal(9, new AvoidEntityGoal<>(this, Guardian.class, 8.0F, 1.0, 1.0));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Guardian.class).setAlertOthers());
+        this.targetSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (ignored, ignored2) -> isNaturallyAggressiveToPlayers)); // Purpur - Dolphins naturally aggressive to players chance
     }
 
     public static AttributeSupplier.Builder createAttributes() {
@@ -209,7 +305,7 @@ public class Dolphin extends AgeableWaterCreature {
 
     @Override
     protected boolean canRide(Entity entity) {
-        return true;
+        return boardingCooldown <= 0; // Purpur - make dolphin honor ride cooldown like all other non-boss mobs;
     }
 
     @Override
@@ -238,6 +334,11 @@ public class Dolphin extends AgeableWaterCreature {
     @Override
     public void tick() {
         super.tick();
+        // Purpur start - Ridables
+        if (spitCooldown > 0) {
+            spitCooldown--;
+        }
+        // Purpur end - Ridables
         if (this.isNoAi()) {
             this.setAirSupply(this.getMaxAirSupply());
         } else {
@@ -392,6 +493,7 @@ public class Dolphin extends AgeableWaterCreature {
 
         @Override
         public boolean canUse() {
+            if (this.dolphin.level().purpurConfig.dolphinDisableTreasureSearching) return false; // Purpur - Add option to disable dolphin treasure searching
             return this.dolphin.gotFish() && this.dolphin.getAirSupply() >= 100;
         }
 
diff --git a/net/minecraft/world/entity/animal/equine/AbstractHorse.java b/net/minecraft/world/entity/animal/equine/AbstractHorse.java
index e837c63631c637238b9fe0ba05984af5e0d2b833..5bd1e0f20a9553ae20db1d72d0b2a88bd92db723 100644
--- a/net/minecraft/world/entity/animal/equine/AbstractHorse.java
+++ b/net/minecraft/world/entity/animal/equine/AbstractHorse.java
@@ -128,11 +128,61 @@ public abstract class AbstractHorse extends Animal implements HasCustomInventory
 
     protected AbstractHorse(EntityType<? extends AbstractHorse> type, Level level) {
         super(type, level);
+        this.moveControl = new net.minecraft.world.entity.ai.control.MoveControl(this); // Purpur - use vanilla controller
+        this.lookControl = new net.minecraft.world.entity.ai.control.LookControl(this); // Purpur - use vanilla controller
         this.createInventory();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return false; // vanilla handles
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.generateMaxHealth(random));
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.generateSpeed(random));
+        this.getAttribute(Attributes.JUMP_STRENGTH).setBaseValue(this.generateJumpStrength(random));
+    }
+
+    protected double generateMaxHealth(double min, double max) {
+        if (min == max) return min;
+        int diff = Mth.floor(max - min);
+        double base = max - diff;
+        int first = Mth.floor((double) diff / 2);
+        int rest = diff - first;
+        return base + random.nextInt(first + 1) + random.nextInt(rest + 1);
+    }
+
+    protected double generateJumpStrength(double min, double max) {
+        if (min == max) return min;
+        return min + (max - min) * this.random.nextDouble();
+    }
+
+    protected double generateSpeed(double min, double max) {
+        if (min == max) return min;
+        return min + (max - min) * this.random.nextDouble();
+    }
+
+    protected float generateMaxHealth(RandomSource random) {
+        return 15.0F + (float) random.nextInt(8) + (float) random.nextInt(9);
+    }
+
+    protected double generateJumpStrength(RandomSource random) {
+        return 0.4F + random.nextDouble() * 0.2 + random.nextDouble() * 0.2 + random.nextDouble() * 0.2;
+    }
+
+    protected double generateSpeed(RandomSource random) {
+        return (0.45F + random.nextDouble() * 0.3 + random.nextDouble() * 0.3 + random.nextDouble() * 0.3) * 0.25;
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HorseHasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new AbstractHorse.MountPanicGoal(1.2));
         this.goalSelector.addGoal(1, new RunAroundLikeCrazyGoal(this, 1.2));
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0, AbstractHorse.class));
@@ -143,6 +193,7 @@ public abstract class AbstractHorse extends Animal implements HasCustomInventory
         if (this.canPerformRearing()) {
             this.goalSelector.addGoal(9, new RandomStandGoal(this));
         }
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HorseHasRider(this)); // Purpur - Ridables
 
         this.addBehaviourGoals();
     }
@@ -1039,7 +1090,7 @@ public abstract class AbstractHorse extends Animal implements HasCustomInventory
             spawnGroupData = new AgeableMob.AgeableMobGroupData(0.2F);
         }
 
-        this.randomizeAttributes(level.getRandom());
+        //this.randomizeAttributes(level.getRandom()); // Purpur - replaced by initAttributes()
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
diff --git a/net/minecraft/world/entity/animal/equine/Donkey.java b/net/minecraft/world/entity/animal/equine/Donkey.java
index 55844fe13c403a55d135ec4ff4731d88601b205e..ca02355276286a88d618467d9191d648a3cf7b12 100644
--- a/net/minecraft/world/entity/animal/equine/Donkey.java
+++ b/net/minecraft/world/entity/animal/equine/Donkey.java
@@ -16,6 +16,51 @@ public class Donkey extends AbstractChestedHorse {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.donkeyRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.donkeyMaxHealthMin, this.level().purpurConfig.donkeyMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.donkeyJumpStrengthMin, this.level().purpurConfig.donkeyJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.donkeyMovementSpeedMin, this.level().purpurConfig.donkeyMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.donkeyBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.donkeyTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.donkeyAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public SoundEvent getAmbientSound() {
         return SoundEvents.DONKEY_AMBIENT;
diff --git a/net/minecraft/world/entity/animal/equine/Horse.java b/net/minecraft/world/entity/animal/equine/Horse.java
index 1763543942a25a788c0f90241db75ddad70a7da8..bb7ae0bc176fc873b0e1c760b62c5c4e0ee05ae8 100644
--- a/net/minecraft/world/entity/animal/equine/Horse.java
+++ b/net/minecraft/world/entity/animal/equine/Horse.java
@@ -50,6 +50,51 @@ public class Horse extends AbstractHorse {
         this.setPathfindingMalus(PathType.DAMAGE_OTHER, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.horseRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.horseMaxHealthMin, this.level().purpurConfig.horseMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.horseJumpStrengthMin, this.level().purpurConfig.horseJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.horseMovementSpeedMin, this.level().purpurConfig.horseMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.horseBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.horseTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.horseAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void randomizeAttributes(RandomSource random) {
         this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(generateMaxHealth(random::nextInt));
diff --git a/net/minecraft/world/entity/animal/equine/Llama.java b/net/minecraft/world/entity/animal/equine/Llama.java
index 1522efc1e6937bc8a24a2df77d5421ae04a6642b..eef4b602bd03df53823da6f576246c330e46d0d4 100644
--- a/net/minecraft/world/entity/animal/equine/Llama.java
+++ b/net/minecraft/world/entity/animal/equine/Llama.java
@@ -76,12 +76,102 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
     boolean didSpit;
     private @Nullable Llama caravanHead;
     public @Nullable Llama caravanTail; // Paper - public
+    public boolean shouldJoinCaravan = true; // Purpur - Llama API
 
     public Llama(EntityType<? extends Llama> type, Level level) {
         super(type, level);
         this.getNavigation().setRequiredPathLength(40.0F);
         this.maxDomestication = 30; // Paper - Missing entity API; configure max temper instead of a hardcoded value
+        // Purpur start - Ridables
+        this.moveControl = new org.purpurmc.purpur.controller.MoveControllerWASD(this) {
+            @Override
+            public void tick() {
+                if (entity.getRider() != null && entity.isControllable() && isSaddled()) {
+                    purpurTick(entity.getRider());
+                } else {
+                    vanillaTick();
+                }
+            }
+        };
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this) {
+            @Override
+            public void tick() {
+                if (entity.getRider() != null && entity.isControllable() && isSaddled()) {
+                    purpurTick(entity.getRider());
+                } else {
+                    vanillaTick();
+                }
+            }
+        };
+        // Purpur end - Ridables
+    }
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.llamaRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.llamaRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.llamaControllable;
+    }
+
+    @Override
+    public boolean isSaddled() {
+        return super.isWearingBodyArmor() || this.isTamed();
+    }
+
+    @Nullable
+    @Override
+    public LivingEntity getControllingPassenger() {
+        Entity firstPassenger = this.getFirstPassenger();
+        return !this.isNoAi() && firstPassenger instanceof net.minecraft.world.entity.Mob mob && firstPassenger.canControlVehicle() ? mob : null;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.llamaMaxHealthMin, this.level().purpurConfig.llamaMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.llamaJumpStrengthMin, this.level().purpurConfig.llamaJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.llamaMovementSpeedMin, this.level().purpurConfig.llamaMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.llamaBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.llamaTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.llamaAlwaysDropExp;
     }
+    // Purpur end - Mobs always drop experience
 
     public boolean isTraderLlama() {
         return false;
@@ -105,6 +195,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
         super.addAdditionalSaveData(output);
         output.store("Variant", Llama.Variant.LEGACY_CODEC, this.getVariant());
         output.putInt("Strength", this.getStrength());
+        output.putBoolean("Purpur.ShouldJoinCaravan", shouldJoinCaravan); // Purpur - Llama API
     }
 
     @Override
@@ -112,11 +203,13 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
         this.setStrength(input.getIntOr("Strength", 0));
         super.readAdditionalSaveData(input);
         this.setVariant(input.read("Variant", Llama.Variant.LEGACY_CODEC).orElse(Llama.Variant.DEFAULT));
+        this.shouldJoinCaravan = input.getBooleanOr("Purpur.ShouldJoinCaravan", true); // Purpur - Llama API
     }
 
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.LlamaHasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new RunAroundLikeCrazyGoal(this, 1.2));
         this.goalSelector.addGoal(2, new LlamaFollowCaravanGoal(this, 2.1F));
         this.goalSelector.addGoal(3, new RangedAttackGoal(this, 1.25, 40, 20.0F));
@@ -127,6 +220,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 0.7));
         this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(9, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.LlamaHasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Llama.LlamaHurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new Llama.LlamaAttackWolfGoal(this));
     }
@@ -388,6 +482,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
 
     public void leaveCaravan() {
         if (this.caravanHead != null) {
+            new org.purpurmc.purpur.event.entity.LlamaLeaveCaravanEvent((org.bukkit.entity.Llama) getBukkitEntity()).callEvent(); // Purpur - Llama API
             this.caravanHead.caravanTail = null;
         }
 
@@ -395,6 +490,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
     }
 
     public void joinCaravan(Llama caravanHead) {
+        if (!this.level().purpurConfig.llamaJoinCaravans || !shouldJoinCaravan || !new org.purpurmc.purpur.event.entity.LlamaJoinCaravanEvent((org.bukkit.entity.Llama) getBukkitEntity(), (org.bukkit.entity.Llama) caravanHead.getBukkitEntity()).callEvent()) return; // Purpur - Llama API // Purpur - Config to disable Llama caravans
         this.caravanHead = caravanHead;
         this.caravanHead.caravanTail = this;
     }
diff --git a/net/minecraft/world/entity/animal/equine/Mule.java b/net/minecraft/world/entity/animal/equine/Mule.java
index b5444b88d30e7d375495bdbbe1469beb72beb87a..8514c0b7657366a1c40217b950c74c95631c328a 100644
--- a/net/minecraft/world/entity/animal/equine/Mule.java
+++ b/net/minecraft/world/entity/animal/equine/Mule.java
@@ -15,6 +15,51 @@ public class Mule extends AbstractChestedHorse {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.muleRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.muleMaxHealthMin, this.level().purpurConfig.muleMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.muleJumpStrengthMin, this.level().purpurConfig.muleJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.muleMovementSpeedMin, this.level().purpurConfig.muleMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.muleBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.muleTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.muleAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public SoundEvent getAmbientSound() {
         return SoundEvents.MULE_AMBIENT;
diff --git a/net/minecraft/world/entity/animal/equine/SkeletonHorse.java b/net/minecraft/world/entity/animal/equine/SkeletonHorse.java
index 0afb4c836e697f820696bd760cca761520bc8250..2502716b8efe4584fba9d9f9989ba9cba67568bc 100644
--- a/net/minecraft/world/entity/animal/equine/SkeletonHorse.java
+++ b/net/minecraft/world/entity/animal/equine/SkeletonHorse.java
@@ -43,6 +43,51 @@ public class SkeletonHorse extends AbstractHorse {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isTamed() {
+        return super.isTamed() || this.level().purpurConfig.skeletonHorseRidable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.skeletonHorseMaxHealthMin, this.level().purpurConfig.skeletonHorseMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.skeletonHorseJumpStrengthMin, this.level().purpurConfig.skeletonHorseJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.skeletonHorseMovementSpeedMin, this.level().purpurConfig.skeletonHorseMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.skeletonHorseTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.skeletonHorseAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return createBaseHorseAttributes().add(Attributes.MAX_HEALTH, 15.0).add(Attributes.MOVEMENT_SPEED, 0.2F);
     }
@@ -62,6 +107,7 @@ public class SkeletonHorse extends AbstractHorse {
 
     @Override
     protected void addBehaviourGoals() {
+        if (level().purpurConfig.skeletonHorseCanSwim) goalSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.FloatGoal(this)); // Purpur - Ridables
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/equine/TraderLlama.java b/net/minecraft/world/entity/animal/equine/TraderLlama.java
index 44f85dc4075e9fc000dc89ba01e2039c01989dde..0515d1071324d82c14be4b9e97c8a583dd45a721 100644
--- a/net/minecraft/world/entity/animal/equine/TraderLlama.java
+++ b/net/minecraft/world/entity/animal/equine/TraderLlama.java
@@ -31,6 +31,66 @@ public class TraderLlama extends Llama {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.traderLlamaRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.traderLlamaRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.traderLlamaControllable;
+    }
+
+    @Override
+    public boolean isSaddled() {
+        return super.isSaddled() || isTamed();
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.traderLlamaMaxHealthMin, this.level().purpurConfig.traderLlamaMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.traderLlamaJumpStrengthMin, this.level().purpurConfig.traderLlamaJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.traderLlamaMovementSpeedMin, this.level().purpurConfig.traderLlamaMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.traderLlamaBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.traderLlamaTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.traderLlamaAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isTraderLlama() {
         return true;
diff --git a/net/minecraft/world/entity/animal/equine/ZombieHorse.java b/net/minecraft/world/entity/animal/equine/ZombieHorse.java
index 4cfae7e877c6545780a8b9fdb3e326edb8cc7943..5b671d468698444569b1d97437d746d49c0db757 100644
--- a/net/minecraft/world/entity/animal/equine/ZombieHorse.java
+++ b/net/minecraft/world/entity/animal/equine/ZombieHorse.java
@@ -52,6 +52,56 @@ public class ZombieHorse extends AbstractHorse {
         this.setPathfindingMalus(PathType.DAMAGE_OTHER, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombieHorseRidableInWater;
+    }
+
+    @Override
+    public boolean isTamed() {
+        return super.isTamed() || this.level().purpurConfig.zombieHorseRidable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.zombieHorseMaxHealthMin, this.level().purpurConfig.zombieHorseMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.zombieHorseJumpStrengthMin, this.level().purpurConfig.zombieHorseJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.zombieHorseMovementSpeedMin, this.level().purpurConfig.zombieHorseMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombieHorseTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombieHorseAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return createBaseHorseAttributes().add(Attributes.MAX_HEALTH, 25.0);
     }
diff --git a/net/minecraft/world/entity/animal/feline/Cat.java b/net/minecraft/world/entity/animal/feline/Cat.java
index f17d7a4ef7061d6ede9a755b5a77324a28c3eeaa..4422cc2f0ed1b603348f3f5c0d6650f871190ffd 100644
--- a/net/minecraft/world/entity/animal/feline/Cat.java
+++ b/net/minecraft/world/entity/animal/feline/Cat.java
@@ -95,10 +95,65 @@ public class Cat extends TamableAnimal {
         this.reassessTameGoals();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.catRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.catRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.catControllable;
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setInSittingPose(false);
+        setLying(false);
+        setRelaxStateOne(false);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.catMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.catScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.catBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.catTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.catAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.temptGoal = new Cat.CatTemptGoal(this, 0.6, stack -> stack.is(ItemTags.CAT_FOOD), true);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new TamableAnimal.TamableAnimalPanicGoal(1.5));
         this.goalSelector.addGoal(2, new SitWhenOrderedToGoal(this));
         this.goalSelector.addGoal(3, new Cat.CatRelaxOnOwnerGoal(this));
@@ -111,6 +166,7 @@ public class Cat extends TamableAnimal {
         this.goalSelector.addGoal(10, new BreedGoal(this, 0.8));
         this.goalSelector.addGoal(11, new WaterAvoidingRandomStrollGoal(this, 0.8, 1.0000001E-5F));
         this.goalSelector.addGoal(12, new LookAtPlayerGoal(this, Player.class, 10.0F));
+        this.targetSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NonTameRandomTargetGoal<>(this, Rabbit.class, false, null));
         this.targetSelector.addGoal(1, new NonTameRandomTargetGoal<>(this, Turtle.class, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
@@ -354,6 +410,14 @@ public class Cat extends TamableAnimal {
         return this.isTame() && otherAnimal instanceof Cat cat && cat.isTame() && super.canMate(otherAnimal);
     }
 
+    // Purpur start - Configurable default collar color
+    @Override
+    public void tame(Player player) {
+        setCollarColor(level().purpurConfig.catDefaultCollarColor);
+        super.tame(player);
+    }
+    // Purpur end - Configurable default collar color
+
     @Override
     public @Nullable SpawnGroupData finalizeSpawn(
         ServerLevelAccessor level, DifficultyInstance difficulty, EntitySpawnReason spawnReason, @Nullable SpawnGroupData spawnGroupData
@@ -365,6 +429,7 @@ public class Cat extends TamableAnimal {
 
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
+        if (getRider() != null) return InteractionResult.PASS; // Purpur - Ridables
         ItemStack itemInHand = player.getItemInHand(hand);
         Item item = itemInHand.getItem();
         if (this.isTame()) {
@@ -451,7 +516,7 @@ public class Cat extends TamableAnimal {
     }
 
     private void tryToTame(Player player) {
-        if (this.random.nextInt(3) == 0 && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit
+        if (((this.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || this.random.nextInt(3) == 0) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit // Purpur - Config to always tame in Creative
             this.tame(player);
             this.setOrderedToSit(true);
             this.level().broadcastEntityEvent(this, EntityEvent.TAMING_SUCCEEDED);
diff --git a/net/minecraft/world/entity/animal/feline/Ocelot.java b/net/minecraft/world/entity/animal/feline/Ocelot.java
index cf940de8767df6d07551d7a221a0e87df4e41785..8583fefcb37dc043293bf622b5a25adbbcc8128e 100644
--- a/net/minecraft/world/entity/animal/feline/Ocelot.java
+++ b/net/minecraft/world/entity/animal/feline/Ocelot.java
@@ -66,6 +66,52 @@ public class Ocelot extends Animal {
         this.reassessTrustingGoals();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ocelotRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ocelotRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ocelotControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ocelotMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ocelotScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.ocelotBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ocelotTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ocelotAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public boolean isTrusting() {
         return this.entityData.get(DATA_TRUSTING);
     }
@@ -97,12 +143,14 @@ public class Ocelot extends Animal {
     protected void registerGoals() {
         this.temptGoal = new Ocelot.OcelotTemptGoal(this, 0.6, itemStack -> itemStack.is(ItemTags.OCELOT_FOOD), true);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(3, this.temptGoal);
         this.goalSelector.addGoal(7, new LeapAtTargetGoal(this, 0.3F));
         this.goalSelector.addGoal(8, new OcelotAttackGoal(this));
         this.goalSelector.addGoal(9, new BreedGoal(this, 0.8));
         this.goalSelector.addGoal(10, new WaterAvoidingRandomStrollGoal(this, 0.8, 1.0000001E-5F));
         this.goalSelector.addGoal(11, new LookAtPlayerGoal(this, Player.class, 10.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Chicken.class, false));
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, false, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
@@ -234,7 +282,7 @@ public class Ocelot extends Animal {
     public boolean checkSpawnObstruction(LevelReader level) {
         if (level.isUnobstructed(this) && !level.containsAnyLiquid(this.getBoundingBox())) {
             BlockPos blockPos = this.blockPosition();
-            if (blockPos.getY() < level.getSeaLevel()) {
+            if (!level().purpurConfig.ocelotSpawnUnderSeaLevel && blockPos.getY() < level.getSeaLevel()) { // Purpur - Option Ocelot Spawn Under Sea Level
                 return false;
             }
 
diff --git a/net/minecraft/world/entity/animal/fish/AbstractFish.java b/net/minecraft/world/entity/animal/fish/AbstractFish.java
index 7b4215058325812e8dc785277d1ece0fd5dd6ea3..970904ce07ebc6aabc97166284cbb855d2976f09 100644
--- a/net/minecraft/world/entity/animal/fish/AbstractFish.java
+++ b/net/minecraft/world/entity/animal/fish/AbstractFish.java
@@ -91,6 +91,7 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
     @Override
     protected void registerGoals() {
         super.registerGoals();
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new PanicGoal(this, 1.25));
         this.goalSelector.addGoal(2, new AvoidEntityGoal<>(this, Player.class, 8.0F, 1.6, 1.4, EntitySelector.NO_SPECTATORS));
         this.goalSelector.addGoal(4, new AbstractFish.FishSwimGoal(this));
@@ -103,7 +104,7 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
 
     @Override
     protected void travelInWater(Vec3 travelVector, double gravity, boolean isFalling, double previousY) {
-        this.moveRelative(0.01F, travelVector);
+        this.moveRelative(getRider() != null ? getSpeed() : 0.01F, travelVector); // Purpur - Ridables
         this.move(MoverType.SELF, this.getDeltaMovement());
         this.setDeltaMovement(this.getDeltaMovement().scale(0.9));
         if (this.getTarget() == null) {
@@ -160,7 +161,7 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
     protected void playStepSound(BlockPos pos, BlockState block) {
     }
 
-    static class FishMoveControl extends MoveControl {
+    static class FishMoveControl extends org.purpurmc.purpur.controller.WaterMoveControllerWASD { // Purpur - Ridables
         private final AbstractFish fish;
 
         FishMoveControl(AbstractFish mob) {
@@ -168,14 +169,22 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
             this.fish = mob;
         }
 
+        // Purpur start - Ridables
         @Override
-        public void tick() {
+        public void purpurTick(Player rider) {
+            super.purpurTick(rider);
+            fish.setDeltaMovement(fish.getDeltaMovement().add(0.0D, 0.005D, 0.0D));
+        }
+        // Purpur end - Ridables
+
+        @Override
+        public void vanillaTick() { // Purpur - Ridables
             if (this.fish.isEyeInFluid(FluidTags.WATER)) {
                 this.fish.setDeltaMovement(this.fish.getDeltaMovement().add(0.0, 0.005, 0.0));
             }
 
             if (this.operation == MoveControl.Operation.MOVE_TO && !this.fish.getNavigation().isDone()) {
-                float f = (float)(this.speedModifier * this.fish.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                float f = (float)(this.getSpeedModifier() * this.fish.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                 this.fish.setSpeed(Mth.lerp(0.125F, this.fish.getSpeed(), f));
                 double d = this.wantedX - this.fish.getX();
                 double d1 = this.wantedY - this.fish.getY();
diff --git a/net/minecraft/world/entity/animal/fish/Cod.java b/net/minecraft/world/entity/animal/fish/Cod.java
index 9a473f29931059e36a6fe8fa541c4706ababf59d..05de579a16726454034dc4a913161676b5c73552 100644
--- a/net/minecraft/world/entity/animal/fish/Cod.java
+++ b/net/minecraft/world/entity/animal/fish/Cod.java
@@ -13,6 +13,39 @@ public class Cod extends AbstractSchoolingFish {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.codRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.codControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.codMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.codTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.codAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public ItemStack getBucketItemStack() {
         return new ItemStack(Items.COD_BUCKET);
diff --git a/net/minecraft/world/entity/animal/fish/Pufferfish.java b/net/minecraft/world/entity/animal/fish/Pufferfish.java
index 3acbe72a1c72c83b33671eb15ac76fc7a6135998..681eb25e45cec76f21cea9f77efe71290bdb547a 100644
--- a/net/minecraft/world/entity/animal/fish/Pufferfish.java
+++ b/net/minecraft/world/entity/animal/fish/Pufferfish.java
@@ -47,6 +47,39 @@ public class Pufferfish extends AbstractFish {
         this.refreshDimensions();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pufferfishRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pufferfishControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pufferfishMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pufferfishTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pufferfishAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
diff --git a/net/minecraft/world/entity/animal/fish/Salmon.java b/net/minecraft/world/entity/animal/fish/Salmon.java
index c691912a8b109e7430ffb39bb832983cbf33fc8a..b76b2c1e7ac93fe01bdf9ee6e3c811f448babcbb 100644
--- a/net/minecraft/world/entity/animal/fish/Salmon.java
+++ b/net/minecraft/world/entity/animal/fish/Salmon.java
@@ -40,6 +40,39 @@ public class Salmon extends AbstractSchoolingFish {
         this.refreshDimensions();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.salmonRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.salmonControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.salmonMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.salmonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.salmonAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public int getMaxSchoolSize() {
         return 5;
diff --git a/net/minecraft/world/entity/animal/fish/TropicalFish.java b/net/minecraft/world/entity/animal/fish/TropicalFish.java
index e3961892ffc05bef4947bda75445ca5e255dce11..c7742f06cf2bed3496c28b541e45948e609c1999 100644
--- a/net/minecraft/world/entity/animal/fish/TropicalFish.java
+++ b/net/minecraft/world/entity/animal/fish/TropicalFish.java
@@ -77,6 +77,39 @@ public class TropicalFish extends AbstractSchoolingFish {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.tropicalFishRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.tropicalFishControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.tropicalFishMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.tropicalFishTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.tropicalFishAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static String getPredefinedName(int variantId) {
         return "entity.minecraft.tropical_fish.predefined." + variantId;
     }
diff --git a/net/minecraft/world/entity/animal/fox/Fox.java b/net/minecraft/world/entity/animal/fox/Fox.java
index 6fb314b49b7a482d4092d5a63c06abab69845c85..98937a998f55ee462421a7477cc3e2fbf4e75ba3 100644
--- a/net/minecraft/world/entity/animal/fox/Fox.java
+++ b/net/minecraft/world/entity/animal/fox/Fox.java
@@ -151,6 +151,73 @@ public class Fox extends Animal {
         this.getNavigation().setRequiredPathLength(32.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.foxRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.foxRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.foxControllable;
+    }
+
+    @Override
+    public float getJumpPower() {
+        return getRider() != null && this.isControllable() ? 0.5F : super.getJumpPower();
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setCanPickUpLoot(false);
+        clearStates();
+        setIsPouncing(false);
+        spitOutItem(getItemBySlot(EquipmentSlot.MAINHAND));
+        setItemSlot(EquipmentSlot.MAINHAND, ItemStack.EMPTY);
+    }
+
+    @Override
+    public void onDismount(Player rider) {
+        super.onDismount(rider);
+        setCanPickUpLoot(true);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.foxMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.foxScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.foxBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.foxTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.foxAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -170,6 +237,7 @@ public class Fox extends Animal {
             this, AbstractFish.class, 20, false, false, (entity, level) -> entity instanceof AbstractSchoolingFish
         );
         this.goalSelector.addGoal(0, new Fox.FoxFloatGoal());
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(1, new Fox.FaceplantGoal());
         this.goalSelector.addGoal(2, new Fox.FoxPanicGoal(2.2));
@@ -195,6 +263,7 @@ public class Fox extends Animal {
         this.goalSelector.addGoal(11, new Fox.FoxSearchForItemsGoal());
         this.goalSelector.addGoal(12, new Fox.FoxLookAtPlayerGoal(this, Player.class, 24.0F));
         this.goalSelector.addGoal(13, new Fox.PerchAndSearchGoal());
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector
             .addGoal(
                 3,
@@ -357,6 +426,11 @@ public class Fox extends Animal {
     }
 
     private void setTargetGoals() {
+        // Purpur start - Tulips change fox type - do not add duplicate goals
+        this.targetSelector.removeGoal(this.landTargetGoal);
+        this.targetSelector.removeGoal(this.turtleEggTargetGoal);
+        this.targetSelector.removeGoal(this.fishTargetGoal);
+        // Purpur end - Tulips change fox type
         if (this.getVariant() == Fox.Variant.RED) {
             this.targetSelector.addGoal(4, this.landTargetGoal);
             this.targetSelector.addGoal(4, this.turtleEggTargetGoal);
@@ -384,6 +458,7 @@ public class Fox extends Animal {
 
     public void setVariant(Fox.Variant variant) {
         this.entityData.set(DATA_TYPE_ID, variant.getId());
+        this.setTargetGoals(); // Purpur - Tulips change fox type - fix API bug not updating pathfinders on type change
     }
 
     @Override
@@ -710,6 +785,36 @@ public class Fox extends Animal {
     }
     // Paper end
 
+    // Purpur start - Tulips change fox type
+    @Override
+    public net.minecraft.world.InteractionResult mobInteract(Player player, net.minecraft.world.InteractionHand hand) {
+        if (level().purpurConfig.foxTypeChangesWithTulips) {
+            ItemStack itemstack = player.getItemInHand(hand);
+            if (getVariant() == Variant.RED && itemstack.getItem() == Items.WHITE_TULIP) {
+                setVariant(Variant.SNOW);
+                if (!player.getAbilities().instabuild) {
+                    itemstack.shrink(1);
+                }
+                return net.minecraft.world.InteractionResult.SUCCESS;
+            } else if (getVariant() == Variant.SNOW && itemstack.getItem() == Items.ORANGE_TULIP) {
+                setVariant(Variant.RED);
+                if (!player.getAbilities().instabuild) {
+                    itemstack.shrink(1);
+                }
+                return net.minecraft.world.InteractionResult.SUCCESS;
+            }
+        }
+        return super.mobInteract(player, hand);
+    }
+    // Purpur end - Tulips change fox type
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.foxCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     // Paper start - Cancellable death event
     protected org.bukkit.event.entity.EntityDeathEvent dropAllDeathLoot(ServerLevel level, DamageSource damageSource) {
@@ -920,8 +1025,10 @@ public class Fox extends Animal {
                     CriteriaTriggers.BRED_ANIMALS.trigger(serverPlayer, this.animal, this.partner, fox);
                 }
 
-                this.animal.setAge(6000);
-                this.partner.setAge(6000);
+                // Purpur start - Make entity breeding times configurable
+                this.animal.setAge(this.animal.getPurpurBreedTime());
+                this.partner.setAge(this.partner.getPurpurBreedTime());
+                // Purpur end - Make entity breeding times configurable
                 this.animal.resetLove();
                 this.partner.resetLove();
                 this.level.addFreshEntityWithPassengers(fox, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BREEDING); // CraftBukkit - added SpawnReason
@@ -976,7 +1083,7 @@ public class Fox extends Animal {
         }
 
         protected void onReachedTarget() {
-            if (getServerLevel(Fox.this.level()).getGameRules().get(GameRules.MOB_GRIEFING)) {
+            if (getServerLevel(Fox.this.level()).getGameRules().get(GameRules.MOB_GRIEFING, getServerLevel(Fox.this.level()).purpurConfig.foxMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                 BlockState blockState = Fox.this.level().getBlockState(this.blockPos);
                 if (blockState.is(Blocks.SWEET_BERRY_BUSH)) {
                     this.pickSweetBerries(blockState);
@@ -1090,15 +1197,15 @@ public class Fox extends Animal {
         }
     }
 
-    public class FoxLookControl extends LookControl {
+    public class FoxLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         public FoxLookControl() {
             super(Fox.this);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (!Fox.this.isSleeping()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
 
@@ -1134,15 +1241,15 @@ public class Fox extends Animal {
         }
     }
 
-    class FoxMoveControl extends MoveControl {
+    class FoxMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         public FoxMoveControl() {
             super(Fox.this);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Fox.this.canMove()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/animal/frog/Frog.java b/net/minecraft/world/entity/animal/frog/Frog.java
index 09d817aa34d4a6d8a49d614087f9942d75e673e8..7d6dbdef68b25e774b5a83bb8aeb2535246459aa 100644
--- a/net/minecraft/world/entity/animal/frog/Frog.java
+++ b/net/minecraft/world/entity/animal/frog/Frog.java
@@ -105,6 +105,8 @@ public class Frog extends Animal {
     public final AnimationState croakAnimationState = new AnimationState();
     public final AnimationState tongueAnimationState = new AnimationState();
     public final AnimationState swimIdleAnimationState = new AnimationState();
+    private org.purpurmc.purpur.controller.MoveControllerWASD purpurLandController; // Purpur - Ridables
+    private org.purpurmc.purpur.controller.WaterMoveControllerWASD purpurWaterController; // Purpur - Ridables
 
     public Frog(EntityType<? extends Animal> type, Level level) {
         super(type, level);
@@ -112,7 +114,62 @@ public class Frog extends Animal {
         this.setPathfindingMalus(PathType.WATER, 4.0F);
         this.setPathfindingMalus(PathType.TRAPDOOR, -1.0F);
         this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur start - Ridables
+        this.purpurLandController = new org.purpurmc.purpur.controller.MoveControllerWASD(this, 0.2F);
+        this.purpurWaterController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(this, 0.5F);
+        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true) {
+            @Override
+            public void tick() {
+                net.minecraft.world.entity.player.Player rider = mob.getRider();
+                if (rider != null && mob.isControllable()) {
+                    if (mob.isInWater()) {
+                        purpurWaterController.purpurTick(rider);
+                        mob.setDeltaMovement(mob.getDeltaMovement().add(0.0D, -0.005D, 0.0D));
+                    } else {
+                        purpurLandController.purpurTick(rider);
+                    }
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
+    }
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.frogRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.frogRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.frogControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+
+    @Override
+    public float getJumpPower() {
+        return (getRider() != null && isControllable()) ? level().purpurConfig.frogRidableJumpHeight * this.getBlockJumpFactor() : super.getJumpPower();
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.frogBreedingTicks;
     }
+    // Purpur end - Make entity breeding times configurable
 
     @Override
     protected Brain.Provider<Frog> brainProvider() {
@@ -204,6 +261,7 @@ public class Frog extends Animal {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("frogBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("frogActivityUpdate");
@@ -373,7 +431,7 @@ public class Frog extends Animal {
         return level.getBlockState(pos.below()).is(BlockTags.FROGS_SPAWNABLE_ON) && isBrightEnoughToSpawn(level, pos);
     }
 
-    class FrogLookControl extends LookControl {
+    class FrogLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         FrogLookControl(final Mob mob) {
             super(mob);
         }
diff --git a/net/minecraft/world/entity/animal/frog/Tadpole.java b/net/minecraft/world/entity/animal/frog/Tadpole.java
index f65cfb908aac16e6df4d209c6b5c3ee5065289d3..9b5205d7f481d4cd8fe454ae588dc2a89bc613bf 100644
--- a/net/minecraft/world/entity/animal/frog/Tadpole.java
+++ b/net/minecraft/world/entity/animal/frog/Tadpole.java
@@ -65,13 +65,50 @@ public class Tadpole extends AbstractFish {
         MemoryModuleType.IS_PANICKING
     );
     public boolean ageLocked; // Paper
+    private org.purpurmc.purpur.controller.WaterMoveControllerWASD purpurController; // Purpur - Ridables
 
     public Tadpole(EntityType<? extends AbstractFish> type, Level level) {
         super(type, level);
-        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur start - Ridables
+        this.purpurController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(this, 0.5F);
+        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true) {
+            @Override
+            public void tick() {
+                Player rider = mob.getRider();
+                if (rider != null && mob.isControllable()) {
+                    purpurController.purpurTick(rider);
+                    mob.setDeltaMovement(mob.getDeltaMovement().add(0.0D, 0.002D, 0.0D));
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
         this.lookControl = new SmoothSwimmingLookControl(this, 10);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.tadpoleRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.tadpoleRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.tadpoleControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
     @Override
     protected PathNavigation createNavigation(Level level) {
         return new WaterBoundPathNavigation(this, level);
@@ -101,6 +138,7 @@ public class Tadpole extends AbstractFish {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("tadpoleBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("tadpoleActivityUpdate");
diff --git a/net/minecraft/world/entity/animal/goat/Goat.java b/net/minecraft/world/entity/animal/goat/Goat.java
index 9f41c1ff3e75cf9164dee0853aeef4bfc473126b..64916356de4b9981e04c5befef15b067914f6d75 100644
--- a/net/minecraft/world/entity/animal/goat/Goat.java
+++ b/net/minecraft/world/entity/animal/goat/Goat.java
@@ -115,6 +115,44 @@ public class Goat extends Animal {
             .orElseGet(() -> new ItemStack(Items.GOAT_HORN));
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.goatRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.goatRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.goatControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.goatBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.goatTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.goatAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected Brain.Provider<Goat> brainProvider() {
         return Brain.provider(MEMORY_TYPES, SENSOR_TYPES);
@@ -191,6 +229,7 @@ public class Goat extends Animal {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("goatBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("goatActivityUpdate");
@@ -389,6 +428,7 @@ public class Goat extends Animal {
 
     // Paper start - Goat ram API
     public void ram(net.minecraft.world.entity.LivingEntity entity) {
+        if(!new org.purpurmc.purpur.event.entity.GoatRamEntityEvent((org.bukkit.entity.Goat) getBukkitEntity(), entity.getBukkitLivingEntity()).callEvent()) return; // Purpur - Added goat ram event
         Brain<Goat> brain = this.getBrain();
         brain.setMemory(MemoryModuleType.RAM_TARGET, entity.position());
         brain.eraseMemory(MemoryModuleType.RAM_COOLDOWN_TICKS);
diff --git a/net/minecraft/world/entity/animal/golem/CopperGolem.java b/net/minecraft/world/entity/animal/golem/CopperGolem.java
index f9a6aba1037e41836b69cd5e66195cdc0b1f7725..493d1678592bce78a15adeb4c9435fdc8e9dab8a 100644
--- a/net/minecraft/world/entity/animal/golem/CopperGolem.java
+++ b/net/minecraft/world/entity/animal/golem/CopperGolem.java
@@ -83,6 +83,7 @@ public class CopperGolem extends AbstractGolem implements ContainerUser, Shearab
     private final AnimationState interactionDropItemAnimationState = new AnimationState();
     private final AnimationState interactionDropNoItemAnimationState = new AnimationState();
     public static final EquipmentSlot EQUIPMENT_SLOT_ANTENNA = EquipmentSlot.SADDLE;
+    @Nullable private UUID summoner; // Purpur - Summoner API
 
     public CopperGolem(EntityType<? extends AbstractGolem> type, Level level) {
         super(type, level);
@@ -96,6 +97,63 @@ public class CopperGolem extends AbstractGolem implements ContainerUser, Shearab
         this.getBrain().setMemory(MemoryModuleType.TRANSPORT_ITEMS_COOLDOWN_TICKS, this.getRandom().nextInt(60, 100));
     }
 
+    // Purpur start - Summoner API
+    @Nullable
+    public UUID getSummoner() {
+        return summoner;
+    }
+
+    public void setSummoner(@Nullable UUID summoner) {
+        this.summoner = summoner;
+    }
+    // Purpur end - Summoner API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.copperGolemRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.copperGolemRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.copperGolemControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this));
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.copperGolemMaxHealth);
+        this.getAttribute(Attributes.STEP_HEIGHT).setBaseValue(this.level().purpurConfig.copperGolemStepHeight);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.copperGolemMovementSpeed);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.copperGolemScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.copperGolemTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.copperGolemAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Mob.createMobAttributes().add(Attributes.MOVEMENT_SPEED, 0.2F).add(Attributes.STEP_HEIGHT, 1.0).add(Attributes.MAX_HEALTH, 12.0);
     }
@@ -171,6 +229,7 @@ public class CopperGolem extends AbstractGolem implements ContainerUser, Shearab
         super.addAdditionalSaveData(output);
         output.putLong("next_weather_age", this.nextWeatheringTick);
         output.store("weather_state", WeatheringCopper.WeatherState.CODEC, this.getWeatherState());
+        output.storeNullable("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC, getSummoner()); // Purpur - Summoner API
     }
 
     @Override
@@ -178,12 +237,14 @@ public class CopperGolem extends AbstractGolem implements ContainerUser, Shearab
         super.readAdditionalSaveData(input);
         this.nextWeatheringTick = input.getLongOr("next_weather_age", -1L);
         this.setWeatherState(input.read("weather_state", WeatheringCopper.WeatherState.CODEC).orElse(WeatheringCopper.WeatherState.UNAFFECTED));
+        this.setSummoner(input.read("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC).orElse(null)); // Purpur - Summoner API
     }
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("copperGolemBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("copperGolemActivityUpdate");
@@ -223,7 +284,7 @@ public class CopperGolem extends AbstractGolem implements ContainerUser, Shearab
                 java.util.List<ItemStack> drops = this.generateDefaultDrops(serverLevel, itemInHand);
                 org.bukkit.event.player.PlayerShearEntityEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.handlePlayerShearEntityEvent(player, this, itemInHand, hand, drops);
                 if (event != null) {
-                    if (event.isCancelled()) return InteractionResult.PASS;
+                    if (event.isCancelled()) return tryRide(player, hand); // Purpur - Ridables
                     drops = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getDrops());
                 }
                 this.shear(serverLevel, SoundSource.PLAYERS, itemInHand, drops);
@@ -259,6 +320,8 @@ public class CopperGolem extends AbstractGolem implements ContainerUser, Shearab
                 }
             }
 
+            if (level().purpurConfig.villagerRidable && itemInHand.isEmpty()) return tryRide(player, hand); // Purpur - Ridables
+
             return super.mobInteract(player, hand);
         }
     }
diff --git a/net/minecraft/world/entity/animal/golem/CopperGolemAi.java b/net/minecraft/world/entity/animal/golem/CopperGolemAi.java
index 56872b4674ae4ce0ebcb6c28ae606265384777cd..fd556e10ff87eac5e965a5eef31cfe0c0f8fbd66 100644
--- a/net/minecraft/world/entity/animal/golem/CopperGolemAi.java
+++ b/net/minecraft/world/entity/animal/golem/CopperGolemAi.java
@@ -43,7 +43,7 @@ public class CopperGolemAi {
     private static final int TICK_TO_START_ON_REACHED_INTERACTION = 1;
     private static final int TICK_TO_PLAY_ON_REACHED_SOUND = 9;
     private static final Predicate<BlockState> TRANSPORT_ITEM_SOURCE_BLOCK = state -> state.is(BlockTags.COPPER_CHESTS);
-    private static final Predicate<BlockState> TRANSPORT_ITEM_DESTINATION_BLOCK = state -> state.is(Blocks.CHEST) || state.is(Blocks.TRAPPED_CHEST);
+    private static final Predicate<BlockState> TRANSPORT_ITEM_DESTINATION_BLOCK = state -> state.is(Blocks.CHEST) || state.is(Blocks.TRAPPED_CHEST); // Purpur - copper golem can place items in barrels or shulkers option - diff on change
     private static final ImmutableList<SensorType<? extends Sensor<? super CopperGolem>>> SENSOR_TYPES = ImmutableList.of(
         SensorType.NEAREST_LIVING_ENTITIES, SensorType.HURT_BY
     );
@@ -158,6 +158,11 @@ public class CopperGolemAi {
                 }
 
                 if (integer == 60) {
+                    // Purpur start - copper golem can place items in barrels or shulkers option
+                    if (container instanceof net.minecraft.world.level.block.entity.ShulkerBoxBlockEntity shulkerBoxBlockEntity && shulkerBoxBlockEntity.openCount > 0) {
+                        container.stopOpen(copperGolem);
+                    }
+                    // Purpur end - copper golem can place items in barrels or shulkers option
                     if (container.getEntitiesWithContainerOpen().contains(pathfinderMob)) {
                         container.stopOpen(copperGolem);
                     }
diff --git a/net/minecraft/world/entity/animal/golem/IronGolem.java b/net/minecraft/world/entity/animal/golem/IronGolem.java
index b2c4e93f6063ded665b18ba3b4eaa0eb4cd98732..ddde4297b77d174034300165b591a224c0401743 100644
--- a/net/minecraft/world/entity/animal/golem/IronGolem.java
+++ b/net/minecraft/world/entity/animal/golem/IronGolem.java
@@ -58,13 +58,66 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     private static final UniformInt PERSISTENT_ANGER_TIME = TimeUtil.rangeOfSeconds(20, 39);
     private long persistentAngerEndTime;
     private @Nullable EntityReference<LivingEntity> persistentAngerTarget;
+    private java.util.@Nullable UUID summoner; // Purpur - Summoner API
 
     public IronGolem(EntityType<? extends IronGolem> type, Level level) {
         super(type, level);
     }
 
+    // Purpur start - Summoner API
+    public java.util.@Nullable UUID getSummoner() {
+        return summoner;
+    }
+
+    public void setSummoner(java.util.@Nullable UUID summoner) {
+        this.summoner = summoner;
+    }
+    // Purpur end - Summoner API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ironGolemRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ironGolemRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ironGolemControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ironGolemMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ironGolemScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ironGolemTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ironGolemAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        if (this.level().purpurConfig.ironGolemPoppyCalm) this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.ReceiveFlower(this)); // Purpur - Iron golem calm anger options
+        if (level().purpurConfig.ironGolemCanSwim) this.goalSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.FloatGoal(this)); // Purpur - Ridables
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new MeleeAttackGoal(this, 1.0, true));
         this.goalSelector.addGoal(2, new MoveTowardsTargetGoal(this, 0.9, 32.0F));
         this.goalSelector.addGoal(2, new MoveBackToVillageGoal(this, 0.6, false));
@@ -72,6 +125,7 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
         this.goalSelector.addGoal(5, new OfferFlowerGoal(this));
         this.goalSelector.addGoal(7, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new DefendVillageTargetGoal(this));
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, this::isAngryAt));
@@ -142,6 +196,7 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putBoolean("PlayerCreated", this.isPlayerCreated());
+        output.storeNullable("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC, getSummoner()); // Purpur - Summoner API
         this.addPersistentAngerSaveData(output);
     }
 
@@ -149,6 +204,7 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.setPlayerCreated(input.getBooleanOr("PlayerCreated", false));
+        this.setSummoner(input.read("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC).orElse(null)); // Purpur - Summoner API
         this.readPersistentAngerSaveData(this.level(), input);
     }
 
@@ -257,16 +313,17 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     protected InteractionResult mobInteract(Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (!itemInHand.is(Items.IRON_INGOT)) {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         } else {
             float health = this.getHealth();
             this.heal(25.0F);
             if (this.getHealth() == health) {
-                return InteractionResult.PASS;
+                return tryRide(player, hand); // Purpur - Ridables
             } else {
                 float f = 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.2F;
                 this.playSound(SoundEvents.IRON_GOLEM_REPAIR, 1.0F, f);
                 itemInHand.consume(1, player);
+                if (this.level().purpurConfig.ironGolemHealCalm && isAngry() && getHealth() == getMaxHealth()) stopBeingAngry(); // Purpur - Iron golem calm anger options
                 return InteractionResult.SUCCESS;
             }
         }
diff --git a/net/minecraft/world/entity/animal/golem/SnowGolem.java b/net/minecraft/world/entity/animal/golem/SnowGolem.java
index f6e8e0c3a9532aaa1034c8a31b32da54d17ef151..c37c999671955eeaff0b145a890a512c78d642a8 100644
--- a/net/minecraft/world/entity/animal/golem/SnowGolem.java
+++ b/net/minecraft/world/entity/animal/golem/SnowGolem.java
@@ -46,17 +46,62 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
     private static final EntityDataAccessor<Byte> DATA_PUMPKIN_ID = SynchedEntityData.defineId(SnowGolem.class, EntityDataSerializers.BYTE);
     private static final byte PUMPKIN_FLAG = 16;
     private static final boolean DEFAULT_PUMPKIN = true;
+    private java.util.@Nullable UUID summoner; // Purpur - Summoner API
 
     public SnowGolem(EntityType<? extends SnowGolem> type, Level level) {
         super(type, level);
     }
 
+    // Purpur start - Summoner API
+    public java.util.@Nullable UUID getSummoner() {
+        return summoner;
+    }
+
+    public void setSummoner(java.util.@Nullable UUID summoner) {
+        this.summoner = summoner;
+    }
+    // Purpur end - Summoner API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.snowGolemRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.snowGolemRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.snowGolemControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.snowGolemMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.snowGolemScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.snowGolemAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
-        this.goalSelector.addGoal(1, new RangedAttackGoal(this, 1.25, 20, 10.0F));
-        this.goalSelector.addGoal(2, new WaterAvoidingRandomStrollGoal(this, 1.0, 1.0000001E-5F));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.goalSelector.addGoal(1, new RangedAttackGoal(this, level().purpurConfig.snowGolemAttackDistance, level().purpurConfig.snowGolemSnowBallMin, level().purpurConfig.snowGolemSnowBallMax, level().purpurConfig.snowGolemSnowBallModifier)); // Purpur - Snow Golem rate of fire config
+        this.goalSelector.addGoal(2, new WaterAvoidingRandomStrollGoal(this, 1.0D, 1.0000001E-5F));
         this.goalSelector.addGoal(3, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(4, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Mob.class, 10, true, false, (entity, level) -> entity instanceof Enemy));
     }
 
@@ -74,17 +119,19 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putBoolean("Pumpkin", this.hasPumpkin());
+        output.storeNullable("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC, getSummoner()); // Purpur - Summoner API
     }
 
     @Override
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.setPumpkin(input.getBooleanOr("Pumpkin", true));
+        this.setSummoner(input.read("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC).orElse(null)); // Purpur - Summoner API
     }
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.snowGolemTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
@@ -95,10 +142,11 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
                 this.hurtServer(serverLevel, this.damageSources().onFire().knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.MELTING), 1.0F); // CraftBukkit
             }
 
-            if (!serverLevel.getGameRules().get(GameRules.MOB_GRIEFING)) {
+            if (!serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.snowGolemMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                 return;
             }
 
+            if (getRider() != null && this.isControllable() && !level().purpurConfig.snowGolemLeaveTrailWhenRidden) return; // Purpur - don't leave snow trail when being ridden
             BlockState blockState = Blocks.SNOW.defaultBlockState();
 
             for (int i = 0; i < 4; i++) {
@@ -141,7 +189,7 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
                 org.bukkit.event.player.PlayerShearEntityEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.handlePlayerShearEntityEvent(player, this, itemInHand, hand, drops);
                 if (event != null) {
                     if (event.isCancelled()) {
-                        return InteractionResult.PASS;
+                        return tryRide(player, hand); // Purpur - Ridables
                     }
                     drops = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getDrops());
                     // Paper end - custom shear drops
@@ -153,8 +201,16 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
             }
 
             return InteractionResult.SUCCESS;
+        // Purpur start - Snowman drop and put back pumpkin
+        } else if (level().purpurConfig.snowGolemPutPumpkinBack && !hasPumpkin() && itemInHand.getItem() == Blocks.CARVED_PUMPKIN.asItem()) {
+            setPumpkin(true);
+            if (!player.getAbilities().instabuild) {
+                itemInHand.shrink(1);
+            }
+            return InteractionResult.SUCCESS;
+        // Purpur end - Snowman drop and put back pumpkin
         } else {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         }
     }
 
diff --git a/net/minecraft/world/entity/animal/happyghast/HappyGhast.java b/net/minecraft/world/entity/animal/happyghast/HappyGhast.java
index 5a4a96895c1d2f7538bf644dd133645bc831b582..8034ce67266b6baab35c72eaebf5ad67fc1a29c6 100644
--- a/net/minecraft/world/entity/animal/happyghast/HappyGhast.java
+++ b/net/minecraft/world/entity/animal/happyghast/HappyGhast.java
@@ -126,6 +126,47 @@ public class HappyGhast extends Animal {
         this.removeAllGoals(goal -> true);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.happyGhastRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.happyGhastMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.happyGhastScale);
+        this.getAttribute(Attributes.TEMPT_RANGE).setBaseValue(this.level().purpurConfig.happyGhastTemptRange);
+        this.getAttribute(Attributes.FLYING_SPEED).setBaseValue(this.level().purpurConfig.happyGhastFlyingSpeed);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.happyGhastMovementSpeed);
+        this.getAttribute(Attributes.FOLLOW_RANGE).setBaseValue(this.level().purpurConfig.happyGhastFollowRange);
+        this.getAttribute(Attributes.CAMERA_DISTANCE).setBaseValue(this.level().purpurConfig.happyGhastCameraDistance);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.happyGhastTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.happyGhastAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void ageBoundaryReached() {
         if (this.isBaby()) {
@@ -149,7 +190,7 @@ public class HappyGhast extends Animal {
 
     @Override
     protected float sanitizeScale(float scale) {
-        return Math.min(scale, 1.0F);
+        return Math.min(scale, 1.0F); // Purpur - Configurable entity base attributes
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/nautilus/Nautilus.java b/net/minecraft/world/entity/animal/nautilus/Nautilus.java
index a02a4b47cf02cd7eaa76d25af2dccb50ad884504..7c4467933061f097425d6c82188a65fd5e4c4d3b 100644
--- a/net/minecraft/world/entity/animal/nautilus/Nautilus.java
+++ b/net/minecraft/world/entity/animal/nautilus/Nautilus.java
@@ -21,6 +21,31 @@ public class Nautilus extends AbstractNautilus {
         super(type, level);
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.nautilusMaxHealth);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.nautilusMovementSpeed);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.nautilusAttackDamage);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.KNOCKBACK_RESISTANCE).setBaseValue(this.level().purpurConfig.nautilusKnockbackResistance);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SCALE).setBaseValue(this.level().purpurConfig.nautilusScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.nautilusBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.nautilusAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected Brain.Provider<Nautilus> brainProvider() {
         return NautilusAi.brainProvider();
diff --git a/net/minecraft/world/entity/animal/nautilus/ZombieNautilus.java b/net/minecraft/world/entity/animal/nautilus/ZombieNautilus.java
index 83c16a44b230efd010e06cabb428954d157cea47..7e4d005053e6812f329ab7ac1f252c547d4c9a12 100644
--- a/net/minecraft/world/entity/animal/nautilus/ZombieNautilus.java
+++ b/net/minecraft/world/entity/animal/nautilus/ZombieNautilus.java
@@ -43,6 +43,31 @@ public class ZombieNautilus extends AbstractNautilus {
         super(type, level);
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zombieNautilusMaxHealth);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.zombieNautilusMovementSpeed);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.zombieNautilusAttackDamage);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.KNOCKBACK_RESISTANCE).setBaseValue(this.level().purpurConfig.zombieNautilusKnockbackResistance);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SCALE).setBaseValue(this.level().purpurConfig.zombieNautilusScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombieNautilusAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return AbstractNautilus.createAttributes().add(Attributes.MOVEMENT_SPEED, 1.1F);
     }
diff --git a/net/minecraft/world/entity/animal/panda/Panda.java b/net/minecraft/world/entity/animal/panda/Panda.java
index c5425b36e96e4f41f0ed7d468f53ea3de6b9ef17..5116e9e16070e23d13b526d21facb7b5ad0988ba 100644
--- a/net/minecraft/world/entity/animal/panda/Panda.java
+++ b/net/minecraft/world/entity/animal/panda/Panda.java
@@ -108,6 +108,62 @@ public class Panda extends Animal {
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pandaRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.pandaRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pandaControllable;
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setForwardMot(0.0F);
+        sit(false);
+        eat(false);
+        setOnBack(false);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pandaMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.pandaScale);
+        setAttributes();
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.pandaBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pandaTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pandaAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected boolean canDispenserEquipIntoSlot(EquipmentSlot slot) {
         return slot == EquipmentSlot.MAINHAND && this.canPickUpLoot();
@@ -260,6 +316,7 @@ public class Panda extends Animal {
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new Panda.PandaPanicGoal(this, 2.0));
         this.goalSelector.addGoal(2, new Panda.PandaBreedGoal(this, 1.0));
         this.goalSelector.addGoal(3, new Panda.PandaAttackGoal(this, 1.2F, true));
@@ -275,6 +332,7 @@ public class Panda extends Animal {
         this.goalSelector.addGoal(12, new Panda.PandaRollGoal(this));
         this.goalSelector.addGoal(13, new FollowParentGoal(this, 1.25));
         this.goalSelector.addGoal(14, new WaterAvoidingRandomStrollGoal(this, 1.0));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Panda.PandaHurtByTargetGoal(this).setAlertOthers());
     }
 
@@ -597,7 +655,11 @@ public class Panda extends Animal {
 
     public void setAttributes() {
         if (this.isWeak()) {
-            this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(10.0);
+            // Purpur start - Configurable entity base attributes
+            net.minecraft.world.entity.ai.attributes.AttributeInstance maxHealth = this.getAttribute(Attributes.MAX_HEALTH);
+            maxHealth.setBaseValue(maxHealth.getValue() / 2);
+            // Purpur end - Configurable entity base attributes
+
         }
 
         if (this.isLazy()) {
@@ -617,7 +679,7 @@ public class Panda extends Animal {
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (this.isScared()) {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         } else if (this.isOnBack()) {
             this.setOnBack(false);
             return InteractionResult.SUCCESS;
@@ -653,7 +715,7 @@ public class Panda extends Animal {
 
             return InteractionResult.SUCCESS_SERVER;
         } else {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         }
     }
 
@@ -958,7 +1020,7 @@ public class Panda extends Animal {
         }
     }
 
-    static class PandaMoveControl extends MoveControl {
+    static class PandaMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Panda panda;
 
         public PandaMoveControl(Panda mob) {
@@ -967,9 +1029,9 @@ public class Panda extends Animal {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.panda.canPerformAction()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/animal/parrot/Parrot.java b/net/minecraft/world/entity/animal/parrot/Parrot.java
index 62a26395ee0c3ee450ad3b1ac88bc85523dd27b4..bbe3977939004b7d77e38b14d48c9c26e596d123 100644
--- a/net/minecraft/world/entity/animal/parrot/Parrot.java
+++ b/net/minecraft/world/entity/animal/parrot/Parrot.java
@@ -137,12 +137,97 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     public Parrot(EntityType<? extends Parrot> type, Level level) {
         super(type, level);
-        this.moveControl = new FlyingMoveControl(this, 10, false);
+        // Purpur start - Ridables
+        final org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD flyingController = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.3F);
+        class ParrotMoveControl extends FlyingMoveControl {
+            public ParrotMoveControl(Mob entity, int maxPitchChange, boolean noGravity) {
+                super(entity, maxPitchChange, noGravity);
+            }
+
+            @Override
+            public void tick() {
+                if (mob.getRider() != null && mob.isControllable()) {
+                    flyingController.purpurTick(mob.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+
+            @Override
+            public boolean hasWanted() {
+                return mob.getRider() != null && mob.isControllable() ? getForwardMot() != 0 || getStrafeMot() != 0 : super.hasWanted();
+            }
+        }
+        this.moveControl = new ParrotMoveControl(this, 10, false);
+        // Purpur end - Ridables
         this.setPathfindingMalus(PathType.DANGER_FIRE, -1.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, -1.0F);
         this.setPathfindingMalus(PathType.COCOA, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.parrotRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.parrotRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.parrotControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.parrotMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 2;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 0.25, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.parrotMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.parrotScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.parrotTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.parrotAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public @Nullable SpawnGroupData finalizeSpawn(
         ServerLevelAccessor level, DifficultyInstance difficulty, EntitySpawnReason spawnReason, @Nullable SpawnGroupData spawnGroupData
@@ -162,8 +247,11 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     @Override
     protected void registerGoals() {
-        this.goalSelector.addGoal(0, new TamableAnimal.TamableAnimalPanicGoal(1.25));
+        //this.goalSelector.addGoal(0, new TamableAnimal.TamableAnimalPanicGoal(1.25)); // Purpur - move down
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        if (this.level().purpurConfig.parrotBreedable) this.goalSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.BreedGoal(this, 1.0D)); // Purpur - Breedable parrots
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.goalSelector.addGoal(1, new TamableAnimal.TamableAnimalPanicGoal(1.25D)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(2, new SitWhenOrderedToGoal(this));
         this.goalSelector.addGoal(2, new FollowOwnerGoal(this, 1.0, 5.0F, 1.0F));
@@ -269,7 +357,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
             }
 
             if (!this.level().isClientSide()) {
-                if (this.random.nextInt(10) == 0 && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit
+                if (((this.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || this.random.nextInt(10) == 0) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit // Purpur - Config to always tame in Creative
                     this.tame(player);
                     this.level().broadcastEntityEvent(this, EntityEvent.TAMING_SUCCEEDED);
                 } else {
@@ -277,6 +365,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
                 }
             }
 
+            if (this.level().purpurConfig.parrotBreedable) return super.mobInteract(player, hand); // Purpur - Breedable parrots
             return InteractionResult.SUCCESS;
         } else if (!itemInHand.is(ItemTags.PARROT_POISONOUS_FOOD)) {
             if (!this.isFlying() && this.isTame() && this.isOwnedBy(player)) {
@@ -301,7 +390,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     @Override
     public boolean isFood(ItemStack stack) {
-        return false;
+        return this.level().purpurConfig.parrotBreedable && stack.is(ItemTags.PARROT_FOOD); // Purpur - Breedable parrots
     }
 
     public static boolean checkParrotSpawnRules(
@@ -316,12 +405,12 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     @Override
     public boolean canMate(Animal otherAnimal) {
-        return false;
+        return super.canMate(otherAnimal); // Purpur - Breedable parrots
     }
 
     @Override
     public @Nullable AgeableMob getBreedOffspring(ServerLevel level, AgeableMob partner) {
-        return null;
+        return level.purpurConfig.parrotBreedable ? EntityType.PARROT.create(level, EntitySpawnReason.BREEDING) : null; // Purpur - Breedable parrots
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/pig/Pig.java b/net/minecraft/world/entity/animal/pig/Pig.java
index 8f5d1e2d98472e8e313fad285bd1629aea4173a9..45142ce558ef28455f9b74ca81d51b3ecdb7a458 100644
--- a/net/minecraft/world/entity/animal/pig/Pig.java
+++ b/net/minecraft/world/entity/animal/pig/Pig.java
@@ -63,9 +63,56 @@ public class Pig extends Animal implements ItemSteerable {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pigRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.pigRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pigControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pigMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.pigScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.pigBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pigTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pigAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PanicGoal(this, 1.25));
         this.goalSelector.addGoal(3, new BreedGoal(this, 1.0));
         this.goalSelector.addGoal(4, new TemptGoal(this, 1.2, itemStack -> itemStack.is(Items.CARROT_ON_A_STICK), false));
@@ -138,6 +185,19 @@ public class Pig extends Animal implements ItemSteerable {
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         boolean isFood = this.isFood(player.getItemInHand(hand));
+        // Purpur start - Pigs give saddle back
+        if (level().purpurConfig.pigGiveSaddleBack && player.isSecondaryUseActive() && !isFood && isSaddled() && !isVehicle()) {
+            this.setItemSlot(EquipmentSlot.SADDLE, ItemStack.EMPTY);
+            if (!player.getAbilities().instabuild) {
+                ItemStack saddle = new ItemStack(Items.SADDLE);
+                if (!player.getInventory().add(saddle)) {
+                    player.drop(saddle, false);
+                }
+            }
+            return InteractionResult.SUCCESS;
+        }
+        // Purpur end - Pigs give saddle back
+
         if (!isFood && this.isSaddled() && !this.isVehicle() && !player.isSecondaryUseActive()) {
             if (!this.level().isClientSide()) {
                 player.startRiding(this);
diff --git a/net/minecraft/world/entity/animal/polarbear/PolarBear.java b/net/minecraft/world/entity/animal/polarbear/PolarBear.java
index 8fd0d632e7c6fc7fcb7e9cf141638b5171800799..592711e205ee959cc66de80933ad5a2dcec3092f 100644
--- a/net/minecraft/world/entity/animal/polarbear/PolarBear.java
+++ b/net/minecraft/world/entity/animal/polarbear/PolarBear.java
@@ -61,11 +61,92 @@ public class PolarBear extends Animal implements NeutralMob {
     private static final UniformInt PERSISTENT_ANGER_TIME = TimeUtil.rangeOfSeconds(20, 39);
     private long persistentAngerEndTime;
     private @Nullable EntityReference<LivingEntity> persistentAngerTarget;
+    private int standTimer = 0; // Purpur - Ridables
 
     public PolarBear(EntityType<? extends PolarBear> type, Level level) {
         super(type, level);
     }
 
+    // Purpur start - Breedable Polar Bears
+    public boolean canMate(Animal other) {
+        if (other == this) {
+            return false;
+        } else if (this.isStanding()) {
+            return false;
+        } else if (this.getTarget() != null) {
+            return false;
+        } else if (!(other instanceof PolarBear)) {
+            return false;
+        } else {
+            PolarBear bear = (PolarBear) other;
+            if (bear.isStanding()) {
+                return false;
+            }
+            if (bear.getTarget() != null) {
+                return false;
+            }
+            return this.isInLove() && bear.isInLove();
+        }
+    }
+    // Purpur end - Breedable Polar Bears
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.polarBearRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.polarBearRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.polarBearControllable;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (!isStanding()) {
+            if (getRider() != null && getRider().getForwardMot() == 0 && getRider().getStrafeMot() == 0) {
+                setStanding(true);
+                playSound(SoundEvents.POLAR_BEAR_WARNING, 1.0F, 1.0F);
+            }
+        }
+        return false;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.polarBearMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.polarBearScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.polarBearBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.polarBearTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.polarBearAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public @Nullable AgeableMob getBreedOffspring(ServerLevel level, AgeableMob partner) {
         return EntityType.POLAR_BEAR.create(level, EntitySpawnReason.BREEDING);
@@ -73,19 +154,27 @@ public class PolarBear extends Animal implements NeutralMob {
 
     @Override
     public boolean isFood(ItemStack stack) {
-        return false;
+        return level().purpurConfig.polarBearBreedableItem != null && stack.getItem() == level().purpurConfig.polarBearBreedableItem; // Purpur - Breedable Polar Bears
     }
 
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PolarBear.PolarBearMeleeAttackGoal());
         this.goalSelector.addGoal(1, new PanicGoal(this, 2.0, mob -> mob.isBaby() ? DamageTypeTags.PANIC_CAUSES : DamageTypeTags.PANIC_ENVIRONMENTAL_CAUSES));
+        // Purpur start - Breedable Polar Bears
+        if (level().purpurConfig.polarBearBreedableItem != null) {
+            this.goalSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.BreedGoal(this, 1.0D));
+            this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.TemptGoal(this, 1.0D, net.minecraft.world.item.crafting.Ingredient.of(level().purpurConfig.polarBearBreedableItem), false));
+        }
+        // Purpur end - Breedable Polar Bears
         this.goalSelector.addGoal(4, new FollowParentGoal(this, 1.25));
         this.goalSelector.addGoal(5, new RandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(7, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new PolarBear.PolarBearHurtByTargetGoal());
         this.targetSelector.addGoal(2, new PolarBear.PolarBearAttackPlayersGoal());
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, this::isAngryAt));
@@ -203,6 +292,12 @@ public class PolarBear extends Animal implements NeutralMob {
         if (!this.level().isClientSide()) {
             this.updatePersistentAnger((ServerLevel)this.level(), true);
         }
+
+        // Purpur start - Ridables
+        if (isStanding() && --standTimer <= 0) {
+            setStanding(false);
+        }
+        // Purpur end - Ridables
     }
 
     @Override
@@ -222,6 +317,7 @@ public class PolarBear extends Animal implements NeutralMob {
 
     public void setStanding(boolean standing) {
         this.entityData.set(DATA_STANDING_ID, standing);
+        standTimer = standing ? 20 : -1; // Purpur - Ridables
     }
 
     public float getStandingAnimationScale(float partialTick) {
diff --git a/net/minecraft/world/entity/animal/rabbit/Rabbit.java b/net/minecraft/world/entity/animal/rabbit/Rabbit.java
index 17e58836d18afc7cfcc1cf7a8ac5b9e66ceb5f0d..c39004a546c28c9f8af26e727c67dbff85ba1212 100644
--- a/net/minecraft/world/entity/animal/rabbit/Rabbit.java
+++ b/net/minecraft/world/entity/animal/rabbit/Rabbit.java
@@ -94,6 +94,7 @@ public class Rabbit extends Animal {
     private boolean wasOnGround;
     private int jumpDelayTicks;
     public int moreCarrotTicks = 0;
+    private boolean actualJump; // Purpur - Ridables
 
     public Rabbit(EntityType<? extends Rabbit> type, Level level) {
         super(type, level);
@@ -102,9 +103,84 @@ public class Rabbit extends Animal {
         // this.setSpeedModifier(0.0); // CraftBukkit
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.rabbitRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.rabbitRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.rabbitControllable;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (onGround) {
+            actualJump = true;
+            jumpFromGround();
+            actualJump = false;
+        }
+        return true;
+    }
+
+    private void handleJumping() {
+        if (onGround) {
+            RabbitJumpControl jumpController = (RabbitJumpControl) jumpControl;
+            if (!wasOnGround) {
+                setJumping(false);
+                jumpController.setCanJump(false);
+            }
+            if (!jumpController.wantJump()) {
+                if (moveControl.hasWanted()) {
+                    startJumping();
+                }
+            } else if (!jumpController.canJump()) {
+                jumpController.setCanJump(true);
+            }
+        }
+        wasOnGround = onGround;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.rabbitMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.rabbitScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.rabbitBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.rabbitTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.rabbitAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(1, new Rabbit.RabbitPanicGoal(this, 2.2));
         this.goalSelector.addGoal(2, new BreedGoal(this, 0.8));
@@ -119,6 +195,14 @@ public class Rabbit extends Animal {
 
     @Override
     protected float getJumpPower() {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            if (getForwardMot() < 0) {
+                setSpeed(getForwardMot() * 2F);
+            }
+            return actualJump ? 0.5F : 0.3F;
+        }
+        // Purpur end - Ridables
         float f = 0.3F;
         if (this.moveControl.getSpeedModifier() <= 0.6) {
             f = 0.2F;
@@ -186,6 +270,12 @@ public class Rabbit extends Animal {
 
     @Override
     public void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            handleJumping();
+            return;
+        }
+        // Purpur end - Ridables
         if (this.jumpDelayTicks > 0) {
             this.jumpDelayTicks--;
         }
@@ -404,10 +494,23 @@ public class Rabbit extends Animal {
         }
 
         this.setVariant(randomRabbitVariant);
+
+        // Purpur start - Special mobs naturally spawn
+        if (randomRabbitVariant != Variant.EVIL && level.getLevel().purpurConfig.rabbitNaturalToast > 0D && random.nextDouble() <= level.getLevel().purpurConfig.rabbitNaturalToast) {
+            setCustomName(Component.translatable("Toast"));
+        }
+        // Purpur end - Special mobs naturally spawn
+
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
     private static Rabbit.Variant getRandomRabbitVariant(LevelAccessor level, BlockPos pos) {
+        // Purpur start - Special mobs naturally spawn
+        Level world = level.getMinecraftWorld();
+        if (world.purpurConfig.rabbitNaturalKiller > 0D && world.getRandom().nextDouble() <= world.purpurConfig.rabbitNaturalKiller) {
+            return Rabbit.Variant.EVIL;
+        }
+        // Purpur end - Special mobs naturally spawn
         Holder<Biome> biome = level.getBiome(pos);
         int randomInt = level.getRandom().nextInt(100);
         if (biome.is(BiomeTags.SPAWNS_WHITE_RABBITS)) {
@@ -498,7 +601,7 @@ public class Rabbit extends Animal {
         }
     }
 
-    static class RabbitMoveControl extends MoveControl {
+    static class RabbitMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Rabbit rabbit;
         private double nextJumpSpeed;
 
@@ -508,14 +611,14 @@ public class Rabbit extends Animal {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.rabbit.onGround() && !this.rabbit.jumping && !((Rabbit.RabbitJumpControl)this.rabbit.jumpControl).wantJump()) {
                 this.rabbit.setSpeedModifier(0.0);
             } else if (this.hasWanted() || this.operation == MoveControl.Operation.JUMPING) {
                 this.rabbit.setSpeedModifier(this.nextJumpSpeed);
             }
 
-            super.tick();
+            super.vanillaTick(); // Purpur - Ridables
         }
 
         @Override
@@ -559,7 +662,7 @@ public class Rabbit extends Animal {
         @Override
         public boolean canUse() {
             if (this.nextStartTick <= 0) {
-                if (!getServerLevel(this.rabbit).getGameRules().get(GameRules.MOB_GRIEFING)) {
+                if (!getServerLevel(this.rabbit).getGameRules().get(GameRules.MOB_GRIEFING, getServerLevel(this.rabbit).purpurConfig.rabbitMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     return false;
                 }
 
diff --git a/net/minecraft/world/entity/animal/sheep/Sheep.java b/net/minecraft/world/entity/animal/sheep/Sheep.java
index 8f4e68b1a910cd56d4c57540c0a09a8724d13738..d712673d237f4e4d99a714ddf09c4582387f0e3c 100644
--- a/net/minecraft/world/entity/animal/sheep/Sheep.java
+++ b/net/minecraft/world/entity/animal/sheep/Sheep.java
@@ -63,10 +63,57 @@ public class Sheep extends Animal implements Shearable {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.sheepRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.sheepRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.sheepControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.sheepMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.sheepScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.sheepBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.sheepTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.sheepAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.eatBlockGoal = new EatBlockGoal(this);
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PanicGoal(this, 1.25));
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
         this.goalSelector.addGoal(3, new TemptGoal(this, 1.1, stack -> stack.is(ItemTags.SHEEP_FOOD), false));
diff --git a/net/minecraft/world/entity/animal/sniffer/Sniffer.java b/net/minecraft/world/entity/animal/sniffer/Sniffer.java
index a4d60a0dddabd7981d2db28af6b1d88d64d6e806..7ef3c94f63c8a25d09e69b818ecdf79795803570 100644
--- a/net/minecraft/world/entity/animal/sniffer/Sniffer.java
+++ b/net/minecraft/world/entity/animal/sniffer/Sniffer.java
@@ -89,6 +89,38 @@ public class Sniffer extends Animal {
         this.setPathfindingMalus(PathType.DAMAGE_CAUTIOUS, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.snifferRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.snifferRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.snifferControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.snifferMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.snifferScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.snifferBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -467,6 +499,7 @@ public class Sniffer extends Animal {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("snifferBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.popPush("snifferActivityUpdate");
         SnifferAi.updateActivity(this);
diff --git a/net/minecraft/world/entity/animal/squid/GlowSquid.java b/net/minecraft/world/entity/animal/squid/GlowSquid.java
index 1012da8b64b0b7a4f832eab48239b2c65bd20eaf..dd1bd8b1a348a0cc398b123a77d3cb28dd1273ae 100644
--- a/net/minecraft/world/entity/animal/squid/GlowSquid.java
+++ b/net/minecraft/world/entity/animal/squid/GlowSquid.java
@@ -30,6 +30,47 @@ public class GlowSquid extends Squid {
         super(type, level);
     }
 
+    // Purpur start - Flying squids! Oh my!
+    @Override
+    public boolean canFly() {
+        return this.level().purpurConfig.glowSquidsCanFly;
+    }
+    // Purpur end - Flying squids! Oh my!
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.glowSquidRidable;
+    }
+
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.glowSquidControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.glowSquidMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.glowSquidTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.glowSquidAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected ParticleOptions getInkParticle() {
         return ParticleTypes.GLOW_SQUID_INK;
diff --git a/net/minecraft/world/entity/animal/squid/Squid.java b/net/minecraft/world/entity/animal/squid/Squid.java
index 0e13879ce2802ff8ef0ee9b745a23396727c3e30..6b5be8e58aa7e3acd14ff3cb1ba25d15f8d37410 100644
--- a/net/minecraft/world/entity/animal/squid/Squid.java
+++ b/net/minecraft/world/entity/animal/squid/Squid.java
@@ -48,13 +48,77 @@ public class Squid extends AgeableWaterCreature {
 
     public Squid(EntityType<? extends Squid> type, Level level) {
         super(type, level);
-        // this.random.setSeed(this.getId()); // Paper - Share random for entities to make them more random
+        if (!level.purpurConfig.entitySharedRandom) this.random.setSeed(this.getId()); // Paper - Share random for entities to make them more random // Purpur - Add toggle for RNG manipulation
         this.tentacleSpeed = 1.0F / (this.random.nextFloat() + 1.0F) * 0.2F;
     }
 
+    // Purpur start - Stop squids floating on top of water
+    @Override
+    public net.minecraft.world.phys.AABB getAxisForFluidCheck() {
+        // Stops squids from floating just over the water
+        return super.getAxisForFluidCheck().offsetY(level().purpurConfig.squidOffsetWaterCheck);
+    }
+    // Purpur end - Stop squids floating on top of water
+
+    // Purpur start - Flying squids! Oh my!
+    public boolean canFly() {
+        return this.level().purpurConfig.squidsCanFly;
+    }
+
+    @Override
+    public boolean isInWater() {
+        return this.wasTouchingWater || canFly();
+    }
+    // Purpur end - Flying squids! Oh my!
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.squidRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.squidControllable;
+    }
+
+    protected static void rotateVectorAroundY(org.bukkit.util.Vector vector, double degrees) {
+        double rad = Math.toRadians(degrees);
+        double cos = Math.cos(rad);
+        double sine = Math.sin(rad);
+        double x = vector.getX();
+        double z = vector.getZ();
+        vector.setX(cos * x - sine * z);
+        vector.setZ(sine * x + cos * z);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.squidMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.squidScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.squidTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.squidAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new Squid.SquidRandomMovementGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Squid.SquidFleeGoal());
     }
 
@@ -128,6 +192,7 @@ public class Squid extends AgeableWaterCreature {
         }
 
         if (this.isInWater()) {
+            if (canFly()) setNoGravity(!wasTouchingWater); // Purpur - Flying squids! Oh my!
             if (this.tentacleMovement < (float) Math.PI) {
                 float f = this.tentacleMovement / (float) Math.PI;
                 this.tentacleAngle = Mth.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
@@ -305,10 +370,41 @@ public class Squid extends AgeableWaterCreature {
 
         @Override
         public void tick() {
+            // Purpur start - Ridables
+            net.minecraft.world.entity.player.Player rider = squid.getRider();
+            if (rider != null && squid.isControllable()) {
+                if (rider.jumping) {
+                    squid.onSpacebar();
+                }
+                float forward = rider.getForwardMot();
+                float strafe = rider.getStrafeMot();
+                float speed = (float) squid.getAttributeValue(Attributes.MOVEMENT_SPEED) * 10F;
+                if (forward < 0.0F) {
+                    speed *= -0.5;
+                }
+                org.bukkit.util.Vector dir = rider.getBukkitEntity().getEyeLocation().getDirection().normalize().multiply(speed / 20.0F);
+                if (strafe != 0.0F) {
+                    if (forward == 0.0F) {
+                        dir.setY(0);
+                        rotateVectorAroundY(dir, strafe > 0.0F ? -90 : 90);
+                    } else if (forward < 0.0F) {
+                        rotateVectorAroundY(dir, strafe > 0.0F ? 45 : -45);
+                    } else {
+                        rotateVectorAroundY(dir, strafe > 0.0F ? -45 : 45);
+                    }
+                }
+                if (forward != 0.0F || strafe != 0.0F) {
+                    squid.movementVector = new Vec3((float) dir.getX(), (float) dir.getY(), (float) dir.getZ());
+                } else {
+                    squid.movementVector = Vec3.ZERO;
+                }
+                return;
+            }
+            // Purpur end - Ridables
             int noActionTime = this.squid.getNoActionTime();
             if (noActionTime > 100) {
                 this.squid.movementVector = Vec3.ZERO;
-            } else if (this.squid.getRandom().nextInt(reducedTickDelay(50)) == 0 || !this.squid.wasTouchingWater || !this.squid.hasMovementVector()) {
+            } else if (this.squid.getRandom().nextInt(reducedTickDelay(50)) == 0 || !this.squid.isInWater() || !this.squid.hasMovementVector()) { // Purpur - Flying squids! Oh my!
                 float f = this.squid.getRandom().nextFloat() * (float) (Math.PI * 2);
                 this.squid.movementVector = new Vec3(Mth.cos(f) * 0.2F, -0.1F + this.squid.getRandom().nextFloat() * 0.2F, Mth.sin(f) * 0.2F);
             }
diff --git a/net/minecraft/world/entity/animal/turtle/Turtle.java b/net/minecraft/world/entity/animal/turtle/Turtle.java
index fdbc70322eb653d2cc576090c27d1cb67bfce1f6..a3f2076e6f0e51ac51a8af94cae91baf82c247a1 100644
--- a/net/minecraft/world/entity/animal/turtle/Turtle.java
+++ b/net/minecraft/world/entity/animal/turtle/Turtle.java
@@ -87,6 +87,52 @@ public class Turtle extends Animal {
         this.moveControl = new Turtle.TurtleMoveControl(this);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.turtleRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.turtleRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.turtleControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.turtleMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.turtleScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.turtleBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.turtleTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.turtleAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public void setHomePos(BlockPos homePos) {
         this.homePos = homePos;
     }
@@ -145,6 +191,7 @@ public class Turtle extends Animal {
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new Turtle.TurtlePanicGoal(this, 1.2));
         this.goalSelector.addGoal(1, new Turtle.TurtleBreedGoal(this, 1.0));
         this.goalSelector.addGoal(1, new Turtle.TurtleLayEggGoal(this, 1.0));
@@ -317,8 +364,10 @@ public class Turtle extends Animal {
             }
 
             this.turtle.setHasEgg(true);
-            this.animal.setAge(6000);
-            this.partner.setAge(6000);
+            // Purpur start - Make entity breeding times configurable
+            this.animal.setAge(this.animal.getPurpurBreedTime());
+            this.partner.setAge(this.partner.getPurpurBreedTime());
+            // Purpur end - Make entity breeding times configurable
             this.animal.resetLove();
             this.partner.resetLove();
             RandomSource random = this.animal.getRandom();
@@ -485,12 +534,14 @@ public class Turtle extends Animal {
         }
     }
 
-    static class TurtleMoveControl extends MoveControl {
+    static class TurtleMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Turtle turtle;
+        private final org.purpurmc.purpur.controller.WaterMoveControllerWASD waterController; // Purpur - Ridables
 
         TurtleMoveControl(Turtle mob) {
             super(mob);
             this.turtle = mob;
+            waterController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(turtle, 0.25D); // Purpur - Ridables
         }
 
         private void updateSpeed() {
@@ -509,7 +560,7 @@ public class Turtle extends Animal {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             this.updateSpeed();
             if (this.operation == MoveControl.Operation.MOVE_TO && !this.turtle.getNavigation().isDone()) {
                 double d = this.wantedX - this.turtle.getX();
@@ -523,7 +574,7 @@ public class Turtle extends Animal {
                     float f = (float)(Mth.atan2(d2, d) * 180.0F / (float)Math.PI) - 90.0F;
                     this.turtle.setYRot(this.rotlerp(this.turtle.getYRot(), f, 90.0F));
                     this.turtle.yBodyRot = this.turtle.getYRot();
-                    float f1 = (float)(this.speedModifier * this.turtle.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                    float f1 = (float)(this.getSpeedModifier() * this.turtle.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                     this.turtle.setSpeed(Mth.lerp(0.125F, this.turtle.getSpeed(), f1));
                     this.turtle.setDeltaMovement(this.turtle.getDeltaMovement().add(0.0, this.turtle.getSpeed() * d1 * 0.1, 0.0));
                 }
diff --git a/net/minecraft/world/entity/animal/wolf/Wolf.java b/net/minecraft/world/entity/animal/wolf/Wolf.java
index ffad6072280fb4d02f0a37a97d8c83fba85d3bc2..7fbe841818d08fd930f7ce405e84e5ed4badb614 100644
--- a/net/minecraft/world/entity/animal/wolf/Wolf.java
+++ b/net/minecraft/world/entity/animal/wolf/Wolf.java
@@ -100,6 +100,37 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         EntityType<?> type = entity.getType();
         return type == EntityType.SHEEP || type == EntityType.RABBIT || type == EntityType.FOX;
     };
+    // Purpur start - Configurable chance for wolves to spawn rabid
+    private boolean isRabid = false;
+    private static final TargetingConditions.Selector RABID_PREDICATE = (entity, ignored) -> entity instanceof net.minecraft.server.level.ServerPlayer || entity instanceof net.minecraft.world.entity.Mob;
+    private final net.minecraft.world.entity.ai.goal.Goal PATHFINDER_VANILLA = new NonTameRandomTargetGoal<>(this, Animal.class, false, PREY_SELECTOR);
+    private final net.minecraft.world.entity.ai.goal.Goal PATHFINDER_RABID = new NonTameRandomTargetGoal<>(this, LivingEntity.class, false, RABID_PREDICATE);
+    private static final class AvoidRabidWolfGoal extends AvoidEntityGoal<Wolf> {
+        private final Wolf wolf;
+
+        public AvoidRabidWolfGoal(Wolf wolf, float distance, double minSpeed, double maxSpeed) {
+            super(wolf, Wolf.class, distance, minSpeed, maxSpeed);
+            this.wolf = wolf;
+        }
+
+        @Override
+        public boolean canUse() {
+            return super.canUse() && !this.wolf.isRabid() && this.toAvoid != null && this.toAvoid.isRabid(); // wolves which are not rabid run away from rabid wolves
+        }
+
+        @Override
+        public void start() {
+            this.wolf.setTarget(null);
+            super.start();
+        }
+
+        @Override
+        public void tick() {
+            this.wolf.setTarget(null);
+            super.tick();
+        }
+    }
+    // Purpur end - Configurable chance for wolves to spawn rabid
     private static final float START_HEALTH = 8.0F;
     private static final float TAME_HEALTH = 40.0F;
     private static final float ARMOR_REPAIR_UNIT = 0.125F;
@@ -121,12 +152,99 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         this.setPathfindingMalus(PathType.DANGER_POWDER_SNOW, -1.0F);
     }
 
+    // Purpur start - Configurable chance for wolves to spawn rabid
+    public boolean isRabid() {
+        return this.isRabid;
+    }
+
+    public void setRabid(boolean isRabid) {
+        this.isRabid = isRabid;
+        updatePathfinders(true);
+    }
+
+    public void updatePathfinders(boolean modifyEffects) {
+        this.targetSelector.removeGoal(PATHFINDER_VANILLA);
+        this.targetSelector.removeGoal(PATHFINDER_RABID);
+        if (this.isRabid) {
+            this.setOwnerReference(null);
+            setTame(false, true);
+            this.targetSelector.addGoal(5, PATHFINDER_RABID);
+            if (modifyEffects) this.addEffect(new net.minecraft.world.effect.MobEffectInstance(net.minecraft.world.effect.MobEffects.NAUSEA, 1200));
+        } else {
+            this.targetSelector.addGoal(5, PATHFINDER_VANILLA);
+            this.stopBeingAngry();
+            if (modifyEffects) this.removeEffect(net.minecraft.world.effect.MobEffects.NAUSEA);
+        }
+    }
+    // Purpur end - Configurable chance for wolves to spawn rabid
+
+    // Purpur start - Configurable default collar color
+    @Override
+    public void tame(Player player) {
+        setCollarColor(level().purpurConfig.wolfDefaultCollarColor);
+        super.tame(player);
+    }
+    // Purpur end - Configurable default collar color
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.wolfRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.wolfRidableInWater;
+    }
+
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setInSittingPose(false);
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.wolfControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.wolfMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.wolfScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.wolfBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.wolfTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.wolfAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new TamableAnimal.TamableAnimalPanicGoal(1.5, DamageTypeTags.PANIC_ENVIRONMENTAL_CAUSES));
         this.goalSelector.addGoal(2, new SitWhenOrderedToGoal(this));
         this.goalSelector.addGoal(3, new Wolf.WolfAvoidEntityGoal<>(this, Llama.class, 24.0F, 1.5, 1.5));
+        this.goalSelector.addGoal(3, new AvoidRabidWolfGoal(this, 24.0F, 1.5D, 1.5D)); // Purpur - Configurable chance for wolves to spawn rabid
         this.goalSelector.addGoal(4, new LeapAtTargetGoal(this, 0.4F));
         this.goalSelector.addGoal(5, new MeleeAttackGoal(this, 1.0, true));
         this.goalSelector.addGoal(6, new FollowOwnerGoal(this, 1.0, 10.0F, 2.0F));
@@ -135,11 +253,12 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         this.goalSelector.addGoal(9, new BegGoal(this, 8.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(10, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new OwnerHurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new OwnerHurtTargetGoal(this));
         this.targetSelector.addGoal(3, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(4, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, this::isAngryAt));
-        this.targetSelector.addGoal(5, new NonTameRandomTargetGoal<>(this, Animal.class, false, PREY_SELECTOR));
+        //this.targetSelector.addGoal(5, new NonTameRandomTargetGoal<>(this, Animal.class, false, PREY_SELECTOR)); // Purpur - Configurable chance for wolves to spawn rabid - moved to updatePathfinders()
         this.targetSelector.addGoal(6, new NonTameRandomTargetGoal<>(this, Turtle.class, false, Turtle.BABY_ON_LAND_SELECTOR));
         this.targetSelector.addGoal(7, new NearestAttackableTargetGoal<>(this, AbstractSkeleton.class, false));
         this.targetSelector.addGoal(8, new ResetUniversalAngerTargetGoal<>(this, true));
@@ -229,6 +348,7 @@ public class Wolf extends TamableAnimal implements NeutralMob {
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.store("CollarColor", DyeColor.LEGACY_ID_CODEC, this.getCollarColor());
+        output.putBoolean("Purpur.IsRabid", this.isRabid); // Purpur - Configurable chance for wolves to spawn rabid
         VariantUtils.writeVariant(output, this.getVariant());
         this.addPersistentAngerSaveData(output);
         this.getSoundVariant()
@@ -243,6 +363,10 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         super.readAdditionalSaveData(input);
         VariantUtils.readVariant(input, Registries.WOLF_VARIANT).ifPresent(this::setVariant);
         this.setCollarColor(input.read("CollarColor", DyeColor.LEGACY_ID_CODEC).orElse(DEFAULT_COLLAR_COLOR));
+        // Purpur start - Configurable chance for wolves to spawn rabid
+        this.isRabid = input.getBooleanOr("Purpur.IsRabid", false);
+        this.updatePathfinders(false);
+        // Purpur end - Configurable chance for wolves to spawn rabid
         this.readPersistentAngerSaveData(this.level(), input);
         input.read("sound_variant", ResourceKey.codec(Registries.WOLF_SOUND_VARIANT))
             .flatMap(resourceKey -> this.registryAccess().lookupOrThrow(Registries.WOLF_SOUND_VARIANT).get((ResourceKey<WolfSoundVariant>)resourceKey))
@@ -266,6 +390,10 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         }
 
         this.setSoundVariant(WolfSoundVariants.pickRandomSoundVariant(this.registryAccess(), level.getRandom()));
+        // Purpur start - Configurable chance for wolves to spawn rabid
+        this.isRabid = level.getLevel().purpurConfig.wolfNaturalRabid > 0.0D && random.nextDouble() <= level.getLevel().purpurConfig.wolfNaturalRabid;
+        this.updatePathfinders(false);
+        // Purpur end - Configurable chance for wolves to spawn rabid
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
@@ -316,6 +444,11 @@ public class Wolf extends TamableAnimal implements NeutralMob {
     public void tick() {
         super.tick();
         if (this.isAlive()) {
+            // Purpur start - Configurable chance for wolves to spawn rabid
+            if (this.age % 300 == 0 && this.isRabid()) {
+                this.addEffect(new net.minecraft.world.effect.MobEffectInstance(net.minecraft.world.effect.MobEffects.NAUSEA, 400));
+            }
+            // Purpur end - Configurable chance for wolves to spawn rabid
             this.interestedAngleO = this.interestedAngle;
             if (this.isInterested()) {
                 this.interestedAngle = this.interestedAngle + (1.0F - this.interestedAngle) * 0.4F;
@@ -517,13 +650,27 @@ public class Wolf extends TamableAnimal implements NeutralMob {
             itemInHand.consume(1, player);
             this.tryToTame(player);
             return InteractionResult.SUCCESS_SERVER;
+        // Purpur start - Configurable chance for wolves to spawn rabid
+        } else if (this.level().purpurConfig.wolfMilkCuresRabies && itemInHand.getItem() == Items.MILK_BUCKET && this.isRabid()) {
+            if (!player.isCreative()) {
+                player.setItemInHand(hand, new ItemStack(Items.BUCKET));
+            }
+            this.setRabid(false);
+            for (int i = 0; i < 10; ++i) {
+                ((ServerLevel) level()).sendParticlesSource(((ServerLevel) level()).players(), null, ParticleTypes.HAPPY_VILLAGER,
+                        false, true,
+                        getX() + random.nextFloat(), getY() + (random.nextFloat() * 1.5), getZ() + random.nextFloat(), 1,
+                        random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, 0);
+            }
+            return InteractionResult.SUCCESS_SERVER;
+        // Purpur end - Configurable chance for wolves to spawn rabid
         }
 
         return super.mobInteract(player, hand);
     }
 
     private void tryToTame(Player player) {
-        if (this.random.nextInt(3) == 0 && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit - added event call
+        if (((this.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || this.random.nextInt(3) == 0) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit - added event call // Purpur - Config to always tame in Creative
             this.tame(player);
             this.navigation.stop();
             this.setTarget(null);
diff --git a/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java b/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
index c095f42aa103b7874fb5d8dcece1b1484c2e2968..21d678008fac473dff4c3e10890882ab94d0087c 100644
--- a/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
+++ b/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
@@ -27,6 +27,12 @@ public class EndCrystal extends Entity {
     private static final boolean DEFAULT_SHOW_BOTTOM = true;
     public int time;
     public boolean generatedByDragonFight = false; // Paper - Fix invulnerable end crystals
+    // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+    private net.minecraft.world.entity.monster.Phantom targetPhantom;
+    private int phantomBeamTicks = 0;
+    private int phantomDamageCooldown = 0;
+    private int idleCooldown = 0;
+    // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
 
     public EndCrystal(EntityType<? extends EndCrystal> type, Level level) {
         super(type, level);
@@ -39,6 +45,24 @@ public class EndCrystal extends Entity {
         this.setPos(x, y, z);
     }
 
+    // Purpur start - End crystal explosion options
+    public boolean shouldExplode() {
+        return showsBottom() ? level().purpurConfig.basedEndCrystalExplode : level().purpurConfig.baselessEndCrystalExplode;
+    }
+
+    public float getExplosionPower() {
+        return (float) (showsBottom() ? level().purpurConfig.basedEndCrystalExplosionPower : level().purpurConfig.baselessEndCrystalExplosionPower);
+    }
+
+    public boolean hasExplosionFire() {
+        return showsBottom() ? level().purpurConfig.basedEndCrystalExplosionFire : level().purpurConfig.baselessEndCrystalExplosionFire;
+    }
+
+    public Level.ExplosionInteraction getExplosionEffect() {
+        return showsBottom() ? level().purpurConfig.basedEndCrystalExplosionEffect : level().purpurConfig.baselessEndCrystalExplosionEffect;
+    }
+    // Purpur end - End crystal explosion options
+
     @Override
     protected Entity.MovementEmission getMovementEmission() {
         return Entity.MovementEmission.NONE;
@@ -75,6 +99,51 @@ public class EndCrystal extends Entity {
             }
         }
         // Paper end - Fix invulnerable end crystals
+        if (this.level().purpurConfig.endCrystalCramming > 0 && this.level().getEntitiesOfClass(EndCrystal.class, getBoundingBox()).size() > this.level().purpurConfig.endCrystalCramming) this.hurt(this.damageSources().cramming(), 6.0F); // Purpur - End Crystal Cramming
+
+        // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+        if (level().purpurConfig.phantomAttackedByCrystalRadius <= 0 || --idleCooldown > 0) {
+            return; // on cooldown
+        }
+
+        if (targetPhantom == null) {
+            for (net.minecraft.world.entity.monster.Phantom phantom : level().getEntitiesOfClass(net.minecraft.world.entity.monster.Phantom.class, getBoundingBox().inflate(level().purpurConfig.phantomAttackedByCrystalRadius))) {
+                if (phantom.hasLineOfSight(this)) {
+                    attackPhantom(phantom);
+                    break;
+                }
+            }
+        } else {
+            setBeamTarget(new BlockPos(targetPhantom).offset(0, -2, 0));
+            if (--phantomBeamTicks > 0 && targetPhantom.isAlive()) {
+                phantomDamageCooldown--;
+                if (targetPhantom.hasLineOfSight(this)) {
+                    if (phantomDamageCooldown <= 0) {
+                        phantomDamageCooldown = 20;
+                        targetPhantom.hurt(targetPhantom.damageSources().indirectMagic(this, this), level().purpurConfig.phantomAttackedByCrystalDamage);
+                    }
+                } else {
+                    forgetPhantom(); // no longer in sight
+                }
+            } else {
+                forgetPhantom(); // attacked long enough
+            }
+        }
+    }
+
+    private void attackPhantom(net.minecraft.world.entity.monster.Phantom phantom) {
+        phantomDamageCooldown = 0;
+        phantomBeamTicks = 60;
+        targetPhantom = phantom;
+    }
+
+    private void forgetPhantom() {
+        targetPhantom = null;
+        setBeamTarget(null);
+        phantomBeamTicks = 0;
+        phantomDamageCooldown = 0;
+        idleCooldown = 60;
+        // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
     }
 
     @Override
@@ -115,15 +184,17 @@ public class EndCrystal extends Entity {
                 }
                 // CraftBukkit end
                 if (!damageSource.is(DamageTypeTags.IS_EXPLOSION)) {
+                    if (shouldExplode()) {// Purpur - End crystal explosion options
                     DamageSource damageSource1 = damageSource.getEntity() != null ? this.damageSources().explosion(this, damageSource.getEntity()) : null;
                     // CraftBukkit start
-                    org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, 6.0F, false);
+                    org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, getExplosionPower(), hasExplosionFire()); // Purpur - End crystal explosion options
                     if (event.isCancelled()) {
                         return false;
                     }
 
                     this.remove(Entity.RemovalReason.KILLED, org.bukkit.event.entity.EntityRemoveEvent.Cause.EXPLODE); // Paper - add Bukkit remove cause
-                    level.explode(this, damageSource1, null, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.BLOCK);
+                    level.explode(this, damageSource1, null, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), getExplosionEffect()); // Purpur - End crystal explosion options
+                    } else this.unsetRemoved(); // Purpur - End crystal explosion options
                 } else {
                     this.remove(Entity.RemovalReason.KILLED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DEATH); // Paper - add Bukkit remove cause
                     // CraftBukkit end
diff --git a/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 1daf8f52148043339f723aaebdf6135763dd805b..335bff0b9537ea4ea9717e76e824b07642d7dd8e 100644
--- a/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -90,6 +90,7 @@ public class EnderDragon extends Mob implements Enemy {
     private final net.minecraft.world.level.Explosion explosionSource; // Paper - reusable source for CraftTNTPrimed.getSource()
     @Nullable private BlockPos podium;
     // Paper end
+    private boolean hadRider; // Purpur - Ridables
 
     public EnderDragon(EntityType<? extends EnderDragon> type, Level level) {
         super(EntityType.ENDER_DRAGON, level);
@@ -106,6 +107,37 @@ public class EnderDragon extends Mob implements Enemy {
         this.noPhysics = true;
         this.phaseManager = new EnderDragonPhaseManager(this);
         this.explosionSource = new net.minecraft.world.level.ServerExplosion(level.getMinecraftWorld(), this, null, null, new Vec3(Double.NaN, Double.NaN, Double.NaN), Float.NaN, true, net.minecraft.world.level.Explosion.BlockInteraction.DESTROY); // Paper
+
+        // Purpur start - Ridables
+        this.moveControl = new org.purpurmc.purpur.controller.FlyingMoveControllerWASD(this) {
+            @Override
+            public void vanillaTick() {
+                // dragon doesn't use the controller. do nothing
+            }
+        };
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this) {
+            @Override
+            public void vanillaTick() {
+                // dragon doesn't use the controller. do nothing
+            }
+
+            @Override
+            public void purpurTick(Player rider) {
+                setYawPitch(rider.getYRot() - 180F, rider.xRotO * 0.5F);
+            }
+        };
+        // Purpur end - Ridables
+    }
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.enderDragonRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.enderDragonRidableInWater;
     }
 
     public void setDragonFight(EndDragonFight dragonFight) {
@@ -120,6 +152,31 @@ public class EnderDragon extends Mob implements Enemy {
         return this.fightOrigin;
     }
 
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.enderDragonControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.enderDragonMaxY;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.enderDragonMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.enderDragonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
     public static AttributeSupplier.Builder createAttributes() {
         return Mob.createMobAttributes().add(Attributes.MAX_HEALTH, 200.0).add(Attributes.CAMERA_DISTANCE, 16.0);
     }
@@ -169,6 +226,37 @@ public class EnderDragon extends Mob implements Enemy {
 
     @Override
     public void aiStep() {
+        // Purpur start - Ridables
+        boolean hasRider = getRider() != null && this.isControllable();
+        if (hasRider) {
+            if (!hadRider) {
+                hadRider = true;
+                noPhysics = false;
+                this.dimensions = net.minecraft.world.entity.EntityDimensions.scalable(4.0F, 2.0F);
+            }
+
+            // dragon doesn't use controllers, so must tick manually
+            moveControl.tick();
+            lookControl.tick();
+
+            moveRelative((float) getAttributeValue(Attributes.MOVEMENT_SPEED) * 0.1F, new Vec3(-getStrafeMot(), getVerticalMot(), -getForwardMot()));
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot);
+            move(MoverType.PLAYER, mot);
+
+            mot = mot.multiply(0.9F, 0.9F, 0.9F);
+            setDeltaMovement(mot);
+
+            // control wing flap speed on client
+            phaseManager.setPhase(mot.x() * mot.x() + mot.z() * mot.z() < 0.005F ? EnderDragonPhase.HOVERING : EnderDragonPhase.HOLDING_PATTERN);
+        } else if (hadRider) {
+            hadRider = false;
+            noPhysics = true;
+            this.dimensions = net.minecraft.world.entity.EntityDimensions.scalable(16.0F, 8.0F);
+            phaseManager.setPhase(EnderDragonPhase.HOLDING_PATTERN); // HoldingPattern
+        }
+        // Purpur end - Ridables
+
         this.processFlappingMovement();
         if (this.level().isClientSide()) {
             this.setHealth(this.getHealth());
@@ -197,6 +285,8 @@ public class EnderDragon extends Mob implements Enemy {
 
         this.oFlapTime = this.flapTime;
         if (this.isDeadOrDying()) {
+            if (hasRider) ejectPassengers(); // Purpur - Ridables
+
             float f = (this.random.nextFloat() - 0.5F) * 8.0F;
             float f1 = (this.random.nextFloat() - 0.5F) * 4.0F;
             float f2 = (this.random.nextFloat() - 0.5F) * 8.0F;
@@ -206,9 +296,9 @@ public class EnderDragon extends Mob implements Enemy {
             Vec3 deltaMovement = this.getDeltaMovement();
             float f1 = 0.2F / ((float)deltaMovement.horizontalDistance() * 10.0F + 1.0F);
             f1 *= (float)Math.pow(2.0, deltaMovement.y);
-            if (this.phaseManager.getCurrentPhase().isSitting()) {
+            if (!hasRider && this.phaseManager.getCurrentPhase().isSitting()) { // Purpur - Ridables
                 this.flapTime += 0.1F;
-            } else if (this.inWall) {
+            } else if (!hasRider && this.inWall) { // Purpur - Ridables
                 this.flapTime += f1 * 0.5F;
             } else {
                 this.flapTime += f1;
@@ -219,7 +309,7 @@ public class EnderDragon extends Mob implements Enemy {
                 this.flapTime = 0.5F;
             } else {
                 this.flightHistory.record(this.getY(), this.getYRot());
-                if (this.level() instanceof ServerLevel serverLevel1) {
+                if (this.level() instanceof ServerLevel serverLevel1 && !hasRider) { // Purpur - Ridables
                     DragonPhaseInstance currentPhase = this.phaseManager.getCurrentPhase();
                     currentPhase.doServerTick(serverLevel1);
                     if (this.phaseManager.getCurrentPhase() != currentPhase) {
@@ -294,7 +384,7 @@ public class EnderDragon extends Mob implements Enemy {
                 this.tickPart(this.body, sin1 * 0.5F, 0.0, -cos1 * 0.5F);
                 this.tickPart(this.wing1, cos1 * 4.5F, 2.0, sin1 * 4.5F);
                 this.tickPart(this.wing2, cos1 * -4.5F, 2.0, sin1 * -4.5F);
-                if (this.level() instanceof ServerLevel serverLevel2 && this.hurtTime == 0) {
+                if (this.level() instanceof ServerLevel serverLevel2 && this.hurtTime == 0 && !hasRider) { // Purpur - Ridables
                     this.knockBack(
                         serverLevel2,
                         serverLevel2.getEntities(
@@ -344,9 +434,9 @@ public class EnderDragon extends Mob implements Enemy {
                 }
 
                 if (this.level() instanceof ServerLevel serverLevel3) {
-                    this.inWall = this.checkWalls(serverLevel3, this.head.getBoundingBox())
+                    this.inWall = !hasRider && this.checkWalls(serverLevel3, this.head.getBoundingBox())
                         | this.checkWalls(serverLevel3, this.neck.getBoundingBox())
-                        | this.checkWalls(serverLevel3, this.body.getBoundingBox());
+                        | this.checkWalls(serverLevel3, this.body.getBoundingBox()); // Purpur - Ridables
                     if (this.dragonFight != null) {
                         this.dragonFight.updateDragon(this);
                     }
@@ -459,7 +549,7 @@ public class EnderDragon extends Mob implements Enemy {
                     BlockPos blockPos = new BlockPos(i, i1, i2);
                     BlockState blockState = level.getBlockState(blockPos);
                     if (!blockState.isAir() && !blockState.is(BlockTags.DRAGON_TRANSPARENT)) {
-                        if (level.getGameRules().get(GameRules.MOB_GRIEFING) && !blockState.is(BlockTags.DRAGON_IMMUNE)) {
+                        if (level.getGameRules().get(GameRules.MOB_GRIEFING, level.purpurConfig.enderDragonMobGriefingOverride) && !blockState.is(BlockTags.DRAGON_IMMUNE)) { // Purpur - Add mobGriefing override to everything affected
                             // CraftBukkit start - Add blocks to list rather than destroying them
                             //flag1 = level.removeBlock(blockPos, false) || flag1;
                             flag1 = true;
@@ -957,6 +1047,7 @@ public class EnderDragon extends Mob implements Enemy {
 
     @Override
     protected boolean canRide(Entity entity) {
+        if (this.level().purpurConfig.enderDragonCanRideVehicles) return this.boardingCooldown <= 0; // Purpur - Configs for if Wither/Ender Dragon can ride vehicles
         return false;
     }
 
@@ -982,7 +1073,7 @@ public class EnderDragon extends Mob implements Enemy {
 
     @Override
     protected float sanitizeScale(float scale) {
-        return 1.0F;
+        return 1.0F; // Purpur - Configurable entity base attributes
     }
 
     // CraftBukkit start - SPIGOT-2420: Special case, the ender dragon drops 12000 xp for the first kill and 500 xp for every other kill and this over time.
@@ -992,7 +1083,7 @@ public class EnderDragon extends Mob implements Enemy {
         boolean flag = level.getGameRules().get(GameRules.MOB_DROPS);
         int i = 500;
 
-        if (this.dragonFight != null && !this.dragonFight.hasPreviouslyKilledDragon()) {
+        if (this.dragonFight != null && (level().purpurConfig.enderDragonAlwaysDropsFullExp || !this.dragonFight.hasPreviouslyKilledDragon())) { // Purpur - Ender dragon always drop full exp
             i = 12000;
         }
 
diff --git a/net/minecraft/world/entity/boss/enderdragon/EnderDragonPart.java b/net/minecraft/world/entity/boss/enderdragon/EnderDragonPart.java
index 41200efbaa29ee487c0383b261122e0701413865..871adbd10f49a4d59820c089da149a47de424656 100644
--- a/net/minecraft/world/entity/boss/enderdragon/EnderDragonPart.java
+++ b/net/minecraft/world/entity/boss/enderdragon/EnderDragonPart.java
@@ -27,6 +27,13 @@ public class EnderDragonPart extends Entity {
         this.name = name;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public net.minecraft.world.InteractionResult interact(net.minecraft.world.entity.player.Player player, net.minecraft.world.InteractionHand hand) {
+        return parentMob.isAlive() ? parentMob.tryRide(player, hand) : net.minecraft.world.InteractionResult.PASS;
+    }
+    // Purpur end - Ridables
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
     }
diff --git a/net/minecraft/world/entity/boss/wither/WitherBoss.java b/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 86b6b94c3e63bb52917fe0f708d24aa813f433c7..eb6dfc7e765616fd26f7a22843e646933f6e933b 100644
--- a/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -72,6 +72,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     private final int[] nextHeadUpdate = new int[2];
     private final int[] idleHeadUpdates = new int[2];
     private int destroyBlocksTick;
+    private int shootCooldown = 0; // Purpur - Ridables
     private boolean canPortal = false; // Paper
     public final ServerBossEvent bossEvent = (ServerBossEvent)new ServerBossEvent(
             this.getDisplayName(), BossEvent.BossBarColor.PURPLE, BossEvent.BossBarOverlay.PROGRESS
@@ -80,14 +81,160 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     private static final TargetingConditions.Selector LIVING_ENTITY_SELECTOR = (entity, level) -> !entity.getType().is(EntityTypeTags.WITHER_FRIENDS)
         && entity.attackable();
     private static final TargetingConditions TARGETING_CONDITIONS = TargetingConditions.forCombat().range(20.0).selector(LIVING_ENTITY_SELECTOR);
+    private java.util.@Nullable UUID summoner; // Purpur - Summoner API
+    private org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD purpurController; // Purpur - Ridables
 
     public WitherBoss(EntityType<? extends WitherBoss> type, Level level) {
         super(type, level);
+        // Purpur start - Ridables
+        this.purpurController = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.1F);
+        this.moveControl = new FlyingMoveControl(this, 10, false) {
+            @Override
+            public void tick() {
+                if (mob.getRider() != null && mob.isControllable()) {
+                    purpurController.purpurTick(mob.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
         this.moveControl = new FlyingMoveControl(this, 10, false);
         this.setHealth(this.getMaxHealth());
         this.xpReward = 50;
     }
 
+    // Purpur start - Summoner API
+    public java.util.@Nullable UUID getSummoner() {
+        return summoner;
+    }
+
+    public void setSummoner(java.util.@Nullable UUID summoner) {
+        this.summoner = summoner;
+    }
+    // Purpur end - Summoner API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.witherRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.witherRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.witherControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.witherMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 5F;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 0.5, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        this.entityData.set(DATA_TARGETS.get(0), 0);
+        this.entityData.set(DATA_TARGETS.get(1), 0);
+        this.entityData.set(DATA_TARGETS.get(2), 0);
+        getNavigation().stop();
+        shootCooldown = 20;
+    }
+
+    @Override
+    public boolean onClick(net.minecraft.world.InteractionHand hand) {
+        return shoot(getRider(), hand == net.minecraft.world.InteractionHand.MAIN_HAND ? new int[]{1} : new int[]{2});
+    }
+
+    public boolean shoot(@Nullable Player rider, int[] heads) {
+        if (shootCooldown > 0) {
+            return false;
+        }
+
+        shootCooldown = 20;
+        if (rider == null) {
+            return false;
+        }
+
+        org.bukkit.craftbukkit.entity.CraftHumanEntity player = rider.getBukkitEntity();
+        if (!player.hasPermission("allow.special.wither")) {
+            return false;
+        }
+
+        net.minecraft.world.phys.HitResult rayTrace = getRayTrace(120, net.minecraft.world.level.ClipContext.Fluid.NONE);
+        if (rayTrace == null) {
+            return false;
+        }
+
+        Vec3 loc;
+        if (rayTrace.getType() == net.minecraft.world.phys.HitResult.Type.BLOCK) {
+            BlockPos pos = ((net.minecraft.world.phys.BlockHitResult) rayTrace).getBlockPos();
+            loc = new Vec3(pos.getX() + 0.5D, pos.getY() + 0.5D, pos.getZ() + 0.5D);
+        } else if (rayTrace.getType() == net.minecraft.world.phys.HitResult.Type.ENTITY) {
+            Entity target = ((net.minecraft.world.phys.EntityHitResult) rayTrace).getEntity();
+            loc = new Vec3(target.getX(), target.getY() + (target.getEyeHeight() / 2), target.getZ());
+        } else {
+            org.bukkit.block.Block block = player.getTargetBlock(null, 120);
+            loc = new Vec3(block.getX() + 0.5D, block.getY() + 0.5D, block.getZ() + 0.5D);
+        }
+
+        for (int head : heads) {
+            shoot(head, loc.x(), loc.y(), loc.z(), rider);
+        }
+
+        return true; // handled
+    }
+
+    public void shoot(int head, double x, double y, double z, Player rider) {
+        level().levelEvent(null, 1024, blockPosition(), 0);
+        double headX = getHeadX(head);
+        double headY = getHeadY(head);
+        double headZ = getHeadZ(head);
+        Vec3 vec3d = new Vec3(x - headX, y - headY, z - headZ);
+        WitherSkull skull = new WitherSkull(level(), this, vec3d.normalize());
+        skull.setPosRaw(headX, headY, headZ);
+        level().addFreshEntity(skull);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.witherMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.witherScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.witherTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.witherAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected PathNavigation createNavigation(Level level) {
         FlyingPathNavigation flyingPathNavigation = new FlyingPathNavigation(this, level);
@@ -98,11 +245,13 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new WitherBoss.WitherDoNothingGoal());
         this.goalSelector.addGoal(2, new RangedAttackGoal(this, 1.0, 40, 20.0F));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomFlyingGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(7, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, LivingEntity.class, 0, false, false, LIVING_ENTITY_SELECTOR));
     }
@@ -120,6 +269,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putInt("Invul", this.getInvulnerableTicks());
+        output.storeNullable("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC, getSummoner()); // Purpur - Summoner API
     }
 
     @Override
@@ -129,6 +279,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
         if (this.hasCustomName()) {
             this.bossEvent.setName(this.getDisplayName());
         }
+        this.setSummoner(input.read("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC).orElse(null)); // Purpur - Summoner API
     }
 
     @Override
@@ -260,6 +411,15 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot.x(), mot.y() + (getVerticalMot() > 0 ? 0.07D : 0.0D), mot.z());
+        }
+        if (shootCooldown > 0) {
+            shootCooldown--;
+        }
+        // Purpur end - Ridables
         if (this.getInvulnerableTicks() > 0) {
             int i = this.getInvulnerableTicks() - 1;
             this.bossEvent.setProgress(1.0F - i / 220.0F);
@@ -272,7 +432,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
                     level.explode(this, this.getX(), this.getEyeY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.MOB);
                 }
                 // CraftBukkit end
-                if (!this.isSilent()) {
+                if (!this.isSilent() && level.purpurConfig.witherPlaySpawnSound) { // Purpur - Toggle for Wither's spawn sound
                     // CraftBukkit start - Use relative location for far away sounds
                     // level.globalLevelEvent(LevelEvent.SOUND_WITHER_BOSS_SPAWN, this.blockPosition(), 0);
                     int viewDistance = level.getCraftServer().getViewDistance() * 16;
@@ -297,7 +457,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
             this.setInvulnerableTicks(i);
             if (this.tickCount % 10 == 0) {
-                this.heal(10.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.WITHER_SPAWN); // CraftBukkit
+                this.heal(this.getMaxHealth() / 30, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.WITHER_SPAWN); // CraftBukkit // Purpur - Configurable entity base attributes
             }
         } else {
             super.customServerAiStep(level);
@@ -349,7 +509,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
             if (this.destroyBlocksTick > 0) {
                 this.destroyBlocksTick--;
-                if (this.destroyBlocksTick == 0 && level.getGameRules().get(GameRules.MOB_GRIEFING)) {
+                if (this.destroyBlocksTick == 0 && level.getGameRules().get(GameRules.MOB_GRIEFING, level.purpurConfig.witherMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     boolean flag = false;
                     int alternativeTarget = Mth.floor(this.getBbWidth() / 2.0F + 1.0F);
                     int floor = Mth.floor(this.getBbHeight());
@@ -379,8 +539,10 @@ public class WitherBoss extends Monster implements RangedAttackMob {
                 }
             }
 
-            if (this.tickCount % 20 == 0) {
-                this.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN); // CraftBukkit
+            // Purpur start - Customizable wither health and healing - customizable heal rate and amount
+            if (this.tickCount % level().purpurConfig.witherHealthRegenDelay == 0) {
+                this.heal(level().purpurConfig.witherHealthRegenAmount, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN); // CraftBukkit
+            // Purpur end - Customizable wither health and healing
             }
 
             this.bossEvent.setProgress(this.getHealth() / this.getMaxHealth());
@@ -564,11 +726,11 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     }
 
     public int getAlternativeTarget(int head) {
-        return this.entityData.get(DATA_TARGETS.get(head));
+        return getRider() != null && this.isControllable() ? 0 : this.entityData.get(DATA_TARGETS.get(head)); // Purpur - Ridables
     }
 
     public void setAlternativeTarget(int targetOffset, int newId) {
-        this.entityData.set(DATA_TARGETS.get(targetOffset), newId);
+        if (getRider() == null || !this.isControllable()) this.entityData.set(DATA_TARGETS.get(targetOffset), newId); // Purpur - Ridables
     }
 
     public boolean isPowered() {
@@ -577,6 +739,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
     @Override
     protected boolean canRide(Entity entity) {
+        if (this.level().purpurConfig.witherCanRideVehicles) return this.boardingCooldown <= 0; // Purpur - Configs for if Wither/Ender Dragon can ride vehicles
         return false;
     }
 
diff --git a/net/minecraft/world/entity/decoration/ArmorStand.java b/net/minecraft/world/entity/decoration/ArmorStand.java
index da7c8745863176ca9224dbb037cad63fe354e501..ae18b3a78075a72c927b7362bed18d4ec3dc2360 100644
--- a/net/minecraft/world/entity/decoration/ArmorStand.java
+++ b/net/minecraft/world/entity/decoration/ArmorStand.java
@@ -92,10 +92,13 @@ public class ArmorStand extends LivingEntity {
     public boolean canTickSetByAPI = false;
     public boolean noTickEquipmentDirty = false;
     // Paper end - Allow ArmorStands not to tick
+    public boolean canMovementTick = true; // Purpur - Movement options for armor stands
 
     public ArmorStand(EntityType<? extends ArmorStand> type, Level level) {
         super(type, level);
         if (level != null) this.canTick = level.paperConfig().entities.armorStands.tick; // Paper - Allow ArmorStands not to tick
+        if (level != null) this.canMovementTick = level.purpurConfig.armorstandMovement; // Purpur - Movement options for armor stands
+        this.setShowArms(level != null && level.purpurConfig.armorstandPlaceWithArms); // Purpur - Config to show Armor Stand arms on spawn
     }
 
     public ArmorStand(Level level, double x, double y, double z) {
@@ -448,6 +451,7 @@ public class ArmorStand extends LivingEntity {
 
     private org.bukkit.event.entity.EntityDeathEvent brokenByPlayer(ServerLevel level, DamageSource damageSource) { // Paper
         ItemStack itemStack = new ItemStack(Items.ARMOR_STAND);
+        if (level.purpurConfig.persistentDroppableEntityDisplayNames) // Purpur - Apply display names from item forms of entities to entities and vice versa
         itemStack.set(DataComponents.CUSTOM_NAME, this.getCustomName());
         this.drops.add(new DefaultDrop(itemStack, stack -> Block.popResource(this.level(), this.blockPosition(), stack))); // CraftBukkit - add to drops // Paper - Restore vanilla drops behavior
         return this.brokenByAnything(level, damageSource); // Paper
@@ -522,6 +526,7 @@ public class ArmorStand extends LivingEntity {
     // Paper start - Allow ArmorStands not to tick
     @Override
     public void tick() {
+        maxUpStep = level().purpurConfig.armorstandStepHeight; // Purpur - Add option to set armorstand step height
         if (!this.canTick) {
             if (this.noTickEquipmentDirty) {
                 this.noTickEquipmentDirty = false;
@@ -810,4 +815,18 @@ public class ArmorStand extends LivingEntity {
         }
     }
     // Paper end
+
+    // Purpur start - Movement options for armor stands
+    @Override
+    public void updateInWaterStateAndDoWaterCurrentPushing() {
+        if (this.level().purpurConfig.armorstandWaterMovement &&
+            (this.level().purpurConfig.armorstandWaterFence || !(level().getBlockState(blockPosition().below()).getBlock() instanceof net.minecraft.world.level.block.FenceBlock)))
+            super.updateInWaterStateAndDoWaterCurrentPushing();
+    }
+
+    @Override
+    public void aiStep() {
+        if (this.canMovementTick && this.canMove) super.aiStep();
+    }
+    // Purpur end - Movement options for armor stands
 }
diff --git a/net/minecraft/world/entity/decoration/ItemFrame.java b/net/minecraft/world/entity/decoration/ItemFrame.java
index 462ad83bc08d6d6ae55ee852489439ff6e1dc845..6bcba89a7bbb08f9b37fdada9df37fe4f9de465d 100644
--- a/net/minecraft/world/entity/decoration/ItemFrame.java
+++ b/net/minecraft/world/entity/decoration/ItemFrame.java
@@ -246,7 +246,11 @@ public class ItemFrame extends HangingEntity {
                 this.removeFramedMap(item);
             } else {
                 if (dropItem) {
-                    this.spawnAtLocation(level, this.getFrameItemStack());
+                    // Purpur start - Apply display names from item forms of entities to entities and vice versa
+                    final ItemStack itemFrame = this.getFrameItemStack();
+                    if (!level.purpurConfig.persistentDroppableEntityDisplayNames) itemFrame.set(DataComponents.CUSTOM_NAME, null);
+                    this.spawnAtLocation(level, itemFrame);
+                    // Purpur end - Apply display names from item forms of entities to entities and vice versa
                 }
 
                 if (!item.isEmpty()) {
diff --git a/net/minecraft/world/entity/decoration/painting/Painting.java b/net/minecraft/world/entity/decoration/painting/Painting.java
index 682d6e8c400e3343815be83d74dafe7f16477ba2..32b7bfec3d169166fb607b68e4abf484756327ee 100644
--- a/net/minecraft/world/entity/decoration/painting/Painting.java
+++ b/net/minecraft/world/entity/decoration/painting/Painting.java
@@ -182,7 +182,11 @@ public class Painting extends HangingEntity {
         if (level.getGameRules().get(GameRules.ENTITY_DROPS)) {
             this.playSound(SoundEvents.PAINTING_BREAK, 1.0F, 1.0F);
             if (!(entity instanceof Player player && player.hasInfiniteMaterials())) {
-                this.spawnAtLocation(level, Items.PAINTING);
+                // Purpur start - Apply display names from item forms of entities to entities and vice versa
+                final ItemStack painting = new ItemStack(Items.PAINTING);
+                if (!this.level().purpurConfig.persistentDroppableEntityDisplayNames) painting.set(net.minecraft.core.component.DataComponents.CUSTOM_NAME, null);
+                this.spawnAtLocation(level, painting);
+                // Purpur end - Apply display names from item forms of entities to entities and vice versa
             }
         }
     }
diff --git a/net/minecraft/world/entity/item/ItemEntity.java b/net/minecraft/world/entity/item/ItemEntity.java
index e82bb8f2d2b0e771dc371fd7e709116e1f5f204f..ddf7fa8e67440beb102b6bf91b30f2b340b52a8e 100644
--- a/net/minecraft/world/entity/item/ItemEntity.java
+++ b/net/minecraft/world/entity/item/ItemEntity.java
@@ -54,6 +54,12 @@ public class ItemEntity extends Entity implements TraceableEntity {
     public boolean canMobPickup = true; // Paper - Item#canEntityPickup
     private int despawnRate = -1; // Paper - Alternative item-despawn-rate
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
+    // Purpur start - Item entity immunities
+    public boolean immuneToCactus = false;
+    public boolean immuneToExplosion = false;
+    public boolean immuneToFire = false;
+    public boolean immuneToLightning = false;
+    // Purpur end - Item entity immunities
 
     public ItemEntity(EntityType<? extends ItemEntity> type, Level level) {
         super(type, level);
@@ -330,7 +336,16 @@ public class ItemEntity extends Entity implements TraceableEntity {
 
     @Override
     public final boolean hurtServer(ServerLevel level, DamageSource damageSource, float amount) {
-        if (this.isInvulnerableToBase(damageSource)) {
+        // Purpur start - Item entity immunities
+        if (
+            (immuneToCactus && damageSource.is(net.minecraft.world.damagesource.DamageTypes.CACTUS)) ||
+            (immuneToFire && (damageSource.is(net.minecraft.tags.DamageTypeTags.IS_FIRE) || damageSource.is(net.minecraft.world.damagesource.DamageTypes.ON_FIRE) || damageSource.is(net.minecraft.world.damagesource.DamageTypes.IN_FIRE))) ||
+            (immuneToLightning && damageSource.is(net.minecraft.world.damagesource.DamageTypes.LIGHTNING_BOLT)) ||
+            (immuneToExplosion && damageSource.is(net.minecraft.tags.DamageTypeTags.IS_EXPLOSION))
+        ) {
+            return false;
+        } else if (this.isInvulnerableToBase(damageSource)) {
+        // Purpur end - Item entity immunities
             return false;
         } else if (!level.getGameRules().get(GameRules.MOB_GRIEFING) && damageSource.getEntity() instanceof Mob) {
             return false;
@@ -508,6 +523,12 @@ public class ItemEntity extends Entity implements TraceableEntity {
     public void setItem(ItemStack stack) {
         this.getEntityData().set(DATA_ITEM, stack);
         this.despawnRate = this.level().paperConfig().entities.spawning.altItemDespawnRate.enabled ? this.level().paperConfig().entities.spawning.altItemDespawnRate.items.getOrDefault(stack.getItem(), this.level().spigotConfig.itemDespawnRate) : this.level().spigotConfig.itemDespawnRate; // Paper - Alternative item-despawn-rate
+        // Purpur start - Item entity immunities
+        if (level().purpurConfig.itemImmuneToCactus.contains(stack.getItem())) immuneToCactus = true;
+        if (level().purpurConfig.itemImmuneToExplosion.contains(stack.getItem())) immuneToExplosion = true;
+        if (level().purpurConfig.itemImmuneToFire.contains(stack.getItem())) immuneToFire = true;
+        if (level().purpurConfig.itemImmuneToLightning.contains(stack.getItem())) immuneToLightning = true;
+        // level end - Item entity immunities
     }
 
     @Override
diff --git a/net/minecraft/world/entity/item/PrimedTnt.java b/net/minecraft/world/entity/item/PrimedTnt.java
index 910e7739aea98d6dfa603072acf5e9936dbb2c5e..5dccf56d19dd217ec4b18a390779f0da0c428b98 100644
--- a/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/net/minecraft/world/entity/item/PrimedTnt.java
@@ -235,4 +235,32 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         return !this.level().paperConfig().fixes.preventTntFromMovingInWater && super.isPushedByFluid();
     }
     // Paper end - Option to prevent TNT from moving in water
+
+    // Purpur start - Shears can defuse TNT
+    @Override
+    public net.minecraft.world.InteractionResult interact(net.minecraft.world.entity.player.Player player, net.minecraft.world.InteractionHand hand) {
+        Level world = this.level();
+
+        if (world instanceof ServerLevel serverWorld && level().purpurConfig.shearsCanDefuseTnt) {
+            final net.minecraft.world.item.ItemStack inHand = player.getItemInHand(hand);
+
+            if (!inHand.is(net.minecraft.world.item.Items.SHEARS) || !player.getBukkitEntity().hasPermission("purpur.tnt.defuse") ||
+                    serverWorld.random.nextFloat() > serverWorld.purpurConfig.shearsCanDefuseTntChance) return net.minecraft.world.InteractionResult.PASS;
+
+            net.minecraft.world.entity.item.ItemEntity tntItem = new net.minecraft.world.entity.item.ItemEntity(serverWorld, getX(), getY(), getZ(),
+                    new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.TNT));
+            tntItem.setPickUpDelay(10);
+
+            inHand.hurtAndBreak(1, player, hand.asEquipmentSlot());
+            serverWorld.addFreshEntity(tntItem, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.CUSTOM);
+
+            this.playSound(net.minecraft.sounds.SoundEvents.SHEEP_SHEAR);
+
+            this.kill(serverWorld);
+            return net.minecraft.world.InteractionResult.SUCCESS;
+        }
+
+        return super.interact(player, hand);
+    }
+    // Purpur end - Shears can defuse TNT
 }
diff --git a/net/minecraft/world/entity/monster/Blaze.java b/net/minecraft/world/entity/monster/Blaze.java
index f5539b27261755380312b392fee836cbaaff2e56..187da2d55cdb039b62abe708dadd6c05e13ac64f 100644
--- a/net/minecraft/world/entity/monster/Blaze.java
+++ b/net/minecraft/world/entity/monster/Blaze.java
@@ -34,26 +34,78 @@ public class Blaze extends Monster {
 
     public Blaze(EntityType<? extends Blaze> type, Level level) {
         super(type, level);
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        this.moveControl = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.3F); // Purpur - Ridables
+        if (isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - Toggle for water sensitive mob damage
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
         this.setPathfindingMalus(PathType.DANGER_FIRE, 0.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, 0.0F);
         this.xpReward = 10;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.blazeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.blazeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.blazeControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.blazeMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED);
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 1.0, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.blazeMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.blazeScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.blazeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, new Blaze.BlazeAttackGoal(this));
         this.goalSelector.addGoal(5, new MoveTowardsRestrictionGoal(this, 1.0));
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0, 0.0F));
         this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Monster.createMonsterAttributes().add(Attributes.ATTACK_DAMAGE, 6.0).add(Attributes.MOVEMENT_SPEED, 0.23F).add(Attributes.FOLLOW_RANGE, 48.0);
+        return Monster.createMonsterAttributes().add(Attributes.ATTACK_DAMAGE, 6.0).add(Attributes.MOVEMENT_SPEED, 0.23F).add(Attributes.FOLLOW_RANGE, 48.0).add(Attributes.FLYING_SPEED, 0.6D); // Purpur - Ridables
     }
 
     @Override
@@ -113,11 +165,18 @@ public class Blaze extends Monster {
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.blazeTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot.x(), getVerticalMot() > 0 ? 0.07D : -0.07D, mot.z());
+            return;
+        }
+        // Purpur end - Ridables
         this.nextHeightOffsetChangeTick--;
         if (this.nextHeightOffsetChangeTick <= 0) {
             this.nextHeightOffsetChangeTick = 100;
diff --git a/net/minecraft/world/entity/monster/Creeper.java b/net/minecraft/world/entity/monster/Creeper.java
index e6d93c7a339f06c40b78f554f4e7070fb7fcad02..608d787b73dce1726ccece9e0372acf995f261d4 100644
--- a/net/minecraft/world/entity/monster/Creeper.java
+++ b/net/minecraft/world/entity/monster/Creeper.java
@@ -56,21 +56,107 @@ public class Creeper extends Monster {
     public int explosionRadius = 3;
     public boolean droppedSkulls;
     public @Nullable Entity entityIgniter; // CraftBukkit
+    private boolean exploding = false; // Purpur - Config to make Creepers explode on death
+    // Purpur start - Ridables
+    private int spacebarCharge = 0;
+    private int prevSpacebarCharge = 0;
+    private int powerToggleDelay = 0;
+    // Purpur end - Ridables
 
     public Creeper(EntityType<? extends Creeper> type, Level level) {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.creeperRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.creeperRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.creeperControllable;
+    }
+
+    @Override
+    protected void customServerAiStep(ServerLevel world) {
+        if (powerToggleDelay > 0) {
+            powerToggleDelay--;
+        }
+        if (getRider() != null && this.isControllable()) {
+            if (getRider().getForwardMot() != 0 || getRider().getStrafeMot() != 0) {
+                spacebarCharge = 0;
+                setIgnited(false);
+                setSwellDir(-1);
+            }
+            if (spacebarCharge == prevSpacebarCharge) {
+                spacebarCharge = 0;
+            }
+            prevSpacebarCharge = spacebarCharge;
+        }
+        super.customServerAiStep(world);
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setIgnited(false);
+        setSwellDir(-1);
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (powerToggleDelay > 0) {
+            return true; // just toggled power, do not jump or ignite
+        }
+        spacebarCharge++;
+        if (spacebarCharge > maxSwell - 2) {
+            spacebarCharge = 0;
+            if (getRider() != null && getRider().getBukkitEntity().hasPermission("allow.powered.creeper")) {
+                powerToggleDelay = 20;
+                setPowered(!isPowered());
+                setIgnited(false);
+                setSwellDir(-1);
+                return true;
+            }
+        }
+        if (!isIgnited()) {
+            if (getRider() != null && getRider().getForwardMot() == 0 && getRider().getStrafeMot() == 0 &&
+                    getRider().getBukkitEntity().hasPermission("allow.special.creeper")) {
+                setIgnited(true);
+                setSwellDir(1);
+                return true;
+            }
+        }
+        return getForwardMot() == 0 && getStrafeMot() == 0; // do not jump if standing still
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.creeperMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.creeperScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
         this.goalSelector.addGoal(2, new SwellGoal(this));
+        this.goalSelector.addGoal(3, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Ocelot.class, 6.0F, 1.0, 1.2));
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Cat.class, 6.0F, 1.0, 1.2));
         this.goalSelector.addGoal(4, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 0.8));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(6, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this));
     }
@@ -159,6 +245,41 @@ public class Creeper extends Monster {
         return false; // CraftBukkit
     }
 
+    // Purpur start - Special mobs naturally spawn
+    @Override
+    public net.minecraft.world.entity.SpawnGroupData finalizeSpawn(net.minecraft.world.level.ServerLevelAccessor world, net.minecraft.world.DifficultyInstance difficulty, net.minecraft.world.entity.EntitySpawnReason spawnReason, net.minecraft.world.entity.@Nullable SpawnGroupData entityData) {
+        double chance = world.getLevel().purpurConfig.creeperChargedChance;
+        if (chance > 0D && random.nextDouble() <= chance) {
+            setPowered(true);
+        }
+        return super.finalizeSpawn(world, difficulty, spawnReason, entityData);
+    }
+    // Purpur end - Special mobs naturally spawn
+
+    // Purpur start - Config to make Creepers explode on death
+    @Override
+    protected org.bukkit.event.entity.EntityDeathEvent dropAllDeathLoot(ServerLevel world, DamageSource damageSource) {
+        if (!this.exploding && this.level().purpurConfig.creeperExplodeWhenKilled && damageSource.getEntity() instanceof net.minecraft.server.level.ServerPlayer) {
+            this.explodeCreeper();
+        }
+        return super.dropAllDeathLoot(world, damageSource);
+    }
+    // Purpur end - Config to make Creepers explode on death
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.creeperTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.creeperAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public SoundEvent getHurtSound(DamageSource damageSource) {
         return SoundEvents.CREEPER_HURT;
@@ -243,14 +364,16 @@ public class Creeper extends Monster {
     }
 
     public void explodeCreeper() {
+        this.exploding = true; // Purpur - Config to make Creepers explode on death
         if (this.level() instanceof ServerLevel serverLevel) {
             float f = this.isPowered() ? 2.0F : 1.0F;
+            float multiplier = serverLevel.purpurConfig.creeperHealthRadius ? this.getHealth() / this.getMaxHealth() : 1; // Purpur - Config for health to impact Creeper explosion radius
             // CraftBukkit start
-            org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, this.explosionRadius * f, false);
+            org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, (this.explosionRadius * f) * multiplier, false); // Purpur - Config for health to impact Creeper explosion radius
             if (!event.isCancelled()) {
             // CraftBukkit end
             this.dead = true;
-            serverLevel.explode(this, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.MOB); // CraftBukkit // Paper - fix DamageSource API (revert to vanilla, no, just no, don't change this)
+            serverLevel.explode(this, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), serverLevel.getGameRules().get(net.minecraft.world.level.gamerules.GameRules.MOB_GRIEFING) && level().purpurConfig.creeperAllowGriefing ? Level.ExplosionInteraction.MOB : Level.ExplosionInteraction.NONE); // CraftBukkit // Paper - fix DamageSource API (revert to vanilla, no, just no, don't change this) // Purpur - Add enderman and creeper griefing controls
             this.spawnLingeringCloud();
             this.triggerOnDeathMobEffects(serverLevel, Entity.RemovalReason.KILLED);
             this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.EXPLODE); // CraftBukkit - add Bukkit remove cause
@@ -261,6 +384,7 @@ public class Creeper extends Monster {
             }
             // CraftBukkit end
         }
+        this.exploding = false; // Purpur - Config to make Creepers explode on death
     }
 
     private void spawnLingeringCloud() {
@@ -289,6 +413,7 @@ public class Creeper extends Monster {
             com.destroystokyo.paper.event.entity.CreeperIgniteEvent event = new com.destroystokyo.paper.event.entity.CreeperIgniteEvent((org.bukkit.entity.Creeper) getBukkitEntity(), ignited);
             if (event.callEvent()) {
                 this.entityData.set(DATA_IS_IGNITED, event.isIgnited());
+                if (!event.isIgnited()) setSwellDir(-1); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/monster/ElderGuardian.java b/net/minecraft/world/entity/monster/ElderGuardian.java
index 3a16eb269b733fcf1db5dbc2dfae13009e2278b5..abb7496c293175828fde54ae2b4991aa3ff6b30f 100644
--- a/net/minecraft/world/entity/monster/ElderGuardian.java
+++ b/net/minecraft/world/entity/monster/ElderGuardian.java
@@ -31,6 +31,40 @@ public class ElderGuardian extends Guardian {
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.elderGuardianRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.elderGuardianControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.elderGuardianMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.elderGuardianScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.elderGuardianTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.elderGuardianAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Guardian.createAttributes().add(Attributes.MOVEMENT_SPEED, 0.3F).add(Attributes.ATTACK_DAMAGE, 8.0).add(Attributes.MAX_HEALTH, 80.0);
     }
diff --git a/net/minecraft/world/entity/monster/EnderMan.java b/net/minecraft/world/entity/monster/EnderMan.java
index 6516cccada06a9a7d3d743929712970fe0a2b8c8..c90a955b14ae10037f31c7e9b8a86df3323602cc 100644
--- a/net/minecraft/world/entity/monster/EnderMan.java
+++ b/net/minecraft/world/entity/monster/EnderMan.java
@@ -86,12 +86,45 @@ public class EnderMan extends Monster implements NeutralMob {
 
     public EnderMan(EntityType<? extends EnderMan> type, Level level) {
         super(type, level);
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        if (isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - Toggle for water sensitive mob damage
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.endermanRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.endermanRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.endermanControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.endermanMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.endermanScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.endermanAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new EnderMan.EndermanFreezeWhenLookedAt(this));
         this.goalSelector.addGoal(2, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0, 0.0F));
@@ -99,9 +132,10 @@ public class EnderMan extends Monster implements NeutralMob {
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
         this.goalSelector.addGoal(10, new EnderMan.EndermanLeaveBlockGoal(this));
         this.goalSelector.addGoal(11, new EnderMan.EndermanTakeBlockGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new EnderMan.EndermanLookForPlayerGoal(this, this::isAngryAt));
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this));
-        this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Endermite.class, true, false));
+        this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Endermite.class, 10, true, false, (entityliving, ignored) -> entityliving.level().purpurConfig.endermanAggroEndermites && entityliving instanceof Endermite endermite && (!entityliving.level().purpurConfig.endermanAggroEndermitesOnlyIfPlayerSpawned || endermite.isPlayerSpawned()))); // Purpur
         this.targetSelector.addGoal(4, new ResetUniversalAngerTargetGoal<>(this, false));
     }
 
@@ -220,7 +254,7 @@ public class EnderMan extends Monster implements NeutralMob {
 
     boolean isBeingStaredBy(Player player) {
         // Paper start - EndermanAttackPlayerEvent
-        final boolean shouldAttack = this.isBeingStaredBy0(player);
+        final boolean shouldAttack = !this.level().purpurConfig.endermanDisableStareAggro && this.isBeingStaredBy0(player); // Purpur - Config to ignore Dragon Head wearers and stare aggro
         final com.destroystokyo.paper.event.entity.EndermanAttackPlayerEvent event = new com.destroystokyo.paper.event.entity.EndermanAttackPlayerEvent((org.bukkit.entity.Enderman) getBukkitEntity(), (org.bukkit.entity.Player) player.getBukkitEntity());
         event.setCancelled(!shouldAttack);
         return event.callEvent();
@@ -258,12 +292,12 @@ public class EnderMan extends Monster implements NeutralMob {
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.endermanTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
-        if (level.isBrightOutside() && this.tickCount >= this.targetChangeTime + 600) {
+        if ((getRider() == null || !this.isControllable()) && level.isBrightOutside() && this.tickCount >= this.targetChangeTime + 600) { // Purpur - Ridables - no random teleporting
             float lightLevelDependentMagicValue = this.getLightLevelDependentMagicValue();
             if (lightLevelDependentMagicValue > 0.5F
                 && level.canSeeSky(this.blockPosition())
@@ -375,6 +409,8 @@ public class EnderMan extends Monster implements NeutralMob {
     public boolean hurtServer(ServerLevel level, DamageSource damageSource, float amount) {
         if (this.isInvulnerableTo(level, damageSource)) {
             return false;
+        } else if (getRider() != null && this.isControllable()) { return super.hurtServer(level, damageSource, amount); // Purpur - no teleporting on damage
+        } else if (org.purpurmc.purpur.PurpurConfig.endermanShortHeight && damageSource.is(net.minecraft.world.damagesource.DamageTypes.IN_WALL)) { return false; // Purpur - no suffocation damage if short height - Short enderman height
         } else {
             AbstractThrownPotion abstractThrownPotion1 = damageSource.getDirectEntity() instanceof AbstractThrownPotion abstractThrownPotion
                 ? abstractThrownPotion
@@ -391,6 +427,7 @@ public class EnderMan extends Monster implements NeutralMob {
             } else {
                 boolean flag = abstractThrownPotion1 != null && this.hurtWithCleanWater(level, damageSource, abstractThrownPotion1, amount);
 
+                if (!flag && level.purpurConfig.endermanIgnoreProjectiles) return super.hurtServer(level, damageSource, amount); // Purpur - Config to disable Enderman teleport on projectile hit
                 if (this.tryEscape(com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason.INDIRECT)) { // Paper - EndermanEscapeEvent
                 for (int i = 0; i < 64; i++) {
                     if (this.teleport()) {
@@ -434,7 +471,7 @@ public class EnderMan extends Monster implements NeutralMob {
 
     @Override
     public boolean requiresCustomPersistence() {
-        return super.requiresCustomPersistence() || this.getCarriedBlock() != null;
+        return super.requiresCustomPersistence() || (!this.level().purpurConfig.endermanDespawnEvenWithBlock && this.getCarriedBlock() != null); // Purpur - Add config for allowing Endermen to despawn even while holding a block
     }
 
     static class EndermanFreezeWhenLookedAt extends Goal {
@@ -477,8 +514,9 @@ public class EnderMan extends Monster implements NeutralMob {
 
         @Override
         public boolean canUse() {
+            if (!enderman.level().purpurConfig.endermanAllowGriefing) return false; // Purpur - Add enderman and creeper griefing controls
             return this.enderman.getCarriedBlock() != null
-                && getServerLevel(this.enderman).getGameRules().get(GameRules.MOB_GRIEFING)
+                && getServerLevel(this.enderman).getGameRules().get(GameRules.MOB_GRIEFING, this.enderman.level().purpurConfig.endermanMobGriefingOverride) // Purpur - Add mobGriefing override to everything affected
                 && this.enderman.getRandom().nextInt(reducedTickDelay(2000)) == 0;
         }
 
@@ -625,8 +663,9 @@ public class EnderMan extends Monster implements NeutralMob {
 
         @Override
         public boolean canUse() {
+            if (!enderman.level().purpurConfig.endermanAllowGriefing) return false; // Purpur - Add enderman and creeper griefing controls
             return this.enderman.getCarriedBlock() == null
-                && getServerLevel(this.enderman).getGameRules().get(GameRules.MOB_GRIEFING)
+                && getServerLevel(this.enderman).getGameRules().get(GameRules.MOB_GRIEFING, this.enderman.level().purpurConfig.endermanMobGriefingOverride) // Purpur - Add mobGriefing override to everything affected
                 && this.enderman.getRandom().nextInt(reducedTickDelay(20)) == 0;
         }
 
diff --git a/net/minecraft/world/entity/monster/Endermite.java b/net/minecraft/world/entity/monster/Endermite.java
index 99e262040639ca9fe9caffb71a54319eabcdc0c7..972006a17c887f9380b1549de8a47e4d265e6e69 100644
--- a/net/minecraft/world/entity/monster/Endermite.java
+++ b/net/minecraft/world/entity/monster/Endermite.java
@@ -30,20 +30,72 @@ public class Endermite extends Monster {
     private static final int MAX_LIFE = 2400;
     private static final int DEFAULT_LIFE = 0;
     public int life = 0;
+    private boolean isPlayerSpawned; // Purpur - Add back player spawned endermite API
 
     public Endermite(EntityType<? extends Endermite> type, Level level) {
         super(type, level);
         this.xpReward = 3;
     }
 
+    // Purpur start - Add back player spawned endermite API
+    public boolean isPlayerSpawned() {
+        return this.isPlayerSpawned;
+    }
+
+    public void setPlayerSpawned(boolean playerSpawned) {
+        this.isPlayerSpawned = playerSpawned;
+    }
+    // Purpur end - Add back player spawned endermite API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.endermiteRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.endermiteRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.endermiteControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.endermiteMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.endermiteScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.endermiteTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.endermiteAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(2, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(3, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(7, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
@@ -81,12 +133,14 @@ public class Endermite extends Monster {
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.life = input.getIntOr("Lifetime", 0);
+        this.isPlayerSpawned = input.getBooleanOr("PlayerSpawned", false); // Purpur - Add back player spawned endermite API
     }
 
     @Override
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putInt("Lifetime", this.life);
+        output.putBoolean("PlayerSpawned", this.isPlayerSpawned); // Purpur - Add back player spawned endermite API
     }
 
     @Override
diff --git a/net/minecraft/world/entity/monster/Ghast.java b/net/minecraft/world/entity/monster/Ghast.java
index 605c47f3bd5c4e72389587d50e70fcd57f2a2b27..673d4e06d6dc4c94ddaafcdc86cbdbd686964ddd 100644
--- a/net/minecraft/world/entity/monster/Ghast.java
+++ b/net/minecraft/world/entity/monster/Ghast.java
@@ -53,11 +53,57 @@ public class Ghast extends Mob implements Enemy {
         this.moveControl = new Ghast.GhastMoveControl(this, false, () -> false);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ghastRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ghastRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ghastControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.ghastMaxY;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ghastMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ghastScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ghastTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ghastAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(5, new Ghast.RandomFloatAroundGoal(this));
         this.goalSelector.addGoal(7, new Ghast.GhastLookGoal(this));
         this.goalSelector.addGoal(7, new Ghast.GhastShootFireballGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector
             .addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entity, level) -> Math.abs(entity.getY() - this.getY()) <= 4.0));
     }
@@ -102,6 +148,15 @@ public class Ghast extends Mob implements Enemy {
     @Override
     public void travel(Vec3 travelVector) {
         this.travelFlying(travelVector, 0.02F);
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED);
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 1.0, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+        // Purpur end - Ridables
     }
 
     @Override
@@ -156,6 +211,11 @@ public class Ghast extends Mob implements Enemy {
     public static boolean checkGhastSpawnRules(
         EntityType<Ghast> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (net.minecraft.world.entity.monster.Monster.canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         return level.getDifficulty() != Difficulty.PEACEFUL && random.nextInt(20) == 0 && checkMobSpawnRules(entityType, level, spawnReason, pos, random);
     }
 
@@ -232,7 +292,7 @@ public class Ghast extends Mob implements Enemy {
         }
     }
 
-    public static class GhastMoveControl extends MoveControl {
+    public static class GhastMoveControl extends org.purpurmc.purpur.controller.FlyingMoveControllerWASD { // Purpur - Ridables
         private final Mob ghast;
         private int floatDuration;
         private final boolean careful;
@@ -246,7 +306,7 @@ public class Ghast extends Mob implements Enemy {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.shouldBeStopped.getAsBoolean()) {
                 this.operation = MoveControl.Operation.WAIT;
                 this.ghast.stopInPlace();
diff --git a/net/minecraft/world/entity/monster/Giant.java b/net/minecraft/world/entity/monster/Giant.java
index 0de6a20a3fed53bd11a0152de6953bfaecc85289..9a081135025f114d473c50e68a778e034f33ab82 100644
--- a/net/minecraft/world/entity/monster/Giant.java
+++ b/net/minecraft/world/entity/monster/Giant.java
@@ -12,6 +12,70 @@ public class Giant extends Monster {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.giantRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.giantRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.giantControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        // Purpur start - Giants AI settings
+        if (level().purpurConfig.giantHaveAI) {
+            this.goalSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.FloatGoal(this));
+            this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this));
+            this.goalSelector.addGoal(7, new net.minecraft.world.entity.ai.goal.WaterAvoidingRandomStrollGoal(this, 1.0D));
+            this.goalSelector.addGoal(8, new net.minecraft.world.entity.ai.goal.LookAtPlayerGoal(this, net.minecraft.world.entity.player.Player.class, 16.0F));
+            this.goalSelector.addGoal(8, new net.minecraft.world.entity.ai.goal.RandomLookAroundGoal(this));
+            this.goalSelector.addGoal(5, new net.minecraft.world.entity.ai.goal.MoveTowardsRestrictionGoal(this, 1.0D));
+            if (level().purpurConfig.giantHaveHostileAI) {
+                this.goalSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.MeleeAttackGoal(this, 1.0D, false));
+                this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this));
+                this.targetSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.target.HurtByTargetGoal(this).setAlertOthers(net.minecraft.world.entity.monster.zombie.ZombifiedPiglin.class));
+                this.targetSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.player.Player.class, true));
+                this.targetSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.npc.villager.Villager.class, false));
+                this.targetSelector.addGoal(4, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.animal.golem.IronGolem.class, true));
+                this.targetSelector.addGoal(5, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.animal.turtle.Turtle.class, true));
+            }
+        }
+        // Purpur end - Giants AI settings
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    protected void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.giantMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.giantScale);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.giantMovementSpeed);
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.giantAttackDamage);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.giantTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.giantAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Monster.createMonsterAttributes()
             .add(Attributes.MAX_HEALTH, 100.0)
@@ -20,8 +84,36 @@ public class Giant extends Monster {
             .add(Attributes.CAMERA_DISTANCE, 16.0);
     }
 
+    // Purpur - Giants AI settings
+    @Override
+    public net.minecraft.world.entity.SpawnGroupData finalizeSpawn(net.minecraft.world.level.ServerLevelAccessor world, net.minecraft.world.DifficultyInstance difficulty, net.minecraft.world.entity.EntitySpawnReason spawnReason, @org.jetbrains.annotations.Nullable net.minecraft.world.entity.SpawnGroupData entityData) {
+        net.minecraft.world.entity.SpawnGroupData groupData = super.finalizeSpawn(world, difficulty, spawnReason, entityData);
+        if (groupData == null) {
+            populateDefaultEquipmentSlots(this.random, difficulty);
+            populateDefaultEquipmentEnchantments(world, this.random, difficulty);
+        }
+        return groupData;
+    }
+
+    @Override
+    protected void populateDefaultEquipmentSlots(net.minecraft.util.RandomSource random, net.minecraft.world.DifficultyInstance difficulty) {
+        super.populateDefaultEquipmentSlots(this.random, difficulty);
+        // TODO make configurable
+        if (random.nextFloat() < (level().getDifficulty() == net.minecraft.world.Difficulty.HARD ? 0.1F : 0.05F)) {
+            this.setItemSlot(net.minecraft.world.entity.EquipmentSlot.MAINHAND, new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.IRON_SWORD));
+        }
+    }
+
+    @Override
+    public float getJumpPower() {
+        // make giants jump as high as everything else relative to their size
+        // 1.0 makes bottom of feet about as high as their waist when they jump
+        return level().purpurConfig.giantJumpHeight;
+    }
+    // Purpur end - Giants AI settings
+
     @Override
     public float getWalkTargetValue(BlockPos pos, LevelReader level) {
-        return level.getPathfindingCostFromLightLevels(pos);
+        return super.getWalkTargetValue(pos, level); // Purpur - Giants AI settings - fix light requirements for natural spawns
     }
 }
diff --git a/net/minecraft/world/entity/monster/Guardian.java b/net/minecraft/world/entity/monster/Guardian.java
index 8229de18fbac59493b377b12a281f3f4d74731d7..60490d0611a352ba0546b39fd41259713a7f18b5 100644
--- a/net/minecraft/world/entity/monster/Guardian.java
+++ b/net/minecraft/world/entity/monster/Guardian.java
@@ -65,14 +65,57 @@ public class Guardian extends Monster {
         this.xpReward = 10;
         this.setPathfindingMalus(PathType.WATER, 0.0F);
         this.moveControl = new Guardian.GuardianMoveControl(this);
+        // Purpur start - Ridables
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this) {
+            @Override
+            public void setYawPitch(float yaw, float pitch) {
+                super.setYawPitch(yaw, pitch * 0.35F);
+            }
+        };
+        // Purpur end - Ridables
         this.clientSideTailAnimation = this.random.nextFloat();
         this.clientSideTailAnimationO = this.clientSideTailAnimation;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.guardianRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.guardianControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.guardianMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.guardianScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.guardianTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.guardianAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         MoveTowardsRestrictionGoal moveTowardsRestrictionGoal = new MoveTowardsRestrictionGoal(this, 1.0);
         this.randomStrollGoal = new RandomStrollGoal(this, 1.0, 80);
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, this.guardianAttackGoal = new Guardian.GuardianAttackGoal(this)); // CraftBukkit - assign field
         this.goalSelector.addGoal(5, moveTowardsRestrictionGoal);
         this.goalSelector.addGoal(7, this.randomStrollGoal);
@@ -81,6 +124,7 @@ public class Guardian extends Monster {
         this.goalSelector.addGoal(9, new RandomLookAroundGoal(this));
         this.randomStrollGoal.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.LOOK));
         moveTowardsRestrictionGoal.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.LOOK));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, LivingEntity.class, 10, true, false, new Guardian.GuardianAttackSelector(this)));
     }
 
@@ -312,6 +356,11 @@ public class Guardian extends Monster {
     public static boolean checkGuardianSpawnRules(
         EntityType<? extends Guardian> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         return (random.nextInt(20) == 0 || !level.canSeeSkyFromBelowWater(pos))
             && level.getDifficulty() != Difficulty.PEACEFUL
             && (EntitySpawnReason.isSpawner(spawnReason) || level.getFluidState(pos).is(FluidTags.WATER))
@@ -341,7 +390,7 @@ public class Guardian extends Monster {
 
     @Override
     protected void travelInWater(Vec3 travelVector, double gravity, boolean isFalling, double previousY) {
-        this.moveRelative(0.1F, travelVector);
+        this.moveRelative(getRider() != null && this.isControllable() ? getSpeed() : 0.1F, travelVector); // Purpur - Ridables
         this.move(MoverType.SELF, this.getDeltaMovement());
         this.setDeltaMovement(this.getDeltaMovement().scale(0.9));
         if (!this.isMoving() && this.getTarget() == null) {
@@ -446,7 +495,7 @@ public class Guardian extends Monster {
         }
     }
 
-    static class GuardianMoveControl extends MoveControl {
+    static class GuardianMoveControl extends org.purpurmc.purpur.controller.WaterMoveControllerWASD { // Purpur - Ridables
         private final Guardian guardian;
 
         public GuardianMoveControl(Guardian mob) {
@@ -454,8 +503,17 @@ public class Guardian extends Monster {
             this.guardian = mob;
         }
 
+        // Purpur start - Ridables
         @Override
-        public void tick() {
+        public void purpurTick(Player rider) {
+            super.purpurTick(rider);
+            guardian.setDeltaMovement(guardian.getDeltaMovement().add(0.0D, 0.005D, 0.0D));
+            guardian.setMoving(guardian.getForwardMot() > 0.0F); // control tail speed
+        }
+        // Purpur end - Ridables
+
+        @Override
+        public void vanillaTick() { // Purpur - Ridables
             if (this.operation == MoveControl.Operation.MOVE_TO && !this.guardian.getNavigation().isDone()) {
                 Vec3 vec3 = new Vec3(this.wantedX - this.guardian.getX(), this.wantedY - this.guardian.getY(), this.wantedZ - this.guardian.getZ());
                 double len = vec3.length();
@@ -465,7 +523,7 @@ public class Guardian extends Monster {
                 float f = (float)(Mth.atan2(vec3.z, vec3.x) * 180.0F / (float)Math.PI) - 90.0F;
                 this.guardian.setYRot(this.rotlerp(this.guardian.getYRot(), f, 90.0F));
                 this.guardian.yBodyRot = this.guardian.getYRot();
-                float f1 = (float)(this.speedModifier * this.guardian.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                float f1 = (float)(this.getSpeedModifier() * this.guardian.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                 float f2 = Mth.lerp(0.125F, this.guardian.getSpeed(), f1);
                 this.guardian.setSpeed(f2);
                 double d3 = Math.sin((this.guardian.tickCount + this.guardian.getId()) * 0.5) * 0.05;
diff --git a/net/minecraft/world/entity/monster/MagmaCube.java b/net/minecraft/world/entity/monster/MagmaCube.java
index c534fd2a8639ed6a587692a7e85e560a2fc0b3e5..765a0d0376e344d2f108a5abe97e654bd972c80b 100644
--- a/net/minecraft/world/entity/monster/MagmaCube.java
+++ b/net/minecraft/world/entity/monster/MagmaCube.java
@@ -24,6 +24,64 @@ public class MagmaCube extends Slime {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.magmaCubeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.magmaCubeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.magmaCubeControllable;
+    }
+
+    @Override
+    public float getJumpPower() {
+        return 0.42F * this.getBlockJumpFactor(); // from EntityLiving
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    protected String getMaxHealthEquation() {
+        return level().purpurConfig.magmaCubeMaxHealth;
+    }
+
+    @Override
+    protected String getAttackDamageEquation() {
+        return level().purpurConfig.magmaCubeAttackDamage;
+    }
+
+    @Override
+    protected java.util.Map<Integer, Double> getMaxHealthCache() {
+        return level().purpurConfig.magmaCubeMaxHealthCache;
+    }
+
+    @Override
+    protected java.util.Map<Integer, Double> getAttackDamageCache() {
+        return level().purpurConfig.magmaCubeAttackDamageCache;
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.magmaCubeTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.magmaCubeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Monster.createMonsterAttributes().add(Attributes.MOVEMENT_SPEED, 0.2F);
     }
@@ -31,6 +89,11 @@ public class MagmaCube extends Slime {
     public static boolean checkMagmaCubeSpawnRules(
         EntityType<MagmaCube> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (net.minecraft.world.entity.monster.Monster.canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         return level.getDifficulty() != Difficulty.PEACEFUL;
     }
 
@@ -71,6 +134,7 @@ public class MagmaCube extends Slime {
         float f = this.getSize() * 0.1F;
         this.setDeltaMovement(deltaMovement.x, this.getJumpPower() + f, deltaMovement.z);
         this.needsSync = true;
+        this.actualJump = false; // Purpur - Ridables
     }
 
     @Override
diff --git a/net/minecraft/world/entity/monster/Monster.java b/net/minecraft/world/entity/monster/Monster.java
index 07293a33c45a0834f3b623a47a1bd25f3e059f54..54033572e325f8486a438e31dde34f8407f9180a 100644
--- a/net/minecraft/world/entity/monster/Monster.java
+++ b/net/minecraft/world/entity/monster/Monster.java
@@ -84,6 +84,11 @@ public abstract class Monster extends PathfinderMob implements Enemy {
     }
 
     public static boolean isDarkEnoughToSpawn(ServerLevelAccessor level, BlockPos pos, RandomSource random) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         if (level.getBrightness(LightLayer.SKY, pos) > random.nextInt(32)) {
             return false;
         } else {
@@ -109,6 +114,11 @@ public abstract class Monster extends PathfinderMob implements Enemy {
     public static boolean checkAnyLightMonsterSpawnRules(
         EntityType<? extends Monster> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         return level.getDifficulty() != Difficulty.PEACEFUL && checkMobSpawnRules(entityType, level, spawnReason, pos, random);
     }
 
@@ -146,4 +156,12 @@ public abstract class Monster extends PathfinderMob implements Enemy {
             return ItemStack.EMPTY;
         }
     }
+
+    // Purpur start - Config to disable hostile mob spawn on ice
+    public static boolean canSpawnInBlueAndPackedIce(LevelAccessor level, BlockPos pos) {
+        net.minecraft.world.level.block.state.BlockState spawnBlock = level.getBlockState(pos.below());
+
+        return (!level.getMinecraftWorld().purpurConfig.mobsSpawnOnPackedIce && spawnBlock.is(net.minecraft.world.level.block.Blocks.PACKED_ICE)) || (!level.getMinecraftWorld().purpurConfig.mobsSpawnOnBlueIce && spawnBlock.is(net.minecraft.world.level.block.Blocks.BLUE_ICE));
+    }
+    // Purpur end - Config to disable hostile mob spawn on ice
 }
diff --git a/net/minecraft/world/entity/monster/Phantom.java b/net/minecraft/world/entity/monster/Phantom.java
index 62c40a04a105eff471599c4535239fee9726dbd1..1f3389185ccf997165dc2caf9f78ec560cfd68bd 100644
--- a/net/minecraft/world/entity/monster/Phantom.java
+++ b/net/minecraft/world/entity/monster/Phantom.java
@@ -49,18 +49,100 @@ public class Phantom extends Mob implements Enemy {
     Vec3 moveTargetPoint = Vec3.ZERO;
     @Nullable public BlockPos anchorPoint;
     Phantom.AttackPhase attackPhase = Phantom.AttackPhase.CIRCLE;
+    Vec3 crystalPosition; // Purpur - Phantoms attracted to crystals and crystals shoot phantoms
     // Paper start
     public java.util.@Nullable UUID spawningEntity;
-    public boolean shouldBurnInDay = true;
+    //public boolean shouldBurnInDay = true; // Purpur - API for any mob to burn daylight
     // Paper end
+    private static final net.minecraft.world.item.crafting.Ingredient TORCH = net.minecraft.world.item.crafting.Ingredient.of(net.minecraft.world.item.Items.TORCH, net.minecraft.world.item.Items.SOUL_TORCH); // Purpur - Phantoms burn in light
 
     public Phantom(EntityType<? extends Phantom> type, Level level) {
         super(type, level);
         this.xpReward = 5;
         this.moveControl = new Phantom.PhantomMoveControl(this);
         this.lookControl = new Phantom.PhantomLookControl(this);
+        this.setShouldBurnInDay(true); // Purpur - API for any mob to burn daylight
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.phantomRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.phantomRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.phantomControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.phantomMaxY;
+    }
+
+    public static net.minecraft.world.entity.ai.attributes.AttributeSupplier.Builder createAttributes() {
+        return Monster.createMonsterAttributes().add(Attributes.FLYING_SPEED, 3.0D);
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (getRider() != null && getRider().getBukkitEntity().hasPermission("allow.special.phantom")) {
+            shoot();
+        }
+        return false;
+    }
+
+    public boolean shoot() {
+        org.bukkit.Location loc = ((org.bukkit.entity.LivingEntity) getBukkitEntity()).getEyeLocation();
+        loc.setPitch(-loc.getPitch());
+        org.bukkit.util.Vector target = loc.getDirection().normalize().multiply(100).add(loc.toVector());
+
+        org.purpurmc.purpur.entity.projectile.PhantomFlames flames = new org.purpurmc.purpur.entity.projectile.PhantomFlames(level(), this);
+        flames.canGrief = level().purpurConfig.phantomAllowGriefing;
+        flames.shoot(target.getX() - getX(), target.getY() - getY(), target.getZ() - getZ(), 1.0F, 5.0F);
+        level().addFreshEntity(flames);
+        return true;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+    @Override
+    protected void dropFromLootTable(ServerLevel world, DamageSource damageSource, boolean causedByPlayer) {
+        boolean dropped = false;
+        if (lastHurtByPlayer == null && damageSource.getEntity() instanceof net.minecraft.world.entity.boss.enderdragon.EndCrystal) {
+            if (random.nextInt(5) < 1) {
+                dropped = spawnAtLocation(world, new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.PHANTOM_MEMBRANE)) != null;
+            }
+        }
+        if (!dropped) {
+            super.dropFromLootTable(world, damageSource, causedByPlayer);
+        }
+    }
+
+    public boolean isCirclingCrystal() {
+        return crystalPosition != null;
+    }
+    // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.phantomTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.phantomAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isFlapping() {
         return (this.getUniqueFlapTickOffset() + this.tickCount) % TICKS_PER_FLAP == 0;
@@ -73,9 +155,17 @@ public class Phantom extends Mob implements Enemy {
 
     @Override
     protected void registerGoals() {
-        this.goalSelector.addGoal(1, new Phantom.PhantomAttackStrategyGoal());
-        this.goalSelector.addGoal(2, new Phantom.PhantomSweepAttackGoal());
-        this.goalSelector.addGoal(3, new Phantom.PhantomCircleAroundAnchorGoal());
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+        if (level().purpurConfig.phantomOrbitCrystalRadius > 0) {
+            this.goalSelector.addGoal(1, new PhantomFindCrystalGoal(this));
+            this.goalSelector.addGoal(2, new PhantomOrbitCrystalGoal(this));
+        }
+        this.goalSelector.addGoal(3, new Phantom.PhantomAttackStrategyGoal());
+        this.goalSelector.addGoal(4, new Phantom.PhantomSweepAttackGoal());
+        this.goalSelector.addGoal(5, new Phantom.PhantomCircleAroundAnchorGoal());
+        // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Phantom.PhantomAttackPlayerTargetGoal());
     }
 
@@ -91,7 +181,11 @@ public class Phantom extends Mob implements Enemy {
 
     private void updatePhantomSizeInfo() {
         this.refreshDimensions();
-        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(6 + this.getPhantomSize());
+        if (level().purpurConfig.phantomFlamesOnSwoop && attackPhase == AttackPhase.SWOOP) shoot(); // Purpur - Ridables - Phantom flames on swoop
+        // Purpur start - Configurable entity base attributes
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(getFromCache(() -> this.level().purpurConfig.phantomMaxHealth, () -> this.level().purpurConfig.phantomMaxHealthCache, () -> 20.0D));
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(getFromCache(() -> this.level().purpurConfig.phantomAttackDamage, () -> this.level().purpurConfig.phantomAttackDamageCache, () -> (double) (6 + this.getPhantomSize())));
+        // Purpur end - Configurable entity base attributes
     }
 
     public int getPhantomSize() {
@@ -111,6 +205,23 @@ public class Phantom extends Mob implements Enemy {
         return this.getId() * 3;
     }
 
+    // Purpur start - Configurable entity base attributes
+    private double getFromCache(java.util.function.Supplier<String> equation, java.util.function.Supplier<java.util.Map<Integer, Double>> cache, java.util.function.Supplier<Double> defaultValue) {
+        int size = getPhantomSize();
+        Double value = cache.get().get(size);
+        if (value == null) {
+            try {
+                value = ((Number) scriptEngine.eval("let size = " + size + "; " + equation.get())).doubleValue();
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                value = defaultValue.get();
+            }
+            cache.get().put(size, value);
+        }
+        return value;
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     public void tick() {
         super.tick();
@@ -143,7 +254,11 @@ public class Phantom extends Mob implements Enemy {
     // Paper start
     @Override
     public boolean isSunBurnTick() {
-        return this.shouldBurnInDay && super.isSunBurnTick();
+        // Purpur start - API for any mob to burn daylight
+        boolean burnFromDaylight = this.shouldBurnInDay && super.isSunBurnTick() && this.level().purpurConfig.phantomBurnInDaylight;
+        boolean burnFromLightSource = this.level().purpurConfig.phantomBurnInLight > 0 && this.level().getMaxLocalRawBrightness(blockPosition()) >= this.level().purpurConfig.phantomBurnInLight;
+        return burnFromDaylight || burnFromLightSource;
+        // Purpur end - API for any mob to burn daylight
     }
     // Paper end
 
@@ -159,6 +274,15 @@ public class Phantom extends Mob implements Enemy {
     @Override
     public void travel(Vec3 travelVector) {
         this.travelFlying(travelVector, 0.2F);
+        // Purpur start - Ridables
+        if (this.getRider() != null && this.isControllable() && !this.onGround) {
+            float speed = (float) this.getAttributeValue(Attributes.FLYING_SPEED);
+            this.setSpeed(speed);
+            Vec3 mot = this.getDeltaMovement();
+            this.move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, speed, speed));
+            this.setDeltaMovement(mot.scale(0.9D));
+        }
+        // Purpur end - Ridables
     }
 
     @Override
@@ -166,7 +290,11 @@ public class Phantom extends Mob implements Enemy {
         ServerLevelAccessor level, DifficultyInstance difficulty, EntitySpawnReason spawnReason, @Nullable SpawnGroupData spawnGroupData
     ) {
         this.anchorPoint = this.blockPosition().above(5);
-        this.setPhantomSize(0);
+        // Purpur start - Configurable phantom size
+        int min = level.getLevel().purpurConfig.phantomMinSize;
+        int max = level.getLevel().purpurConfig.phantomMaxSize;
+        this.setPhantomSize(min == max ? min : level.getRandom().nextInt(max + 1 - min) + min);
+        // Purpur end - Configurable phantom size
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
@@ -177,7 +305,7 @@ public class Phantom extends Mob implements Enemy {
         this.setPhantomSize(input.getIntOr("size", 0));
         // Paper start
         this.spawningEntity = input.read("Paper.SpawningEntity", net.minecraft.core.UUIDUtil.CODEC).orElse(null);
-        this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true);
+        //this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Purpur - implemented in LivingEntity - API for any mob to burn daylight
         // Paper end
     }
 
@@ -188,7 +316,7 @@ public class Phantom extends Mob implements Enemy {
         output.putInt("size", this.getPhantomSize());
         // Paper start
         output.storeNullable("Paper.SpawningEntity", net.minecraft.core.UUIDUtil.CODEC, this.spawningEntity);
-        output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay);
+        //output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - implemented in LivingEntity - API for any mob to burn daylight
         // Paper end
     }
 
@@ -258,6 +386,7 @@ public class Phantom extends Mob implements Enemy {
                 List<Player> nearbyPlayers = serverLevel.getNearbyPlayers(
                     this.attackTargeting, Phantom.this, Phantom.this.getBoundingBox().inflate(16.0, 64.0, 16.0)
                 );
+                if (level().purpurConfig.phantomIgnorePlayersWithTorch) nearbyPlayers.removeIf(human -> TORCH.test(human.getItemInHand(net.minecraft.world.InteractionHand.MAIN_HAND)) || TORCH.test(human.getItemInHand(net.minecraft.world.InteractionHand.OFF_HAND))); // Purpur - Phantoms burn in light
                 if (!nearbyPlayers.isEmpty()) {
                     nearbyPlayers.sort(Comparator.<Player, Double>comparing(Entity::getY).reversed());
 
@@ -408,25 +537,160 @@ public class Phantom extends Mob implements Enemy {
         }
     }
 
-    static class PhantomLookControl extends LookControl {
+    static class PhantomLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         public PhantomLookControl(Mob mob) {
             super(mob);
         }
 
+        // Purpur start - Ridables
+        public void purpurTick(Player rider) {
+            setYawPitch(rider.getYRot(), -rider.xRotO * 0.75F);
+        }
+        // Purpur end - Ridables
+
+        @Override
+        public void vanillaTick() { // Purpur - Ridables
+        }
+    }
+
+    // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+    class PhantomFindCrystalGoal extends Goal {
+        private final Phantom phantom;
+        private net.minecraft.world.entity.boss.enderdragon.EndCrystal crystal;
+        private Comparator<net.minecraft.world.entity.boss.enderdragon.EndCrystal> comparator;
+
+        PhantomFindCrystalGoal(Phantom phantom) {
+            this.phantom = phantom;
+            this.comparator = Comparator.comparingDouble(phantom::distanceToSqr);
+            this.setFlags(EnumSet.of(Flag.LOOK));
+        }
+
+        @Override
+        public boolean canUse() {
+            double range = maxTargetRange();
+            List<net.minecraft.world.entity.boss.enderdragon.EndCrystal> crystals = level().getEntitiesOfClass(net.minecraft.world.entity.boss.enderdragon.EndCrystal.class, phantom.getBoundingBox().inflate(range));
+            if (crystals.isEmpty()) {
+                return false;
+            }
+            crystals.sort(comparator);
+            crystal = crystals.get(0);
+            if (phantom.distanceToSqr(crystal) > range * range) {
+                crystal = null;
+                return false;
+            }
+            return true;
+        }
+
+        @Override
+        public boolean canContinueToUse() {
+            if (crystal == null || !crystal.isAlive()) {
+                return false;
+            }
+            double range = maxTargetRange();
+            return phantom.distanceToSqr(crystal) <= (range * range) * 2;
+        }
+
+        @Override
+        public void start() {
+            phantom.crystalPosition = new Vec3(crystal.getX(), crystal.getY() + (phantom.random.nextInt(10) + 10), crystal.getZ());
+        }
+
+        @Override
+        public void stop() {
+            crystal = null;
+            phantom.crystalPosition = null;
+            super.stop();
+        }
+
+        private double maxTargetRange() {
+            return phantom.level().purpurConfig.phantomOrbitCrystalRadius;
+        }
+    }
+
+    class PhantomOrbitCrystalGoal extends Goal {
+        private final Phantom phantom;
+        private float offset;
+        private float radius;
+        private float verticalChange;
+        private float direction;
+
+        PhantomOrbitCrystalGoal(Phantom phantom) {
+            this.phantom = phantom;
+            this.setFlags(EnumSet.of(Flag.MOVE));
+        }
+
+        @Override
+        public boolean canUse() {
+            return phantom.isCirclingCrystal();
+        }
+
+        @Override
+        public void start() {
+            this.radius = 5.0F + phantom.random.nextFloat() * 10.0F;
+            this.verticalChange = -4.0F + phantom.random.nextFloat() * 9.0F;
+            this.direction = phantom.random.nextBoolean() ? 1.0F : -1.0F;
+            updateOffset();
+        }
+
         @Override
         public void tick() {
+            if (phantom.random.nextInt(350) == 0) {
+                this.verticalChange = -4.0F + phantom.random.nextFloat() * 9.0F;
+            }
+            if (phantom.random.nextInt(250) == 0) {
+                ++this.radius;
+                if (this.radius > 15.0F) {
+                    this.radius = 5.0F;
+                    this.direction = -this.direction;
+                }
+            }
+            if (phantom.random.nextInt(450) == 0) {
+                this.offset = phantom.random.nextFloat() * 2.0F * 3.1415927F;
+                updateOffset();
+            }
+            if (phantom.moveTargetPoint.distanceToSqr(phantom.getX(), phantom.getY(), phantom.getZ()) < 4.0D) {
+                updateOffset();
+            }
+            if (phantom.moveTargetPoint.y < phantom.getY() && !phantom.level().isEmptyBlock(new BlockPos(phantom).below(1))) {
+                this.verticalChange = Math.max(1.0F, this.verticalChange);
+                updateOffset();
+            }
+            if (phantom.moveTargetPoint.y > phantom.getY() && !phantom.level().isEmptyBlock(new BlockPos(phantom).above(1))) {
+                this.verticalChange = Math.min(-1.0F, this.verticalChange);
+                updateOffset();
+            }
+        }
+
+        private void updateOffset() {
+            this.offset += this.direction * 15.0F * 0.017453292F;
+            phantom.moveTargetPoint = phantom.crystalPosition.add(
+                    this.radius * Mth.cos(this.offset),
+                    -4.0F + this.verticalChange,
+                    this.radius * Mth.sin(this.offset));
         }
     }
+    // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
 
-    class PhantomMoveControl extends MoveControl {
+    class PhantomMoveControl extends org.purpurmc.purpur.controller.FlyingMoveControllerWASD { // Purpur - Ridables
         private float speed = 0.1F;
 
         public PhantomMoveControl(final Mob mob) {
             super(mob);
         }
 
+        // Purpur start - Ridables
+        public void purpurTick(Player rider) {
+            if (!Phantom.this.onGround) {
+                // phantom is always in motion when flying
+                // TODO - FIX THIS
+                // rider.setForward(1.0F);
+            }
+            super.purpurTick(rider);
+        }
+        // Purpur end - Ridables
+
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Phantom.this.horizontalCollision) {
                 Phantom.this.setYRot(Phantom.this.getYRot() + 180.0F);
                 this.speed = 0.1F;
@@ -493,6 +757,12 @@ public class Phantom extends Mob implements Enemy {
                 return false;
             } else if (!target.isAlive()) {
                 return false;
+            // Purpur start - Phantoms burn in light
+            } else if (level().purpurConfig.phantomBurnInLight > 0 && level().getLightEmission(new BlockPos(Phantom.this)) >= level().purpurConfig.phantomBurnInLight) {
+                return false;
+            } else if (level().purpurConfig.phantomIgnorePlayersWithTorch && (TORCH.test(target.getItemInHand(net.minecraft.world.InteractionHand.MAIN_HAND)) || TORCH.test(target.getItemInHand(net.minecraft.world.InteractionHand.OFF_HAND)))) {
+                return false;
+            // Purpur end - Phantoms burn in light
             } else if (target instanceof Player player && (target.isSpectator() || player.isCreative())) {
                 return false;
             } else if (!this.canUse()) {
diff --git a/net/minecraft/world/entity/monster/Ravager.java b/net/minecraft/world/entity/monster/Ravager.java
index 631092f088355be45f598bb91bd5d38a39a55d5b..5e6fd02985eef337f2ff8e48fbd904a064c0560a 100644
--- a/net/minecraft/world/entity/monster/Ravager.java
+++ b/net/minecraft/world/entity/monster/Ravager.java
@@ -72,14 +72,62 @@ public class Ravager extends Raider {
         this.setPathfindingMalus(PathType.LEAVES, 0.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ravagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ravagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ravagerControllable;
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        getNavigation().stop();
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ravagerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ravagerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ravagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ravagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        if (level().purpurConfig.ravagerAvoidRabbits) this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.AvoidEntityGoal<>(this, net.minecraft.world.entity.animal.rabbit.Rabbit.class, 6.0F, 1.0D, 1.2D)); // Purpur - option to make ravagers afraid of rabbits
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, new MeleeAttackGoal(this, 1.0, true));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 0.4));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(4, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, true, (entity, level) -> !entity.isBaby()));
@@ -136,7 +184,7 @@ public class Ravager extends Raider {
     @Override
     public void aiStep() {
         super.aiStep();
-        if (this.isAlive()) {
+        if (this.isAlive() && (getRider() == null || !this.isControllable())) { // Purpur - Ridables
             if (this.isImmobile()) {
                 this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(0.0);
             } else {
@@ -145,7 +193,7 @@ public class Ravager extends Raider {
                 this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(Mth.lerp(0.1, baseValue, d));
             }
 
-            if (this.level() instanceof ServerLevel serverLevel && this.horizontalCollision && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING)) {
+            if (this.level() instanceof ServerLevel serverLevel && this.horizontalCollision && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.ravagerMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                 boolean flag = false;
                 AABB aabb = this.getBoundingBox().inflate(0.2);
 
@@ -154,7 +202,7 @@ public class Ravager extends Raider {
                 )) {
                     BlockState blockState = serverLevel.getBlockState(blockPos);
                     Block block = blockState.getBlock();
-                    if (block instanceof LeavesBlock) {
+                    if (this.level().purpurConfig.ravagerGriefableBlocks.contains(block)) { // Purpur - Configurable ravager griefable blocks list
                         // CraftBukkit start
                         if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, blockPos, blockState.getFluidState().createLegacyBlock())) { // Paper - fix wrong block state
                             continue;
diff --git a/net/minecraft/world/entity/monster/Shulker.java b/net/minecraft/world/entity/monster/Shulker.java
index 935c608ba0fc2246a3f79bf4865cfeb6fe68b0f4..2b73382e5bcf47da483ea88e2eae480ebb48e8f9 100644
--- a/net/minecraft/world/entity/monster/Shulker.java
+++ b/net/minecraft/world/entity/monster/Shulker.java
@@ -93,12 +93,68 @@ public class Shulker extends AbstractGolem implements Enemy {
         this.lookControl = new Shulker.ShulkerLookControl(this);
     }
 
+    // Purpur start - Shulker change color with dye
+    @Override
+    protected net.minecraft.world.InteractionResult mobInteract(Player player, net.minecraft.world.InteractionHand hand) {
+        net.minecraft.world.item.ItemStack itemstack = player.getItemInHand(hand);
+        if (player.level().purpurConfig.shulkerChangeColorWithDye && itemstack.getItem() instanceof net.minecraft.world.item.DyeItem dye && dye.getDyeColor() != this.getColor()) {
+            this.setVariant(Optional.of(dye.getDyeColor()));
+            if (!player.getAbilities().instabuild) {
+                itemstack.shrink(1);
+            }
+            return net.minecraft.world.InteractionResult.SUCCESS;
+        }
+        return super.mobInteract(player, hand);
+    }
+    // Purpur end - Shulker change color with dye
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.shulkerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.shulkerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.shulkerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.shulkerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.shulkerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.shulkerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.shulkerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new LookAtPlayerGoal(this, Player.class, 8.0F, 0.02F, true));
         this.goalSelector.addGoal(4, new Shulker.ShulkerAttackGoal());
         this.goalSelector.addGoal(7, new Shulker.ShulkerPeekGoal());
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, this.getClass()).setAlertOthers());
         this.targetSelector.addGoal(2, new Shulker.ShulkerNearestAttackGoal(this));
         this.targetSelector.addGoal(3, new Shulker.ShulkerDefenseAttackGoal(this));
@@ -454,11 +510,21 @@ public class Shulker extends AbstractGolem implements Enemy {
     private void hitByShulkerBullet() {
         Vec3 vec3 = this.position();
         AABB boundingBox = this.getBoundingBox();
-        if (!this.isClosed() && this.teleportSomewhere()) {
-            int size = this.level().getEntities(EntityType.SHULKER, boundingBox.inflate(8.0), Entity::isAlive).size();
-            float f = (size - 1) / 5.0F;
-            if (!(this.level().random.nextFloat() < f)) {
+        // Purpur start - Shulker spawn from bullet options
+        if ((!this.level().purpurConfig.shulkerSpawnFromBulletRequireOpenLid || !this.isClosed()) && this.teleportSomewhere()) {
+            float chance = this.level().purpurConfig.shulkerSpawnFromBulletBaseChance;
+            if (!this.level().purpurConfig.shulkerSpawnFromBulletNearbyEquation.isBlank()) {
+                int nearby = this.level().getEntities((net.minecraft.world.level.entity.EntityTypeTest) EntityType.SHULKER, boundingBox.inflate(this.level().purpurConfig.shulkerSpawnFromBulletNearbyRange), Entity::isAlive).size();
+                try {
+                    chance -= ((Number) scriptEngine.eval("let nearby = " + nearby + "; " + this.level().purpurConfig.shulkerSpawnFromBulletNearbyEquation)).floatValue();
+                } catch (javax.script.ScriptException e) {
+                    e.printStackTrace();
+                    chance -= (nearby - 1) / 5.0F;
+                }
+            }
+            if (this.level().random.nextFloat() <= chance) {
                 Shulker shulker = EntityType.SHULKER.create(this.level(), EntitySpawnReason.BREEDING);
+                // Purpur end - Shulker spawn from bullet options
                 if (shulker != null) {
                     shulker.setVariant(this.getVariant());
                     shulker.snapTo(vec3);
@@ -557,7 +623,7 @@ public class Shulker extends AbstractGolem implements Enemy {
 
     @Override
     protected float sanitizeScale(float scale) {
-        return Math.min(scale, 3.0F);
+        return Math.min(scale, MAX_SCALE); // Purpur - Configurable entity base attributes
     }
 
     private void setVariant(Optional<DyeColor> variant) {
@@ -565,7 +631,7 @@ public class Shulker extends AbstractGolem implements Enemy {
     }
 
     public Optional<DyeColor> getVariant() {
-        return Optional.ofNullable(this.getColor());
+        return Optional.ofNullable(this.level().purpurConfig.shulkerSpawnFromBulletRandomColor ? DyeColor.random(this.level().random) : this.getColor()); // Purpur - Shulker spawn from bullet options
     }
 
     public @Nullable DyeColor getColor() {
@@ -683,7 +749,7 @@ public class Shulker extends AbstractGolem implements Enemy {
         }
     }
 
-    class ShulkerLookControl extends LookControl {
+    class ShulkerLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         public ShulkerLookControl(final Mob mob) {
             super(mob);
         }
diff --git a/net/minecraft/world/entity/monster/Silverfish.java b/net/minecraft/world/entity/monster/Silverfish.java
index 142f776ea2bfcd434d045a78d5629cd05b006b20..ba80f86980b6789bf944a4350b6f89d644cc283d 100644
--- a/net/minecraft/world/entity/monster/Silverfish.java
+++ b/net/minecraft/world/entity/monster/Silverfish.java
@@ -38,14 +38,57 @@ public class Silverfish extends Monster {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.silverfishRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.silverfishRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.silverfishControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.silverfishMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.silverfishScale);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.silverfishMovementSpeed);
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.silverfishAttackDamage);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.silverfishTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.silverfishAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.friendsGoal = new Silverfish.SilverfishWakeUpFriendsGoal(this);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(3, this.friendsGoal);
         this.goalSelector.addGoal(4, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(5, new Silverfish.SilverfishMergeWithStoneGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
@@ -139,7 +182,7 @@ public class Silverfish extends Monster {
                 return false;
             } else {
                 RandomSource random = this.mob.getRandom();
-                if (getServerLevel(this.mob).getGameRules().get(GameRules.MOB_GRIEFING) && random.nextInt(reducedTickDelay(10)) == 0) {
+                if (getServerLevel(this.mob).getGameRules().get(GameRules.MOB_GRIEFING, getServerLevel(this.mob).purpurConfig.silverfishMobGriefingOverride) && random.nextInt(reducedTickDelay(10)) == 0) { // Purpur - Add mobGriefing override to everything affected
                     this.selectedDirection = Direction.getRandom(random);
                     BlockPos blockPos = BlockPos.containing(this.mob.getX(), this.mob.getY() + 0.5, this.mob.getZ()).relative(this.selectedDirection);
                     BlockState blockState = this.mob.level().getBlockState(blockPos);
@@ -216,7 +259,7 @@ public class Silverfish extends Monster {
                             Block block = blockState.getBlock();
                             if (block instanceof InfestedBlock) {
                                 // CraftBukkit start
-                                BlockState afterState = getServerLevel(level).getGameRules().get(GameRules.MOB_GRIEFING) ? blockState.getFluidState().createLegacyBlock() : ((InfestedBlock) block).hostStateByInfested(level.getBlockState(blockPos1)); // Paper - fix wrong block state
+                                BlockState afterState = getServerLevel(level).getGameRules().get(GameRules.MOB_GRIEFING, getServerLevel(level).purpurConfig.silverfishMobGriefingOverride) ? blockState.getFluidState().createLegacyBlock() : ((InfestedBlock) block).hostStateByInfested(level.getBlockState(blockPos1)); // Paper - fix wrong block state // Purpur - Add mobGriefing override to everything affected
                                 if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.silverfish, blockPos1, afterState)) { // Paper - fix wrong block state
                                     continue;
                                 }
diff --git a/net/minecraft/world/entity/monster/Slime.java b/net/minecraft/world/entity/monster/Slime.java
index f1eb8c9120a4794b1b70777c272e1a0491fa5164..29d6d0c9687b835d24fe51c3824deeb67af1ba4f 100644
--- a/net/minecraft/world/entity/monster/Slime.java
+++ b/net/minecraft/world/entity/monster/Slime.java
@@ -60,6 +60,7 @@ public class Slime extends Mob implements Enemy {
     public float oSquish;
     private boolean wasOnGround = false;
     private boolean canWander = true; // Paper - Slime pathfinder events
+    protected boolean actualJump; // Purpur - Ridables
 
     public Slime(EntityType<? extends Slime> type, Level level) {
         super(type, level);
@@ -67,12 +68,95 @@ public class Slime extends Mob implements Enemy {
         this.moveControl = new Slime.SlimeMoveControl(this);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.slimeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.slimeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.slimeControllable;
+    }
+
+    @Override
+    public float getJumpPower() {
+        float height = super.getJumpPower();
+        return getRider() != null && this.isControllable() && actualJump ? height * 1.5F : height;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (onGround && getRider() != null && this.isControllable()) {
+            actualJump = true;
+            if (getRider().getForwardMot() == 0 || getRider().getStrafeMot() == 0) {
+                jumpFromGround(); // jump() here if not moving
+            }
+        }
+        return true; // do not jump() in wasd controller, let vanilla controller handle
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    protected String getMaxHealthEquation() {
+        return level().purpurConfig.slimeMaxHealth;
+    }
+
+    protected String getAttackDamageEquation() {
+        return level().purpurConfig.slimeAttackDamage;
+    }
+
+    protected java.util.Map<Integer, Double> getMaxHealthCache() {
+        return level().purpurConfig.slimeMaxHealthCache;
+    }
+
+    protected java.util.Map<Integer, Double> getAttackDamageCache() {
+        return level().purpurConfig.slimeAttackDamageCache;
+    }
+
+    protected double getFromCache(java.util.function.Supplier<String> equation, java.util.function.Supplier<java.util.Map<Integer, Double>> cache, java.util.function.Supplier<Double> defaultValue) {
+        int size = getSize();
+        Double value = cache.get().get(size);
+        if (value == null) {
+            try {
+                value = ((Number) scriptEngine.eval("let size = " + size + "; " + equation.get())).doubleValue();
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                value = defaultValue.get();
+            }
+            cache.get().put(size, value);
+        }
+        return value;
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.slimeTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.slimeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Slime.SlimeFloatGoal(this));
         this.goalSelector.addGoal(2, new Slime.SlimeAttackGoal(this));
         this.goalSelector.addGoal(3, new Slime.SlimeRandomDirectionGoal(this));
         this.goalSelector.addGoal(5, new Slime.SlimeKeepOnJumpingGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector
             .addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entity, level) -> Math.abs(entity.getY() - this.getY()) <= 4.0));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
@@ -95,9 +179,9 @@ public class Slime extends Mob implements Enemy {
         this.entityData.set(ID_SIZE, i);
         this.reapplyPosition();
         this.refreshDimensions();
-        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(i * i);
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(getFromCache(this::getMaxHealthEquation, this::getMaxHealthCache, () -> (double) (size * size))); // Purpur - Configurable entity base attributes
         this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(0.2F + 0.1F * i);
-        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(i);
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(getFromCache(this::getAttackDamageEquation, this::getAttackDamageCache, () -> (double) i)); // Purpur - Configurable entity base attributes
         if (resetHealth) {
             this.setHealth(this.getMaxHealth());
         }
@@ -302,6 +386,11 @@ public class Slime extends Mob implements Enemy {
     public static boolean checkSlimeSpawnRules(
         EntityType<Slime> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (net.minecraft.world.entity.monster.Monster.canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         if (level.getDifficulty() != Difficulty.PEACEFUL) {
             if (EntitySpawnReason.isSpawner(spawnReason)) {
                 return checkMobSpawnRules(entityType, level, spawnReason, pos, random);
@@ -354,6 +443,7 @@ public class Slime extends Mob implements Enemy {
         Vec3 deltaMovement = this.getDeltaMovement();
         this.setDeltaMovement(deltaMovement.x, this.getJumpPower(), deltaMovement.z);
         this.needsSync = true;
+        this.actualJump = false; // Purpur - Ridables
     }
 
     @Override
@@ -517,7 +607,7 @@ public class Slime extends Mob implements Enemy {
         }
     }
 
-    static class SlimeMoveControl extends MoveControl {
+    static class SlimeMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private float yRot;
         private int jumpDelay;
         private final Slime slime;
@@ -535,21 +625,33 @@ public class Slime extends Mob implements Enemy {
         }
 
         public void setWantedMovement(double speedModifier) {
-            this.speedModifier = speedModifier;
+            this.setSpeedModifier(speedModifier); // Purpur - Ridables
             this.operation = MoveControl.Operation.MOVE_TO;
         }
 
         @Override
         public void tick() {
+            // Purpur start - Ridables
+            if (slime.getRider() != null && slime.isControllable()) {
+                purpurTick(slime.getRider());
+                if (slime.getForwardMot() != 0 || slime.getStrafeMot() != 0) {
+                    if (jumpDelay > 10) {
+                        jumpDelay = 6;
+                    }
+                } else {
+                    jumpDelay = 20;
+                }
+            } else {
+            // Purpur end - Ridables
             this.mob.setYRot(this.rotlerp(this.mob.getYRot(), this.yRot, 90.0F));
             this.mob.yHeadRot = this.mob.getYRot();
             this.mob.yBodyRot = this.mob.getYRot();
-            if (this.operation != MoveControl.Operation.MOVE_TO) {
+            } if ((slime.getRider() == null || !slime.isControllable()) && this.operation != MoveControl.Operation.MOVE_TO) { // Purpur - Ridables
                 this.mob.setZza(0.0F);
             } else {
                 this.operation = MoveControl.Operation.WAIT;
                 if (this.mob.onGround()) {
-                    this.mob.setSpeed((float)(this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
+                    this.mob.setSpeed((float)(this.getSpeedModifier() * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED) * (slime.getRider() != null && slime.isControllable() && (slime.getRider().getForwardMot() != 0 || slime.getRider().getStrafeMot() != 0) ? 2.0D : 1.0D))); // Purpur - Ridables
                     if (this.jumpDelay-- <= 0) {
                         this.jumpDelay = this.slime.getJumpDelay();
                         if (this.isAggressive) {
@@ -566,7 +668,7 @@ public class Slime extends Mob implements Enemy {
                         this.mob.setSpeed(0.0F);
                     }
                 } else {
-                    this.mob.setSpeed((float)(this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
+                    this.mob.setSpeed((float)(this.getSpeedModifier() * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED) * (slime.getRider() != null && slime.isControllable() && (slime.getRider().getForwardMot() != 0 || slime.getRider().getStrafeMot() != 0) ? 2.0D : 1.0D))); // Purpur - Ridables
                 }
             }
         }
diff --git a/net/minecraft/world/entity/monster/Strider.java b/net/minecraft/world/entity/monster/Strider.java
index b451566378401e471a98db63df502b7c4cd20f42..37b0c8f55ed4ac4feac6a35bd4377007a19ea2ce 100644
--- a/net/minecraft/world/entity/monster/Strider.java
+++ b/net/minecraft/world/entity/monster/Strider.java
@@ -86,12 +86,51 @@ public class Strider extends Animal implements ItemSteerable {
     public Strider(EntityType<? extends Strider> type, Level level) {
         super(type, level);
         this.blocksBuilding = true;
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        if (isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - Toggle for water sensitive mob damage
         this.setPathfindingMalus(PathType.LAVA, 0.0F);
         this.setPathfindingMalus(PathType.DANGER_FIRE, 0.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, 0.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.striderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.striderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.striderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.striderMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.striderScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.striderBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.striderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static boolean checkStriderSpawnRules(
         EntityType<Strider> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
@@ -138,6 +177,7 @@ public class Strider extends Animal implements ItemSteerable {
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new PanicGoal(this, 1.65));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
         this.temptGoal = new TemptGoal(this, 1.4, itemStack -> itemStack.is(ItemTags.STRIDER_TEMPT_ITEMS), false);
         this.goalSelector.addGoal(3, this.temptGoal);
@@ -355,7 +395,7 @@ public class Strider extends Animal implements ItemSteerable {
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.striderTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
@@ -390,6 +430,18 @@ public class Strider extends Animal implements ItemSteerable {
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         boolean isFood = this.isFood(player.getItemInHand(hand));
+        // Purpur start
+        if (level().purpurConfig.striderGiveSaddleBack && player.isSecondaryUseActive() && !isFood && isSaddled() && !isVehicle()) {
+            this.setItemSlot(EquipmentSlot.SADDLE, ItemStack.EMPTY);
+            if (!player.getAbilities().instabuild) {
+                ItemStack saddle = new ItemStack(Items.SADDLE);
+                if (!player.getInventory().add(saddle)) {
+                    player.drop(saddle, false);
+                }
+            }
+            return InteractionResult.SUCCESS;
+        }
+        // Purpur end
         if (!isFood && this.isSaddled() && !this.isVehicle() && !player.isSecondaryUseActive()) {
             if (!this.level().isClientSide()) {
                 player.startRiding(this);
@@ -402,7 +454,7 @@ public class Strider extends Animal implements ItemSteerable {
                 ItemStack itemInHand = player.getItemInHand(hand);
                 return (InteractionResult)(this.isEquippableInSlot(itemInHand, EquipmentSlot.SADDLE)
                     ? itemInHand.interactLivingEntity(player, this, hand)
-                    : InteractionResult.PASS);
+                    : tryRide(player, hand)); // Purpur - Ridables
             } else {
                 if (isFood && !this.isSilent()) {
                     this.level()
diff --git a/net/minecraft/world/entity/monster/Vex.java b/net/minecraft/world/entity/monster/Vex.java
index a6bfb39305732068c50ae99a28114b58b76d2cf7..acd196d435758a8730569ba4e772bb954c4f85b6 100644
--- a/net/minecraft/world/entity/monster/Vex.java
+++ b/net/minecraft/world/entity/monster/Vex.java
@@ -58,6 +58,72 @@ public class Vex extends Monster implements TraceableEntity {
         this.xpReward = 3;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.vexRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.vexRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.vexControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.vexMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable()) {
+            float speed;
+            if (onGround) {
+                speed = (float) getAttributeValue(Attributes.MOVEMENT_SPEED) * 0.1F;
+            } else {
+                speed = (float) getAttributeValue(Attributes.FLYING_SPEED);
+            }
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 1.0, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+
+    @Override
+    public boolean causeFallDamage(double fallDistance, float damageMultiplier, DamageSource damageSource) {
+        return false; //  no fall damage please
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.vexMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.vexScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.vexTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.vexAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isFlapping() {
         return this.tickCount % TICKS_PER_FLAP == 0;
@@ -70,7 +136,7 @@ public class Vex extends Monster implements TraceableEntity {
 
     @Override
     public void tick() {
-        this.noPhysics = true;
+        this.noPhysics = getRider() == null || !this.isControllable(); // Purpur - Ridables
         super.tick();
         this.noPhysics = false;
         this.setNoGravity(true);
@@ -84,17 +150,19 @@ public class Vex extends Monster implements TraceableEntity {
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, new Vex.VexChargeAttackGoal());
         this.goalSelector.addGoal(8, new Vex.VexRandomMoveGoal());
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 3.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new Vex.VexCopyOwnerTargetGoal(this));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Monster.createMonsterAttributes().add(Attributes.MAX_HEALTH, 14.0).add(Attributes.ATTACK_DAMAGE, 4.0);
+        return Monster.createMonsterAttributes().add(Attributes.MAX_HEALTH, 14.0).add(Attributes.ATTACK_DAMAGE, 4.0).add(Attributes.FLYING_SPEED, 0.6D); // Purpur;
     }
 
     @Override
@@ -293,13 +361,13 @@ public class Vex extends Monster implements TraceableEntity {
         }
     }
 
-    class VexMoveControl extends MoveControl {
+    class VexMoveControl extends org.purpurmc.purpur.controller.FlyingMoveControllerWASD { // Purpur - Ridables
         public VexMoveControl(final Vex mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.operation == MoveControl.Operation.MOVE_TO) {
                 Vec3 vec3 = new Vec3(this.wantedX - Vex.this.getX(), this.wantedY - Vex.this.getY(), this.wantedZ - Vex.this.getZ());
                 double len = vec3.length();
@@ -307,7 +375,7 @@ public class Vex extends Monster implements TraceableEntity {
                     this.operation = MoveControl.Operation.WAIT;
                     Vex.this.setDeltaMovement(Vex.this.getDeltaMovement().scale(0.5));
                 } else {
-                    Vex.this.setDeltaMovement(Vex.this.getDeltaMovement().add(vec3.scale(this.speedModifier * 0.05 / len)));
+                    Vex.this.setDeltaMovement(Vex.this.getDeltaMovement().add(vec3.scale(this.getSpeedModifier() * 0.05 / len))); // Purpur - Ridables
                     if (Vex.this.getTarget() == null) {
                         Vec3 deltaMovement = Vex.this.getDeltaMovement();
                         Vex.this.setYRot(-((float)Mth.atan2(deltaMovement.x, deltaMovement.z)) * (180.0F / (float)Math.PI));
diff --git a/net/minecraft/world/entity/monster/Witch.java b/net/minecraft/world/entity/monster/Witch.java
index 38991c0c17554c0b58980759eaeb3e9fee774420..97a427faa37ce9b0c558da40d582b16ac1e96da2 100644
--- a/net/minecraft/world/entity/monster/Witch.java
+++ b/net/minecraft/world/entity/monster/Witch.java
@@ -57,6 +57,45 @@ public class Witch extends Raider implements RangedAttackMob {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.witchRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.witchRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.witchControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.witchMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.witchScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.witchTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.witchAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
@@ -65,10 +104,12 @@ public class Witch extends Raider implements RangedAttackMob {
         );
         this.attackPlayersGoal = new NearestAttackableWitchTargetGoal<>(this, Player.class, 10, true, false, null);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new RangedAttackGoal(this, 1.0, 60, 10.0F));
         this.goalSelector.addGoal(2, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(3, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(3, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class));
         this.targetSelector.addGoal(2, this.healRaidersGoal);
         this.targetSelector.addGoal(3, this.attackPlayersGoal);
diff --git a/net/minecraft/world/entity/monster/Zoglin.java b/net/minecraft/world/entity/monster/Zoglin.java
index 201ccf4f20bd9e48ed8c1d59d70f843c74e5287f..d6de61ed4415cd00858375406567ea9407030e1e 100644
--- a/net/minecraft/world/entity/monster/Zoglin.java
+++ b/net/minecraft/world/entity/monster/Zoglin.java
@@ -87,6 +87,45 @@ public class Zoglin extends Monster implements HoglinBase {
         this.xpReward = 5;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zoglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zoglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zoglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zoglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.zoglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zoglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zoglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected Brain.Provider<Zoglin> brainProvider() {
         return Brain.provider(MEMORY_TYPES, SENSOR_TYPES);
@@ -251,6 +290,7 @@ public class Zoglin extends Monster implements HoglinBase {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("zoglinBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         this.updateActivity();
diff --git a/net/minecraft/world/entity/monster/breeze/Breeze.java b/net/minecraft/world/entity/monster/breeze/Breeze.java
index d0019ebf0469f4070d323d03dbe54375b8d2ce73..6f22312d0a5ab38be4a07b93fdb29b7f36f67c71 100644
--- a/net/minecraft/world/entity/monster/breeze/Breeze.java
+++ b/net/minecraft/world/entity/monster/breeze/Breeze.java
@@ -236,6 +236,7 @@ public class Breeze extends Monster {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("breezeBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.popPush("breezeActivityUpdate");
         BreezeAi.updateActivity(this);
diff --git a/net/minecraft/world/entity/monster/creaking/Creaking.java b/net/minecraft/world/entity/monster/creaking/Creaking.java
index 6775e62ae5b133bc44d730924b4821e0c0b8497c..a84edd4953e59daed6816531545a6ec1c914bce6 100644
--- a/net/minecraft/world/entity/monster/creaking/Creaking.java
+++ b/net/minecraft/world/entity/monster/creaking/Creaking.java
@@ -103,6 +103,37 @@ public class Creaking extends Monster {
         return this.getHomePos() != null;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.creakingRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.creakingRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.creakingControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.creakingMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.creakingScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected BodyRotationControl createBodyControl() {
         return new Creaking.CreakingBodyRotationControl(this);
@@ -547,28 +578,28 @@ public class Creaking extends Monster {
         }
     }
 
-    class CreakingLookControl extends LookControl {
+    class CreakingLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables {
         public CreakingLookControl(final Creaking mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Creaking.this.canMove()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
 
-    class CreakingMoveControl extends MoveControl {
+    class CreakingMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         public CreakingMoveControl(final Creaking mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Creaking.this.canMove()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/monster/hoglin/Hoglin.java b/net/minecraft/world/entity/monster/hoglin/Hoglin.java
index 330d831abb22aba9f6f60c0174769a0e78411dfd..460640f5512be6553f1ec69e20e27c7cc797068b 100644
--- a/net/minecraft/world/entity/monster/hoglin/Hoglin.java
+++ b/net/minecraft/world/entity/monster/hoglin/Hoglin.java
@@ -97,6 +97,52 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
         this.xpReward = 5;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.hoglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.hoglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.hoglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.hoglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.hoglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.hoglinBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.hoglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.hoglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @VisibleForTesting
     public void setTimeInOverworld(int timeInOverworld) {
         this.timeInOverworld = timeInOverworld;
@@ -165,6 +211,7 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("hoglinBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         HoglinAi.updateActivity(this);
@@ -202,6 +249,11 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
     public static boolean checkHoglinSpawnRules(
         EntityType<Hoglin> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (net.minecraft.world.entity.monster.Monster.canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         return !level.getBlockState(pos.below()).is(Blocks.NETHER_WART_BLOCK);
     }
 
diff --git a/net/minecraft/world/entity/monster/illager/Evoker.java b/net/minecraft/world/entity/monster/illager/Evoker.java
index f291887c07fee2ad8d00bc79822e709777dc3fc3..1572f7653045902fa05f0499d920eb2b2ff46931 100644
--- a/net/minecraft/world/entity/monster/illager/Evoker.java
+++ b/net/minecraft/world/entity/monster/illager/Evoker.java
@@ -49,10 +49,50 @@ public class Evoker extends SpellcasterIllager {
         this.xpReward = 10;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.evokerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.evokerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.evokerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.evokerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.evokerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.evokerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.evokerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Evoker.EvokerCastingSpellGoal());
         this.goalSelector.addGoal(2, new AvoidEntityGoal<>(this, Player.class, 8.0F, 0.6, 1.0));
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 0.6, 1.0));
@@ -62,6 +102,7 @@ public class Evoker extends SpellcasterIllager {
         this.goalSelector.addGoal(8, new RandomStrollGoal(this, 0.6));
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 3.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true).setUnseenMemoryTicks(300));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false).setUnseenMemoryTicks(300));
@@ -279,7 +320,7 @@ public class Evoker extends SpellcasterIllager {
                 return false;
             } else {
                 ServerLevel serverLevel = getServerLevel(Evoker.this.level());
-                if (!serverLevel.getGameRules().get(GameRules.MOB_GRIEFING)) {
+                if (!serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.evokerMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     return false;
                 } else {
                     List<Sheep> nearbyEntities = serverLevel.getNearbyEntities(
diff --git a/net/minecraft/world/entity/monster/illager/Illusioner.java b/net/minecraft/world/entity/monster/illager/Illusioner.java
index 1f80b1732ae809ce9ea26b0e8ddd507d0a96dbef..ea9b61b6f8463edf3497d240b010f8da3e04f62f 100644
--- a/net/minecraft/world/entity/monster/illager/Illusioner.java
+++ b/net/minecraft/world/entity/monster/illager/Illusioner.java
@@ -59,10 +59,52 @@ public class Illusioner extends SpellcasterIllager implements RangedAttackMob {
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.illusionerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.illusionerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.illusionerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    protected void initAttributes() {
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.illusionerMovementSpeed);
+        this.getAttribute(Attributes.FOLLOW_RANGE).setBaseValue(this.level().purpurConfig.illusionerFollowRange);
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.illusionerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.illusionerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.illusionerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.illusionerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new SpellcasterIllager.SpellcasterCastingSpellGoal());
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 1.0, 1.2));
         this.goalSelector.addGoal(4, new Illusioner.IllusionerMirrorSpellGoal());
@@ -71,6 +113,7 @@ public class Illusioner extends SpellcasterIllager implements RangedAttackMob {
         this.goalSelector.addGoal(8, new RandomStrollGoal(this, 0.6));
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 3.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true).setUnseenMemoryTicks(300));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false).setUnseenMemoryTicks(300));
diff --git a/net/minecraft/world/entity/monster/illager/Pillager.java b/net/minecraft/world/entity/monster/illager/Pillager.java
index e9207ed52cdf28bffcc6e6d9fc550285e1ee6294..1a283185ac03ba44bae531f9b234703fa213df1a 100644
--- a/net/minecraft/world/entity/monster/illager/Pillager.java
+++ b/net/minecraft/world/entity/monster/illager/Pillager.java
@@ -65,16 +65,64 @@ public class Pillager extends AbstractIllager implements CrossbowAttackMob, Inve
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pillagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.pillagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pillagerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pillagerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.pillagerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pillagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pillagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.pillagerCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 1.0, 1.2));
         this.goalSelector.addGoal(2, new Raider.HoldGroundAttackGoal(this, 10.0F));
         this.goalSelector.addGoal(3, new RangedCrossbowAttackGoal<>(this, 1.0, 8.0F));
         this.goalSelector.addGoal(8, new RandomStrollGoal(this, 0.6));
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 15.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 15.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false));
diff --git a/net/minecraft/world/entity/monster/illager/Vindicator.java b/net/minecraft/world/entity/monster/illager/Vindicator.java
index bfad794ff21e2f97654fbb1207b14fd088aec721..97bf22925df40a2f757b50f3fc7cbefc951443bb 100644
--- a/net/minecraft/world/entity/monster/illager/Vindicator.java
+++ b/net/minecraft/world/entity/monster/illager/Vindicator.java
@@ -57,15 +57,63 @@ public class Vindicator extends AbstractIllager {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.vindicatorRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.vindicatorRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.vindicatorControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.vindicatorMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.vindicatorScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.vindicatorTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.vindicatorAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.vindicatorCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 1.0, 1.2));
         this.goalSelector.addGoal(2, new Vindicator.VindicatorBreakDoorGoal(this));
         this.goalSelector.addGoal(3, new AbstractIllager.RaiderOpenDoorGoal(this));
         this.goalSelector.addGoal(4, new Raider.HoldGroundAttackGoal(this, 10.0F));
         this.goalSelector.addGoal(5, new MeleeAttackGoal(this, 1.0, false));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, true));
@@ -131,6 +179,11 @@ public class Vindicator extends AbstractIllager {
         RandomSource random = level.getRandom();
         this.populateDefaultEquipmentSlots(random, difficulty);
         this.populateDefaultEquipmentEnchantments(level, random, difficulty);
+        // Purpur start - Special mobs naturally spawn
+        if (level().purpurConfig.vindicatorJohnnySpawnChance > 0D && random.nextDouble() <= level().purpurConfig.vindicatorJohnnySpawnChance) {
+            setCustomName(Component.translatable("Johnny"));
+        }
+        // Purpur end - Special mobs naturally spawn
         return spawnGroupData1;
     }
 
diff --git a/net/minecraft/world/entity/monster/piglin/Piglin.java b/net/minecraft/world/entity/monster/piglin/Piglin.java
index 2497779f96e3b6c7e7aa048c2047c04f06cb7ede..6f1c3d423b7a37aa261c78a0c8f5e1cb02eee320 100644
--- a/net/minecraft/world/entity/monster/piglin/Piglin.java
+++ b/net/minecraft/world/entity/monster/piglin/Piglin.java
@@ -141,6 +141,52 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
         this.xpReward = 5;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.piglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.piglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.piglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.piglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.piglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.piglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.piglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.piglinCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
@@ -208,6 +254,11 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
     public static boolean checkPiglinSpawnRules(
         EntityType<Piglin> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         return !level.getBlockState(pos.below()).is(Blocks.NETHER_WART_BLOCK);
     }
 
@@ -314,6 +365,7 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("piglinBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         PiglinAi.updateActivity(this);
@@ -417,7 +469,7 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
 
     @Override
     public boolean wantsToPickUp(ServerLevel level, ItemStack stack) {
-        return level.getGameRules().get(GameRules.MOB_GRIEFING) && this.canPickUpLoot() && PiglinAi.wantsToPickup(this, stack);
+        return level.getGameRules().get(GameRules.MOB_GRIEFING, level.purpurConfig.piglinCanPickUpLoot) && this.canPickUpLoot() && PiglinAi.wantsToPickup(this, stack); // Purpur - Check mobGriefing Overrides
     }
 
     protected boolean canReplaceCurrentItem(ItemStack candidate) {
diff --git a/net/minecraft/world/entity/monster/piglin/PiglinAi.java b/net/minecraft/world/entity/monster/piglin/PiglinAi.java
index 436b17a709517766fdb9d7198f0ae457facd90a1..49294ccf5c4ac3acf7793c8d7cbc449a0d0f44e6 100644
--- a/net/minecraft/world/entity/monster/piglin/PiglinAi.java
+++ b/net/minecraft/world/entity/monster/piglin/PiglinAi.java
@@ -660,7 +660,10 @@ public class PiglinAi {
 
     public static boolean isWearingSafeArmor(LivingEntity entity) {
         for (EquipmentSlot equipmentSlot : EquipmentSlotGroup.ARMOR) {
-            if (entity.getItemBySlot(equipmentSlot).is(ItemTags.PIGLIN_SAFE_ARMOR)) {
+            // Purpur start - piglins ignore gold-trimmed armor
+            net.minecraft.world.item.ItemStack itemStack = entity.getItemBySlot(equipmentSlot);
+            if (itemStack.is(ItemTags.PIGLIN_SAFE_ARMOR) || (entity.level().purpurConfig.piglinIgnoresArmorWithGoldTrim && isWearingGoldTrim(itemStack))) {
+            // Purpur end - piglins ignore gold-trimmed armor
                 return true;
             }
         }
@@ -668,6 +671,13 @@ public class PiglinAi {
         return false;
     }
 
+    // Purpur start - piglins ignore gold-trimmed armor
+    private static boolean isWearingGoldTrim(net.minecraft.world.item.ItemStack itemstack) {
+        net.minecraft.world.item.equipment.trim.ArmorTrim armorTrim = itemstack.getComponents().get(net.minecraft.core.component.DataComponents.TRIM);
+        return armorTrim != null && armorTrim.material().is(net.minecraft.world.item.equipment.trim.TrimMaterials.GOLD);
+    }
+    // Purpur end - piglins ignore gold-trimmed armor
+
     private static void stopWalking(Piglin piglin) {
         piglin.getBrain().eraseMemory(MemoryModuleType.WALK_TARGET);
         piglin.getNavigation().stop();
diff --git a/net/minecraft/world/entity/monster/piglin/PiglinBrute.java b/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
index d33c4d32c99b0b4553ce89746b443820f586ce73..91f1e6b1c916b06914c32b268b8b8c2eb3c49ce2 100644
--- a/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
+++ b/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
@@ -65,6 +65,52 @@ public class PiglinBrute extends AbstractPiglin {
         this.xpReward = 20;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.piglinBruteRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.piglinBruteRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.piglinBruteControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.piglinBruteMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.piglinBruteScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.piglinBruteTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.piglinBruteAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.piglinBruteCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     public static AttributeSupplier.Builder createAttributes() {
         return Monster.createMonsterAttributes()
             .add(Attributes.MAX_HEALTH, 50.0)
@@ -116,6 +162,7 @@ public class PiglinBrute extends AbstractPiglin {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("piglinBruteBrain");
+        if (getRider() == null || this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         PiglinBruteAi.updateActivity(this);
diff --git a/net/minecraft/world/entity/monster/skeleton/AbstractSkeleton.java b/net/minecraft/world/entity/monster/skeleton/AbstractSkeleton.java
index 0f5bfbfc97c2826de72985c4e2e1dec1d94337f2..60afd81d3bf671889fbff5d4a3fabb38a8e2d461 100644
--- a/net/minecraft/world/entity/monster/skeleton/AbstractSkeleton.java
+++ b/net/minecraft/world/entity/monster/skeleton/AbstractSkeleton.java
@@ -66,21 +66,24 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
             AbstractSkeleton.this.setAggressive(true);
         }
     };
-    private boolean shouldBurnInDay = true; // Paper - shouldBurnInDay API
+    //private boolean shouldBurnInDay = true; // Paper - shouldBurnInDay API // Purpur - moved to LivingEntity; keep methods for ABI compatibility - API for any mob to burn daylight
 
     protected AbstractSkeleton(EntityType<? extends AbstractSkeleton> type, Level level) {
         super(type, level);
         this.reassessWeaponGoal();
+        this.setShouldBurnInDay(true); // Purpur - API for any mob to burn daylight
     }
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new RestrictSunGoal(this));
         this.goalSelector.addGoal(3, new FleeSunGoal(this, 1.0));
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Wolf.class, 6.0F, 1.0, 1.2));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(6, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
@@ -137,7 +140,7 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
         this.populateDefaultEquipmentEnchantments(level, random, difficulty);
         this.reassessWeaponGoal();
         this.setCanPickUpLoot(level.getLevel().paperConfig().entities.behavior.mobsCanAlwaysPickUpLoot.skeletons || random.nextFloat() < 0.55F * difficulty.getSpecialMultiplier()); // Paper - Add world settings for mobs picking up loot
-        if (this.getItemBySlot(EquipmentSlot.HEAD).isEmpty() && SpecialDates.isHalloween() && random.nextFloat() < 0.25F) {
+        if (this.getItemBySlot(EquipmentSlot.HEAD).isEmpty() && (level.getLevel().purpurConfig.forceHalloweenSeason || SpecialDates.isHalloween()) && random.nextFloat() < this.level().purpurConfig.chanceHeadHalloweenOnEntity) { // Purpur - Halloween options and optimizations
             this.setItemSlot(EquipmentSlot.HEAD, new ItemStack(random.nextFloat() < 0.1F ? Blocks.JACK_O_LANTERN : Blocks.CARVED_PUMPKIN));
             this.setDropChance(EquipmentSlot.HEAD, 0.0F);
         }
@@ -184,7 +187,7 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
         double squareRoot = Math.sqrt(d * d + d2 * d2);
         if (this.level() instanceof ServerLevel serverLevel) {
             Projectile.Delayed<AbstractArrow> delayedEntity = Projectile.spawnProjectileUsingShootDelayed( // Paper - delayed
-                arrow, serverLevel, projectile, d, d1 + squareRoot * 0.2F, d2, 1.6F, 14 - serverLevel.getDifficulty().getId() * 4
+                arrow, serverLevel, projectile, d, d1 + squareRoot * 0.2F, d2, 1.6F, serverLevel.purpurConfig.skeletonBowAccuracyMap.getOrDefault(serverLevel.getDifficulty().getId(), (float) (14 - serverLevel.getDifficulty().getId() * 4))  // Purpur - skeleton bow accuracy option
             );
 
             // Paper start - call EntityShootBowEvent
@@ -221,14 +224,14 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.reassessWeaponGoal();
-        this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - shouldBurnInDay API
+        //this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - shouldBurnInDay API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
 
     // Paper start - shouldBurnInDay API
     @Override
     protected void addAdditionalSaveData(final net.minecraft.world.level.storage.ValueOutput output) {
         super.addAdditionalSaveData(output);
-        output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay);
+        //output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
     // Paper end - shouldBurnInDay API
 
diff --git a/net/minecraft/world/entity/monster/skeleton/Bogged.java b/net/minecraft/world/entity/monster/skeleton/Bogged.java
index c54ad2d6a271d70cc9eeb284f13e5d143f81a084..59c986a28a5546a9070ec9bcf3f1994317b47fff 100644
--- a/net/minecraft/world/entity/monster/skeleton/Bogged.java
+++ b/net/minecraft/world/entity/monster/skeleton/Bogged.java
@@ -41,6 +41,38 @@ public class Bogged extends AbstractSkeleton implements Shearable {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.boggedRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.boggedRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.boggedControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.boggedMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.boggedScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.boggedCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
diff --git a/net/minecraft/world/entity/monster/skeleton/Skeleton.java b/net/minecraft/world/entity/monster/skeleton/Skeleton.java
index 94a01d35457053bb4265acb5542ae2f83671d9bb..304e6e23a616ddc3312ef27ae5d94c927a52fb80 100644
--- a/net/minecraft/world/entity/monster/skeleton/Skeleton.java
+++ b/net/minecraft/world/entity/monster/skeleton/Skeleton.java
@@ -26,6 +26,51 @@ public class Skeleton extends AbstractSkeleton {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.skeletonRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.skeletonRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.skeletonControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.skeletonMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.skeletonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.skeletonAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.skeletonCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -130,4 +175,64 @@ public class Skeleton extends AbstractSkeleton {
     SoundEvent getStepSound() {
         return SoundEvents.SKELETON_STEP;
     }
+
+    // Purpur start - Skeletons eat wither roses
+    private int witherRosesFed = 0;
+
+    @Override
+    public net.minecraft.world.InteractionResult mobInteract(net.minecraft.world.entity.player.Player player, net.minecraft.world.InteractionHand hand) {
+        net.minecraft.world.item.ItemStack stack = player.getItemInHand(hand);
+
+        if (level().purpurConfig.skeletonFeedWitherRoses > 0 && this.getType() != EntityType.WITHER_SKELETON && stack.getItem() == net.minecraft.world.level.block.Blocks.WITHER_ROSE.asItem()) {
+            return this.feedWitherRose(player, stack);
+        }
+
+        return super.mobInteract(player, hand);
+    }
+
+    private net.minecraft.world.InteractionResult feedWitherRose(net.minecraft.world.entity.player.Player player, net.minecraft.world.item.ItemStack stack) {
+        if (++witherRosesFed < level().purpurConfig.skeletonFeedWitherRoses) {
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(1);
+            }
+            return net.minecraft.world.InteractionResult.CONSUME;
+        }
+
+        WitherSkeleton skeleton = EntityType.WITHER_SKELETON.create(level(), net.minecraft.world.entity.EntitySpawnReason.CONVERSION);
+        if (skeleton == null) {
+            return net.minecraft.world.InteractionResult.PASS;
+        }
+
+        skeleton.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
+        skeleton.setHealth(this.getHealth());
+        skeleton.setAggressive(this.isAggressive());
+        skeleton.copyPosition(this);
+        skeleton.setYBodyRot(this.yBodyRot);
+        skeleton.setYHeadRot(this.getYHeadRot());
+        skeleton.yRotO = this.yRotO;
+        skeleton.xRotO = this.xRotO;
+
+        if (this.hasCustomName()) {
+            skeleton.setCustomName(this.getCustomName());
+        }
+
+        if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTransformEvent(this, skeleton, org.bukkit.event.entity.EntityTransformEvent.TransformReason.INFECTION).isCancelled()) {
+            return net.minecraft.world.InteractionResult.PASS;
+        }
+
+        this.level().addFreshEntity(skeleton);
+        this.remove(RemovalReason.DISCARDED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        if (!player.getAbilities().instabuild) {
+            stack.shrink(1);
+        }
+
+        for (int i = 0; i < 15; ++i) {
+            ((net.minecraft.server.level.ServerLevel) level()).sendParticlesSource(((net.minecraft.server.level.ServerLevel) level()).players(), null, net.minecraft.core.particles.ParticleTypes.HAPPY_VILLAGER,
+                    false, true,
+                    getX() + random.nextFloat(), getY() + (random.nextFloat() * 2), getZ() + random.nextFloat(), 1,
+                    random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, 0);
+        }
+        return net.minecraft.world.InteractionResult.SUCCESS;
+    }
+    // Purpur end - Skeletons eat wither roses
 }
diff --git a/net/minecraft/world/entity/monster/skeleton/Stray.java b/net/minecraft/world/entity/monster/skeleton/Stray.java
index 24ae7263b2661899e7824ab5877f9b1c9f04d80f..262bea9ca0daba064d2e74223b47eb1fbb761479 100644
--- a/net/minecraft/world/entity/monster/skeleton/Stray.java
+++ b/net/minecraft/world/entity/monster/skeleton/Stray.java
@@ -23,6 +23,51 @@ public class Stray extends AbstractSkeleton {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.strayRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.strayRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.strayControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.strayMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.strayTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.strayAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.strayCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     public static boolean checkStraySpawnRules(
         EntityType<Stray> entityType, ServerLevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
diff --git a/net/minecraft/world/entity/monster/skeleton/WitherSkeleton.java b/net/minecraft/world/entity/monster/skeleton/WitherSkeleton.java
index 79326303fc1adf5a35343847a2401d193368b64f..c01f182e65b7891dfdd7b92ff2c6e2cf3a8a0374 100644
--- a/net/minecraft/world/entity/monster/skeleton/WitherSkeleton.java
+++ b/net/minecraft/world/entity/monster/skeleton/WitherSkeleton.java
@@ -34,6 +34,52 @@ public class WitherSkeleton extends AbstractSkeleton {
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.witherSkeletonRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.witherSkeletonRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.witherSkeletonControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.witherSkeletonMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.witherSkeletonScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.witherSkeletonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.witherSkeletonAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.witherSkeletonCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void registerGoals() {
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractPiglin.class, true));
diff --git a/net/minecraft/world/entity/monster/spider/CaveSpider.java b/net/minecraft/world/entity/monster/spider/CaveSpider.java
index 6a1714d093fc35e6ca840b769723f7bffaea7ba6..fb4caabbbe5bd0befdaba49ee3cfe70c326b50a7 100644
--- a/net/minecraft/world/entity/monster/spider/CaveSpider.java
+++ b/net/minecraft/world/entity/monster/spider/CaveSpider.java
@@ -26,6 +26,45 @@ public class CaveSpider extends Spider {
         return Spider.createAttributes().add(Attributes.MAX_HEALTH, 12.0);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.caveSpiderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.caveSpiderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.caveSpiderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.caveSpiderMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.caveSpiderScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.caveSpiderTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.caveSpiderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean doHurtTarget(ServerLevel level, Entity target) {
         if (super.doHurtTarget(level, target)) {
diff --git a/net/minecraft/world/entity/monster/spider/Spider.java b/net/minecraft/world/entity/monster/spider/Spider.java
index 64a84f73d48deb254345a5c25f3fe650591e64a1..7993ea937772cabe848726c942b6df0ae52e74e2 100644
--- a/net/minecraft/world/entity/monster/spider/Spider.java
+++ b/net/minecraft/world/entity/monster/spider/Spider.java
@@ -52,15 +52,56 @@ public class Spider extends Monster {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.spiderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.spiderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.spiderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.spiderMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.spiderScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.spiderTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.spiderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new AvoidEntityGoal<>(this, Armadillo.class, 6.0F, 1.0, 1.2, livingEntity -> !((Armadillo)livingEntity).isScared()));
         this.goalSelector.addGoal(3, new LeapAtTargetGoal(this, 0.4F));
         this.goalSelector.addGoal(4, new Spider.SpiderAttackGoal(this));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 0.8));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(6, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new Spider.SpiderTargetGoal<>(this, Player.class));
         this.targetSelector.addGoal(3, new Spider.SpiderTargetGoal<>(this, IronGolem.class));
diff --git a/net/minecraft/world/entity/monster/warden/Warden.java b/net/minecraft/world/entity/monster/warden/Warden.java
index 3b931c6105ea14add0d2a60dc19cc3601a092a3b..4f4bf16cfa1390f19a7e8745d86e42e24ffb3bbc 100644
--- a/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/net/minecraft/world/entity/monster/warden/Warden.java
@@ -124,8 +124,32 @@ public class Warden extends Monster implements VibrationSystem {
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, 0.0F);
         this.setPathfindingMalus(PathType.DANGER_FIRE, 0.0F);
+        this.moveControl = new org.purpurmc.purpur.controller.MoveControllerWASD(this, 0.5F); // Purpur - Ridables
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.wardenRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.wardenRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.wardenControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
     @Override
     public Packet<ClientGamePacketListener> getAddEntityPacket(ServerEntity entity) {
         return new ClientboundAddEntityPacket(this, entity, this.hasPose(Pose.EMERGING) ? 1 : 0);
@@ -280,6 +304,7 @@ public class Warden extends Monster implements VibrationSystem {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("wardenBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         super.customServerAiStep(level);
@@ -382,6 +407,7 @@ public class Warden extends Monster implements VibrationSystem {
 
     @Contract("null->false")
     public boolean canTargetEntity(@Nullable Entity entity) {
+        if (getRider() != null && isControllable()) return false; // Purpur - Ridables
         return entity instanceof LivingEntity livingEntity
             && this.level() == entity.level()
             && EntitySelector.NO_CREATIVE_OR_SPECTATOR.test(entity)
diff --git a/net/minecraft/world/entity/monster/warden/WardenAi.java b/net/minecraft/world/entity/monster/warden/WardenAi.java
index b1bca206a880f763c5e9234a20943e9918889b44..5fc0c82231f3407199f1bf0db8ac278e4b29d1e2 100644
--- a/net/minecraft/world/entity/monster/warden/WardenAi.java
+++ b/net/minecraft/world/entity/monster/warden/WardenAi.java
@@ -175,15 +175,16 @@ public class WardenAi {
         brain.addActivityAndRemoveMemoryWhenStopped(
             Activity.FIGHT,
             10,
-            ImmutableList.of(
+            ImmutableList.copyOf(java.util.stream.Stream.<BehaviorControl<? super Warden>>of( // Purpur - configurable warden sonic boom
                 DIG_COOLDOWN_SETTER,
                 StopAttackingIfTargetInvalid.<Warden>create(
                     (level, entity) -> !warden.getAngerLevel().isAngry() || !warden.canTargetEntity(entity), WardenAi::onTargetInvalid, false
                 ),
                 SetEntityLookTarget.create(entity -> isTarget(warden, entity), (float)warden.getAttributeValue(Attributes.FOLLOW_RANGE)),
                 SetWalkTargetFromAttackTargetIfTargetOutOfReach.create(1.2F),
-                new SonicBoom(),
+                warden.level().purpurConfig.wardenCanUseSonicBoom ? new SonicBoom() : null, // Purpur - configurable warden sonic boom
                 MeleeAttack.create(18)
+            ).filter(java.util.Objects::nonNull).toList() // Purpur - configurable warden sonic boom
             ),
             MemoryModuleType.ATTACK_TARGET
         );
diff --git a/net/minecraft/world/entity/monster/zombie/Drowned.java b/net/minecraft/world/entity/monster/zombie/Drowned.java
index db164101d440c503e2e88b1f31af7f0638faaec5..51e9c23436b620c32c4e5a5448fac8ae67c1dcc0 100644
--- a/net/minecraft/world/entity/monster/zombie/Drowned.java
+++ b/net/minecraft/world/entity/monster/zombie/Drowned.java
@@ -74,11 +74,79 @@ public class Drowned extends Zombie implements RangedAttackMob {
         return Zombie.createAttributes().add(Attributes.STEP_HEIGHT, 1.0);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.drownedRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.drownedRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.drownedControllable;
+    }
+    // Purpur end - Ridables
+
     @Override
     protected PathNavigation createNavigation(Level level) {
         return new AmphibiousPathNavigation(this, level);
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.drownedMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.drownedScale);
+    }
+
+    @Override
+    protected void randomizeReinforcementsChance() {
+        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.drownedSpawnReinforcements);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.drownedJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.drownedJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.drownedJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.drownedTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.drownedAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.drownedCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void addBehaviourGoals() {
         this.goalSelector.addGoal(1, new Drowned.DrownedGoToWaterGoal(this, 1.0));
@@ -86,10 +154,23 @@ public class Drowned extends Zombie implements RangedAttackMob {
         this.goalSelector.addGoal(2, new Drowned.DrownedAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(5, new Drowned.DrownedGoToBeachGoal(this, 1.0));
         this.goalSelector.addGoal(6, new Drowned.DrownedSwimUpGoal(this, 1.0, this.level().getSeaLevel()));
+        if (level().purpurConfig.drownedBreakDoors) this.goalSelector.addGoal(6, new net.minecraft.world.entity.ai.goal.MoveThroughVillageGoal(this, 1.0D, true, 4, this::canBreakDoors)); // Purpur - Option to make drowned break doors
         this.goalSelector.addGoal(7, new RandomStrollGoal(this, 1.0));
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Drowned.class).setAlertOthers(ZombifiedPiglin.class));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entity, level) -> this.okTarget(entity)));
-        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Paper - Check drowned for villager aggression config
+        // Purpur start - Add option to disable zombie aggressiveness towards villagers
+        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false) { // Paper - Check drowned for villager aggression config
+            @Override
+            public boolean canUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canUse();
+            }
+
+            @Override
+            public boolean canContinueToUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canContinueToUse();
+            }
+        });
+        // Purpur end - Add option to disable zombie aggressiveness towards villagers
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Axolotl.class, true, false));
         this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
@@ -420,7 +501,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
         }
     }
 
-    static class DrownedMoveControl extends MoveControl {
+    static class DrownedMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Drowned drowned;
 
         public DrownedMoveControl(Drowned mob) {
@@ -429,7 +510,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             LivingEntity target = this.drowned.getTarget();
             if (this.drowned.wantsToSwim() && this.drowned.isInWater()) {
                 if (target != null && target.getY() > this.drowned.getY() || this.drowned.searchingForLand) {
@@ -449,7 +530,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
                 float f = (float)(Mth.atan2(d2, d) * 180.0F / (float)Math.PI) - 90.0F;
                 this.drowned.setYRot(this.rotlerp(this.drowned.getYRot(), f, 90.0F));
                 this.drowned.yBodyRot = this.drowned.getYRot();
-                float f1 = (float)(this.speedModifier * this.drowned.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                float f1 = (float)(this.getSpeedModifier() * this.drowned.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                 float f2 = Mth.lerp(0.125F, this.drowned.getSpeed(), f1);
                 this.drowned.setSpeed(f2);
                 this.drowned.setDeltaMovement(this.drowned.getDeltaMovement().add(f2 * d * 0.005, f2 * d1 * 0.1, f2 * d2 * 0.005));
@@ -458,7 +539,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
                     this.drowned.setDeltaMovement(this.drowned.getDeltaMovement().add(0.0, -0.008, 0.0));
                 }
 
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/monster/zombie/Husk.java b/net/minecraft/world/entity/monster/zombie/Husk.java
index f36d92f0f62354be5f4e39e768aabb1369cfe18c..d1390e0a88de89b3dc381449ef98a89b327eb4c9 100644
--- a/net/minecraft/world/entity/monster/zombie/Husk.java
+++ b/net/minecraft/world/entity/monster/zombie/Husk.java
@@ -27,11 +27,79 @@ import org.jspecify.annotations.Nullable;
 public class Husk extends Zombie {
     public Husk(EntityType<? extends Husk> type, Level level) {
         super(type, level);
+        this.setShouldBurnInDay(false); // Purpur - API for any mob to burn daylight
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.huskRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.huskRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.huskControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.huskMaxHealth);
+    }
+
+    @Override
+    protected void randomizeReinforcementsChance() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.huskSpawnReinforcements);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.huskJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.huskJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.huskJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.huskTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.huskAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.huskCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     public boolean isSunSensitive() {
-        return false;
+        return this.shouldBurnInDay; // Purpur - moved to LivingEntity; keep methods for ABI compatibility - API for any mob to burn daylight
     }
 
     @Override
diff --git a/net/minecraft/world/entity/monster/zombie/Zombie.java b/net/minecraft/world/entity/monster/zombie/Zombie.java
index d9935d71393b28ee8052b1c05739bfd44d6afb47..f9435eee22c85f8a62611d6742d145f4eeeff525 100644
--- a/net/minecraft/world/entity/monster/zombie/Zombie.java
+++ b/net/minecraft/world/entity/monster/zombie/Zombie.java
@@ -92,22 +92,85 @@ public class Zombie extends Monster {
     private boolean canBreakDoors = false;
     private int inWaterTime = 0;
     public int conversionTime;
-    private boolean shouldBurnInDay = true; // Paper - Add more Zombie API
+    //private boolean shouldBurnInDay = true; // Paper - Add more Zombie API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
 
     public Zombie(EntityType<? extends Zombie> type, Level level) {
         super(type, level);
         this.breakDoorGoal = new BreakDoorGoal(this, com.google.common.base.Predicates.in(level.paperConfig().entities.behavior.doorBreakingDifficulty.getOrDefault(type, level.paperConfig().entities.behavior.doorBreakingDifficulty.get(EntityType.ZOMBIE)))); // Paper - Configurable door breaking difficulty
+        this.setShouldBurnInDay(true); // Purpur - API for any mob to burn daylight
     }
 
     public Zombie(Level level) {
         this(EntityType.ZOMBIE, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zombieRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombieRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zombieControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zombieMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.zombieScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start -  Configurable jockey options
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.zombieJockeyOnlyBaby;
+    }
+
+    public double jockeyChance() {
+        return level().purpurConfig.zombieJockeyChance;
+    }
+
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.zombieJockeyTryExistingChickens;
+    }
+    // Purpur end -  Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombieTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombieAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.zombieCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         if (this.level().paperConfig().entities.behavior.zombiesTargetTurtleEggs) this.goalSelector.addGoal(4, new Zombie.ZombieAttackTurtleEggGoal(this, 1.0, 3)); // Paper - Add zombie targets turtle egg config
         this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.addBehaviourGoals();
     }
 
@@ -118,7 +181,19 @@ public class Zombie extends Monster {
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers(ZombifiedPiglin.class));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
-        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Spigot
+        // Purpur start - Add option to disable zombie aggressiveness towards villagers
+        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false) { // Spigot
+            @Override
+            public boolean canUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canUse();
+            }
+
+            @Override
+            public boolean canContinueToUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canContinueToUse();
+            }
+        });
+        // Purpur end - Add option to disable zombie aggressiveness towards villagers
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
         this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
@@ -287,6 +362,7 @@ public class Zombie extends Monster {
         // CraftBukkit end
     }
 
+    public boolean shouldBurnInDay() { return this.isSunSensitive(); } // Purpur - for ABI compatibility - API for any mob to burn daylight
     public boolean isSunSensitive() {
         return this.shouldBurnInDay; // Paper - Add more Zombie API
     }
@@ -426,7 +502,7 @@ public class Zombie extends Monster {
         output.putBoolean("CanBreakDoors", this.canBreakDoors());
         output.putInt("InWaterTime", this.isInWater() ? this.inWaterTime : -1);
         output.putInt("DrownedConversionTime", this.isUnderWaterConverting() ? this.conversionTime : -1);
-        output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Paper - Add more Zombie API
+        //output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Paper - Add more Zombie API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
 
     @Override
@@ -441,7 +517,7 @@ public class Zombie extends Monster {
         } else {
             this.getEntityData().set(DATA_DROWNED_CONVERSION_ID, false);
         }
-        this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - Add more Zombie API
+        //this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - Add more Zombie API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
 
     @Override
@@ -492,19 +568,18 @@ public class Zombie extends Monster {
         }
 
         if (spawnGroupData instanceof Zombie.ZombieGroupData zombieGroupData) {
-            if (zombieGroupData.isBaby) {
-                this.setBaby(true);
+            if (!jockeyOnlyBaby() || zombieGroupData.isBaby) { // Purpur - Configurable jockey options
+                this.setBaby(zombieGroupData.isBaby); // Purpur - Configurable jockey options
                 if (zombieGroupData.canSpawnJockey) {
-                    if (random.nextFloat() < 0.05) {
-                        List<Chicken> entitiesOfClass = level.getEntitiesOfClass(
+                    if (random.nextFloat() < jockeyChance()) { // Purpur - Configurable jockey options
+                        List<Chicken> entitiesOfClass = jockeyTryExistingChickens() ? level.getEntitiesOfClass( // Purpur - Configurable jockey options
                             Chicken.class, this.getBoundingBox().inflate(5.0, 3.0, 5.0), EntitySelector.ENTITY_NOT_BEING_RIDDEN
-                        );
+                        ) : java.util.Collections.emptyList(); // Purpur - Configurable jockey options
                         if (!entitiesOfClass.isEmpty()) {
                             Chicken chicken = entitiesOfClass.get(0);
                             chicken.setChickenJockey(true);
                             this.startRiding(chicken, false, false);
-                        }
-                    } else if (random.nextFloat() < 0.05) {
+                    } else { // Purpur - Configurable jockey options
                         Chicken chicken1 = EntityType.CHICKEN.create(this.level(), EntitySpawnReason.JOCKEY);
                         if (chicken1 != null) {
                             chicken1.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), 0.0F);
@@ -513,6 +588,7 @@ public class Zombie extends Monster {
                             this.startRiding(chicken1, false, false);
                             level.addFreshEntity(chicken1, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.MOUNT); // CraftBukkit
                         }
+                        } // Purpur - Configurable jockey options
                     }
                 }
             }
@@ -524,7 +600,7 @@ public class Zombie extends Monster {
             }
         }
 
-        if (this.getItemBySlot(EquipmentSlot.HEAD).isEmpty() && SpecialDates.isHalloween() && random.nextFloat() < 0.25F) {
+        if (this.getItemBySlot(EquipmentSlot.HEAD).isEmpty() && (level.getLevel().purpurConfig.forceHalloweenSeason || SpecialDates.isHalloween()) && random.nextFloat() < level.getLevel().purpurConfig.chanceHeadHalloweenOnEntity) { // Purpur - Halloween options and optimizations
             this.setItemSlot(EquipmentSlot.HEAD, new ItemStack(random.nextFloat() < 0.1F ? Blocks.JACK_O_LANTERN : Blocks.CARVED_PUMPKIN));
             this.setDropChance(EquipmentSlot.HEAD, 0.0F);
         }
@@ -573,7 +649,7 @@ public class Zombie extends Monster {
     }
 
     protected void randomizeReinforcementsChance() {
-        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * 0.1F);
+        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.zombieSpawnReinforcements); // Purpur - Configurable entity base attributes
     }
 
     class ZombieAttackTurtleEggGoal extends RemoveBlockGoal {
diff --git a/net/minecraft/world/entity/monster/zombie/ZombieVillager.java b/net/minecraft/world/entity/monster/zombie/ZombieVillager.java
index 8af935a11a0988f10a2908f6337504f7f6e13d1b..cfaf0da5f039986db99db9ee86da39310268606e 100644
--- a/net/minecraft/world/entity/monster/zombie/ZombieVillager.java
+++ b/net/minecraft/world/entity/monster/zombie/ZombieVillager.java
@@ -85,6 +85,73 @@ public class ZombieVillager extends Zombie implements VillagerDataHolder {
         super(type, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zombieVillagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombieVillagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zombieVillagerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zombieVillagerMaxHealth);
+    }
+
+    @Override
+    protected void randomizeReinforcementsChance() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.zombieVillagerSpawnReinforcements);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.zombieVillagerJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.zombieVillagerJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.zombieVillagerJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombieVillagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombieVillagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.zombieVillagerCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -159,10 +226,10 @@ public class ZombieVillager extends Zombie implements VillagerDataHolder {
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (itemInHand.is(Items.GOLDEN_APPLE)) {
-            if (this.hasEffect(MobEffects.WEAKNESS)) {
+            if (this.hasEffect(MobEffects.WEAKNESS) && level().purpurConfig.zombieVillagerCureEnabled) { // Purpur - Add option to disable zombie villagers cure
                 itemInHand.consume(1, player);
                 if (!this.level().isClientSide()) {
-                    this.startConverting(player.getUUID(), this.random.nextInt(2401) + 3600);
+                    this.startConverting(player.getUUID(), this.random.nextInt(level().purpurConfig.zombieVillagerCuringTimeMax - level().purpurConfig.zombieVillagerCuringTimeMin + 1) + level().purpurConfig.zombieVillagerCuringTimeMin); // Purpur - Customizable Zombie Villager curing times
                 }
 
                 return InteractionResult.SUCCESS_SERVER;
diff --git a/net/minecraft/world/entity/monster/zombie/ZombifiedPiglin.java b/net/minecraft/world/entity/monster/zombie/ZombifiedPiglin.java
index 8fcb6cd1cefa6c9e1809944b4720cfdc35325729..2d6b6bbd06d0a0443e4c32e3c9aecfe8716e1a55 100644
--- a/net/minecraft/world/entity/monster/zombie/ZombifiedPiglin.java
+++ b/net/minecraft/world/entity/monster/zombie/ZombifiedPiglin.java
@@ -64,6 +64,69 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zombifiedPiglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombifiedPiglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zombifiedPiglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zombifiedPiglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.zombifiedPiglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.zombifiedPiglinJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.zombifiedPiglinJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.zombifiedPiglinJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombifiedPiglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombifiedPiglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.zombifiedPiglinCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     protected void addBehaviourGoals() {
         this.goalSelector.addGoal(1, new SpearUseGoal<>(this, 1.0, 1.0, 10.0F, 2.0F));
@@ -109,6 +172,12 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
             this.maybeAlertOthers();
         }
 
+        // Purpur start - Toggle for Zombified Piglin death always counting as player kill when angry
+        if (this.isAngry() && this.level().purpurConfig.zombifiedPiglinCountAsPlayerKillWhenAngry) {
+            this.lastHurtByPlayerMemoryTime = this.tickCount;
+        }
+        // Purpur end - Toggle for Zombified Piglin death always counting as player kill when angry
+
         super.customServerAiStep(level);
     }
 
@@ -156,6 +225,12 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
             this.ticksUntilNextAlert = ALERT_INTERVAL.sample(this.random);
         }
 
+        // Purpur start - Toggle for Zombified Piglin death always counting as player kill when angry
+        if (target instanceof Player player && this.level().purpurConfig.zombifiedPiglinCountAsPlayerKillWhenAngry) {
+            this.setLastHurtByPlayer(player, this.tickCount);
+        }
+        // Purpur end - Toggle for Zombified Piglin death always counting as player kill when angry
+
         return super.setTarget(target, reason); // CraftBukkit
     }
 
@@ -176,6 +251,11 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
     public static boolean checkZombifiedPiglinSpawnRules(
         EntityType<ZombifiedPiglin> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (canSpawnInBlueAndPackedIce(level, pos)) {
+            return false;
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         return level.getDifficulty() != Difficulty.PEACEFUL && !level.getBlockState(pos.below()).is(Blocks.NETHER_WART_BLOCK);
     }
 
@@ -233,7 +313,7 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
 
     @Override
     protected void randomizeReinforcementsChance() {
-        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(0.0);
+        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.zombifiedPiglinSpawnReinforcements); // Purpur - Configurable entity base attributes
     }
 
     @Override
diff --git a/net/minecraft/world/entity/npc/CatSpawner.java b/net/minecraft/world/entity/npc/CatSpawner.java
index 5401976c4fa86e2db6622743c8e8ea7381f72878..278a4000d06690a41e58a059d54e0044944a51fe 100644
--- a/net/minecraft/world/entity/npc/CatSpawner.java
+++ b/net/minecraft/world/entity/npc/CatSpawner.java
@@ -23,7 +23,7 @@ public class CatSpawner implements CustomSpawner {
     public void tick(ServerLevel level, boolean spawnEnemies) {
         this.nextTick--;
         if (this.nextTick <= 0) {
-            this.nextTick = 1200;
+            this.nextTick = level.purpurConfig.catSpawnDelay; // Purpur - Cat spawning options
             Player randomPlayer = level.getRandomPlayer();
             if (randomPlayer != null) {
                 RandomSource randomSource = level.random;
@@ -45,9 +45,12 @@ public class CatSpawner implements CustomSpawner {
     }
 
     private void spawnInVillage(ServerLevel level, BlockPos pos) {
-        int i = 48;
-        if (level.getPoiManager().getCountInRange(holder -> holder.is(PoiTypes.HOME), pos, 48, PoiManager.Occupancy.IS_OCCUPIED) > 4L) {
-            List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(48.0, 8.0, 48.0));
+        // Purpur start - Cat spawning options
+        int range = level.purpurConfig.catSpawnVillageScanRange;
+        if (range <= 0) return;
+        if (level.getPoiManager().getCountInRange(holder -> holder.is(PoiTypes.HOME), pos, range, PoiManager.Occupancy.IS_OCCUPIED) > 4L) {
+            List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(range, 8.0, range));
+        // Purpur end - Cat spawning options
             if (entitiesOfClass.size() < 5) {
                 this.spawnCat(pos, level, false);
             }
@@ -55,8 +58,11 @@ public class CatSpawner implements CustomSpawner {
     }
 
     private void spawnInHut(ServerLevel level, BlockPos pos) {
-        int i = 16;
-        List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(16.0, 8.0, 16.0));
+        // Purpur start - Cat spawning options
+        int range = level.purpurConfig.catSpawnSwampHutScanRange;
+        if (range <= 0) return;
+        List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(range, 8.0, range));
+        // Purpur end - Cat spawning options
         if (entitiesOfClass.isEmpty()) {
             this.spawnCat(pos, level, true);
         }
diff --git a/net/minecraft/world/entity/npc/villager/AbstractVillager.java b/net/minecraft/world/entity/npc/villager/AbstractVillager.java
index fa8f1ea38192f9ad0a961a53399f295d83af7721..05d1a859e1aee639ad9572f2369e6db3c3d7a111 100644
--- a/net/minecraft/world/entity/npc/villager/AbstractVillager.java
+++ b/net/minecraft/world/entity/npc/villager/AbstractVillager.java
@@ -38,6 +38,7 @@ import net.minecraft.world.phys.Vec3;
 import org.jspecify.annotations.Nullable;
 
 public abstract class AbstractVillager extends AgeableMob implements InventoryCarrier, Npc, Merchant {
+    public static final net.minecraft.world.item.crafting.Ingredient TEMPT_ITEMS = net.minecraft.world.item.crafting.Ingredient.of(net.minecraft.world.level.block.Blocks.EMERALD_BLOCK.asItem()); // Purpur - Villagers follow emerald blocks
     private static final EntityDataAccessor<Integer> DATA_UNHAPPY_COUNTER = SynchedEntityData.defineId(AbstractVillager.class, EntityDataSerializers.INT);
     public static final int VILLAGER_SLOT_OFFSET = 300;
     private static final int VILLAGER_INVENTORY_SIZE = 8;
diff --git a/net/minecraft/world/entity/npc/villager/Villager.java b/net/minecraft/world/entity/npc/villager/Villager.java
index 89844d7e804cc8a2110b694e448bc5993991bea7..0c110421074d57e7283168c1133cd4ee314b57f6 100644
--- a/net/minecraft/world/entity/npc/villager/Villager.java
+++ b/net/minecraft/world/entity/npc/villager/Villager.java
@@ -179,6 +179,8 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         MemoryModuleType.MEETING_POINT,
         (villager, poiType) -> poiType.is(PoiTypes.MEETING)
     );
+    private boolean isLobotomized = false; public boolean isLobotomized() { return this.isLobotomized; } // Purpur - Lobotomize stuck villagers
+    private int notLobotomizedCount = 0; // Purpur - Lobotomize stuck villagers
 
     public Villager(EntityType<? extends Villager> type, Level level) {
         this(type, level, VillagerType.PLAINS);
@@ -197,6 +199,110 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         this.setVillagerData(this.getVillagerData().withType(villagerType).withProfession(level.registryAccess(), VillagerProfession.NONE));
     }
 
+    // Purpur start - Allow leashing villagers
+    @Override
+    public boolean canBeLeashed() {
+        return level().purpurConfig.villagerCanBeLeashed;
+    }
+    // Purpur end - Allow leashing villagers
+
+    // Purpur start - Lobotomize stuck villagers
+    private boolean checkLobotomized() {
+        int interval = this.level().purpurConfig.villagerLobotomizeCheckInterval;
+        boolean shouldCheckForTradeLocked = this.level().purpurConfig.villagerLobotomizeWaitUntilTradeLocked;
+        if (this.notLobotomizedCount > 3) {
+            // check half as often if not lobotomized for the last 3+ consecutive checks
+            interval *= 2;
+        }
+        if (this.level().getGameTime() % interval == 0) {
+            // offset Y for short blocks like dirt_path/farmland
+            this.isLobotomized = !(shouldCheckForTradeLocked && this.getVillagerXp() == 0) && !canTravelFrom(BlockPos.containing(this.position().x, this.getBoundingBox().minY + 0.0625D, this.position().z));
+
+            if (this.isLobotomized) {
+                this.notLobotomizedCount = 0;
+            } else {
+                this.notLobotomizedCount++;
+            }
+        }
+        return this.isLobotomized;
+    }
+
+    private boolean canTravelFrom(BlockPos pos) {
+        return canTravelTo(pos.east()) || canTravelTo(pos.west()) || canTravelTo(pos.north()) || canTravelTo(pos.south());
+    }
+
+    private boolean canTravelTo(BlockPos pos) {
+        net.minecraft.world.level.block.state.BlockState state = this.level().getBlockStateIfLoaded(pos);
+        if (state == null) {
+            // chunk not loaded
+            return false;
+        }
+        net.minecraft.world.level.block.Block bottom = state.getBlock();
+        if (bottom instanceof net.minecraft.world.level.block.FenceBlock ||
+            bottom instanceof net.minecraft.world.level.block.FenceGateBlock ||
+            bottom instanceof net.minecraft.world.level.block.WallBlock) {
+            // bottom block is too tall to get over
+            return false;
+        }
+        net.minecraft.world.level.block.Block top = level().getBlockState(pos.above()).getBlock();
+        // only if both blocks have no collision
+        return !bottom.hasCollision && !top.hasCollision;
+    }
+    // Purpur end - Lobotomize stuck villagers
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.villagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.villagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.villagerControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this));
+        if (level().purpurConfig.villagerFollowEmeraldBlock) this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.TemptGoal(this, 1.0D, TEMPT_ITEMS, false)); // Purpur - Villagers follow emerald blocks
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.villagerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.villagerScale);
+        this.getAttribute(Attributes.TEMPT_RANGE).setBaseValue(this.level().purpurConfig.villagerTemptRange); // Purpur - Villagers follow emerald blocks
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.villagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.villagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    // Purpur start - Check mobGriefing Overrides
+    @Override
+    protected Boolean checkEntityPickUpLootOverride() {
+        return this.level().purpurConfig.villagerCanPickUpLoot;
+    }
+    // Purpur end - Check mobGriefing Overrides
+
     @Override
     public Brain<Villager> getBrain() {
         return (Brain<Villager>)super.getBrain();
@@ -230,7 +336,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
             villagerBrain.setSchedule(EnvironmentAttributes.VILLAGER_ACTIVITY);
             villagerBrain.addActivityWithConditions(
                 Activity.WORK,
-                VillagerGoalPackages.getWorkPackage(holder, 0.5F),
+                VillagerGoalPackages.getWorkPackage(holder, 0.5F, this.level().purpurConfig.villagerClericsFarmWarts), // Purpur - Option for Villager Clerics to farm Nether Wart
                 ImmutableSet.of(Pair.of(MemoryModuleType.JOB_SITE, MemoryStatus.VALUE_PRESENT))
             );
         }
@@ -262,7 +368,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Mob.createMobAttributes().add(Attributes.MOVEMENT_SPEED, 0.5);
+        return Mob.createMobAttributes().add(Attributes.MOVEMENT_SPEED, 0.5).add(Attributes.TEMPT_RANGE, 10.0D); // Purpur - Villagers follow emerald blocks
     }
 
     public boolean assignProfessionWhenSpawned() {
@@ -293,11 +399,22 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         // Paper start - EAR 2
         this.customServerAiStep(level, false);
     }
-    protected void customServerAiStep(ServerLevel level, final boolean inactive) {
+    protected void customServerAiStep(ServerLevel level, boolean inactive) { // Purpur - Lobotomize stuck villagers - not final
         // Paper end - EAR 2
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("villagerBrain");
-        if (!inactive) this.getBrain().tick(level, this); // Paper - EAR 2
+        // Purpur start - Lobotomize stuck villagers
+        if (this.level().purpurConfig.villagerLobotomizeEnabled) {
+            // treat as inactive if lobotomized
+            inactive = inactive || checkLobotomized();
+        } else {
+            this.isLobotomized = false;
+        }
+        if (!inactive && (getRider() == null || !this.isControllable())) { // Purpur - Ridables
+            this.getBrain().tick(level, this); // Paper - EAR 2
+        }
+        else if (this.isLobotomized && shouldRestock(level)) restock();
+        // Purpur end - Lobotomize stuck villagers
         profilerFiller.pop();
         if (this.assignProfessionWhenSpawned) {
             this.assignProfessionWhenSpawned = false;
@@ -353,7 +470,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
             return super.mobInteract(player, hand);
         } else if (this.isBaby()) {
             this.setUnhappy();
-            return InteractionResult.SUCCESS;
+            return tryRide(player, hand, InteractionResult.SUCCESS); // Purpur - Ridables
         } else {
             if (!this.level().isClientSide()) {
                 boolean isEmpty = this.getOffers().isEmpty();
@@ -366,9 +483,12 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
                 }
 
                 if (isEmpty) {
-                    return InteractionResult.CONSUME;
+                    return tryRide(player, hand, InteractionResult.CONSUME); // Purpur - Ridables
                 }
 
+                if (level().purpurConfig.villagerRidable && itemInHand.isEmpty()) return tryRide(player, hand); // Purpur - Ridables
+
+                if (this.level().purpurConfig.villagerAllowTrading) // Purpur - Add config for villager trading
                 this.startTrading(player);
             }
 
@@ -500,7 +620,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     public void updateDemand() {
         for (MerchantOffer merchantOffer : this.getOffers()) {
-            merchantOffer.updateDemand();
+            merchantOffer.updateDemand(this.level().purpurConfig.villagerMinimumDemand); // Purpur - Configurable minimum demand for trades
         }
     }
 
@@ -692,7 +812,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     @Override
     public boolean canBreed() {
-        return this.foodLevel + this.countFoodPointsInInventory() >= 12 && !this.isSleeping() && this.getAge() == 0;
+        return this.level().purpurConfig.villagerCanBreed && this.foodLevel + this.countFoodPointsInInventory() >= 12 && !this.isSleeping() && this.getAge() == 0; // Purpur - Configurable villager breeding
     }
 
     private boolean hungry() {
@@ -857,7 +977,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
 
     public boolean hasFarmSeeds() {
-        return this.getInventory().hasAnyMatching(stack -> stack.is(ItemTags.VILLAGER_PLANTABLE_SEEDS));
+        return this.getInventory().hasAnyMatching(stack -> this.level().purpurConfig.villagerClericsFarmWarts && this.getVillagerData().profession().is(VillagerProfession.CLERIC) ? stack.is(Items.NETHER_WART) : stack.is(ItemTags.VILLAGER_PLANTABLE_SEEDS)); // Purpur - Option for Villager Clerics to farm Nether Wart
     }
 
     @Override
@@ -915,6 +1035,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
 
     public void spawnGolemIfNeeded(ServerLevel level, long gameTime, int minVillagerAmount) {
+        if (level.purpurConfig.villagerSpawnIronGolemRadius > 0 && level.getEntitiesOfClass(net.minecraft.world.entity.animal.golem.IronGolem.class, getBoundingBox().inflate(level.purpurConfig.villagerSpawnIronGolemRadius)).size() > level.purpurConfig.villagerSpawnIronGolemLimit) return; // Purpur - Implement configurable search radius for villagers to spawn iron golems
         if (this.wantsToSpawnGolem(gameTime)) {
             AABB aabb = this.getBoundingBox().inflate(10.0, 10.0, 10.0);
             List<Villager> entitiesOfClass = level.getEntitiesOfClass(Villager.class, aabb);
@@ -982,6 +1103,12 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     @Override
     public void startSleeping(BlockPos pos) {
+        // Purpur start - Option for beds to explode on villager sleep
+        if (level().purpurConfig.bedExplodeOnVillagerSleep && this.level().getBlockState(pos).getBlock() instanceof net.minecraft.world.level.block.BedBlock) {
+            this.level().explode(null, (double) pos.getX() + 0.5D, (double) pos.getY() + 0.5D, (double) pos.getZ() + 0.5D, (float) this.level().purpurConfig.bedExplosionPower, this.level().purpurConfig.bedExplosionFire, this.level().purpurConfig.bedExplosionEffect);
+            return;
+        }
+        // Purpur end - Option for beds to explode on villager sleep
         super.startSleeping(pos);
         this.brain.setMemory(MemoryModuleType.LAST_SLEPT, this.level().getGameTime());
         this.brain.eraseMemory(MemoryModuleType.WALK_TARGET);
diff --git a/net/minecraft/world/entity/npc/villager/VillagerProfession.java b/net/minecraft/world/entity/npc/villager/VillagerProfession.java
index 0acfa8f9d2eab00cf0d8b4bc65c3af52046272bd..8f2edbe693a793d31295d035bc01e4c2b7742b4e 100644
--- a/net/minecraft/world/entity/npc/villager/VillagerProfession.java
+++ b/net/minecraft/world/entity/npc/villager/VillagerProfession.java
@@ -103,7 +103,7 @@ public record VillagerProfession(
         register(registry, ARMORER, PoiTypes.ARMORER, SoundEvents.VILLAGER_WORK_ARMORER);
         register(registry, BUTCHER, PoiTypes.BUTCHER, SoundEvents.VILLAGER_WORK_BUTCHER);
         register(registry, CARTOGRAPHER, PoiTypes.CARTOGRAPHER, SoundEvents.VILLAGER_WORK_CARTOGRAPHER);
-        register(registry, CLERIC, PoiTypes.CLERIC, SoundEvents.VILLAGER_WORK_CLERIC);
+        register(registry, CLERIC, PoiTypes.CLERIC, ImmutableSet.of(Items.NETHER_WART), ImmutableSet.of(Blocks.SOUL_SAND), SoundEvents.VILLAGER_WORK_CLERIC); // Purpur - Option for Villager Clerics to farm Nether Wart
         register(
             registry,
             FARMER,
diff --git a/net/minecraft/world/entity/npc/wanderingtrader/WanderingTrader.java b/net/minecraft/world/entity/npc/wanderingtrader/WanderingTrader.java
index 3eb6ee2ffecbdeb6057d81b7936b80e205db7cdc..9502fe0c4f125f5802fde032954c447b14435da2 100644
--- a/net/minecraft/world/entity/npc/wanderingtrader/WanderingTrader.java
+++ b/net/minecraft/world/entity/npc/wanderingtrader/WanderingTrader.java
@@ -61,6 +61,58 @@ public class WanderingTrader extends AbstractVillager implements Consumable.Over
         super(type, level);
     }
 
+    // Purpur start - Allow leashing villagers
+    @Override
+    public boolean canBeLeashed() {
+        return level().purpurConfig.wanderingTraderCanBeLeashed;
+    }
+    // Purpur end - Allow leashing villagers
+
+    // Purpur - start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.wanderingTraderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.wanderingTraderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.wanderingTraderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.wanderingTraderMaxHealth);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.TEMPT_RANGE).setBaseValue(this.level().purpurConfig.wanderingTraderTemptRange); // Purpur - Villagers follow emerald blocks
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Villagers follow emerald blocks
+    public static net.minecraft.world.entity.ai.attributes.AttributeSupplier.Builder createAttributes() {
+        return Mob.createMobAttributes().add(net.minecraft.world.entity.ai.attributes.Attributes.TEMPT_RANGE, 10.0D);
+    }
+    // Purpur end - Villagers follow emerald blocks
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.wanderingTraderTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.wanderingTraderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
@@ -81,7 +133,7 @@ public class WanderingTrader extends AbstractVillager implements Consumable.Over
                     this,
                     new ItemStack(Items.MILK_BUCKET),
                     SoundEvents.WANDERING_TRADER_REAPPEARED,
-                    wanderingTrader -> this.canDrinkMilk && this.level().isBrightOutside() && wanderingTrader.isInvisible() // Paper - Add more WanderingTrader API
+                    wanderingTrader -> level().purpurConfig.milkClearsBeneficialEffects && this.canDrinkMilk && this.level().isBrightOutside() && wanderingTrader.isInvisible() // Paper - Add more WanderingTrader API // // Purpur - Milk Keeps Beneficial Effects
                 )
             );
         this.goalSelector.addGoal(1, new TradeWithPlayerGoal(this));
@@ -95,6 +147,7 @@ public class WanderingTrader extends AbstractVillager implements Consumable.Over
         this.goalSelector.addGoal(1, new PanicGoal(this, 0.5));
         this.goalSelector.addGoal(1, new LookAtTradingPlayerGoal(this));
         this.goalSelector.addGoal(2, new WanderingTrader.WanderToPositionGoal(this, 2.0, 0.35));
+        if (level().purpurConfig.wanderingTraderFollowEmeraldBlock) this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.TemptGoal(this, 1.0D, TEMPT_ITEMS, false)); // Purpur - Villagers follow emerald blocks
         this.goalSelector.addGoal(4, new MoveTowardsRestrictionGoal(this, 0.35));
         this.goalSelector.addGoal(8, new WaterAvoidingRandomStrollGoal(this, 0.35));
         this.goalSelector.addGoal(9, new InteractGoal(this, Player.class, 3.0F, 1.0F));
@@ -121,11 +174,14 @@ public class WanderingTrader extends AbstractVillager implements Consumable.Over
 
             if (!this.level().isClientSide()) {
                 if (this.getOffers().isEmpty()) {
-                    return InteractionResult.CONSUME;
+                    return tryRide(player, hand, InteractionResult.CONSUME); // Purpur - Ridables
                 }
+                if (level().purpurConfig.wanderingTraderRidable && itemInHand.isEmpty()) return tryRide(player, hand); // Purpur - Ridables
 
+                if (this.level().purpurConfig.wanderingTraderAllowTrading) { // Purpur - Add config for villager trading
                 this.setTradingPlayer(player);
                 this.openTradingScreen(player, this.getDisplayName(), 1);
+                } // Purpur - Add config for villager trading
             }
 
             return InteractionResult.SUCCESS;
diff --git a/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java b/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java
index 44b43ca9fba989f975133f966cedd582a93d3350..7aef337fc0b6fd52c27ad5ca3f38d74f213d9725 100644
--- a/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java
+++ b/net/minecraft/world/entity/npc/wanderingtrader/WanderingTraderSpawner.java
@@ -134,7 +134,17 @@ public class WanderingTraderSpawner implements CustomSpawner {
             int i1 = pos.getX() + this.random.nextInt(maxDistance * 2) - maxDistance;
             int i2 = pos.getZ() + this.random.nextInt(maxDistance * 2) - maxDistance;
             int height = level.getHeight(Heightmap.Types.WORLD_SURFACE, i1, i2);
-            BlockPos blockPos1 = new BlockPos(i1, height, i2);
+            // Purpur start - Allow toggling special MobSpawners per world - allow traders to spawn below nether roof
+            BlockPos.MutableBlockPos blockPos1 = new BlockPos.MutableBlockPos(i1, height, i2);
+            if (level.dimensionType().hasCeiling()) {
+                do {
+                    blockPos1.relative(net.minecraft.core.Direction.DOWN);
+                } while (!level.getBlockState(blockPos1).isAir());
+                do {
+                    blockPos1.relative(net.minecraft.core.Direction.DOWN);
+                } while (level.getBlockState(blockPos1).isAir() && blockPos1.getY() > 0);
+            }
+            // Purpur end - Allow toggling special MobSpawners per world
             if (placementType.isSpawnPositionOk(level, blockPos1, EntityType.WANDERING_TRADER)) {
                 blockPos = blockPos1;
                 break;
diff --git a/net/minecraft/world/entity/player/Player.java b/net/minecraft/world/entity/player/Player.java
index e5540b85cfa159d102a5710b4ccea5c3b61b7f1d..b0d2ddd2b2abf2e2980b9440f7109c32e8606c04 100644
--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -179,17 +179,40 @@ public abstract class Player extends Avatar implements ContainerUser {
     private int currentImpulseContextResetGraceTime = 0;
     public boolean affectsSpawning = true; // Paper - Affects Spawning API
     public net.kyori.adventure.util.TriState flyingFallDamage = net.kyori.adventure.util.TriState.NOT_SET; // Paper - flying fall damage
+    public int burpDelay = 0; // Purpur - Burp delay
+    public boolean canPortalInstant = false; // Purpur - Add portal permission bypass
+    public int sixRowEnderchestSlotCount = -1; // Purpur - Barrels and enderchests 6 rows
 
     // CraftBukkit start
     public boolean fauxSleeping;
     public int oldLevel = -1;
 
+    // Purpur start - AFK API
+    public abstract void setAfk(boolean afk);
+
+    public boolean isAfk() {
+        return false;
+    }
+    // Purpur end - AFK API
     @Override
     public org.bukkit.craftbukkit.entity.CraftHumanEntity getBukkitEntity() {
         return (org.bukkit.craftbukkit.entity.CraftHumanEntity) super.getBukkitEntity();
     }
     // CraftBukkit end
 
+    // Purpur start - Ridables
+    public abstract void resetLastActionTime();
+
+    @Override
+    public boolean processClick(InteractionHand hand) {
+        Entity vehicle = getRootVehicle();
+        if (vehicle != null && vehicle.getRider() == this) {
+            return vehicle.onClick(hand);
+        }
+        return false;
+    }
+    // Purpur end - Ridables
+
     public Player(Level level, GameProfile gameProfile) {
         super(EntityType.PLAYER, level);
         this.setUUID(gameProfile.id());
@@ -245,6 +268,12 @@ public abstract class Player extends Avatar implements ContainerUser {
 
     @Override
     public void tick() {
+        // Purpur start - Burp delay
+        if (this.burpDelay > 0 && --this.burpDelay == 0) {
+            this.level().playSound(null, getX(), getY(), getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 1.0F, this.level().random.nextFloat() * 0.1F + 0.9F);
+        }
+        // Purpur end - Burp delay
+
         this.noPhysics = this.isSpectator();
         if (this.isSpectator() || this.isPassenger()) {
             this.setOnGround(false);
@@ -302,6 +331,17 @@ public abstract class Player extends Avatar implements ContainerUser {
             this.turtleHelmetTick();
         }
 
+        // Purpur start - Full netherite armor grants fire resistance
+        if (this.level().purpurConfig.playerNetheriteFireResistanceDuration > 0 && this.level().getGameTime() % 20 == 0) {
+            if (this.getItemBySlot(EquipmentSlot.HEAD).is(Items.NETHERITE_HELMET)
+                && this.getItemBySlot(EquipmentSlot.CHEST).is(Items.NETHERITE_CHESTPLATE)
+                && this.getItemBySlot(EquipmentSlot.LEGS).is(Items.NETHERITE_LEGGINGS)
+                && this.getItemBySlot(EquipmentSlot.FEET).is(Items.NETHERITE_BOOTS)) {
+                this.addEffect(new MobEffectInstance(MobEffects.FIRE_RESISTANCE, this.level().purpurConfig.playerNetheriteFireResistanceDuration, this.level().purpurConfig.playerNetheriteFireResistanceAmplifier, this.level().purpurConfig.playerNetheriteFireResistanceAmbient, this.level().purpurConfig.playerNetheriteFireResistanceShowParticles, this.level().purpurConfig.playerNetheriteFireResistanceShowIcon), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.NETHERITE_ARMOR);
+            }
+        }
+        // Purpur end - Full netherite armor grants fire resistance
+
         this.cooldowns.tick();
         this.updatePlayerPose();
         if (this.currentImpulseContextResetGraceTime > 0) {
@@ -510,7 +550,7 @@ public abstract class Player extends Avatar implements ContainerUser {
             List<Entity> list = Lists.newArrayList();
 
             for (Entity entity : entities) {
-                if (entity.getType() == EntityType.EXPERIENCE_ORB) {
+                if (entity.getType() == EntityType.EXPERIENCE_ORB && entity.level().purpurConfig.playerExpPickupDelay >= 0) { // Purpur - Configurable player pickup exp delay
                     list.add(entity);
                 } else if (!entity.isRemoved()) {
                     this.touch(entity);
@@ -1052,7 +1092,7 @@ public abstract class Player extends Avatar implements ContainerUser {
                     flag2 = flag2 && !this.level().paperConfig().entities.behavior.disablePlayerCrits; // Paper - Toggleable player crits
                     if (flag2) {
                         damageSource = damageSource.critical(); // Paper - critical damage API
-                        f *= 1.5F;
+                        f *= (float) this.level().purpurConfig.playerCriticalDamageMultiplier; // Purpur - Add config change multiplier critical damage value
                     }
 
                     float f2 = f + f1;
@@ -1764,7 +1804,23 @@ public abstract class Player extends Avatar implements ContainerUser {
 
     @Override
     protected int getBaseExperienceReward(ServerLevel level) {
-        return !level.getGameRules().get(GameRules.KEEP_INVENTORY) && !this.isSpectator() ? Math.min(this.experienceLevel * 7, 100) : 0;
+        // Purpur start - Add player death exp control options
+        if (!level.getGameRules().get(GameRules.KEEP_INVENTORY) && !this.isSpectator()) {
+            int toDrop;
+            try {
+                toDrop = Math.round(((Number) scriptEngine.eval("let expLevel = " + experienceLevel + "; " +
+                    "let expTotal = " + totalExperience + "; " +
+                    "let exp = " + experienceProgress + "; " +
+                    level().purpurConfig.playerDeathExpDropEquation)).floatValue());
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                toDrop = experienceLevel * 7;
+            }
+            return Math.min(toDrop, level().purpurConfig.playerDeathExpDropMax);
+        } else {
+            return 0;
+        }
+        // Purpur end - Add player death exp control options
     }
 
     @Override
@@ -1808,6 +1864,13 @@ public abstract class Player extends Avatar implements ContainerUser {
         return this.inventory.add(stack);
     }
 
+    // Purpur start - Player ridable in water option
+    @Override
+    public boolean dismountsUnderwater() {
+        return !level().purpurConfig.playerRidableInWater;
+    }
+    // Purpur end - Player ridable in water option
+
     public abstract @Nullable GameType gameMode();
 
     @Override
diff --git a/net/minecraft/world/entity/projectile/LlamaSpit.java b/net/minecraft/world/entity/projectile/LlamaSpit.java
index b8e3616de5f07e49a8bbab314329157e4268fb1e..56d78249c3fd7da0ff963712fe3a5c722b907c09 100644
--- a/net/minecraft/world/entity/projectile/LlamaSpit.java
+++ b/net/minecraft/world/entity/projectile/LlamaSpit.java
@@ -33,6 +33,12 @@ public class LlamaSpit extends Projectile {
         );
     }
 
+    // Purpur start - Ridables
+    public void projectileTick() {
+        super.tick();
+    }
+    // Purpur end - Ridables
+
     @Override
     protected double getDefaultGravity() {
         return 0.06;
diff --git a/net/minecraft/world/entity/projectile/Projectile.java b/net/minecraft/world/entity/projectile/Projectile.java
index 6298e6de25f1dd9ff880a9ad2882dc7ccb2f100c..36479ed544ce812113c9a9c982a74a950cb9b26a 100644
--- a/net/minecraft/world/entity/projectile/Projectile.java
+++ b/net/minecraft/world/entity/projectile/Projectile.java
@@ -434,7 +434,7 @@ public abstract class Projectile extends Entity implements TraceableEntity {
     @Override
     public boolean mayInteract(ServerLevel level, BlockPos pos) {
         Entity owner = this.getOwner();
-        return owner instanceof Player ? owner.mayInteract(level, pos) : owner == null || level.getGameRules().get(GameRules.MOB_GRIEFING);
+        return owner instanceof Player ? owner.mayInteract(level, pos) : owner == null || level.getGameRules().get(GameRules.MOB_GRIEFING, level.purpurConfig.projectilesMobGriefingOverride); // Purpur - Add mobGriefing override to everything affected
     }
 
     public boolean mayBreak(ServerLevel level) {
diff --git a/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java b/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java
index 51d3560c5d8cba89469c07fe6b13f0016adc6db7..d4c6a68c59b710cd3d158c674df03cbc2f2f307b 100644
--- a/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java
+++ b/net/minecraft/world/entity/projectile/arrow/AbstractArrow.java
@@ -78,6 +78,7 @@ public abstract class AbstractArrow extends Projectile {
     private @Nullable List<Entity> piercedAndKilledEntities;
     public ItemStack pickupItemStack = this.getDefaultPickupItem();
     public @Nullable ItemStack firedFromWeapon = null;
+    public net.minecraft.world.item.enchantment.ItemEnchantments actualEnchantments = net.minecraft.world.item.enchantment.ItemEnchantments.EMPTY; // Purpur - Add an option to fix MC-3304 projectile looting
 
     protected AbstractArrow(EntityType<? extends AbstractArrow> type, Level level) {
         super(type, level);
@@ -594,6 +595,12 @@ public abstract class AbstractArrow extends Projectile {
         return this.firedFromWeapon;
     }
 
+    // Purpur start - Add an option to fix MC-3304 projectile looting
+    public void setActualEnchantments(net.minecraft.world.item.enchantment.ItemEnchantments actualEnchantments) {
+        this.actualEnchantments = actualEnchantments;
+    }
+    // Purpur end - Add an option to fix MC-3304 projectile looting
+
     protected SoundEvent getDefaultHitGroundSoundEvent() {
         return SoundEvents.ARROW_HIT;
     }
diff --git a/net/minecraft/world/entity/projectile/arrow/ThrownTrident.java b/net/minecraft/world/entity/projectile/arrow/ThrownTrident.java
index 483b8247d3be5839f9d764912ae5b879a9f729aa..fc29a8c27ce02ce81e3799fc999aba70b9800c10 100644
--- a/net/minecraft/world/entity/projectile/arrow/ThrownTrident.java
+++ b/net/minecraft/world/entity/projectile/arrow/ThrownTrident.java
@@ -72,7 +72,7 @@ public class ThrownTrident extends AbstractArrow {
 
         Entity owner = this.getOwner();
         int i = this.entityData.get(ID_LOYALTY);
-        if (i > 0 && (this.dealtDamage || this.isNoPhysics()) && owner != null) {
+        if (i > 0 && (this.dealtDamage || this.isNoPhysics() || (level().purpurConfig.tridentLoyaltyVoidReturnHeight < 0.0D && getY() < level().purpurConfig.tridentLoyaltyVoidReturnHeight)) && owner != null) { // Purpur - Add option to allow loyalty on tridents to work in the void
             if (!this.isAcceptibleReturnOwner()) {
                 if (this.level() instanceof ServerLevel serverLevel && this.pickup == AbstractArrow.Pickup.ALLOWED) {
                     this.spawnAtLocation(serverLevel, this.getPickupItem(), 0.1F);
diff --git a/net/minecraft/world/entity/projectile/hurtingprojectile/LargeFireball.java b/net/minecraft/world/entity/projectile/hurtingprojectile/LargeFireball.java
index de0f086da9fe4afa14d2b77f6b0a2c0910745b94..775aa79a0d503217dbe42268f4feccbc2d3e1edb 100644
--- a/net/minecraft/world/entity/projectile/hurtingprojectile/LargeFireball.java
+++ b/net/minecraft/world/entity/projectile/hurtingprojectile/LargeFireball.java
@@ -20,20 +20,20 @@ public class LargeFireball extends Fireball {
 
     public LargeFireball(EntityType<? extends LargeFireball> type, Level level) {
         super(type, level);
-        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING); // CraftBukkit
+        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // CraftBukkit // Purpur - Add mobGriefing override to everything affected
     }
 
     public LargeFireball(Level level, LivingEntity owner, Vec3 movement, int explosionPower) {
         super(EntityType.FIREBALL, owner, movement, level);
         this.explosionPower = explosionPower;
-        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING); // CraftBukkit
+        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // CraftBukkit // Purpur - Add mobGriefing override to everything affected
     }
 
     @Override
     protected void onHit(HitResult result) {
         super.onHit(result);
         if (this.level() instanceof ServerLevel serverLevel) {
-            // boolean flag = serverLevel.getGameRules().get(GameRules.MOB_GRIEFING); // CraftBukkit - baked into fields (see constructor)
+            // boolean flag = serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // CraftBukkit - baked into fields (see constructor) // Purpur - Add mobGriefing override to everything affected
             // CraftBukkit start - fire ExplosionPrimeEvent
             org.bukkit.event.entity.ExplosionPrimeEvent event = new org.bukkit.event.entity.ExplosionPrimeEvent((org.bukkit.entity.Explosive) this.getBukkitEntity());
             if (event.callEvent()) {
diff --git a/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java b/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java
index 043ddaa0e8718f50881d16892eab188aed70f67f..a10617c29098f28c5b5586a43071a47ef17e5744 100644
--- a/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java
+++ b/net/minecraft/world/entity/projectile/hurtingprojectile/SmallFireball.java
@@ -25,7 +25,7 @@ public class SmallFireball extends Fireball {
         super(EntityType.SMALL_FIREBALL, owner, movement, level);
         // CraftBukkit start
         if (this.getOwner() != null && this.getOwner() instanceof Mob) {
-            this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING);
+            this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // Purpur - Add mobGriefing override to everything affected
         }
         // CraftBukkit end
     }
diff --git a/net/minecraft/world/entity/projectile/hurtingprojectile/WitherSkull.java b/net/minecraft/world/entity/projectile/hurtingprojectile/WitherSkull.java
index 31125bf31c2e1e749873a0387aea6040f5f832dd..fced6e9df3239ffff9f297706c764cb9675c0ebb 100644
--- a/net/minecraft/world/entity/projectile/hurtingprojectile/WitherSkull.java
+++ b/net/minecraft/world/entity/projectile/hurtingprojectile/WitherSkull.java
@@ -94,7 +94,7 @@ public class WitherSkull extends AbstractHurtingProjectile {
         super.onHit(result);
         if (!this.level().isClientSide()) {
             // CraftBukkit start
-            org.bukkit.event.entity.ExplosionPrimeEvent event = new org.bukkit.event.entity.ExplosionPrimeEvent(this.getBukkitEntity(), 1.0F, false);
+            org.bukkit.event.entity.ExplosionPrimeEvent event = new org.bukkit.event.entity.ExplosionPrimeEvent(this.getBukkitEntity(), this.level().purpurConfig.witherExplosionRadius, false); // Purpur - Config for wither explosion radius
             if (event.callEvent()) {
                 this.level().explode(this, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.MOB);
             }
@@ -103,6 +103,21 @@ public class WitherSkull extends AbstractHurtingProjectile {
         }
     }
 
+    // Purpur start - Add canSaveToDisk to Entity
+    @Override
+    public boolean canSaveToDisk() {
+        return false;
+    }
+    // Purpur end - Add canSaveToDisk to Entity
+
+    // Purpur start - Ridables
+    @Override
+    public boolean canHitEntity(Entity target) {
+        // do not hit rider
+        return target != this.getRider() && super.canHitEntity(target);
+    }
+    // Purpur end - Ridables
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         builder.define(DATA_DANGEROUS, false);
diff --git a/net/minecraft/world/entity/projectile/throwableitemprojectile/Snowball.java b/net/minecraft/world/entity/projectile/throwableitemprojectile/Snowball.java
index 89a061cd0a2b39fc05ea96ac0f5d5a8c26582f97..3dfe7eef12d40d986d2eb3f750b09b47ee04aecc 100644
--- a/net/minecraft/world/entity/projectile/throwableitemprojectile/Snowball.java
+++ b/net/minecraft/world/entity/projectile/throwableitemprojectile/Snowball.java
@@ -53,10 +53,40 @@ public class Snowball extends ThrowableItemProjectile {
     protected void onHitEntity(EntityHitResult result) {
         super.onHitEntity(result);
         Entity entity = result.getEntity();
-        int i = entity instanceof Blaze ? 3 : 0;
+        int i = entity.level().purpurConfig.snowballDamage >= 0 ? entity.level().purpurConfig.snowballDamage : entity instanceof Blaze ? 3 : 0; // Purpur - Add configurable snowball damage
         entity.hurt(this.damageSources().thrown(this, this.getOwner()), i);
     }
 
+    // Purpur start - options to extinguish fire blocks with snowballs - borrowed and modified code from ThrownPotion#onHitBlock and ThrownPotion#dowseFire
+    @Override
+    protected void onHitBlock(net.minecraft.world.phys.BlockHitResult blockHitResult) {
+        super.onHitBlock(blockHitResult);
+
+        if (!this.level().isClientSide()) {
+            net.minecraft.core.BlockPos pos = blockHitResult.getBlockPos();
+            net.minecraft.core.BlockPos relativePos = pos.relative(blockHitResult.getDirection());
+
+            net.minecraft.world.level.block.state.BlockState blockState = this.level().getBlockState(pos);
+
+            if (this.level().purpurConfig.snowballExtinguishesFire && this.level().getBlockState(relativePos).is(net.minecraft.world.level.block.Blocks.FIRE)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, relativePos, net.minecraft.world.level.block.Blocks.AIR.defaultBlockState())) {
+                    this.level().removeBlock(relativePos, false);
+                }
+            } else if (this.level().purpurConfig.snowballExtinguishesCandles && net.minecraft.world.level.block.AbstractCandleBlock.isLit(blockState)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, pos, blockState.setValue(net.minecraft.world.level.block.AbstractCandleBlock.LIT, false))) {
+                    net.minecraft.world.level.block.AbstractCandleBlock.extinguish(null, blockState, this.level(), pos);
+                }
+            } else if (this.level().purpurConfig.snowballExtinguishesCampfires && net.minecraft.world.level.block.CampfireBlock.isLitCampfire(blockState)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, pos, blockState.setValue(net.minecraft.world.level.block.CampfireBlock.LIT, false))) {
+                    this.level().levelEvent(null, 1009, pos, 0);
+                    net.minecraft.world.level.block.CampfireBlock.dowse(this.getOwner(), this.level(), pos, blockState);
+                    this.level().setBlockAndUpdate(pos, blockState.setValue(net.minecraft.world.level.block.CampfireBlock.LIT, false));
+                }
+            }
+        }
+    }
+    // Purpur end - options to extinguish fire blocks with snowballs
+
     @Override
     protected void onHit(HitResult result) {
         super.onHit(result);
diff --git a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
index 66df6c69a95c5ca6b07294fdb3b13eee6651d22d..6ad07d8f82c0f745d3c3c742f25d05b9b38193c2 100644
--- a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
+++ b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
@@ -112,9 +112,10 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                             return;
                         }
                         // CraftBukkit end
-                        if (this.random.nextFloat() < 0.05F && serverLevel.isSpawningMonsters()) {
+                        if (this.random.nextFloat() < serverLevel.purpurConfig.enderPearlEndermiteChance && serverLevel.isSpawningMonsters()) { // Purpur - Configurable Ender Pearl RNG
                             Endermite endermite = EntityType.ENDERMITE.create(serverLevel, EntitySpawnReason.TRIGGERED);
                             if (endermite != null) {
+                                endermite.setPlayerSpawned(true); // Purpur - Add back player spawned endermite API
                                 endermite.snapTo(preTeleportX, preTeleportY, preTeleportZ, preTeleportYRot, preTeleportXRot); // Paper - spawn endermite at pre teleport position as teleport has been moved up
                                 serverLevel.addFreshEntity(endermite, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.ENDER_PEARL); // Paper - add reason
                             }
@@ -134,7 +135,7 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                         if (serverPlayer1 != null) {
                             serverPlayer1.resetFallDistance();
                             serverPlayer1.resetCurrentImpulseContext();
-                            serverPlayer1.hurtServer(serverPlayer.level(), this.damageSources().enderPearl().eventEntityDamager(this), 5.0F); // CraftBukkit // Paper - fix DamageSource API
+                            serverPlayer1.hurtServer(serverPlayer.level(), this.damageSources().enderPearl().eventEntityDamager(this), this.level().purpurConfig.enderPearlDamage); // CraftBukkit // Paper - fix DamageSource API // Purpur - Configurable Ender Pearl damage
                         }
 
                         this.playSound(serverLevel, vec3);
diff --git a/net/minecraft/world/entity/raid/Raider.java b/net/minecraft/world/entity/raid/Raider.java
index ab94809c5cedc8ea7db6db45394bc9c65516da63..e9a0372f5a262d13b25875d8c507fba9b5751840 100644
--- a/net/minecraft/world/entity/raid/Raider.java
+++ b/net/minecraft/world/entity/raid/Raider.java
@@ -396,7 +396,7 @@ public abstract class Raider extends PatrollingMonster {
         }
 
         private boolean cannotPickUpBanner() {
-            if (!getServerLevel(this.mob).getGameRules().get(net.minecraft.world.level.gamerules.GameRules.MOB_GRIEFING)) return true; // Paper - respect game and entity rules for picking up items
+            if (!getServerLevel(this.mob).getGameRules().get(net.minecraft.world.level.gamerules.GameRules.MOB_GRIEFING, this.mob.level().purpurConfig.pillagerCanPickUpLoot)) return true; // Paper - respect game and entity rules for picking up items // Purpur - Check mobGriefing Overrides
             if (!this.mob.hasActiveRaid()) {
                 return true;
             } else if (this.mob.getCurrentRaid().isOver()) {
diff --git a/net/minecraft/world/entity/raid/Raids.java b/net/minecraft/world/entity/raid/Raids.java
index 9ded4e75da1efd2fb351fa1544dca33da8455d98..f96d8c241bc0aa44750da7231edbbc5abd802619 100644
--- a/net/minecraft/world/entity/raid/Raids.java
+++ b/net/minecraft/world/entity/raid/Raids.java
@@ -31,6 +31,7 @@ import org.jspecify.annotations.Nullable;
 
 public class Raids extends SavedData {
     private static final String RAID_FILE_ID = "raids";
+    public final java.util.Map<java.util.UUID, Integer> playerCooldowns = com.google.common.collect.Maps.newHashMap(); // Purpur - Raid cooldown setting
     public static final Codec<Raids> CODEC = RecordCodecBuilder.create(
         instance -> instance.group(
                 Raids.RaidWithId.CODEC
@@ -82,6 +83,17 @@ public class Raids extends SavedData {
 
     public void tick(ServerLevel level) {
         this.tick++;
+        // Purpur start - Raid cooldown setting
+        if (level.purpurConfig.raidCooldownSeconds != 0 && this.tick % 20 == 0) {
+            com.google.common.collect.ImmutableMap.copyOf(playerCooldowns).forEach((uuid, i) -> {
+                if (i < 1) {
+                    playerCooldowns.remove(uuid);
+                } else {
+                    playerCooldowns.put(uuid, i - 1);
+                }
+            });
+        }
+        // Purpur end - Raid cooldown setting
         Iterator<Raid> iterator = this.raidMap.values().iterator();
 
         while (iterator.hasNext()) {
@@ -144,11 +156,11 @@ public class Raids extends SavedData {
                 // }
 
                 if (!raid.isStarted() || (raid.isInProgress() && raid.getRaidOmenLevel() < raid.getMaxRaidOmenLevel())) { // CraftBukkit - fixed a bug with raid: players could add up Bad Omen level even when the raid had finished
-                    // CraftBukkit start
+                    if (serverLevel.purpurConfig.raidCooldownSeconds != 0 && playerCooldowns.containsKey(player.getUUID())) return null; // Purpur - Raid cooldown setting// CraftBukkit start
                     if (!org.bukkit.craftbukkit.event.CraftEventFactory.callRaidTriggerEvent(serverLevel, raid, player)) {
                         player.removeEffect(net.minecraft.world.effect.MobEffects.RAID_OMEN);
                         return null;
-                    }
+                    }if (serverLevel.purpurConfig.raidCooldownSeconds != 0) playerCooldowns.put(player.getUUID(), serverLevel.purpurConfig.raidCooldownSeconds); // Purpur - Raid cooldown setting
 
                     if (!raid.isStarted() && !this.raidMap.containsValue(raid)) {
                         this.raidMap.put(this.getUniqueId(), raid);
diff --git a/net/minecraft/world/entity/vehicle/boat/AbstractBoat.java b/net/minecraft/world/entity/vehicle/boat/AbstractBoat.java
index 6b337848d91cc4f24655d053bc69b0cd22447dda..e5854af03a58dc26a100feac59357862e46bfeed 100644
--- a/net/minecraft/world/entity/vehicle/boat/AbstractBoat.java
+++ b/net/minecraft/world/entity/vehicle/boat/AbstractBoat.java
@@ -431,6 +431,7 @@ public abstract class AbstractBoat extends VehicleEntity implements Leashable {
             float groundFriction = this.getGroundFriction();
             if (groundFriction > 0.0F) {
                 this.landFriction = groundFriction;
+                if (level().purpurConfig.boatEjectPlayersOnLand) ejectPassengers(); // Purpur - Add option for boats to eject players on land
                 return AbstractBoat.Status.ON_LAND;
             } else {
                 return AbstractBoat.Status.IN_AIR;
@@ -817,7 +818,13 @@ public abstract class AbstractBoat extends VehicleEntity implements Leashable {
 
     @Override
     public final ItemStack getPickResult() {
-        return new ItemStack(this.dropItem.get());
+        // Purpur start - Apply display names from item forms of entities to entities and vice versa
+        final ItemStack boat = new ItemStack(this.dropItem.get());
+        if (!this.level().purpurConfig.persistentDroppableEntityDisplayNames) {
+            boat.set(net.minecraft.core.component.DataComponents.CUSTOM_NAME, null);
+        }
+        return boat;
+        // Purpur end - Apply display names from item forms of entities to entities and vice versa
     }
 
     public static enum Status {
diff --git a/net/minecraft/world/entity/vehicle/minecart/AbstractMinecart.java b/net/minecraft/world/entity/vehicle/minecart/AbstractMinecart.java
index 1123ec0038552e0b40774f4a433ff325695ea071..48099ae66045b6e78ec52832e3b972ac9c9bc246 100644
--- a/net/minecraft/world/entity/vehicle/minecart/AbstractMinecart.java
+++ b/net/minecraft/world/entity/vehicle/minecart/AbstractMinecart.java
@@ -105,6 +105,10 @@ public abstract class AbstractMinecart extends VehicleEntity {
     private double flyingY = 0.95;
     private double flyingZ = 0.95;
     public @Nullable Double maxSpeed;
+    // Purpur start - Minecart settings and WASD controls
+    public double storedMaxSpeed;
+    public boolean isNewBehavior;
+    // Purpur end - Minecart settings and WASD controls
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
     // CraftBukkit end
 
@@ -113,8 +117,13 @@ public abstract class AbstractMinecart extends VehicleEntity {
         this.blocksBuilding = true;
         if (useExperimentalMovement(level)) {
             this.behavior = new NewMinecartBehavior(this);
+            this.isNewBehavior = true; // Purpur - Minecart settings and WASD controls
         } else {
             this.behavior = new OldMinecartBehavior(this);
+            // Purpur start - Minecart settings and WASD controls
+            this.isNewBehavior = false;
+            maxSpeed = storedMaxSpeed = level.purpurConfig.minecartMaxSpeed;
+            // Purpur end - Minecart settings and WASD controls
         }
     }
 
@@ -278,6 +287,14 @@ public abstract class AbstractMinecart extends VehicleEntity {
 
     @Override
     public void tick() {
+        // Purpur start - Minecart settings and WASD controls
+        if (!this.isNewBehavior) {
+            if (storedMaxSpeed != level().purpurConfig.minecartMaxSpeed) {
+                maxSpeed = storedMaxSpeed = level().purpurConfig.minecartMaxSpeed;
+            }
+        }
+        // Purpur end - Minecart settings and WASD controls
+
         // CraftBukkit start
         double prevX = this.getX();
         double prevY = this.getY();
@@ -392,15 +409,61 @@ public abstract class AbstractMinecart extends VehicleEntity {
         this.behavior.moveAlongTrack(level);
     }
 
+    // Purpur start - Minecart settings and WASD controls
+    private Double lastSpeed;
+
+    public double getControllableSpeed() {
+        BlockState blockState = level().getBlockState(this.blockPosition());
+        if (!blockState.isSolid()) {
+            blockState = level().getBlockState(this.blockPosition().relative(Direction.DOWN));
+        }
+        Double speed = level().purpurConfig.minecartControllableBlockSpeeds.get(blockState.getBlock());
+        if (!blockState.isSolid()) {
+            speed = lastSpeed;
+        }
+        if (speed == null) {
+            speed = level().purpurConfig.minecartControllableBaseSpeed;
+        }
+        return lastSpeed = speed;
+    }
+    // Purpur end - Minecart settings and WASD controls
+
     protected void comeOffTrack(ServerLevel level) {
         double maxSpeed = this.getMaxSpeed(level);
         Vec3 deltaMovement = this.getDeltaMovement();
         this.setDeltaMovement(Mth.clamp(deltaMovement.x, -maxSpeed, maxSpeed), deltaMovement.y, Mth.clamp(deltaMovement.z, -maxSpeed, maxSpeed));
+
+        // Purpur start - Minecart settings and WASD controls
+        if (level().purpurConfig.minecartControllable && !isInWater() && !isInLava() && !passengers.isEmpty()) {
+            Entity passenger = passengers.get(0);
+            if (passenger instanceof net.minecraft.server.level.ServerPlayer player) {
+                net.minecraft.world.entity.player.Input lastClientInput = player.getLastClientInput();
+                float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F);
+                if (lastClientInput.jump() && this.onGround) {
+                    setDeltaMovement(new Vec3(getDeltaMovement().x, level().purpurConfig.minecartControllableHopBoost, getDeltaMovement().z));
+                }
+                if (forward != 0.0F) {
+                    org.bukkit.util.Vector velocity = player.getBukkitEntity().getEyeLocation().getDirection().normalize().multiply(getControllableSpeed());
+                    if (forward < 0.0) {
+                        velocity.multiply(-0.5);
+                    }
+                    setDeltaMovement(new Vec3(velocity.getX(), getDeltaMovement().y, velocity.getZ()));
+                }
+                this.setYRot(passenger.getYRot() - 90);
+                maxUpStep = level().purpurConfig.minecartControllableStepHeight;
+            } else {
+                maxUpStep = 0.0F;
+            }
+        } else {
+            maxUpStep = 0.0F;
+        }
+        // Purpur end - Minecart settings and WASD controls
         if (this.onGround()) {
             // CraftBukkit start - replace magic numbers with our variables
             this.setDeltaMovement(new Vec3(this.getDeltaMovement().x * this.derailedX, this.getDeltaMovement().y * this.derailedY, this.getDeltaMovement().z * this.derailedZ));
             // CraftBukkit end
         }
+        else if (level().purpurConfig.minecartControllable) setDeltaMovement(new Vec3(getDeltaMovement().x * derailedX, getDeltaMovement().y, getDeltaMovement().z * derailedZ)); // Purpur - Minecart settings and WASD controls
 
         this.move(MoverType.SELF, this.getDeltaMovement());
         if (!this.onGround()) {
diff --git a/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java b/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java
index 7cc494d53c9a6d2fa0d34a60da50a9d199d65340..84b11654411eaa561a9b58ffa1210ca3d3b5a7cd 100644
--- a/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java
@@ -391,7 +391,7 @@ public class NewMinecartBehavior extends MinecartBehavior {
     private Vec3 calculateBoostTrackSpeed(Vec3 speed, BlockPos pos, BlockState state) {
         if (state.is(Blocks.POWERED_RAIL) && state.getValue(PoweredRailBlock.POWERED)) {
             if (speed.length() > 0.01) {
-                return speed.normalize().scale(speed.length() + 0.06);
+                return speed.normalize().scale(speed.length() + this.level().purpurConfig.poweredRailBoostModifier); // Purpur - Configurable powered rail boost modifier
             } else {
                 Vec3 redstoneDirection = this.minecart.getRedstoneDirection(pos);
                 return redstoneDirection.lengthSqr() <= 0.0 ? speed : redstoneDirection.scale(speed.length() + 0.2);
diff --git a/net/minecraft/world/entity/vehicle/minecart/OldMinecartBehavior.java b/net/minecraft/world/entity/vehicle/minecart/OldMinecartBehavior.java
index 780b53eab14a087436e5f27c8d646042f4b357c9..7ab2542ddd7494585f240657906ccee80cd7944e 100644
--- a/net/minecraft/world/entity/vehicle/minecart/OldMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/minecart/OldMinecartBehavior.java
@@ -243,8 +243,8 @@ public class OldMinecartBehavior extends MinecartBehavior {
             Vec3 deltaMovement1 = this.getDeltaMovement();
             double d13 = deltaMovement1.horizontalDistance();
             if (d13 > 0.01) {
-                double d14 = 0.06;
-                this.setDeltaMovement(deltaMovement1.add(deltaMovement1.x / d13 * 0.06, 0.0, deltaMovement1.z / d13 * 0.06));
+                double d14 = level.purpurConfig.poweredRailBoostModifier; // Purpur - Configurable powered rail boost modifier
+                this.setDeltaMovement(deltaMovement1.add(deltaMovement1.x / d13 * level.purpurConfig.poweredRailBoostModifier, 0.0, deltaMovement1.z / d13 * level.purpurConfig.poweredRailBoostModifier)); // Purpur - Configurable powered rail boost modifier
             } else {
                 Vec3 deltaMovement2 = this.getDeltaMovement();
                 double d15 = deltaMovement2.x;
diff --git a/net/minecraft/world/food/FoodData.java b/net/minecraft/world/food/FoodData.java
index f4925847ee2dac8740148ffa82d8c23c4d0c7af0..5fa21ff6624df90925a6850f9f9f092396ed8b83 100644
--- a/net/minecraft/world/food/FoodData.java
+++ b/net/minecraft/world/food/FoodData.java
@@ -39,6 +39,7 @@ public class FoodData {
         int oldFoodLevel = this.foodLevel;
         org.bukkit.event.entity.FoodLevelChangeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callFoodLevelChangeEvent(serverPlayer, foodProperties.nutrition() + oldFoodLevel, stack);
         if (!event.isCancelled()) {
+            if (serverPlayer.level().purpurConfig.playerBurpWhenFull && event.getFoodLevel() == 20 && oldFoodLevel < 20) serverPlayer.burpDelay = serverPlayer.level().purpurConfig.playerBurpDelay; // Purpur - Burp after eating food fills hunger bar completely
             this.add(event.getFoodLevel() - oldFoodLevel, foodProperties.saturation());
         }
         serverPlayer.getBukkitEntity().sendHealthUpdate();
@@ -87,7 +88,7 @@ public class FoodData {
             this.tickTimer++;
             if (this.tickTimer >= this.starvationRate) { // CraftBukkit - add regen rate manipulation
                 if (player.getHealth() > 10.0F || difficulty == Difficulty.HARD || player.getHealth() > 1.0F && difficulty == Difficulty.NORMAL) {
-                    player.hurtServer(serverLevel, player.damageSources().starve(), 1.0F);
+                    player.hurtServer(serverLevel, player.damageSources().starve(), player.level().purpurConfig.hungerStarvationDamage); // Purpur - Configurable hunger starvation damage
                 }
 
                 this.tickTimer = 0;
diff --git a/net/minecraft/world/food/FoodProperties.java b/net/minecraft/world/food/FoodProperties.java
index 793e4528755fa5688efbad75418188e693ad0157..20f702c8266eb54a8835861188eb937f4732e078 100644
--- a/net/minecraft/world/food/FoodProperties.java
+++ b/net/minecraft/world/food/FoodProperties.java
@@ -42,9 +42,11 @@ public record FoodProperties(int nutrition, float saturation, boolean canAlwaysE
         level.playSound(null, entity.getX(), entity.getY(), entity.getZ(), consumable.sound().value(), SoundSource.NEUTRAL, 1.0F, random.triangle(1.0F, 0.4F));
         if (entity instanceof Player player) {
             player.getFoodData().eat(this, stack, (net.minecraft.server.level.ServerPlayer) player); // CraftBukkit
-            level.playSound(
-                null, player.getX(), player.getY(), player.getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 0.5F, Mth.randomBetween(random, 0.9F, 1.0F)
-            );
+            // Purpur start - Burp delay - moved to Player#tick()
+            //level.playSound(
+            //    null, player.getX(), player.getY(), player.getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 0.5F, Mth.randomBetween(random, 0.9F, 1.0F)
+            //);
+            // Purpur end - Burp delay - moved to Player#tick()
         }
     }
 
diff --git a/net/minecraft/world/inventory/AbstractContainerMenu.java b/net/minecraft/world/inventory/AbstractContainerMenu.java
index f51dbc45204c2727122aeb6b5002216e3200680d..19bdb38a69dcdb3d30f08a85b3e9c3d6d723191f 100644
--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -63,6 +63,7 @@ public abstract class AbstractContainerMenu {
     private final List<ContainerListener> containerListeners = Lists.newArrayList();
     private @Nullable ContainerSynchronizer synchronizer;
     private boolean suppressRemoteUpdates;
+    @Nullable protected ItemStack activeQuickItem = null; // Purpur - Anvil API
     // CraftBukkit start
     public boolean checkReachable = true;
     public abstract org.bukkit.inventory.InventoryView getBukkitView();
diff --git a/net/minecraft/world/inventory/AbstractFurnaceMenu.java b/net/minecraft/world/inventory/AbstractFurnaceMenu.java
index 6e13b05ebd924d98066624d9ff6ee7f61e248617..9304bc239ffafbef3b34c5a5a42039c86acd5e80 100644
--- a/net/minecraft/world/inventory/AbstractFurnaceMenu.java
+++ b/net/minecraft/world/inventory/AbstractFurnaceMenu.java
@@ -121,7 +121,13 @@ public abstract class AbstractFurnaceMenu extends RecipeBookMenu {
             } else if (slotIndex != 1 && slotIndex != 0) {
                 if (this.canSmelt(item)) {
                     if (!this.moveItemStackTo(item, 0, 1, false)) {
-                        return ItemStack.EMPTY;
+                        // Purpur start - Added the ability to add combustible items
+                        if (this.isFuel(item)) {
+                            if (!this.moveItemStackTo(item, 1, 2, false)) {
+                                return ItemStack.EMPTY;
+                            }
+                        }
+                        // Purpur end - Added the ability to add combustible items
                     }
                 } else if (this.isFuel(item)) {
                     if (!this.moveItemStackTo(item, 1, 2, false)) {
diff --git a/net/minecraft/world/inventory/AnvilMenu.java b/net/minecraft/world/inventory/AnvilMenu.java
index 7939f19b87364a32a40e58e001cea14e06348f86..b790b9476ec0a0569470d5de4067caa5373b2f6b 100644
--- a/net/minecraft/world/inventory/AnvilMenu.java
+++ b/net/minecraft/world/inventory/AnvilMenu.java
@@ -23,6 +23,12 @@ import net.minecraft.world.level.block.state.BlockState;
 import org.jspecify.annotations.Nullable;
 import org.slf4j.Logger;
 
+// Purpur start - Anvil API
+import net.minecraft.network.protocol.game.ClientboundContainerSetDataPacket;
+import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
+import net.minecraft.server.level.ServerPlayer;
+// Purpur end - Anvil API
+
 public class AnvilMenu extends ItemCombinerMenu {
     public static final int INPUT_SLOT = 0;
     public static final int ADDITIONAL_SLOT = 1;
@@ -51,6 +57,10 @@ public class AnvilMenu extends ItemCombinerMenu {
     private org.bukkit.craftbukkit.inventory.view.CraftAnvilView bukkitEntity;
     // CraftBukkit end
     public boolean bypassEnchantmentLevelRestriction = false; // Paper - bypass anvil level restrictions
+    // Purpur start - Anvil API
+    public boolean bypassCost = false;
+    public boolean canDoUnsafeEnchants = false;
+    // Purpur end - Anvil API
 
     public AnvilMenu(int containerId, Inventory playerInventory) {
         this(containerId, playerInventory, ContainerLevelAccess.NULL);
@@ -76,12 +86,17 @@ public class AnvilMenu extends ItemCombinerMenu {
 
     @Override
     protected boolean mayPickup(Player player, boolean hasStack) {
-        return (player.hasInfiniteMaterials() || player.experienceLevel >= this.cost.get()) && this.cost.get() > AnvilMenu.DEFAULT_DENIED_COST && hasStack; // CraftBukkit - allow cost 0 like a free item
+        return (player.hasInfiniteMaterials() || player.experienceLevel >= this.cost.get()) && (this.bypassCost || this.cost.get() > AnvilMenu.DEFAULT_DENIED_COST) && hasStack; // CraftBukkit - allow cost 0 like a free item // Purpur - Anvil API
     }
 
     @Override
     protected void onTake(Player player, ItemStack stack) {
+        // Purpur start - Anvil API
+        ItemStack itemstack = this.activeQuickItem != null ? this.activeQuickItem : stack;
+        if (org.purpurmc.purpur.event.inventory.AnvilTakeResultEvent.getHandlerList().getRegisteredListeners().length > 0) new org.purpurmc.purpur.event.inventory.AnvilTakeResultEvent(player.getBukkitEntity(), getBukkitView(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)).callEvent();
+        // Purpur end - Anvil API
         if (!player.hasInfiniteMaterials()) {
+            if (this.bypassCost) ((ServerPlayer) player).lastSentExp = -1; else // Purpur - Anvil API
             player.giveExperienceLevels(-this.cost.get());
         }
 
@@ -134,13 +149,19 @@ public class AnvilMenu extends ItemCombinerMenu {
 
     @Override
     public void createResult() {
+        // Purpur start - Anvil API
+        this.bypassCost = false;
+        this.canDoUnsafeEnchants = false;
+        if (org.purpurmc.purpur.event.inventory.AnvilUpdateResultEvent.getHandlerList().getRegisteredListeners().length > 0) new org.purpurmc.purpur.event.inventory.AnvilUpdateResultEvent(getBukkitView()).callEvent();
+        // Purpur end - Anvil API
+
         ItemStack item = this.inputSlots.getItem(0);
         this.onlyRenaming = false;
         this.cost.set(1);
         int i = 0;
         long l = 0L;
         int i1 = 0;
-        if (!item.isEmpty() && EnchantmentHelper.canStoreEnchantments(item)) {
+        if (!item.isEmpty() && this.canDoUnsafeEnchants || EnchantmentHelper.canStoreEnchantments(item)) { // Purpur - Anvil API
             ItemStack itemStack = item.copy();
             ItemStack item1 = this.inputSlots.getItem(1);
             ItemEnchantments.Mutable mutable = new ItemEnchantments.Mutable(EnchantmentHelper.getEnchantmentsForCrafting(itemStack));
@@ -198,23 +219,34 @@ public class AnvilMenu extends ItemCombinerMenu {
                         int intValue = entry.getIntValue();
                         intValue = level == intValue ? intValue + 1 : Math.max(intValue, level);
                         Enchantment enchantment = holder.value();
-                        boolean canEnchant = enchantment.canEnchant(item);
+                        // Purpur start - Config to allow unsafe enchants
+                        boolean canEnchant = this.canDoUnsafeEnchants || org.purpurmc.purpur.PurpurConfig.allowInapplicableEnchants || enchantment.canEnchant(item); // whether the enchantment can be applied on specific item type
+                        boolean canEnchant1 = true; // whether two incompatible enchantments can be applied on a single item
+                        // Purpur end - Config to allow unsafe enchants
                         if (this.player.hasInfiniteMaterials() || item.is(Items.ENCHANTED_BOOK)) {
                             canEnchant = true;
                         }
 
+                        java.util.Set<Holder<Enchantment>> removedEnchantments = new java.util.HashSet<>(); // Purpur - Config to allow unsafe enchants
                         for (Holder<Enchantment> holder1 : mutable.keySet()) {
                             if (!holder1.equals(holder) && !Enchantment.areCompatible(holder, holder1)) {
-                                canEnchant = false;
+                                canEnchant1 = this.canDoUnsafeEnchants || org.purpurmc.purpur.PurpurConfig.allowIncompatibleEnchants; // Purpur - Anvil API // Purpur - canEnchant -> canEnchant1 - Config to allow unsafe enchants
+                                // Purpur start - Config to allow unsafe enchants
+                                if (!canEnchant1 && org.purpurmc.purpur.PurpurConfig.replaceIncompatibleEnchants) {
+                                    removedEnchantments.add(holder1);
+                                    canEnchant1 = true;
+                                }
+                                // Purpur end - Config to allow unsafe enchants
                                 i++;
                             }
                         }
+                        mutable.removeIf(removedEnchantments::contains); // Purpur - Config to allow unsafe enchants
 
-                        if (!canEnchant) {
+                        if (!canEnchant || !canEnchant1) { // Purpur - Config to allow unsafe enchants
                             flag1 = true;
                         } else {
                             flag = true;
-                            if (intValue > enchantment.getMaxLevel() && !this.bypassEnchantmentLevelRestriction) { // Paper - bypass anvil level restrictions
+                            if (!org.purpurmc.purpur.PurpurConfig.allowHigherEnchantsLevels && intValue > enchantment.getMaxLevel() && !this.bypassEnchantmentLevelRestriction) { // Paper - bypass anvil level restrictions // Purpur - Config to allow unsafe enchants
                                 intValue = enchantment.getMaxLevel();
                             }
 
@@ -243,6 +275,54 @@ public class AnvilMenu extends ItemCombinerMenu {
                 if (!this.itemName.equals(item.getHoverName().getString())) {
                     i1 = 1;
                     i += i1;
+                    // Purpur start - Allow anvil colors
+                    if (this.player != null) {
+                        org.bukkit.craftbukkit.entity.CraftHumanEntity player = this.player.getBukkitEntity();
+                        String name = this.itemName;
+                        boolean removeItalics = false;
+                        if (player.hasPermission("purpur.anvil.remove_italics")) {
+                            if (name.startsWith("&r")) {
+                                name = name.substring(2);
+                                removeItalics = true;
+                            } else if (name.startsWith("<r>")) {
+                                name = name.substring(3);
+                                removeItalics = true;
+                            } else if (name.startsWith("<reset>")) {
+                                name = name.substring(7);
+                                removeItalics = true;
+                            }
+                        }
+                        if (this.player.level().purpurConfig.anvilAllowColors) {
+                            if (player.hasPermission("purpur.anvil.color")) {
+                                java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("(?i)&([0-9a-fr])").matcher(name);
+                                while (matcher.find()) {
+                                    String match = matcher.group(1);
+                                    name = name.replace("&" + match, "\u00a7" + match.toLowerCase(java.util.Locale.ROOT));
+                                }
+                                //name = name.replaceAll("(?i)&([0-9a-fr])", "\u00a7$1");
+                            }
+                            if (player.hasPermission("purpur.anvil.format")) {
+                                java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("(?i)&([k-or])").matcher(name);
+                                while (matcher.find()) {
+                                    String match = matcher.group(1);
+                                    name = name.replace("&" + match, "\u00a7" + match.toLowerCase(java.util.Locale.ROOT));
+                                }
+                                //name = name.replaceAll("(?i)&([l-or])", "\u00a7$1");
+                            }
+                        }
+                        net.kyori.adventure.text.Component component;
+                        if (this.player.level().purpurConfig.anvilColorsUseMiniMessage && player.hasPermission("purpur.anvil.minimessage")) {
+                            component = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.bukkit.ChatColor.stripColor(name));
+                        } else {
+                            component = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(name);
+                        }
+                        if (removeItalics) {
+                            component = component.decoration(net.kyori.adventure.text.format.TextDecoration.ITALIC, false);
+                        }
+                        itemStack.set(DataComponents.CUSTOM_NAME, io.papermc.paper.adventure.PaperAdventure.asVanilla(component));
+                    }
+                    else
+                    // Purpur end - Allow anvil colors
                     itemStack.set(DataComponents.CUSTOM_NAME, Component.literal(this.itemName));
                 }
             } else if (item.has(DataComponents.CUSTOM_NAME)) {
@@ -267,6 +347,12 @@ public class AnvilMenu extends ItemCombinerMenu {
                 this.onlyRenaming = true;
             }
 
+            // Purpur start - Anvil API
+            if (this.bypassCost && this.cost.get() >= this.maximumRepairCost) {
+                this.cost.set(this.maximumRepairCost - 1);
+            }
+            // Purpur end - Anvil API
+
             if (this.cost.get() >= this.maximumRepairCost && !this.player.hasInfiniteMaterials()) { // CraftBukkit
                 itemStack = ItemStack.EMPTY;
             }
@@ -287,6 +373,13 @@ public class AnvilMenu extends ItemCombinerMenu {
 
             org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(this.getBukkitView(), itemStack); // CraftBukkit
             this.broadcastChanges();
+
+            // Purpur start - Anvil API
+            if ((this.canDoUnsafeEnchants || org.purpurmc.purpur.PurpurConfig.allowInapplicableEnchants || org.purpurmc.purpur.PurpurConfig.allowIncompatibleEnchants) && itemStack != ItemStack.EMPTY) { // Purpur - Config to allow unsafe enchants
+                ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetSlotPacket(this.containerId, this.incrementStateId(), 2, itemStack));
+                ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetDataPacket(this.containerId, 0, this.cost.get()));
+            }
+            // Purpur end - Anvil API
         } else {
             org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(this.getBukkitView(), ItemStack.EMPTY); // CraftBukkit
             this.cost.set(AnvilMenu.DEFAULT_DENIED_COST); // CraftBukkit - use a variable for set a cost for denied item
@@ -295,7 +388,7 @@ public class AnvilMenu extends ItemCombinerMenu {
     }
 
     public static int calculateIncreasedRepairCost(int oldRepairCost) {
-        return (int)Math.min(oldRepairCost * 2L + 1L, 2147483647L);
+        return org.purpurmc.purpur.PurpurConfig.anvilCumulativeCost ? (int)Math.min(oldRepairCost * 2L + 1L, 2147483647L) : 0; // Purpur - Make anvil cumulative cost configurable
     }
 
     public boolean setItemName(String itemName) {
diff --git a/net/minecraft/world/inventory/ArmorSlot.java b/net/minecraft/world/inventory/ArmorSlot.java
index f9fef56709a40e2581170a807a0035b593795b05..cdc95952311e6a2df757c3d8ec1224e3e5ad3069 100644
--- a/net/minecraft/world/inventory/ArmorSlot.java
+++ b/net/minecraft/world/inventory/ArmorSlot.java
@@ -46,7 +46,7 @@ class ArmorSlot extends Slot {
     @Override
     public boolean mayPickup(Player player) {
         ItemStack item = this.getItem();
-        return (item.isEmpty() || player.isCreative() || !EnchantmentHelper.has(item, EnchantmentEffectComponents.PREVENT_ARMOR_CHANGE))
+        return (item.isEmpty() || player.isCreative() || (!EnchantmentHelper.has(item, EnchantmentEffectComponents.PREVENT_ARMOR_CHANGE) || player.level().purpurConfig.playerRemoveBindingWithWeakness && player.hasEffect(net.minecraft.world.effect.MobEffects.WEAKNESS))) // Purpur - Config to remove curse of binding with weakness
             && super.mayPickup(player);
     }
 
diff --git a/net/minecraft/world/inventory/ChestMenu.java b/net/minecraft/world/inventory/ChestMenu.java
index 1fb3a34ea872dec73658fac59743e46ef8db5151..4c3b8d7ba777916ffc5ad0feccffbc7634bffe8d 100644
--- a/net/minecraft/world/inventory/ChestMenu.java
+++ b/net/minecraft/world/inventory/ChestMenu.java
@@ -66,10 +66,30 @@ public class ChestMenu extends AbstractContainerMenu {
         return new ChestMenu(MenuType.GENERIC_9x6, containerId, playerInventory, 6);
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    public static ChestMenu oneRow(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x1, syncId, playerInventory, inventory, 1);
+    }
+
+    public static ChestMenu twoRows(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x2, syncId, playerInventory, inventory, 2);
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     public static ChestMenu threeRows(int containerId, Inventory playerInventory, Container container) {
         return new ChestMenu(MenuType.GENERIC_9x3, containerId, playerInventory, container, 3);
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    public static ChestMenu fourRows(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x4, syncId, playerInventory, inventory, 4);
+    }
+
+    public static ChestMenu fiveRows(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x5, syncId, playerInventory, inventory, 5);
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     public static ChestMenu sixRows(int containerId, Inventory playerInventory, Container container) {
         return new ChestMenu(MenuType.GENERIC_9x6, containerId, playerInventory, container, 6);
     }
diff --git a/net/minecraft/world/inventory/EnchantmentMenu.java b/net/minecraft/world/inventory/EnchantmentMenu.java
index 385eecd0c59d3c9510e39f96aa9614a7a57fb65a..40860d2facd6720300793dcc2cf99cb3367e61f7 100644
--- a/net/minecraft/world/inventory/EnchantmentMenu.java
+++ b/net/minecraft/world/inventory/EnchantmentMenu.java
@@ -63,6 +63,22 @@ public class EnchantmentMenu extends AbstractContainerMenu {
                 return access.getLocation();
             }
             // CraftBukkit end
+
+            // Purpur start - Enchantment Table Persists Lapis
+            @Override
+            public void onClose(org.bukkit.craftbukkit.entity.CraftHumanEntity who) {
+                super.onClose(who);
+
+                if (who.getHandle().level().purpurConfig.enchantmentTableLapisPersists) {
+                    access.execute((level, pos) -> {
+                        net.minecraft.world.level.block.entity.BlockEntity blockEntity = level.getBlockEntity(pos);
+                        if (blockEntity instanceof net.minecraft.world.level.block.entity.EnchantingTableBlockEntity enchantmentTable) {
+                            enchantmentTable.setLapis(this.getItem(1).getCount());
+                        }
+                    });
+                }
+            }
+            // Purpur end - Enchantment Table Persists Lapis
         };
         // Paper end - Add missing InventoryHolders
         this.access = access;
@@ -83,6 +99,16 @@ public class EnchantmentMenu extends AbstractContainerMenu {
                 return EnchantmentMenu.EMPTY_SLOT_LAPIS_LAZULI;
             }
         });
+        // Purpur start - Enchantment Table Persists Lapis
+        access.execute((level, pos) -> {
+            if (level.purpurConfig.enchantmentTableLapisPersists) {
+                net.minecraft.world.level.block.entity.BlockEntity blockEntity = level.getBlockEntity(pos);
+                if (blockEntity instanceof net.minecraft.world.level.block.entity.EnchantingTableBlockEntity enchantmentTable) {
+                    this.getSlot(1).set(new ItemStack(Items.LAPIS_LAZULI, enchantmentTable.getLapis()));
+                }
+            }
+        });
+        // Purpur end - Enchantment Table Persists Lapis
         this.addStandardInventorySlots(playerInventory, 8, 84);
         this.addDataSlot(DataSlot.shared(this.costs, 0));
         this.addDataSlot(DataSlot.shared(this.costs, 1));
@@ -299,7 +325,7 @@ public class EnchantmentMenu extends AbstractContainerMenu {
     @Override
     public void removed(Player player) {
         super.removed(player);
-        this.access.execute((level, pos) -> this.clearContainer(player, this.enchantSlots));
+        this.access.execute((level, pos) -> {if (level.purpurConfig.enchantmentTableLapisPersists) this.getSlot(1).set(ItemStack.EMPTY);this.clearContainer(player, this.enchantSlots);}); // Purpur - Enchantment Table Persists Lapis
     }
 
     @Override
diff --git a/net/minecraft/world/inventory/GrindstoneMenu.java b/net/minecraft/world/inventory/GrindstoneMenu.java
index ad70a0f7debee27d9f3b2ff39cb0429b39485190..e991ca16d069fddc3e4eb6d8c78c0dbffeb75a54 100644
--- a/net/minecraft/world/inventory/GrindstoneMenu.java
+++ b/net/minecraft/world/inventory/GrindstoneMenu.java
@@ -92,11 +92,13 @@ public class GrindstoneMenu extends AbstractContainerMenu {
             @Override
             public void onTake(Player player, ItemStack stack) {
                 access.execute((level, blockPos) -> {
+                    ItemStack itemstack = activeQuickItem == null ? stack : activeQuickItem; // Purpur - Grindstone API
                     if (level instanceof ServerLevel) {
                         // Paper start - Fire BlockExpEvent on grindstone use
                         org.bukkit.event.block.BlockExpEvent event = new org.bukkit.event.block.BlockExpEvent(org.bukkit.craftbukkit.block.CraftBlock.at(level, blockPos), this.getExperienceAmount(level));
                         event.callEvent();
-                        ExperienceOrb.awardWithDirection((ServerLevel) level, Vec3.atCenterOf(blockPos), Vec3.ZERO, event.getExpToDrop(), org.bukkit.entity.ExperienceOrb.SpawnReason.GRINDSTONE, player, null);
+                        org.purpurmc.purpur.event.inventory.GrindstoneTakeResultEvent grindstoneTakeResultEvent = new org.purpurmc.purpur.event.inventory.GrindstoneTakeResultEvent(player.getBukkitEntity(), getBukkitView(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack), event.getExpToDrop()); grindstoneTakeResultEvent.callEvent(); // Purpur - Grindstone API
+                        ExperienceOrb.awardWithDirection((ServerLevel) level, Vec3.atCenterOf(blockPos), Vec3.ZERO, grindstoneTakeResultEvent.getExperienceAmount(), org.bukkit.entity.ExperienceOrb.SpawnReason.GRINDSTONE, player, null); // Purpur - Grindstone API
                         // Paper end - Fire BlockExpEvent on grindstone use
                     }
 
@@ -125,7 +127,7 @@ public class GrindstoneMenu extends AbstractContainerMenu {
                 for (Entry<Holder<Enchantment>> entry : enchantmentsForCrafting.entrySet()) {
                     Holder<Enchantment> holder = entry.getKey();
                     int intValue = entry.getIntValue();
-                    if (!holder.is(EnchantmentTags.CURSE)) {
+                    if (!org.purpurmc.purpur.PurpurConfig.grindstoneIgnoredEnchants.contains(holder.value())) { // Purpur - Config for grindstones
                         i += holder.value().getMinCost(intValue);
                     }
                 }
@@ -203,15 +205,75 @@ public class GrindstoneMenu extends AbstractContainerMenu {
 
             for (Entry<Holder<Enchantment>> entry : enchantmentsForCrafting.entrySet()) {
                 Holder<Enchantment> holder = entry.getKey();
-                if (!holder.is(EnchantmentTags.CURSE) || mutable.getLevel(holder) == 0) {
+                if (!org.purpurmc.purpur.PurpurConfig.grindstoneIgnoredEnchants.contains(holder.value()) || mutable.getLevel(holder) == 0) { // Purpur - Config for grindstones
                     mutable.upgrade(holder, entry.getIntValue());
                 }
             }
         });
     }
 
+    // Purpur start - Config for grindstones
+    private java.util.List<net.minecraft.core.component.DataComponentType<?>> GRINDSTONE_REMOVE_ATTRIBUTES_REMOVAL_LIST = java.util.List.of(
+        // DataComponents.MAX_STACK_SIZE,
+        // DataComponents.DAMAGE,
+        // DataComponents.BLOCK_STATE,
+        DataComponents.CUSTOM_DATA,
+        // DataComponents.MAX_DAMAGE,
+        // DataComponents.UNBREAKABLE,
+        // DataComponents.CUSTOM_NAME,
+        // DataComponents.ITEM_NAME,
+        // DataComponents.LORE,
+        // DataComponents.RARITY,
+        // DataComponents.ENCHANTMENTS,
+        // DataComponents.CAN_PLACE_ON,
+        // DataComponents.CAN_BREAK,
+        DataComponents.ATTRIBUTE_MODIFIERS,
+        DataComponents.CUSTOM_MODEL_DATA,
+        // DataComponents.HIDE_ADDITIONAL_TOOLTIP,
+        // DataComponents.HIDE_TOOLTIP,
+        // DataComponents.REPAIR_COST,
+        // DataComponents.CREATIVE_SLOT_LOCK,
+        // DataComponents.ENCHANTMENT_GLINT_OVERRIDE,
+        // DataComponents.INTANGIBLE_PROJECTILE,
+        // DataComponents.FOOD,
+        // DataComponents.FIRE_RESISTANT,
+        // DataComponents.TOOL,
+        // DataComponents.STORED_ENCHANTMENTS,
+        DataComponents.DYED_COLOR,
+        // DataComponents.MAP_COLOR,
+        // DataComponents.MAP_ID,
+        // DataComponents.MAP_DECORATIONS,
+        // DataComponents.MAP_POST_PROCESSING,
+        // DataComponents.CHARGED_PROJECTILES,
+        // DataComponents.BUNDLE_CONTENTS,
+        // DataComponents.POTION_CONTENTS,
+        DataComponents.SUSPICIOUS_STEW_EFFECTS
+        // DataComponents.WRITABLE_BOOK_CONTENT,
+        // DataComponents.WRITTEN_BOOK_CONTENT,
+        // DataComponents.TRIM,
+        // DataComponents.DEBUG_STICK_STATE,
+        // DataComponents.ENTITY_DATA,
+        // DataComponents.BUCKET_ENTITY_DATA,
+        // DataComponents.BLOCK_ENTITY_DATA,
+        // DataComponents.INSTRUMENT,
+        // DataComponents.OMINOUS_BOTTLE_AMPLIFIER,
+        // DataComponents.RECIPES,
+        // DataComponents.LODESTONE_TRACKER,
+        // DataComponents.FIREWORK_EXPLOSION,
+        // DataComponents.FIREWORKS,
+        // DataComponents.PROFILE,
+        // DataComponents.NOTE_BLOCK_SOUND,
+        // DataComponents.BANNER_PATTERNS,
+        // DataComponents.BASE_COLOR,
+        // DataComponents.POT_DECORATIONS,
+        // DataComponents.CONTAINER,
+        // DataComponents.BEES,
+        // DataComponents.LOCK,
+        // DataComponents.CONTAINER_LOOT,
+    );
+    // Purpur end - Config for grindstones
     private ItemStack removeNonCursesFrom(ItemStack item) {
-        ItemEnchantments itemEnchantments = EnchantmentHelper.updateEnchantments(item, mutable -> mutable.removeIf(holder -> !holder.is(EnchantmentTags.CURSE)));
+        ItemEnchantments itemEnchantments = EnchantmentHelper.updateEnchantments(item, mutable -> mutable.removeIf(holder -> !org.purpurmc.purpur.PurpurConfig.grindstoneIgnoredEnchants.contains(holder.value()))); // Purpur - Config for grindstones
         if (item.is(Items.ENCHANTED_BOOK) && itemEnchantments.isEmpty()) {
             item = item.transmuteCopy(Items.BOOK);
         }
@@ -223,6 +285,23 @@ public class GrindstoneMenu extends AbstractContainerMenu {
         }
 
         item.set(DataComponents.REPAIR_COST, i);
+
+        // Purpur start - Config for grindstones
+        net.minecraft.core.component.DataComponentPatch.Builder builder = net.minecraft.core.component.DataComponentPatch.builder();
+        if (org.purpurmc.purpur.PurpurConfig.grindstoneRemoveAttributes) {
+            item.getComponents().forEach(typedDataComponent -> {
+                if (GRINDSTONE_REMOVE_ATTRIBUTES_REMOVAL_LIST.contains(typedDataComponent.type())) {
+                    builder.remove(typedDataComponent.type());
+                }
+            });
+        }
+        if (org.purpurmc.purpur.PurpurConfig.grindstoneRemoveDisplay) {
+            builder.remove(DataComponents.CUSTOM_NAME);
+            builder.remove(DataComponents.LORE);
+        }
+        item.applyComponents(builder.build());
+        // Purpur end - Config for grindstones
+
         return item;
     }
 
@@ -279,7 +358,9 @@ public class GrindstoneMenu extends AbstractContainerMenu {
                 return ItemStack.EMPTY;
             }
 
+            this.activeQuickItem = itemStack; // Purpur - Grindstone API
             slot.onTake(player, item);
+            this.activeQuickItem = null; // Purpur - Grindstone API
         }
 
         return itemStack;
diff --git a/net/minecraft/world/inventory/ItemCombinerMenu.java b/net/minecraft/world/inventory/ItemCombinerMenu.java
index 1296631fc74e83e6c9d6af0cd46d12d9851a30b1..e6c3a0086963298be31befbbbf8d42e85f379c79 100644
--- a/net/minecraft/world/inventory/ItemCombinerMenu.java
+++ b/net/minecraft/world/inventory/ItemCombinerMenu.java
@@ -156,7 +156,9 @@ public abstract class ItemCombinerMenu extends AbstractContainerMenu {
                 return ItemStack.EMPTY;
             }
 
+            this.activeQuickItem = itemStack; // Purpur - Anvil API
             slot.onTake(player, item);
+            this.activeQuickItem = null; // Purpur - Anvil API
         }
 
         return itemStack;
diff --git a/net/minecraft/world/inventory/PlayerEnderChestContainer.java b/net/minecraft/world/inventory/PlayerEnderChestContainer.java
index 9749909b8253b432bb2f7fba2cd8ff17a8579b30..1ef8696003e62af8dfd59340dd9cce76920b45f6 100644
--- a/net/minecraft/world/inventory/PlayerEnderChestContainer.java
+++ b/net/minecraft/world/inventory/PlayerEnderChestContainer.java
@@ -26,11 +26,18 @@ public class PlayerEnderChestContainer extends SimpleContainer {
     }
 
     public PlayerEnderChestContainer(Player owner) {
-        super(27);
+        super(org.purpurmc.purpur.PurpurConfig.enderChestSixRows ? 54 : 27); // Purpur - Barrels and enderchests 6 rows
         this.owner = owner;
         // CraftBukkit end
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    @Override
+    public int getContainerSize() {
+        return owner == null || owner.sixRowEnderchestSlotCount < 0 ? super.getContainerSize() : owner.sixRowEnderchestSlotCount;
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     public void setActiveChest(EnderChestBlockEntity enderChestBlockEntity) {
         this.activeChest = enderChestBlockEntity;
     }
diff --git a/net/minecraft/world/item/ArmorStandItem.java b/net/minecraft/world/item/ArmorStandItem.java
index 962483d6f7225f13f121141882262d36dacad8cb..89d4bc00898fd8f6d40cda87c04c5983e2ea223c 100644
--- a/net/minecraft/world/item/ArmorStandItem.java
+++ b/net/minecraft/world/item/ArmorStandItem.java
@@ -51,6 +51,10 @@ public class ArmorStandItem extends Item {
                         return InteractionResult.FAIL;
                     }
                     // CraftBukkit end
+                    // Purpur start - Apply display names from item forms of entities to entities and vice versa
+                    if (!serverLevel.purpurConfig.persistentDroppableEntityDisplayNames) armorStand.setCustomName(null);
+                    if (serverLevel.purpurConfig.armorstandSetNameVisible && armorStand.getCustomName() != null) armorStand.setCustomNameVisible(true);
+                    // Purpur end - Apply display names from item forms of entities to entities and vice versa
                     serverLevel.addFreshEntityWithPassengers(armorStand);
                     level.playSound(
                         null, armorStand.getX(), armorStand.getY(), armorStand.getZ(), SoundEvents.ARMOR_STAND_PLACE, SoundSource.BLOCKS, 0.75F, 0.8F
diff --git a/net/minecraft/world/item/AxeItem.java b/net/minecraft/world/item/AxeItem.java
index 8b006edd6f766f942d691f5271a7505a75700d0c..443410efadc9b8e919a23e475ff9457b93e8f156 100644
--- a/net/minecraft/world/item/AxeItem.java
+++ b/net/minecraft/world/item/AxeItem.java
@@ -65,13 +65,15 @@ public class AxeItem extends Item {
         if (playerHasBlockingItemUseIntent(context)) {
             return InteractionResult.PASS;
         } else {
-            Optional<BlockState> optional = this.evaluateNewBlockState(level, clickedPos, player, level.getBlockState(clickedPos));
+            Optional<org.purpurmc.purpur.tool.Actionable> optional = this.evaluateActionable(level, clickedPos, player, level.getBlockState(clickedPos)); // Purpur - Tool actionable options
             if (optional.isEmpty()) {
                 return InteractionResult.PASS;
             } else {
+                org.purpurmc.purpur.tool.Actionable actionable = optional.get(); // Purpur - Tool actionable options
+                BlockState state = actionable.into().withPropertiesOf(level.getBlockState(clickedPos)); // Purpur - Tool actionable options
                 ItemStack itemInHand = context.getItemInHand();
                 // Paper start - EntityChangeBlockEvent
-                if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(player, clickedPos, optional.get())) {
+                if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(player, clickedPos, state)) { // Purpur - Tool actionable options
                     return InteractionResult.PASS;
                 }
                 // Paper end
@@ -79,8 +81,15 @@ public class AxeItem extends Item {
                     CriteriaTriggers.ITEM_USED_ON_BLOCK.trigger((ServerPlayer)player, clickedPos, itemInHand);
                 }
 
-                level.setBlock(clickedPos, optional.get(), Block.UPDATE_ALL_IMMEDIATE);
-                level.gameEvent(GameEvent.BLOCK_CHANGE, clickedPos, GameEvent.Context.of(player, optional.get()));
+                // Purpur start - Tool actionable options
+                level.setBlock(clickedPos, state, Block.UPDATE_ALL_IMMEDIATE);
+                actionable.drops().forEach((drop, chance) -> {
+                    if (level.random.nextDouble() < chance) {
+                        Block.popResourceFromFace(level, clickedPos, context.getClickedFace(), new ItemStack(drop));
+                    }
+                });
+                level.gameEvent(GameEvent.BLOCK_CHANGE, clickedPos, GameEvent.Context.of(player, state));
+                // Purpur end - Tool actionable options
                 if (player != null) {
                     itemInHand.hurtAndBreak(1, player, context.getHand().asEquipmentSlot());
                 }
@@ -97,21 +106,23 @@ public class AxeItem extends Item {
             && !player.isSecondaryUseActive();
     }
 
-    private Optional<BlockState> evaluateNewBlockState(Level level, BlockPos pos, @Nullable Player player, BlockState state) {
-        Optional<BlockState> stripped = this.getStripped(state);
+    private Optional<org.purpurmc.purpur.tool.Actionable> evaluateActionable(Level level, BlockPos pos, @Nullable Player player, BlockState state) { // Purpur - Tool actionable options
+        Optional<org.purpurmc.purpur.tool.Actionable> stripped = Optional.ofNullable(level.purpurConfig.axeStrippables.get(state.getBlock())); // Purpur - Tool actionable options
         if (stripped.isPresent()) {
-            level.playSound(player, pos, SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F);
+            level.playSound(STRIPPABLES.containsKey(state.getBlock()) ? player : null, pos, SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F); // Purpur - force sound
             return stripped;
         } else {
-            Optional<BlockState> previous = WeatheringCopper.getPrevious(state);
+            Optional<org.purpurmc.purpur.tool.Actionable> previous = Optional.ofNullable(level.purpurConfig.axeWeatherables.get(state.getBlock())); // Purpur - Tool actionable options
             if (previous.isPresent()) {
-                spawnSoundAndParticle(level, pos, player, state, SoundEvents.AXE_SCRAPE, LevelEvent.PARTICLES_SCRAPE);
+                spawnSoundAndParticle(level, pos, WeatheringCopper.getPrevious(state).isPresent() ? player : null, state, SoundEvents.AXE_SCRAPE, LevelEvent.PARTICLES_SCRAPE); // Purpur - Tool actionable options - force sound
                 return previous;
             } else {
-                Optional<BlockState> optional = Optional.ofNullable(HoneycombItem.WAX_OFF_BY_BLOCK.get().get(state.getBlock()))
-                    .map(block -> block.withPropertiesOf(state));
+                // Purpur start - Tool actionable options
+                Optional<org.purpurmc.purpur.tool.Actionable> optional = Optional.ofNullable(level.purpurConfig.axeWaxables.get(state.getBlock()));
+                //    .map(block -> block.withPropertiesOf(state));
+                // Purpur end - Tool actionable options
                 if (optional.isPresent()) {
-                    spawnSoundAndParticle(level, pos, player, state, SoundEvents.AXE_WAX_OFF, LevelEvent.PARTICLES_WAX_OFF);
+                    spawnSoundAndParticle(level, pos, HoneycombItem.WAX_OFF_BY_BLOCK.get().containsKey(state.getBlock()) ? player : null, state, SoundEvents.AXE_WAX_OFF, LevelEvent.PARTICLES_WAX_OFF); // Purpur - Tool actionable options - force sound
                     return optional;
                 } else {
                     return Optional.empty();
diff --git a/net/minecraft/world/item/BlockItem.java b/net/minecraft/world/item/BlockItem.java
index 73ce7c82c0bd28c2e43ca40ba35c4603b21375ad..60261f504dc5669f9e2d0a2aee5dbd33c62c8893 100644
--- a/net/minecraft/world/item/BlockItem.java
+++ b/net/minecraft/world/item/BlockItem.java
@@ -143,7 +143,16 @@ public class BlockItem extends Item {
     }
 
     protected boolean updateCustomBlockEntityTag(BlockPos pos, Level level, @Nullable Player player, ItemStack stack, BlockState state) {
-        return updateCustomBlockEntityTag(level, player, pos, stack);
+        // Purpur start - Persistent BlockEntity Lore and DisplayName
+        boolean handled = updateCustomBlockEntityTag(level, player, pos, stack);
+        if (level.purpurConfig.persistentTileEntityLore) {
+            BlockEntity blockEntity1 = level.getBlockEntity(pos);
+            if (blockEntity1 != null) {
+                blockEntity1.setPersistentLore(stack.getOrDefault(DataComponents.LORE, net.minecraft.world.item.component.ItemLore.EMPTY));
+            }
+        }
+        return handled;
+        // Purpur end - Persistent BlockEntity Lore and DisplayName
     }
 
     protected @Nullable BlockState getPlacementState(BlockPlaceContext context) {
@@ -204,6 +213,7 @@ public class BlockItem extends Item {
                     }
 
                     if (!type.onlyOpCanSetNbt() || player != null && (player.canUseGameMasterBlocks() || (player.getAbilities().instabuild && player.getBukkitEntity().hasPermission("minecraft.nbt.place")))) { // Spigot - add permission
+                        if (!(level.purpurConfig.silkTouchEnabled && blockEntity instanceof net.minecraft.world.level.block.entity.SpawnerBlockEntity && player.getBukkitEntity().hasPermission("purpur.drop.spawners"))) // Purpur - Silk touch spawners
                         return typedEntityData.loadInto(blockEntity, level.registryAccess());
                     }
 
@@ -244,6 +254,7 @@ public class BlockItem extends Item {
     public void onDestroyed(ItemEntity itemEntity) {
         ItemContainerContents itemContainerContents = itemEntity.getItem().set(DataComponents.CONTAINER, ItemContainerContents.EMPTY);
         if (itemContainerContents != null) {
+            if (itemEntity.level().purpurConfig.shulkerBoxItemDropContentsWhenDestroyed && this.getBlock() instanceof ShulkerBoxBlock) // Purpur - option to disable shulker box items from dropping contents when destroyed
             ItemUtils.onContainerDestroyed(itemEntity, itemContainerContents.nonEmptyItemsCopy());
         }
     }
diff --git a/net/minecraft/world/item/BoatItem.java b/net/minecraft/world/item/BoatItem.java
index a8732056d0086a0932e82f70396a8849bf8d0ee1..2219d5e3e3d1aaa9f729205191a1f549ed662e2e 100644
--- a/net/minecraft/world/item/BoatItem.java
+++ b/net/minecraft/world/item/BoatItem.java
@@ -63,6 +63,7 @@ public class BoatItem extends Item {
                     return InteractionResult.FAIL;
                 } else {
                     boat.setYRot(player.getYRot());
+                    if (!level.purpurConfig.persistentDroppableEntityDisplayNames) boat.setCustomName(null); // Purpur - Apply display names from item forms of entities to entities and vice versa
                     if (!level.noCollision(boat, boat.getBoundingBox())) {
                         return InteractionResult.FAIL;
                     } else {
diff --git a/net/minecraft/world/item/BowItem.java b/net/minecraft/world/item/BowItem.java
index 616f17713c43b6b28cb58c45071f1a7a74010261..0a14a098f3aa40c8195c3a3bdf61ad6ae0fcc9d2 100644
--- a/net/minecraft/world/item/BowItem.java
+++ b/net/minecraft/world/item/BowItem.java
@@ -28,6 +28,11 @@ public class BowItem extends ProjectileWeaponItem {
             return false;
         } else {
             ItemStack projectile = player.getProjectile(stack);
+            //  Purpur start - Infinity bow settings
+            if (level.purpurConfig.infinityWorksWithoutArrows && projectile.isEmpty() && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.INFINITY, stack) > 0) {
+                projectile = new ItemStack(Items.ARROW);
+            }
+            // Purpur end - Infinity bow settings
             if (projectile.isEmpty()) {
                 return false;
             } else {
@@ -38,7 +43,7 @@ public class BowItem extends ProjectileWeaponItem {
                 } else {
                     List<ItemStack> list = draw(stack, projectile, player);
                     if (level instanceof ServerLevel serverLevel && !list.isEmpty()) {
-                        this.shoot(serverLevel, player, player.getUsedItemHand(), stack, list, powerForTime * 3.0F, 1.0F, powerForTime == 1.0F, null, powerForTime); // Paper - Pass draw strength
+                        this.shoot(serverLevel, player, player.getUsedItemHand(), stack, list, powerForTime * 3.0F, (float) serverLevel.purpurConfig.bowProjectileOffset, powerForTime == 1.0F, null, powerForTime); // Paper - Pass draw strength // Purpur - Projectile offset config
                     }
 
                     level.playSound(
@@ -89,7 +94,7 @@ public class BowItem extends ProjectileWeaponItem {
     public InteractionResult use(Level level, Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         boolean flag = !player.getProjectile(itemInHand).isEmpty();
-        if (!player.hasInfiniteMaterials() && !flag) {
+        if (!player.hasInfiniteMaterials() && !flag && !(level.purpurConfig.infinityWorksWithoutArrows && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.INFINITY, itemInHand) > 0)) { // Purpur - Infinity bow settings
             return InteractionResult.FAIL;
         } else {
             player.startUsingItem(hand);
diff --git a/net/minecraft/world/item/BucketItem.java b/net/minecraft/world/item/BucketItem.java
index 9d6485148393292006ed4453e0ed228b6197b239..0ffdbcd75fa57feb2ada835c0189246821d279d1 100644
--- a/net/minecraft/world/item/BucketItem.java
+++ b/net/minecraft/world/item/BucketItem.java
@@ -148,7 +148,7 @@ public class BucketItem extends Item implements DispensibleContainerItem {
             // CraftBukkit end
             if (!flag2) {
                 return hitResult != null && this.emptyContents(entity, level, hitResult.getBlockPos().relative(hitResult.getDirection()), null, direction, clicked, itemstack, hand); // CraftBukkit
-            } else if (level.environmentAttributes().getValue(EnvironmentAttributes.WATER_EVAPORATES, pos) && this.content.is(FluidTags.WATER)) {
+            } else if ((level.environmentAttributes().getValue(EnvironmentAttributes.WATER_EVAPORATES, pos) || (level.isTheEnd() && !org.purpurmc.purpur.PurpurConfig.allowWaterPlacementInTheEnd)) && this.content.is(FluidTags.WATER)) { // Purpur - Add allow water in end world option
                 int x = pos.getX();
                 int y = pos.getY();
                 int z = pos.getZ();
diff --git a/net/minecraft/world/item/CrossbowItem.java b/net/minecraft/world/item/CrossbowItem.java
index a9d811b5feb7733c21bb868126c9a34ac7c408da..260fb5c317f9bc9fcc5660cf1d91fc37e4924bb5 100644
--- a/net/minecraft/world/item/CrossbowItem.java
+++ b/net/minecraft/world/item/CrossbowItem.java
@@ -66,7 +66,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
         ItemStack itemInHand = player.getItemInHand(hand);
         ChargedProjectiles chargedProjectiles = itemInHand.get(DataComponents.CHARGED_PROJECTILES);
         if (chargedProjectiles != null && !chargedProjectiles.isEmpty()) {
-            this.performShooting(level, player, hand, itemInHand, getShootingPower(chargedProjectiles), 1.0F, null);
+            this.performShooting(level, player, hand, itemInHand, getShootingPower(chargedProjectiles), (float) level.purpurConfig.crossbowProjectileOffset, null); // Purpur - Projectile offset config
             return InteractionResult.CONSUME;
         } else if (!player.getProjectile(itemInHand).isEmpty()) {
             this.startSoundPlayed = false;
diff --git a/net/minecraft/world/item/DyeColor.java b/net/minecraft/world/item/DyeColor.java
index 083ec53b1e46b8ad23db7e57296c222ad4c3cd4b..f2e761f253969ca01b78c7ddc7a571ecc9655432 100644
--- a/net/minecraft/world/item/DyeColor.java
+++ b/net/minecraft/world/item/DyeColor.java
@@ -124,4 +124,10 @@ public enum DyeColor implements StringRepresentable {
     private static CraftingInput makeCraftColorInput(DyeColor first, DyeColor second) {
         return CraftingInput.of(2, 1, List.of(new ItemStack(DyeItem.byColor(first)), new ItemStack(DyeItem.byColor(second))));
     }
+
+    // Purpur start - Shulker spawn from bullet options
+    public static DyeColor random(net.minecraft.util.RandomSource random) {
+        return values()[random.nextInt(values().length)];
+    }
+    // Purpur end - Shulker spawn from bullet options
 }
diff --git a/net/minecraft/world/item/EggItem.java b/net/minecraft/world/item/EggItem.java
index 848144ce792de422921242282cefb2077a56563d..654d67dfc38b872352ea1cb6314f989c464a4ce1 100644
--- a/net/minecraft/world/item/EggItem.java
+++ b/net/minecraft/world/item/EggItem.java
@@ -24,7 +24,7 @@ public class EggItem extends Item implements ProjectileItem {
     public InteractionResult use(Level level, Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         // Paper start
-        final Projectile.Delayed<ThrownEgg> thrownEgg = Projectile.spawnProjectileFromRotationDelayed(ThrownEgg::new, (ServerLevel) level, itemInHand, player, 0.0F, EggItem.PROJECTILE_SHOOT_POWER, 1.0F);
+        final Projectile.Delayed<ThrownEgg> thrownEgg = Projectile.spawnProjectileFromRotationDelayed(ThrownEgg::new, (ServerLevel) level, itemInHand, player, 0.0F, EggItem.PROJECTILE_SHOOT_POWER, (float) level.purpurConfig.eggProjectileOffset); // Purpur - Projectile offset config
         com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) thrownEgg.projectile().getBukkitEntity());
         if (event.callEvent() && thrownEgg.attemptSpawn()) {
             if (event.shouldConsume()) {
diff --git a/net/minecraft/world/item/EndCrystalItem.java b/net/minecraft/world/item/EndCrystalItem.java
index 05ec512839898f96d9769bb0d00f6ba11dda0c4b..6e4a3c9c090a68bf5785a01d815c275411859c7b 100644
--- a/net/minecraft/world/item/EndCrystalItem.java
+++ b/net/minecraft/world/item/EndCrystalItem.java
@@ -24,7 +24,7 @@ public class EndCrystalItem extends Item {
         Level level = context.getLevel();
         BlockPos clickedPos = context.getClickedPos();
         BlockState blockState = level.getBlockState(clickedPos);
-        if (!blockState.is(Blocks.OBSIDIAN) && !blockState.is(Blocks.BEDROCK)) {
+        if (!level.purpurConfig.endCrystalPlaceAnywhere && !blockState.is(Blocks.OBSIDIAN) && !blockState.is(Blocks.BEDROCK)) { // Purpur - place end crystal on any block
             return InteractionResult.FAIL;
         } else {
             BlockPos blockPos = clickedPos.above(); final BlockPos aboveBlockPos = blockPos; // Paper - OBFHELPER
diff --git a/net/minecraft/world/item/EnderpearlItem.java b/net/minecraft/world/item/EnderpearlItem.java
index 7f1bc41d2ad20f2d96397e6e2eaedc4bbe5a7ba1..647f2fb76b1e1d8ca5046348b216a8ca0fa02de9 100644
--- a/net/minecraft/world/item/EnderpearlItem.java
+++ b/net/minecraft/world/item/EnderpearlItem.java
@@ -24,7 +24,7 @@ public class EnderpearlItem extends Item {
         if (level instanceof ServerLevel serverLevel) {
             // CraftBukkit start
             // Paper start - PlayerLaunchProjectileEvent
-            final Projectile.Delayed<ThrownEnderpearl> thrownEnderpearl = Projectile.spawnProjectileFromRotationDelayed(ThrownEnderpearl::new, serverLevel, itemInHand, player, 0.0F, EnderpearlItem.PROJECTILE_SHOOT_POWER, 1.0F);
+            final Projectile.Delayed<ThrownEnderpearl> thrownEnderpearl = Projectile.spawnProjectileFromRotationDelayed(ThrownEnderpearl::new, serverLevel, itemInHand, player, 0.0F, EnderpearlItem.PROJECTILE_SHOOT_POWER, (float) serverLevel.purpurConfig.enderPearlProjectileOffset); // Purpur - Projectile offset config
             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) thrownEnderpearl.projectile().getBukkitEntity());
             if (event.callEvent() && thrownEnderpearl.attemptSpawn()) {
                 if (event.shouldConsume()) {
@@ -44,6 +44,7 @@ public class EnderpearlItem extends Item {
                     0.4F / (level.getRandom().nextFloat() * 0.4F + 0.8F)
                 );
                 player.awardStat(Stats.ITEM_USED.get(this));
+                player.getCooldowns().addCooldown(itemInHand, player.getAbilities().instabuild ? level.purpurConfig.enderPearlCooldownCreative : level.purpurConfig.enderPearlCooldown); // Purpur - Configurable Ender Pearl cooldown
             } else {
                 if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer) {
                     serverPlayer.deregisterEnderPearl(thrownEnderpearl.projectile());
diff --git a/net/minecraft/world/item/FireworkRocketItem.java b/net/minecraft/world/item/FireworkRocketItem.java
index 2c597e20c1ff587f2eadef600bedb9e01b999bbf..e548f7161f14d7dc02d6882c3639ff65d59d7b37 100644
--- a/net/minecraft/world/item/FireworkRocketItem.java
+++ b/net/minecraft/world/item/FireworkRocketItem.java
@@ -73,6 +73,17 @@ public class FireworkRocketItem extends Item implements ProjectileItem {
                     if (player.dropAllLeashConnections(null)) {
                         level.playSound(null, player, SoundEvents.LEAD_BREAK, SoundSource.NEUTRAL, 1.0F, 1.0F);
                     }
+                    // Purpur start - Implement elytra settings
+                    if (level.purpurConfig.elytraDamagePerFireworkBoost > 0) {
+                        java.util.List<net.minecraft.world.entity.EquipmentSlot> list = net.minecraft.world.entity.EquipmentSlot.VALUES.stream().filter((enumitemslot) -> net.minecraft.world.entity.LivingEntity.canGlideUsing(player.getItemBySlot(enumitemslot), enumitemslot)).toList();
+                        net.minecraft.world.entity.EquipmentSlot enumitemslot = net.minecraft.util.Util.getRandom(list, player.random);
+
+                        ItemStack glideItem = player.getItemBySlot(enumitemslot);
+                        if (player.canGlide()) {
+                            glideItem.hurtAndBreak(level.purpurConfig.elytraDamagePerFireworkBoost, player, enumitemslot);
+                        }
+                    }
+                    // Purpur end - Implement elytra settings
                     if (event.shouldConsume() && !player.hasInfiniteMaterials()) {
                         itemInHand.shrink(1); // Moved up from below
                     } else {
diff --git a/net/minecraft/world/item/HangingEntityItem.java b/net/minecraft/world/item/HangingEntityItem.java
index e9403c7c857bfaf09d8f8851b468aa4431c5be54..ecc890ae91475420215b61311ff959d9c522202d 100644
--- a/net/minecraft/world/item/HangingEntityItem.java
+++ b/net/minecraft/world/item/HangingEntityItem.java
@@ -59,7 +59,7 @@ public class HangingEntityItem extends Item {
                 hangingEntity = new GlowItemFrame(level, blockPos, clickedFace);
             }
 
-            EntityType.<HangingEntity>createDefaultStackConfig(level, itemInHand, player).accept(hangingEntity);
+            EntityType.<HangingEntity>appendDefaultStackConfig(entity -> {if (!level.purpurConfig.persistentDroppableEntityDisplayNames) entity.setCustomName(null);}, level, itemInHand, player).accept(hangingEntity); // Purpur - Apply display names from item forms of entities to entities and vice versa
             if (hangingEntity.survives()) {
                 if (!level.isClientSide()) {
                     // CraftBukkit start - fire HangingPlaceEvent
diff --git a/net/minecraft/world/item/HoeItem.java b/net/minecraft/world/item/HoeItem.java
index d9d03bfcb1cb10aa03b35255c4237760bc836752..bf14cbcc6ed4c89ef6f15b3cb248a599cbc26e29 100644
--- a/net/minecraft/world/item/HoeItem.java
+++ b/net/minecraft/world/item/HoeItem.java
@@ -44,15 +44,25 @@ public class HoeItem extends Item {
     public InteractionResult useOn(UseOnContext context) {
         Level level = context.getLevel();
         BlockPos clickedPos = context.getClickedPos();
-        Pair<Predicate<UseOnContext>, Consumer<UseOnContext>> pair = TILLABLES.get(level.getBlockState(clickedPos).getBlock());
-        if (pair == null) {
+        // Purpur start - Tool actionable options
+        Block clickedBlock = level.getBlockState(clickedPos).getBlock();
+        org.purpurmc.purpur.tool.Tillable tillable = level.purpurConfig.hoeTillables.get(clickedBlock);
+        if (tillable == null) {
             return InteractionResult.PASS;
         } else {
-            Predicate<UseOnContext> predicate = pair.getFirst();
-            Consumer<UseOnContext> consumer = pair.getSecond();
+            Predicate<UseOnContext> predicate = tillable.condition().predicate();
+            Consumer<UseOnContext> consumer = (ctx) -> {
+                level.setBlock(clickedPos, tillable.into().defaultBlockState(), 11);
+                tillable.drops().forEach((drop, chance) -> {
+                    if (level.random.nextDouble() < chance) {
+                        Block.popResourceFromFace(level, clickedPos, ctx.getClickedFace(), new ItemStack(drop));
+                    }
+                });
+            };
+            // Purpur end - Tool actionable options
             if (predicate.test(context)) {
                 Player player = context.getPlayer();
-                level.playSound(player, clickedPos, SoundEvents.HOE_TILL, SoundSource.BLOCKS, 1.0F, 1.0F);
+                if (!TILLABLES.containsKey(clickedBlock)) level.playSound(null, clickedPos, SoundEvents.HOE_TILL, SoundSource.BLOCKS, 1.0F, 1.0F); // Purpur - Tool actionable options - force sound
                 if (!level.isClientSide()) {
                     consumer.accept(context);
                     if (player != null) {
diff --git a/net/minecraft/world/item/ItemStack.java b/net/minecraft/world/item/ItemStack.java
index ed06cffe8a5eba2ca4a34ade81f8185e21d7b651..3e31abbca1426c9332ecb02613648383c8b27cce 100644
--- a/net/minecraft/world/item/ItemStack.java
+++ b/net/minecraft/world/item/ItemStack.java
@@ -456,6 +456,7 @@ public final class ItemStack implements DataComponentHolder {
                     // revert back all captured blocks
                     for (org.bukkit.block.BlockState blockstate : blocks) {
                         ((org.bukkit.craftbukkit.block.CraftBlockState) blockstate).revertPlace();
+                        ((org.bukkit.craftbukkit.block.CraftBlock) blockstate.getBlock()).getNMS().getBlock().forgetPlacer(); // Purpur - Store placer on Block when placed
                     }
 
                     SignItem.openSign = null; // SPIGOT-6758 - Reset on early return
@@ -479,6 +480,7 @@ public final class ItemStack implements DataComponentHolder {
                         if (!(block.getBlock() instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // Containers get placed automatically
                             block.onPlace(serverLevel, newPos, oldBlock, true, context);
                         }
+                        block.getBlock().forgetPlacer(); // Purpur - Store placer on Block when placed
 
                         serverLevel.notifyAndUpdatePhysics(newPos, null, oldBlock, block, serverLevel.getBlockState(newPos), updateFlags, net.minecraft.world.level.block.Block.UPDATE_LIMIT); // send null chunk as chunk.k() returns false by this point
                     }
@@ -599,6 +601,26 @@ public final class ItemStack implements DataComponentHolder {
         return this.isDamageableItem() && this.getDamageValue() > 0;
     }
 
+    // Purpur start - Add option to mend the most damaged equipment first
+    public float getDamagePercent() {
+        if (this.has(DataComponents.UNBREAKABLE)) {
+            return 0.0F;
+        }
+
+        final int maxDamage = this.getOrDefault(DataComponents.MAX_DAMAGE, 0);
+        if (maxDamage == 0) {
+            return 0.0F;
+        }
+
+        final int damage = this.getOrDefault(DataComponents.DAMAGE, 0);
+        if (damage == 0) {
+            return 0.0F;
+        }
+
+        return (float) damage / maxDamage;
+    }
+    // Purpur end - Add option to mend the most damaged equipment first
+
     public int getDamageValue() {
         return Mth.clamp(this.getOrDefault(DataComponents.DAMAGE, 0), 0, this.getMaxDamage());
     }
@@ -680,6 +702,14 @@ public final class ItemStack implements DataComponentHolder {
                 org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerItemBreakEvent(serverPlayer, this); // Paper - Add EntityDamageItemEvent
             }
             // CraftBukkit end
+
+            // Purpur start - Implement elytra settings
+            if (this.has(DataComponents.GLIDER)) {
+                setDamageValue(this.getMaxDamage() - 1);
+                return;
+            }
+            // Purpur end - Implement elytra settings
+
             this.shrink(1);
             onBreak.accept(item);
         }
@@ -1248,6 +1278,12 @@ public final class ItemStack implements DataComponentHolder {
         return !this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY).isEmpty();
     }
 
+    // Purpur start - Config to allow unsafe enchants
+    public boolean hasEnchantment(Holder<Enchantment> enchantment) {
+        return this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY).getLevel(enchantment) > 0;
+    }
+    // Purpur end - Config to allow unsafe enchants
+
     public ItemEnchantments getEnchantments() {
         return this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY);
     }
diff --git a/net/minecraft/world/item/Items.java b/net/minecraft/world/item/Items.java
index 3e0ae17bf7129aa62765be453edba1bdd50324ab..310e61a9bbece157d81095130ecb3131deef9288 100644
--- a/net/minecraft/world/item/Items.java
+++ b/net/minecraft/world/item/Items.java
@@ -420,7 +420,7 @@ public class Items {
     public static final Item PURPUR_BLOCK = registerBlock(Blocks.PURPUR_BLOCK);
     public static final Item PURPUR_PILLAR = registerBlock(Blocks.PURPUR_PILLAR);
     public static final Item PURPUR_STAIRS = registerBlock(Blocks.PURPUR_STAIRS);
-    public static final Item SPAWNER = registerBlock(Blocks.SPAWNER);
+    public static final Item SPAWNER = registerBlock(Blocks.SPAWNER, org.purpurmc.purpur.item.SpawnerItem::new, new Item.Properties().rarity(Rarity.EPIC)); // Purpur - Silk touch spawners
     public static final Item CREAKING_HEART = registerBlock(Blocks.CREAKING_HEART);
     public static final Item CHEST = registerBlock(Blocks.CHEST, properties -> properties.component(DataComponents.CONTAINER, ItemContainerContents.EMPTY));
     public static final Item CRAFTING_TABLE = registerBlock(Blocks.CRAFTING_TABLE);
@@ -2169,7 +2169,7 @@ public class Items {
         "sweet_berries", createBlockItemWithCustomItemName(Blocks.SWEET_BERRY_BUSH), new Item.Properties().food(Foods.SWEET_BERRIES)
     );
     public static final Item GLOW_BERRIES = registerItem(
-        "glow_berries", createBlockItemWithCustomItemName(Blocks.CAVE_VINES), new Item.Properties().food(Foods.GLOW_BERRIES)
+        "glow_berries", settings -> new org.purpurmc.purpur.item.GlowBerryItem(Blocks.CAVE_VINES, settings.useItemDescriptionPrefix()), new Item.Properties().food(Foods.GLOW_BERRIES) // Purpur - Eating glow berries adds glow effect
     );
     public static final Item CAMPFIRE = registerBlock(
         Blocks.CAMPFIRE, properties -> properties.component(DataComponents.CONTAINER, ItemContainerContents.EMPTY)
diff --git a/net/minecraft/world/item/MapItem.java b/net/minecraft/world/item/MapItem.java
index 8479f971afdcae0143bbec25ab258485e49722af..63c9805a2c2c8ac8fff4e322e1627880c3fabd83 100644
--- a/net/minecraft/world/item/MapItem.java
+++ b/net/minecraft/world/item/MapItem.java
@@ -192,6 +192,7 @@ public class MapItem extends Item {
     public static void renderBiomePreviewMap(ServerLevel level, ItemStack stack) {
         MapItemSavedData savedData = getSavedData(stack, level);
         if (savedData != null) {
+            savedData.isExplorerMap = true; // Purpur - Explorer Map API
             if (level.dimension() == savedData.dimension) {
                 int i = 1 << savedData.scale;
                 int i1 = savedData.centerX;
diff --git a/net/minecraft/world/item/MinecartItem.java b/net/minecraft/world/item/MinecartItem.java
index 3b511139985ea1646661ae0a6bcd1f0e386561e7..3a65e1a0b914d113feb727833803ece8f3b2e020 100644
--- a/net/minecraft/world/item/MinecartItem.java
+++ b/net/minecraft/world/item/MinecartItem.java
@@ -30,8 +30,9 @@ public class MinecartItem extends Item {
         BlockPos clickedPos = context.getClickedPos();
         BlockState blockState = level.getBlockState(clickedPos);
         if (!blockState.is(BlockTags.RAILS)) {
-            return InteractionResult.FAIL;
-        } else {
+            if (!level.purpurConfig.minecartPlaceAnywhere) return InteractionResult.FAIL; // Purpur - Minecart settings and WASD controls
+            if (blockState.isSolid()) clickedPos = clickedPos.relative(context.getClickedFace());
+        } // else { // Purpur - Minecart settings and WASD controls
             ItemStack itemInHand = context.getItemInHand();
             RailShape railShape = blockState.getBlock() instanceof BaseRailBlock
                 ? blockState.getValue(((BaseRailBlock)blockState.getBlock()).getShapeProperty())
@@ -72,6 +73,6 @@ public class MinecartItem extends Item {
                 itemInHand.shrink(1);
                 return InteractionResult.SUCCESS;
             }
-        }
+        // } // Purpur - Minecart settings and WASD controls
     }
 }
diff --git a/net/minecraft/world/item/NameTagItem.java b/net/minecraft/world/item/NameTagItem.java
index 24bf4cd320c67b852d3905c50740c8006592bd68..7ee4bd968a43123e21e65f77f30495e65146aca5 100644
--- a/net/minecraft/world/item/NameTagItem.java
+++ b/net/minecraft/world/item/NameTagItem.java
@@ -24,6 +24,7 @@ public class NameTagItem extends Item {
 
                 LivingEntity newEntity = ((org.bukkit.craftbukkit.entity.CraftLivingEntity) event.getEntity()).getHandle();
                 newEntity.setCustomName(event.getName() != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(event.getName()) : null);
+                if (player.level().purpurConfig.armorstandFixNametags && target instanceof net.minecraft.world.entity.decoration.ArmorStand) target.setCustomNameVisible(true); // Purpur - Set name visible when using a Name Tag on an Armor Stand
                 if (event.isPersistent() && newEntity instanceof Mob mob) {
                     // Paper end - Add PlayerNameEntityEvent
                     mob.setPersistenceRequired();
diff --git a/net/minecraft/world/item/ProjectileWeaponItem.java b/net/minecraft/world/item/ProjectileWeaponItem.java
index ba93379b6e85bed3eedc4869b83b3d45aa770cce..8fb0eacdf739e5559fb725571fb3a65fb6b17e8a 100644
--- a/net/minecraft/world/item/ProjectileWeaponItem.java
+++ b/net/minecraft/world/item/ProjectileWeaponItem.java
@@ -106,6 +106,8 @@ public abstract class ProjectileWeaponItem extends Item {
             abstractArrow.setCritArrow(true);
         }
 
+        abstractArrow.setActualEnchantments(weapon.getEnchantments()); // Purpur - Add an option to fix MC-3304 projectile looting
+
         return abstractArrow;
     }
 
diff --git a/net/minecraft/world/item/ShovelItem.java b/net/minecraft/world/item/ShovelItem.java
index ba0609f4d9166e66599f9d4430885ab03d53ef41..7910c96cc47985acc8b64ba376933c84c51022d4 100644
--- a/net/minecraft/world/item/ShovelItem.java
+++ b/net/minecraft/world/item/ShovelItem.java
@@ -46,9 +46,12 @@ public class ShovelItem extends Item {
             BlockState blockState1 = FLATTENABLES.get(blockState.getBlock());
             BlockState blockState2 = null;
             Runnable afterAction = null; // Paper
+            org.purpurmc.purpur.tool.Flattenable flattenable = level.purpurConfig.shovelFlattenables.get(blockState.getBlock()); // Purpur - Tool actionable options
             if (blockState1 != null && level.getBlockState(clickedPos.above()).isAir()) {
-                afterAction = () -> level.playSound(player, clickedPos, SoundEvents.SHOVEL_FLATTEN, SoundSource.BLOCKS, 1.0F, 1.0F); // Paper
-                blockState2 = blockState1;
+                // Purpur start - Tool actionable options
+                afterAction = () -> {if (!FLATTENABLES.containsKey(blockState.getBlock())) level.playSound(player, clickedPos, SoundEvents.SHOVEL_FLATTEN, SoundSource.BLOCKS, 1.0F, 1.0F);}; // Paper
+                blockState2 = flattenable.into().defaultBlockState();
+                // Purpur end - Tool actionable options
             } else if (blockState.getBlock() instanceof CampfireBlock && blockState.getValue(CampfireBlock.LIT)) {
                 afterAction = () -> { // Paper
                 if (!level.isClientSide()) {
diff --git a/net/minecraft/world/item/SnowballItem.java b/net/minecraft/world/item/SnowballItem.java
index a5bfd497a07f2e2311db8eca5b8ba8af9f4d1080..67145fd5adc5ebb38efb978119ba1f7e4f2c563f 100644
--- a/net/minecraft/world/item/SnowballItem.java
+++ b/net/minecraft/world/item/SnowballItem.java
@@ -26,7 +26,7 @@ public class SnowballItem extends Item implements ProjectileItem {
         // CraftBukkit start - moved down
         if (level instanceof ServerLevel serverLevel) {
             // Paper start - PlayerLaunchProjectileEvent
-            final Projectile.Delayed<Snowball> snowball = Projectile.spawnProjectileFromRotationDelayed(Snowball::new, serverLevel, itemInHand, player, 0.0F, SnowballItem.PROJECTILE_SHOOT_POWER, 1.0F);
+            final Projectile.Delayed<Snowball> snowball = Projectile.spawnProjectileFromRotationDelayed(Snowball::new, serverLevel, itemInHand, player, 0.0F, SnowballItem.PROJECTILE_SHOOT_POWER, (float) serverLevel.purpurConfig.snowballProjectileOffset); // Purpur - Projectile offset config
             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) snowball.projectile().getBukkitEntity());
             if (event.callEvent() && snowball.attemptSpawn()) {
                 player.awardStat(Stats.ITEM_USED.get(this));
diff --git a/net/minecraft/world/item/SpawnEggItem.java b/net/minecraft/world/item/SpawnEggItem.java
index 079cccadfca55cd718bf75b244901f774c818811..8ab8f00995136c81abf7855e02b186a3df9a02d9 100644
--- a/net/minecraft/world/item/SpawnEggItem.java
+++ b/net/minecraft/world/item/SpawnEggItem.java
@@ -70,6 +70,23 @@ public class SpawnEggItem extends Item {
                     return InteractionResult.FAIL;
                 } else {
                     if (level.paperConfig().entities.spawning.disableMobSpawnerSpawnEggTransformation) return InteractionResult.FAIL; // Paper - Allow disabling mob spawner spawn egg transformation
+                    // Purpur start - PlayerSetSpawnerTypeWithEggEvent
+                    if (spawner instanceof net.minecraft.world.level.block.entity.SpawnerBlockEntity) {
+                        org.bukkit.block.Block bukkitBlock = level.getWorld().getBlockAt(clickedPos.getX(), clickedPos.getY(), clickedPos.getZ());
+                        org.purpurmc.purpur.event.PlayerSetSpawnerTypeWithEggEvent event = new org.purpurmc.purpur.event.PlayerSetSpawnerTypeWithEggEvent((org.bukkit.entity.Player) context.getPlayer().getBukkitEntity(), bukkitBlock, (org.bukkit.block.CreatureSpawner) bukkitBlock.getState(), org.bukkit.entity.EntityType.fromName(type.getName()));
+                        if (!event.callEvent()) {
+                            return InteractionResult.FAIL;
+                        }
+                        type = EntityType.getFromBukkitType(event.getEntityType());
+                    } else if (spawner instanceof net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity) {
+                        org.bukkit.block.Block bukkitBlock = level.getWorld().getBlockAt(clickedPos.getX(), clickedPos.getY(), clickedPos.getZ());
+                        org.purpurmc.purpur.event.PlayerSetTrialSpawnerTypeWithEggEvent event = new org.purpurmc.purpur.event.PlayerSetTrialSpawnerTypeWithEggEvent((org.bukkit.entity.Player) context.getPlayer().getBukkitEntity(), bukkitBlock, (org.bukkit.block.TrialSpawner) bukkitBlock.getState(), org.bukkit.entity.EntityType.fromName(type.getName()));
+                        if (!event.callEvent()) {
+                            return InteractionResult.FAIL;
+                        }
+                        type = EntityType.getFromBukkitType(event.getEntityType());
+                    }
+                    // Purpur end - PlayerSetSpawnerTypeWithEggEvent
                     spawner.setEntityId(type, level.getRandom());
                     level.sendBlockUpdated(clickedPos, blockState, blockState, Block.UPDATE_ALL);
                     level.gameEvent(context.getPlayer(), GameEvent.BLOCK_CHANGE, clickedPos);
diff --git a/net/minecraft/world/item/ThrowablePotionItem.java b/net/minecraft/world/item/ThrowablePotionItem.java
index 2707c2e3c6e32bb7c497808dceb34690e27a567a..a9bce92803772c1d76e1c3eabe1147d4c5211440 100644
--- a/net/minecraft/world/item/ThrowablePotionItem.java
+++ b/net/minecraft/world/item/ThrowablePotionItem.java
@@ -24,7 +24,7 @@ public abstract class ThrowablePotionItem extends PotionItem implements Projecti
         ItemStack itemInHand = player.getItemInHand(hand);
         if (level instanceof ServerLevel serverLevel) {
             // Paper start - PlayerLaunchProjectileEvent
-            final Projectile.Delayed<AbstractThrownPotion> thrownPotion = Projectile.spawnProjectileFromRotationDelayed(this::createPotion, serverLevel, itemInHand, player, -20.0F, PROJECTILE_SHOOT_POWER, 1.0F);
+            final Projectile.Delayed<AbstractThrownPotion> thrownPotion = Projectile.spawnProjectileFromRotationDelayed(this::createPotion, serverLevel, itemInHand, player, -20.0F, PROJECTILE_SHOOT_POWER, (float) serverLevel.purpurConfig.throwablePotionProjectileOffset); // Purpur - Projectile offset config
             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) thrownPotion.projectile().getBukkitEntity());
             if (event.callEvent() && thrownPotion.attemptSpawn()) {
                 if (event.shouldConsume()) {
diff --git a/net/minecraft/world/item/TridentItem.java b/net/minecraft/world/item/TridentItem.java
index d029fda2e8bac95fb75f75666a55b0c3aa3bb12d..4f63ebf5ff1381fc69d4d6e73d326fe6833e3654 100644
--- a/net/minecraft/world/item/TridentItem.java
+++ b/net/minecraft/world/item/TridentItem.java
@@ -83,7 +83,7 @@ public class TridentItem extends Item implements ProjectileItem {
                         if (tridentSpinAttackStrength == 0.0F) {
                             ItemStack itemStack = stack.copyWithCount(1); // Paper
                             Projectile.Delayed<ThrownTrident> tridentDelayed = Projectile.spawnProjectileFromRotationDelayed( // Paper - PlayerLaunchProjectileEvent(
-                                ThrownTrident::new, serverLevel, itemStack, player, 0.0F, 2.5F, 1.0F
+                                ThrownTrident::new, serverLevel, itemStack, player, 0.0F, 2.5F, (float) serverLevel.purpurConfig.tridentProjectileOffset  // Purpur - Projectile offset config
                             );
                             // Paper start - PlayerLaunchProjectileEvent
                             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(stack), (org.bukkit.entity.Projectile) tridentDelayed.projectile().getBukkitEntity());
@@ -93,6 +93,7 @@ public class TridentItem extends Item implements ProjectileItem {
                                 return false;
                             }
                             ThrownTrident thrownTrident = tridentDelayed.projectile(); // Paper - PlayerLaunchProjectileEvent
+                            thrownTrident.setActualEnchantments(stack.getEnchantments()); // Purpur - Add an option to fix MC-3304 projectile looting
                             if (event.shouldConsume()) {
                                 itemStack.hurtWithoutBreaking(1, player); // Paper - PlayerLaunchProjectileEvent - use itemStack; pickup item damage
                             }
@@ -125,6 +126,17 @@ public class TridentItem extends Item implements ProjectileItem {
                         f1 *= tridentSpinAttackStrength / squareRoot;
                         f2 *= tridentSpinAttackStrength / squareRoot;
                         if (!org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerRiptideEvent(player, stack, f, f1, f2)) return false; // Paper - Add player riptide event
+                        // Purpur start - Implement elytra settings
+                        List<net.minecraft.world.entity.EquipmentSlot> list = net.minecraft.world.entity.EquipmentSlot.VALUES.stream().filter((enumitemslot) -> LivingEntity.canGlideUsing(entity.getItemBySlot(enumitemslot), enumitemslot)).toList();
+                        if (!list.isEmpty()) {
+                            net.minecraft.world.entity.EquipmentSlot enumitemslot = net.minecraft.util.Util.getRandom(list, entity.random);
+                            ItemStack glideItem = entity.getItemBySlot(enumitemslot);
+                            if (glideItem.has(net.minecraft.core.component.DataComponents.GLIDER) && level.purpurConfig.elytraDamagePerTridentBoost > 0) {
+                                glideItem.hurtAndBreak(level.purpurConfig.elytraDamagePerTridentBoost, entity, enumitemslot);
+                            }
+                        }
+                        // Purpur end - Implement elytra settings
+
                         player.push(f, f1, f2);
                         player.startAutoSpinAttack(20, 8.0F, stack);
                         if (player.onGround()) {
diff --git a/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java b/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java
index 41e1e076a4567d3d3202cf8e426a1ebb391d85e8..2d710dd3f20cbea06c16f14a558b575b369c6ca2 100644
--- a/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java
+++ b/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java
@@ -20,6 +20,12 @@ public record ClearAllStatusEffectsConsumeEffect() implements ConsumeEffect {
     @Override
     // CraftBukkit start
     public boolean apply(Level level, ItemStack stack, LivingEntity entity, org.bukkit.event.entity.EntityPotionEffectEvent.Cause cause) {
+        // Purpur start - Option to toggle milk curing bad omen
+        net.minecraft.world.effect.MobEffectInstance badOmen = entity.getEffect(net.minecraft.world.effect.MobEffects.BAD_OMEN);
+        if (!level.purpurConfig.milkCuresBadOmen && stack.is(net.minecraft.world.item.Items.MILK_BUCKET) && badOmen != null) {
+            return entity.removeAllEffects(cause) && entity.addEffect(badOmen);
+        }
+        // Purpur end - Option to toggle milk curing bad omen
         return entity.removeAllEffects(cause);
         // CraftBukkit end
     }
diff --git a/net/minecraft/world/item/crafting/Ingredient.java b/net/minecraft/world/item/crafting/Ingredient.java
index da95f40503f3696c8daa8fd0e947508fe43060ba..edeb3d74b0f240914b84da6dff3b057e89617a11 100644
--- a/net/minecraft/world/item/crafting/Ingredient.java
+++ b/net/minecraft/world/item/crafting/Ingredient.java
@@ -36,6 +36,7 @@ public final class Ingredient implements StackedContents.IngredientInfo<io.paper
     // CraftBukkit start
     @javax.annotation.Nullable
     private java.util.Set<ItemStack> itemStacks; // Paper - Improve exact choice recipe ingredients
+    public Predicate<org.bukkit.inventory.ItemStack> predicate; // Purpur - Add predicate to recipe's ExactChoice ingredient
 
     public boolean isExact() {
         return this.itemStacks != null;
@@ -88,6 +89,11 @@ public final class Ingredient implements StackedContents.IngredientInfo<io.paper
             return this.itemStacks.contains(stack); // Paper - Improve exact choice recipe ingredients (hashing FTW!)
         }
         // CraftBukkit end
+        // Purpur start - Add predicate to recipe's ExactChoice ingredient
+        if (predicate != null) {
+            return predicate.test(stack.asBukkitCopy());
+        }
+        // Purpur end - Add predicate to recipe's ExactChoice ingredient
         return stack.is(this.values);
     }
 
diff --git a/net/minecraft/world/item/enchantment/EnchantmentHelper.java b/net/minecraft/world/item/enchantment/EnchantmentHelper.java
index b61e0e179e78f37f670ad86476b5a533e7835948..d9eed93017906785716cf747317be7737bc2a38e 100644
--- a/net/minecraft/world/item/enchantment/EnchantmentHelper.java
+++ b/net/minecraft/world/item/enchantment/EnchantmentHelper.java
@@ -616,4 +616,58 @@ public class EnchantmentHelper {
     interface EnchantmentVisitor {
         void accept(Holder<Enchantment> enchantment, int level);
     }
+
+    // Purpur start - Enchantment convenience methods
+    public static Holder.Reference<Enchantment> getEnchantmentHolder(ResourceKey<Enchantment> enchantment) {
+        return net.minecraft.server.MinecraftServer.getServer().registryAccess().lookupOrThrow(Registries.ENCHANTMENT).getOrThrow(enchantment);
+    }
+
+    public static int getItemEnchantmentLevel(ResourceKey<Enchantment> enchantment, ItemStack stack) {
+        return getItemEnchantmentLevel(getEnchantmentHolder(enchantment), stack);
+    }
+    // Purpur end - Enchantment convenience methods
+
+    // Purpur start - Add option to mend the most damaged equipment first
+    public static Optional<EnchantedItemInUse> getMostDamagedItemWith(DataComponentType<?> componentType, LivingEntity entity) {
+        ItemStack maxStack = null;
+        EquipmentSlot maxSlot = null;
+        float maxPercent = 0.0F;
+
+        equipmentSlotLoop:
+        for (EquipmentSlot equipmentSlot : EquipmentSlot.values()) {
+            ItemStack stack = entity.getItemBySlot(equipmentSlot);
+
+            // do not even check enchantments for item with lower or equal damage percent
+            float percent = stack.getDamagePercent();
+            if (percent <= maxPercent) {
+                continue;
+            }
+
+            ItemEnchantments itemEnchantments = stack.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY);
+
+            for (Entry<Holder<Enchantment>> entry : itemEnchantments.entrySet()) {
+                Enchantment enchantment = entry.getKey().value();
+
+                net.minecraft.core.component.DataComponentMap effects = enchantment.effects();
+                if (!effects.has(componentType)) {
+                    // try with another enchantment
+                    continue;
+                }
+
+                if (enchantment.matchingSlot(equipmentSlot)) {
+                    maxStack = stack;
+                    maxSlot = equipmentSlot;
+                    maxPercent = percent;
+
+                    // check another slot now
+                    continue equipmentSlotLoop;
+                }
+            }
+        }
+
+        return maxStack != null
+            ? Optional.of(new EnchantedItemInUse(maxStack, maxSlot, entity))
+            : Optional.empty();
+    }
+    // Purpur end - Add option to mend the most damaged equipment first
 }
diff --git a/net/minecraft/world/item/enchantment/ItemEnchantments.java b/net/minecraft/world/item/enchantment/ItemEnchantments.java
index 40e94e008ddf8d7670496f3f30a3e6320a11c936..b666181af7d6663f2fce58a7d9a4c805687f5409 100644
--- a/net/minecraft/world/item/enchantment/ItemEnchantments.java
+++ b/net/minecraft/world/item/enchantment/ItemEnchantments.java
@@ -32,7 +32,7 @@ public class ItemEnchantments implements TooltipProvider {
     private static final java.util.Comparator<Holder<Enchantment>> ENCHANTMENT_ORDER = java.util.Comparator.comparing(Holder::getRegisteredName);
     public static final ItemEnchantments EMPTY = new ItemEnchantments(new it.unimi.dsi.fastutil.objects.Object2IntAVLTreeMap<>(ENCHANTMENT_ORDER));
     // Paper end - sort enchantments
-    private static final Codec<Integer> LEVEL_CODEC = Codec.intRange(1, 255);
+    private static final Codec<Integer> LEVEL_CODEC = Codec.intRange(1, (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767)); // Purpur - Add toggle for enchant level clamping
     public static final Codec<ItemEnchantments> CODEC = Codec.unboundedMap(Enchantment.CODEC, LEVEL_CODEC)
         .xmap(
             map -> new net.minecraft.world.item.enchantment.ItemEnchantments(net.minecraft.util.Util.make(new it.unimi.dsi.fastutil.objects.Object2IntAVLTreeMap<>(ENCHANTMENT_ORDER), m -> m.putAll(map))), // Paper - sort enchantments
@@ -50,7 +50,7 @@ public class ItemEnchantments implements TooltipProvider {
 
         for (Entry<Holder<Enchantment>> entry : enchantments.object2IntEntrySet()) {
             int intValue = entry.getIntValue();
-            if (intValue < 0 || intValue > 255) {
+            if (intValue < 0 || intValue > (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767)) { // Purpur - Add toggle for enchant level clamping
                 throw new IllegalArgumentException("Enchantment " + entry.getKey() + " has invalid level " + intValue);
             }
         }
@@ -133,13 +133,13 @@ public class ItemEnchantments implements TooltipProvider {
             if (level <= 0) {
                 this.enchantments.removeInt(enchantment);
             } else {
-                this.enchantments.put(enchantment, Math.min(level, 255));
+                this.enchantments.put(enchantment, Math.min(level, (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767))); // Purpur - Add toggle for enchant level clamping
             }
         }
 
         public void upgrade(Holder<Enchantment> enchantment, int level) {
             if (level > 0) {
-                this.enchantments.merge(enchantment, Math.min(level, 255), Integer::max);
+                this.enchantments.merge(enchantment, Math.min(level, (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767)), Integer::max); // Purpur - Add toggle for enchant level clamping
             }
         }
 
diff --git a/net/minecraft/world/item/trading/MerchantOffer.java b/net/minecraft/world/item/trading/MerchantOffer.java
index 6afeb92c2e00ca5b945b7c7de9257bd741d53c3d..3e2a1b3f1098bf4f45fed76b6ca4f9a3d5add6ee 100644
--- a/net/minecraft/world/item/trading/MerchantOffer.java
+++ b/net/minecraft/world/item/trading/MerchantOffer.java
@@ -143,8 +143,13 @@ public class MerchantOffer {
     }
 
     public void updateDemand() {
+        // Purpur start - Configurable minimum demand for trades
+        this.updateDemand(0);
+    }
+    public void updateDemand(int minimumDemand) {
+        // Purpur end - Configurable minimum demand for trades
         this.demand = this.demand + this.uses - (this.maxUses - this.uses);
-        if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.preventNegativeVillagerDemand) this.demand = Math.max(0, this.demand); // Paper - Fix MC-163962
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.preventNegativeVillagerDemand) this.demand = Math.max(minimumDemand, this.demand); // Paper - Fix MC-163962 // Purpur - Configurable minimum demand for trades
     }
 
     public ItemStack assemble() {
diff --git a/net/minecraft/world/level/BaseSpawner.java b/net/minecraft/world/level/BaseSpawner.java
index ff9dd4aedc91d151f1955e2e9bed1c597341964c..93fa81eb9d4ad5f942f96ba0c0e69635a5fc408f 100644
--- a/net/minecraft/world/level/BaseSpawner.java
+++ b/net/minecraft/world/level/BaseSpawner.java
@@ -60,6 +60,7 @@ public abstract class BaseSpawner {
     }
 
     public boolean isNearPlayer(Level level, BlockPos pos) {
+        if (level.purpurConfig.spawnerDeactivateByRedstone && level.hasNeighborSignal(pos)) return false; // Purpur - Redstone deactivates spawners
         return level.hasNearbyAlivePlayerThatAffectsSpawning(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5, this.requiredPlayerRange); // Paper - Affects Spawning API
     }
 
diff --git a/net/minecraft/world/level/EntityGetter.java b/net/minecraft/world/level/EntityGetter.java
index 6ae3698e8e2c84fb21c0a4facbbf1568dbd45405..1ad405fba4d7f8e7f4e8dc97b3a73692c16de104 100644
--- a/net/minecraft/world/level/EntityGetter.java
+++ b/net/minecraft/world/level/EntityGetter.java
@@ -187,7 +187,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
 
     default boolean hasNearbyAlivePlayer(double x, double y, double z, double distance) {
         for (Player player : this.players()) {
-            if (EntitySelector.NO_SPECTATORS.test(player) && EntitySelector.LIVING_ENTITY_STILL_ALIVE.test(player)) {
+            if (EntitySelector.NO_SPECTATORS.test(player) && EntitySelector.LIVING_ENTITY_STILL_ALIVE.test(player) && EntitySelector.notAfk.test(player)) { // Purpur - AFK API
                 double d = player.distanceToSqr(x, y, z);
                 if (distance < 0.0 || d < distance * distance) {
                     return true;
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index 579bbba4e823d4d0318e58759ca732b7c8e4d865..87ba05261739c64c1534df9721e0b067a6191af6 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -165,11 +165,55 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
     // Paper end - add paper world config
 
+    public final org.purpurmc.purpur.PurpurWorldConfig purpurConfig; // Purpur - Purpur config files
     public static @Nullable BlockPos lastPhysicsProblem; // Spigot
     private int tileTickPosition;
     public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new java.util.HashMap<>(); // Paper - Optimize explosions
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here
 
+    // Purpur start - Add adjustable breeding cooldown to config
+    private com.google.common.cache.Cache<BreedingCooldownPair, Object> playerBreedingCooldowns;
+
+    private com.google.common.cache.Cache<BreedingCooldownPair, Object> getNewBreedingCooldownCache() {
+        return com.google.common.cache.CacheBuilder.newBuilder().expireAfterWrite(this.purpurConfig.animalBreedingCooldownSeconds, java.util.concurrent.TimeUnit.SECONDS).build();
+    }
+
+    public void resetBreedingCooldowns() {
+        this.playerBreedingCooldowns = this.getNewBreedingCooldownCache();
+    }
+
+    public boolean hasBreedingCooldown(java.util.UUID player, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) { // Purpur
+        return this.playerBreedingCooldowns.getIfPresent(new BreedingCooldownPair(player, animalType)) != null;
+    }
+
+    public void addBreedingCooldown(java.util.UUID player, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) {
+        this.playerBreedingCooldowns.put(new BreedingCooldownPair(player, animalType), new Object());
+    }
+
+    private static final class BreedingCooldownPair {
+        private final java.util.UUID playerUUID;
+        private final Class<? extends net.minecraft.world.entity.animal.Animal> animalType;
+
+        public BreedingCooldownPair(java.util.UUID playerUUID, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) {
+            this.playerUUID = playerUUID;
+            this.animalType = animalType;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            BreedingCooldownPair that = (BreedingCooldownPair) o;
+            return playerUUID.equals(that.playerUUID) && animalType.equals(that.animalType);
+        }
+
+        @Override
+        public int hashCode() {
+            return java.util.Objects.hash(playerUUID, animalType);
+        }
+    }
+    // Purpur end - Add adjustable breeding cooldown to config
+
     public CraftWorld getWorld() {
         return this.world;
     }
@@ -845,6 +889,8 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         // Paper end - getblock optimisations - cache world height/sections
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) levelData).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper - create paper world config
+        this.purpurConfig = new org.purpurmc.purpur.PurpurWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) levelData).getLevelName(), environment); // Purpur - Purpur config files
+        this.playerBreedingCooldowns = this.getNewBreedingCooldownCache(); // Purpur - Add adjustable breeding cooldown to config
         this.generator = generator;
         this.world = new CraftWorld((ServerLevel) this, generator, biomeProvider, environment);
 
@@ -2090,4 +2136,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return this.moonrise$getEntityLookup().getEntityCount(); // Paper - rewrite chunk system
     }
     // Paper end - allow patching this logic
+    
+    // Purpur start - Add allow water in end world option
+    public boolean isNether() {
+        return getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER;
+    }
+
+    public boolean isTheEnd() {
+        return getWorld().getEnvironment() == org.bukkit.World.Environment.THE_END;
+    }
+    // Purpur end - Add allow water in end world option
 }
diff --git a/net/minecraft/world/level/NaturalSpawner.java b/net/minecraft/world/level/NaturalSpawner.java
index 4e5078495037078922ab6350a500acdabe177ca5..14e21c5439cfdf870feeccf638d6494a0c003d64 100644
--- a/net/minecraft/world/level/NaturalSpawner.java
+++ b/net/minecraft/world/level/NaturalSpawner.java
@@ -264,7 +264,7 @@ public final class NaturalSpawner {
                     mutableBlockPos.set(x, y, z);
                     double d = x + 0.5;
                     double d1 = z + 0.5;
-                    Player nearestPlayer = level.getNearestPlayer(d, y, d1, -1.0, false);
+                    Player nearestPlayer = level.getNearestPlayer(d, y, d1, -1.0, level.purpurConfig.mobSpawningIgnoreCreativePlayers); // Purpur - mob spawning option to ignore creative players
                     if (nearestPlayer != null) {
                         double d2 = nearestPlayer.distanceToSqr(d, y, d1);
                         if (level.isLoadedAndInBounds(mutableBlockPos) && isRightDistanceToPlayerAndSpawnPoint(level, chunk, mutableBlockPos, d2)) { // Paper - don't load chunks for mob spawn
diff --git a/net/minecraft/world/level/ServerExplosion.java b/net/minecraft/world/level/ServerExplosion.java
index 1e94326047622d8975fd1cc5f44e75104fd56946..bcbf7daa2c2b7941ab7cb333de15494969ca665c 100644
--- a/net/minecraft/world/level/ServerExplosion.java
+++ b/net/minecraft/world/level/ServerExplosion.java
@@ -640,6 +640,23 @@ public class ServerExplosion implements Explosion {
         this.directMappedBlockCache = new ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache[BLOCK_EXPLOSION_CACHE_WIDTH * BLOCK_EXPLOSION_CACHE_WIDTH * BLOCK_EXPLOSION_CACHE_WIDTH];
         this.mutablePos = new BlockPos.MutableBlockPos();
         // Paper end - collision optimisations
+        // Purpur start - add PreExplodeEvents
+        if (this.source != null) {
+            Location location = new Location(this.level.getWorld(), this.center.x, this.center.y, this.center.z);
+            if(!new org.purpurmc.purpur.event.entity.PreEntityExplodeEvent(this.source.getBukkitEntity(), location, this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, org.bukkit.craftbukkit.CraftExplosionResult.toExplosionResult(getBlockInteraction())).callEvent()) {
+                this.wasCanceled = true;
+                return 0;
+            }
+        } else {
+            Location location = new Location(this.level.getWorld(), this.center.x, this.center.y, this.center.z);
+            org.bukkit.block.Block block = location.getBlock();
+            org.bukkit.block.BlockState blockState = (this.damageSource.causingBlockSnapshot() != null) ? this.damageSource.causingBlockSnapshot() : block.getState();
+            if(!new org.purpurmc.purpur.event.PreBlockExplodeEvent(location.getBlock(), this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, blockState, org.bukkit.craftbukkit.CraftExplosionResult.toExplosionResult(getBlockInteraction())).callEvent()) {
+                this.wasCanceled = true;
+                return 0;
+            }
+        }
+        // Purpur end - Add PreExplodeEvents
         this.level.gameEvent(this.source, GameEvent.EXPLODE, this.center);
         List<BlockPos> list = this.calculateExplodedPositions();
         this.hurtEntities();
diff --git a/net/minecraft/world/level/block/AnvilBlock.java b/net/minecraft/world/level/block/AnvilBlock.java
index bfcf55cf52b468fbb3fe60daae1068b6e54524a2..ac01a06e000354356c5f3b2e0a8049bd742b0727 100644
--- a/net/minecraft/world/level/block/AnvilBlock.java
+++ b/net/minecraft/world/level/block/AnvilBlock.java
@@ -54,6 +54,53 @@ public class AnvilBlock extends FallingBlock {
         return this.defaultBlockState().setValue(FACING, context.getHorizontalDirection().getClockWise());
     }
 
+    // Purpur start - Anvil repair/damage options
+    @Override
+    protected net.minecraft.world.InteractionResult useItemOn(final net.minecraft.world.item.ItemStack stack, final BlockState state, final Level world, final BlockPos pos, final Player player, final net.minecraft.world.InteractionHand hand, final BlockHitResult hit) {
+        if (world.purpurConfig.anvilRepairIngotsAmount > 0 && stack.is(net.minecraft.world.item.Items.IRON_INGOT)) {
+            if (stack.getCount() < world.purpurConfig.anvilRepairIngotsAmount) {
+                // not enough iron ingots, play "error" sound and consume
+                world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_HIT, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+                return net.minecraft.world.InteractionResult.CONSUME;
+            }
+            if (state.is(Blocks.DAMAGED_ANVIL)) {
+                world.setBlock(pos, Blocks.CHIPPED_ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            } else if (state.is(Blocks.CHIPPED_ANVIL)) {
+                world.setBlock(pos, Blocks.ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            } else if (state.is(Blocks.ANVIL)) {
+                // anvil is already fully repaired, play "error" sound and consume
+                world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_HIT, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+                return net.minecraft.world.InteractionResult.CONSUME;
+            }
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(world.purpurConfig.anvilRepairIngotsAmount);
+            }
+            world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_PLACE, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+            return net.minecraft.world.InteractionResult.CONSUME;
+        }
+        if (world.purpurConfig.anvilDamageObsidianAmount > 0 && stack.is(net.minecraft.world.item.Items.OBSIDIAN)) {
+            if (stack.getCount() < world.purpurConfig.anvilDamageObsidianAmount) {
+                // not enough obsidian, play "error" sound and consume
+                world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_HIT, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+                return net.minecraft.world.InteractionResult.CONSUME;
+            }
+            if (state.is(Blocks.DAMAGED_ANVIL)) {
+                world.destroyBlock(pos, false);
+            } else if (state.is(Blocks.CHIPPED_ANVIL)) {
+                world.setBlock(pos, Blocks.DAMAGED_ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            } else if (state.is(Blocks.ANVIL)) {
+                world.setBlock(pos, Blocks.CHIPPED_ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            }
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(world.purpurConfig.anvilDamageObsidianAmount);
+            }
+            world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_LAND, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+            return net.minecraft.world.InteractionResult.CONSUME;
+        }
+        return net.minecraft.world.InteractionResult.TRY_WITH_EMPTY_HAND;
+    }
+    // Purpur end - Anvil repair/damage options
+
     @Override
     protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hitResult) {
         if (!level.isClientSide()) {
diff --git a/net/minecraft/world/level/block/AzaleaBlock.java b/net/minecraft/world/level/block/AzaleaBlock.java
index 435a455ad2ec3dfb142d570a51a720bc6c49dac3..32a1dc20202bad7a15794e98cdc1bf2fb2ad5308 100644
--- a/net/minecraft/world/level/block/AzaleaBlock.java
+++ b/net/minecraft/world/level/block/AzaleaBlock.java
@@ -50,6 +50,20 @@ public class AzaleaBlock extends VegetationBlock implements BonemealableBlock {
 
     @Override
     public void performBonemeal(ServerLevel level, RandomSource random, BlockPos pos, BlockState state) {
+        // Purpur start - Chance for azalea blocks to grow into trees naturally
+        growTree(level, random, pos, state);
+    }
+
+    @Override
+    public void randomTick(net.minecraft.world.level.block.state.BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
+        double chance = state.getBlock() == Blocks.FLOWERING_AZALEA ? world.purpurConfig.floweringAzaleaGrowthChance : world.purpurConfig.azaleaGrowthChance;
+        if (chance > 0.0D && world.getMaxLocalRawBrightness(pos.above()) > 9 && random.nextDouble() < chance) {
+            growTree(world, random, pos, state);
+        }
+    }
+
+    private void growTree(ServerLevel level, RandomSource random, BlockPos pos, net.minecraft.world.level.block.state.BlockState state) {
+        // Purpur end - Chance for azalea blocks to grow into trees naturally
         TreeGrower.AZALEA.growTree(level, level.getChunkSource().getGenerator(), pos, state, random);
     }
 
diff --git a/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java b/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java
index e348412960da6623cf8d878ea37af05e6b606adc..f178c45c834aa276522c4ecd6995d9eaf63d3eb6 100644
--- a/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java
+++ b/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java
@@ -39,6 +39,7 @@ public abstract class BaseCoralPlantTypeBlock extends Block implements SimpleWat
     }
 
     protected static boolean scanForWater(BlockState state, BlockGetter level, BlockPos pos) {
+        if (!((net.minecraft.world.level.LevelAccessor) level).getMinecraftWorld().purpurConfig.coralDieOutsideWater) return true; // Purpur - Config to not let coral die
         if (state.getValue(WATERLOGGED)) {
             return true;
         } else {
diff --git a/net/minecraft/world/level/block/BaseFireBlock.java b/net/minecraft/world/level/block/BaseFireBlock.java
index 1ff7387320928af6630b9e0cbc30199b4770737d..42e897dc4bee8e9c075415d494ce13c404f2042a 100644
--- a/net/minecraft/world/level/block/BaseFireBlock.java
+++ b/net/minecraft/world/level/block/BaseFireBlock.java
@@ -208,7 +208,7 @@ public abstract class BaseFireBlock extends Block {
             boolean flag = false;
 
             for (Direction direction1 : Direction.values()) {
-                if (level.getBlockState(mutableBlockPos.set(pos).move(direction1)).is(Blocks.OBSIDIAN)) {
+                if (PortalShape.FRAME.test(level.getBlockState(mutableBlockPos.set(pos).move(direction1)), level, mutableBlockPos)) { // Purpur - Crying obsidian valid for portal frames
                     flag = true;
                     break;
                 }
diff --git a/net/minecraft/world/level/block/BedBlock.java b/net/minecraft/world/level/block/BedBlock.java
index 7bfc62120cae4c5e83cb0d86b759b7ffb2336a95..c4823d0538558b674457c99dc540a6a5757492e7 100644
--- a/net/minecraft/world/level/block/BedBlock.java
+++ b/net/minecraft/world/level/block/BedBlock.java
@@ -100,7 +100,7 @@ public class BedBlock extends HorizontalDirectionalBlock implements EntityBlock
                 }
 
                 Vec3 center = pos.getCenter();
-                level.explode(null, level.damageSources().badRespawnPointExplosion(center), null, center, 5.0F, true, Level.ExplosionInteraction.BLOCK);
+                if (level.purpurConfig.bedExplode) level.explode(null, level.damageSources().badRespawnPointExplosion(center), null, center, (float) level.purpurConfig.bedExplosionPower, level.purpurConfig.bedExplosionFire, level.purpurConfig.bedExplosionEffect); // Purpur - Implement bed explosion options
                 return InteractionResult.SUCCESS_SERVER;
             } else if (state.getValue(OCCUPIED)) {
                 if (bedRule.explodes()) return this.explodeBed(state, level, pos); // Paper - check explode first
@@ -153,7 +153,7 @@ public class BedBlock extends HorizontalDirectionalBlock implements EntityBlock
         }
 
         Vec3 center = pos.getCenter();
-        level.explode(null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), null, center, 5.0F, true, Level.ExplosionInteraction.BLOCK); // CraftBukkit - add state
+        if (level.purpurConfig.bedExplode) level.explode(null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), null, center, (float) level.purpurConfig.bedExplosionPower, level.purpurConfig.bedExplosionFire, level.purpurConfig.bedExplosionEffect); // CraftBukkit - add state // Purpur - Implement bed explosion options
         return InteractionResult.SUCCESS_SERVER;
     }
     // CraftBukkit end
@@ -170,7 +170,7 @@ public class BedBlock extends HorizontalDirectionalBlock implements EntityBlock
 
     @Override
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
-        super.fallOn(level, state, pos, entity, fallDistance * 0.5);
+        super.fallOn(level, state, pos, entity, fallDistance); // Purpur - Configurable block fall damage modifiers
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/BigDripleafBlock.java b/net/minecraft/world/level/block/BigDripleafBlock.java
index c2ef71dd9ee070f80d32b8829b80240ff22f0f7f..9cbeba234dc96264a6bb134fc2af073e62925836 100644
--- a/net/minecraft/world/level/block/BigDripleafBlock.java
+++ b/net/minecraft/world/level/block/BigDripleafBlock.java
@@ -251,7 +251,7 @@ public class BigDripleafBlock extends HorizontalDirectionalBlock implements Bone
             playTiltSound(level, pos, sound);
         }
 
-        int _int = DELAY_UNTIL_NEXT_TILT_STATE.getInt(tilt);
+        int _int = level.purpurConfig.bigDripleafTiltDelay.getOrDefault(tilt, -1); // Purpur - Big dripleaf tilt delay
         if (_int != -1) {
             level.scheduleTick(pos, this, _int);
         }
diff --git a/net/minecraft/world/level/block/Block.java b/net/minecraft/world/level/block/Block.java
index 94b4143449c99ee35db44ab8e2a766d924aa6410..f6dcd981b6bddadb7618f022908cbbad67095e1b 100644
--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -113,6 +113,10 @@ public class Block extends BlockBehaviour implements ItemLike {
     public static final int UPDATE_LIMIT = 512;
     protected final StateDefinition<Block, BlockState> stateDefinition;
     private BlockState defaultBlockState;
+    // Purpur start - Configurable block fall damage modifiers
+    public float fallDamageMultiplier = 1.0F;
+    public float fallDistanceMultiplier = 1.0F;
+    // Purpur end - Configurable block fall damage modifiers
     // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
     public final boolean isDestroyable() {
         return io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits ||
@@ -395,7 +399,7 @@ public class Block extends BlockBehaviour implements ItemLike {
             event.setExpToDrop(block.getExpDrop(state, serverLevel, pos, net.minecraft.world.item.ItemStack.EMPTY, true)); // Paper - Properly handle xp dropping
             event.callEvent();
             for (org.bukkit.inventory.ItemStack drop : event.getDrops()) {
-                popResource(serverLevel, pos, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(drop));
+                popResource(serverLevel, pos, applyLoreFromTile(org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(drop), blockEntity)); // Purpur - Persistent BlockEntity Lore and DisplayName
             }
             state.spawnAfterBreak(serverLevel, pos, ItemStack.EMPTY, false); // Paper - Properly handle xp dropping
             block.popExperience(serverLevel, pos, event.getExpToDrop()); // Paper - Properly handle xp dropping
@@ -413,7 +417,7 @@ public class Block extends BlockBehaviour implements ItemLike {
 
     public static void dropResources(BlockState state, LevelAccessor level, BlockPos pos, @Nullable BlockEntity blockEntity) {
         if (level instanceof ServerLevel) {
-            getDrops(state, (ServerLevel)level, pos, blockEntity).forEach(stack -> popResource((ServerLevel)level, pos, stack));
+            getDrops(state, (ServerLevel)level, pos, blockEntity).forEach(stack -> popResource((ServerLevel)level, pos, applyLoreFromTile(stack, blockEntity))); // Purpur - Persistent BlockEntity Lore and DisplayName
             state.spawnAfterBreak((ServerLevel)level, pos, ItemStack.EMPTY, true);
         }
     }
@@ -425,11 +429,30 @@ public class Block extends BlockBehaviour implements ItemLike {
     public static void dropResources(BlockState state, Level level, BlockPos pos, @Nullable BlockEntity blockEntity, @Nullable Entity entity, ItemStack tool, boolean dropExperience) {
         // Paper end - Properly handle xp dropping
         if (level instanceof ServerLevel) {
-            getDrops(state, (ServerLevel)level, pos, blockEntity, entity, tool).forEach(stack -> popResource(level, pos, stack));
+            getDrops(state, (ServerLevel)level, pos, blockEntity, entity, tool).forEach(stack -> popResource(level, pos, applyLoreFromTile(stack, blockEntity))); // Purpur - Persistent BlockEntity Lore and DisplayName
             state.spawnAfterBreak((ServerLevel)level, pos, tool, dropExperience); // Paper - Properly handle xp dropping
         }
     }
 
+    // Purpur start - Persistent BlockEntity Lore and DisplayName
+    private static ItemStack applyLoreFromTile(ItemStack stack, @Nullable BlockEntity blockEntity) {
+        if (stack.getItem() instanceof BlockItem) {
+            if (blockEntity != null && blockEntity.getLevel() instanceof ServerLevel) {
+                net.minecraft.world.item.component.ItemLore lore = blockEntity.getPersistentLore();
+                net.minecraft.core.component.DataComponentPatch.Builder builder = net.minecraft.core.component.DataComponentPatch.builder();
+                if (blockEntity.getLevel().purpurConfig.persistentTileEntityLore && lore != null) {
+                    builder.set(net.minecraft.core.component.DataComponents.LORE, lore);
+                }
+                if (!blockEntity.getLevel().purpurConfig.persistentTileEntityDisplayName) {
+                    builder.remove(net.minecraft.core.component.DataComponents.CUSTOM_NAME);
+                }
+                stack.applyComponents(builder.build());
+            }
+        }
+        return stack;
+    }
+    // Purpur end - Persistent BlockEntity Lore and DisplayName
+
     public static void popResource(Level level, BlockPos pos, ItemStack stack) {
         double d = EntityType.ITEM.getHeight() / 2.0;
         double d1 = pos.getX() + 0.5 + Mth.nextDouble(level.random, -0.25, 0.25);
@@ -509,7 +532,15 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
 
     public void setPlacedBy(Level level, BlockPos pos, BlockState state, @Nullable LivingEntity placer, ItemStack stack) {
+        this.placer = placer; // Purpur - Store placer on Block when placed
+    }
+
+    // Purpur start - Store placer on Block when placed
+    @Nullable protected LivingEntity placer = null;
+    public void forgetPlacer() {
+        this.placer = null;
     }
+    // Purpur end - Store placer on Block when placed
 
     public boolean isPossibleToRespawnInThis(BlockState state) {
         return !state.isSolid() && !state.liquid();
@@ -520,7 +551,7 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
 
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
-        entity.causeFallDamage(fallDistance, 1.0F, entity.damageSources().fall());
+        entity.causeFallDamage(fallDistance * fallDistanceMultiplier, fallDamageMultiplier, entity.damageSources().fall()); // Purpur - Configurable block fall damage modifiers
     }
 
     public void updateEntityMovementAfterFallOn(BlockGetter level, Entity entity) {
diff --git a/net/minecraft/world/level/block/Blocks.java b/net/minecraft/world/level/block/Blocks.java
index 2eb6fe73adeda3e525e147b7f7034bdec651e04a..4001a0c25796cd33d110b4f534590c342b1f37fc 100644
--- a/net/minecraft/world/level/block/Blocks.java
+++ b/net/minecraft/world/level/block/Blocks.java
@@ -6806,6 +6806,7 @@ public class Blocks {
         BlockBehaviour.Properties.of()
             .mapColor(MapColor.PLANT)
             .forceSolidOff()
+            .randomTicks() // Purpur - Chance for azalea blocks to grow into trees naturally
             .instabreak()
             .sound(SoundType.AZALEA)
             .noOcclusion()
@@ -6817,6 +6818,7 @@ public class Blocks {
         BlockBehaviour.Properties.of()
             .mapColor(MapColor.PLANT)
             .forceSolidOff()
+            .randomTicks() // Purpur - Chance for azalea blocks to grow into trees naturally
             .instabreak()
             .sound(SoundType.FLOWERING_AZALEA)
             .noOcclusion()
diff --git a/net/minecraft/world/level/block/BubbleColumnBlock.java b/net/minecraft/world/level/block/BubbleColumnBlock.java
index 596640c1473b8526b8bb57c5714a84ee55372d07..26f6a795a4d5be2b1c319a114c26c8f5f607d9cd 100644
--- a/net/minecraft/world/level/block/BubbleColumnBlock.java
+++ b/net/minecraft/world/level/block/BubbleColumnBlock.java
@@ -99,9 +99,9 @@ public class BubbleColumnBlock extends Block implements BucketPickup {
         if (state.is(Blocks.BUBBLE_COLUMN)) {
             return state;
         } else if (state.is(Blocks.SOUL_SAND)) {
-            return Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, false);
+            return Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, org.purpurmc.purpur.PurpurConfig.soulSandBlockReverseBubbleColumnFlow); // Purpur - Config to reverse bubble column flow
         } else {
-            return state.is(Blocks.MAGMA_BLOCK) ? Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, true) : Blocks.WATER.defaultBlockState();
+            return state.is(Blocks.MAGMA_BLOCK) ? Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, !org.purpurmc.purpur.PurpurConfig.magmaBlockReverseBubbleColumnFlow) : Blocks.WATER.defaultBlockState(); // Purpur - Config to reverse bubble column flow
         }
     }
 
diff --git a/net/minecraft/world/level/block/CactusBlock.java b/net/minecraft/world/level/block/CactusBlock.java
index 9662828596de15e5b855f12d2a3b014763b3fc2e..f6a20e5676136389cd504af503c1207d339aa70c 100644
--- a/net/minecraft/world/level/block/CactusBlock.java
+++ b/net/minecraft/world/level/block/CactusBlock.java
@@ -22,7 +22,7 @@ import net.minecraft.world.level.pathfinder.PathComputationType;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
-public class CactusBlock extends Block {
+public class CactusBlock extends Block implements BonemealableBlock { // Purpur - bonemealable cactus
     public static final MapCodec<CactusBlock> CODEC = simpleCodec(CactusBlock::new);
     public static final IntegerProperty AGE = BlockStateProperties.AGE_15;
     public static final int MAX_AGE = 15;
@@ -117,7 +117,7 @@ public class CactusBlock extends Block {
     protected boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
         for (Direction direction : Direction.Plane.HORIZONTAL) {
             BlockState blockState = level.getBlockState(pos.relative(direction));
-            if (blockState.isSolid() || level.getFluidState(pos.relative(direction)).is(FluidTags.LAVA)) {
+            if ((level.getWorldBorder().world == null || level.getWorldBorder().world.purpurConfig.cactusBreaksFromSolidNeighbors) && blockState.isSolid() || level.getFluidState(pos.relative(direction)).is(FluidTags.LAVA)) { // Purpur - Cactus breaks from solid neighbors config
                 return false;
             }
         }
@@ -141,4 +141,34 @@ public class CactusBlock extends Block {
     protected boolean isPathfindable(BlockState state, PathComputationType pathComputationType) {
         return false;
     }
+
+    // Purpur start - bonemealable cactus
+    @Override
+    public boolean isValidBonemealTarget(final LevelReader world, final BlockPos pos, final BlockState state) {
+        if (!((Level) world).purpurConfig.cactusAffectedByBonemeal || !world.isEmptyBlock(pos.above())) return false;
+
+        int cactusHeight = 0;
+        while (world.getBlockState(pos.below(cactusHeight)).is(this)) {
+            cactusHeight++;
+        }
+
+        return cactusHeight < ((Level) world).paperConfig().maxGrowthHeight.cactus;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        int cactusHeight = 0;
+        while (world.getBlockState(pos.below(cactusHeight)).is(this)) {
+            cactusHeight++;
+        }
+        for (int i = 0; i <= world.paperConfig().maxGrowthHeight.cactus - cactusHeight; i++) {
+            world.setBlockAndUpdate(pos.above(i), state.setValue(CactusBlock.AGE, 0));
+        }
+    }
+    // Purpur end - bonemealable cactus
 }
diff --git a/net/minecraft/world/level/block/CakeBlock.java b/net/minecraft/world/level/block/CakeBlock.java
index cca7bde128f88df4327e6b011c301f60d909bb4d..576e00d1e9eb2a692b1ee0f1086ee0db230d4e7e 100644
--- a/net/minecraft/world/level/block/CakeBlock.java
+++ b/net/minecraft/world/level/block/CakeBlock.java
@@ -109,6 +109,7 @@ public class CakeBlock extends Block {
             org.bukkit.event.entity.FoodLevelChangeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callFoodLevelChangeEvent(player, 2 + oldFoodLevel);
 
             if (!event.isCancelled()) {
+                if (player.level().purpurConfig.playerBurpWhenFull && event.getFoodLevel() == 20 && oldFoodLevel < 20) player.burpDelay = player.level().purpurConfig.playerBurpDelay; // Purpur - Burp after eating food fills hunger bar completely
                 player.getFoodData().eat(event.getFoodLevel() - oldFoodLevel, 0.1F);
             }
 
diff --git a/net/minecraft/world/level/block/CampfireBlock.java b/net/minecraft/world/level/block/CampfireBlock.java
index b9e11a361e91cf3d5c929330fc0ba59cfe903198..2049ccee48c63fc0bfb5e5486c2603756fd20c7d 100644
--- a/net/minecraft/world/level/block/CampfireBlock.java
+++ b/net/minecraft/world/level/block/CampfireBlock.java
@@ -123,7 +123,7 @@ public class CampfireBlock extends BaseEntityBlock implements SimpleWaterloggedB
         return this.defaultBlockState()
             .setValue(WATERLOGGED, flag)
             .setValue(SIGNAL_FIRE, this.isSmokeSource(level.getBlockState(clickedPos.below())))
-            .setValue(LIT, !flag)
+            .setValue(LIT, level.getMinecraftWorld().purpurConfig.campFireLitWhenPlaced && !flag) // Purpur - Campfire option for lit when placed
             .setValue(FACING, context.getHorizontalDirection());
     }
 
diff --git a/net/minecraft/world/level/block/CarvedPumpkinBlock.java b/net/minecraft/world/level/block/CarvedPumpkinBlock.java
index b45e5f571e72028996f641157473039ba9dd3520..b192b384fa5b9b6ab5b72f6c6414c4fa4f36c75e 100644
--- a/net/minecraft/world/level/block/CarvedPumpkinBlock.java
+++ b/net/minecraft/world/level/block/CarvedPumpkinBlock.java
@@ -67,7 +67,7 @@ public class CarvedPumpkinBlock extends HorizontalDirectionalBlock {
         if (blockPatternMatch != null) {
             SnowGolem snowGolem = EntityType.SNOW_GOLEM.create(level, EntitySpawnReason.TRIGGERED);
             if (snowGolem != null) {
-                spawnGolemInWorld(level, blockPatternMatch, snowGolem, blockPatternMatch.getBlock(0, 2, 0).getPos());
+                spawnGolemInWorld(level, blockPatternMatch, snowGolem, blockPatternMatch.getBlock(0, 2, 0).getPos(), this.placer); // Purpur - Summoner API
                 return;
             }
         }
@@ -77,7 +77,7 @@ public class CarvedPumpkinBlock extends HorizontalDirectionalBlock {
             IronGolem ironGolem = EntityType.IRON_GOLEM.create(level, EntitySpawnReason.TRIGGERED);
             if (ironGolem != null) {
                 ironGolem.setPlayerCreated(true);
-                spawnGolemInWorld(level, blockPatternMatch1, ironGolem, blockPatternMatch1.getBlock(1, 2, 0).getPos());
+                spawnGolemInWorld(level, blockPatternMatch1, ironGolem, blockPatternMatch1.getBlock(1, 2, 0).getPos(), this.placer); // Purpur - Summoner API
                 return;
             }
         }
@@ -86,7 +86,7 @@ public class CarvedPumpkinBlock extends HorizontalDirectionalBlock {
         if (blockPatternMatch2 != null) {
             CopperGolem copperGolem = EntityType.COPPER_GOLEM.create(level, EntitySpawnReason.TRIGGERED);
             if (copperGolem != null) {
-                spawnGolemInWorld(level, blockPatternMatch2, copperGolem, blockPatternMatch2.getBlock(0, 0, 0).getPos());
+                spawnGolemInWorld(level, blockPatternMatch2, copperGolem, blockPatternMatch2.getBlock(0, 0, 0).getPos(), this.placer); // Purpur - Summoner API
                 if (!copperGolem.valid) return; // Paper - entityspawnevent - entity was not added to the world so prevent world mutation
                 this.replaceCopperBlockWithChest(level, blockPatternMatch2);
                 copperGolem.spawn(this.getWeatherStateFromPattern(blockPatternMatch2));
@@ -105,7 +105,20 @@ public class CarvedPumpkinBlock extends HorizontalDirectionalBlock {
                 .getAge();
     }
 
+    @io.papermc.paper.annotation.DoNotUse
     private static void spawnGolemInWorld(Level level, BlockPattern.BlockPatternMatch patternMatch, Entity golem, BlockPos pos) {
+        // Purpur start - Summoner API
+        spawnGolemInWorld(level, patternMatch, golem, pos, null);
+    }
+    private static void spawnGolemInWorld(Level level, BlockPattern.BlockPatternMatch patternMatch, Entity golem, BlockPos pos, net.minecraft.world.entity.LivingEntity placer) {
+        java.util.UUID summoner = placer == null ? null : placer.getUUID();
+        switch (golem) {
+            case SnowGolem snowGolem -> snowGolem.setSummoner(summoner);
+            case IronGolem ironGolem -> ironGolem.setSummoner(summoner);
+            case CopperGolem copperGolem -> copperGolem.setSummoner(summoner);
+            default -> throw new IllegalStateException("Unexpected value: " + golem);
+        }
+        // Purpur end - Summoner API
         // clearPatternBlocks(level, patternMatch); // Paper - moved down
         golem.snapTo(pos.getX() + 0.5, pos.getY() + 0.05, pos.getZ() + 0.5, 0.0F, 0.0F);
         // Paper start
diff --git a/net/minecraft/world/level/block/CauldronBlock.java b/net/minecraft/world/level/block/CauldronBlock.java
index 523a769ce8f73b2f216d0768ab8f2f9f1bfa949d..703c15dfc3dd0b209502c0a0b75d714318e608a8 100644
--- a/net/minecraft/world/level/block/CauldronBlock.java
+++ b/net/minecraft/world/level/block/CauldronBlock.java
@@ -32,8 +32,8 @@ public class CauldronBlock extends AbstractCauldronBlock {
 
     protected static boolean shouldHandlePrecipitation(Level level, Biome.Precipitation precipitation) {
         return precipitation == Biome.Precipitation.RAIN
-            ? level.getRandom().nextFloat() < 0.05F
-            : precipitation == Biome.Precipitation.SNOW && level.getRandom().nextFloat() < 0.1F;
+            ? level.getRandom().nextFloat() < level.purpurConfig.cauldronRainChance // Purpur - Cauldron fill chances
+            : precipitation == Biome.Precipitation.SNOW && level.getRandom().nextFloat() < level.purpurConfig.cauldronPowderSnowChance; // Purpur - Cauldron fill chances
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/CaveVinesBlock.java b/net/minecraft/world/level/block/CaveVinesBlock.java
index f4a4dc14012c110e58b1c9272d80d4b89394d090..da85ec2b88b200fd28d89d9ae35c7319d4b028b7 100644
--- a/net/minecraft/world/level/block/CaveVinesBlock.java
+++ b/net/minecraft/world/level/block/CaveVinesBlock.java
@@ -92,4 +92,11 @@ public class CaveVinesBlock extends GrowingPlantHeadBlock implements CaveVines {
     public void performBonemeal(ServerLevel level, RandomSource random, BlockPos pos, BlockState state) {
         level.setBlock(pos, state.setValue(BERRIES, true), Block.UPDATE_CLIENTS);
     }
+
+    // Purpur start - cave vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.caveVinesMaxGrowthAge;
+    }
+    // Purpur end - cave vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/ChangeOverTimeBlock.java b/net/minecraft/world/level/block/ChangeOverTimeBlock.java
index ea5a987b9925a7ff0cbc65a9cd98114770377442..d03e234fe20b33ebf7b6af6fb1b1738a6ff48a99 100644
--- a/net/minecraft/world/level/block/ChangeOverTimeBlock.java
+++ b/net/minecraft/world/level/block/ChangeOverTimeBlock.java
@@ -51,7 +51,7 @@ public interface ChangeOverTimeBlock<T extends Enum<T>> {
         }
 
         float f = (float)(i1 + 1) / (i1 + i + 1);
-        float f1 = f * f * this.getChanceModifier();
+        float f1 = level.purpurConfig.disableOxidationProximityPenalty ? this.getChanceModifier() :f * f * this.getChanceModifier();// Purpur - option to disable the copper oxidation proximity penalty
         return random.nextFloat() < f1 ? this.getNext(state) : Optional.empty();
     }
 }
diff --git a/net/minecraft/world/level/block/ChestBlock.java b/net/minecraft/world/level/block/ChestBlock.java
index fa2dce759419f62825000718361f47c6f208cdb2..6cd7150c23572b1ad627cabe406ebd9015a89c31 100644
--- a/net/minecraft/world/level/block/ChestBlock.java
+++ b/net/minecraft/world/level/block/ChestBlock.java
@@ -370,6 +370,7 @@ public class ChestBlock extends AbstractChestBlock<ChestBlockEntity> implements
     }
 
     public static boolean isBlockedChestByBlock(BlockGetter level, BlockPos pos) {
+        if (level instanceof Level level1 && level1.purpurConfig.chestOpenWithBlockOnTop) return false; // Purpur - Option for chests to open even with a solid block on top
         BlockPos blockPos = pos.above();
         return level.getBlockState(blockPos).isRedstoneConductor(level, blockPos);
     }
diff --git a/net/minecraft/world/level/block/ComposterBlock.java b/net/minecraft/world/level/block/ComposterBlock.java
index 429e833ffe7c89d7b0ca7515dbd82ffc1ce8d60d..f57feed60fdd99cc652be67ed2ada7d761167deb 100644
--- a/net/minecraft/world/level/block/ComposterBlock.java
+++ b/net/minecraft/world/level/block/ComposterBlock.java
@@ -250,17 +250,27 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
     ) {
         int levelValue = state.getValue(LEVEL);
         if (levelValue < 8 && COMPOSTABLES.containsKey(stack.getItem())) {
-            if (levelValue < 7 && !level.isClientSide()) {
-                BlockState blockState = addItem(player, state, level, pos, stack);
-                // Paper start - handle cancelled events
-                if (blockState == null) {
-                    return InteractionResult.PASS;
-                }
-                // Paper end
-                level.levelEvent(LevelEvent.COMPOSTER_FILL, pos, state != blockState ? 1 : 0);
-                player.awardStat(Stats.ITEM_USED.get(stack.getItem()));
-                stack.consume(1, player);
+            // Purpur start - sneak to bulk process composter
+            BlockState newState = process(levelValue, player, state, level, pos, stack);
+            if (newState == null) {
+                return InteractionResult.PASS;
             }
+            if (level.purpurConfig.composterBulkProcess && player.isShiftKeyDown() && newState != state) {
+                BlockState oldState;
+                int oldCount, newCount, oldLevel, newLevel;
+                do {
+                    oldState = newState;
+                    oldCount = stack.getCount();
+                    oldLevel = oldState.getValue(ComposterBlock.LEVEL);
+                    newState = process(oldLevel, player, oldState, level, pos, stack);
+                    if (newState == null) {
+                        return InteractionResult.PASS;
+                    }
+                    newCount = stack.getCount();
+                    newLevel = newState.getValue(ComposterBlock.LEVEL);
+                } while (newCount > 0 && (newCount != oldCount || newLevel != oldLevel || newState != oldState));
+            }
+            // Purpur end - Sneak to bulk process composter
 
             return InteractionResult.SUCCESS;
         } else {
@@ -268,6 +278,25 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
         }
     }
 
+    // Purpur start - sneak to bulk process composter
+    private static @Nullable BlockState process(int levelValue, Player player, BlockState state, Level level, BlockPos pos, ItemStack stack) {
+        if (levelValue < 7 && !level.isClientSide()) {
+            BlockState blockState = ComposterBlock.addItem(player, state, level, pos, stack);
+            // Paper start - handle cancelled events
+            if (blockState == null) {
+                return null;
+            }
+            // Paper end
+
+            level.levelEvent(LevelEvent.COMPOSTER_FILL, pos, state != blockState ? 1 : 0);
+            player.awardStat(Stats.ITEM_USED.get(stack.getItem()));
+            stack.consume(1, player);
+            return blockState;
+        }
+        return state;
+    }
+    // Purpur end - Sneak to bulk process composter
+
     @Override
     protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hitResult) {
         int levelValue = state.getValue(LEVEL);
diff --git a/net/minecraft/world/level/block/CoralBlock.java b/net/minecraft/world/level/block/CoralBlock.java
index 1c86b4fce7392851b2e33914fb588775f90f766b..337985a30767aaac573fce6301b2690473f8305a 100644
--- a/net/minecraft/world/level/block/CoralBlock.java
+++ b/net/minecraft/world/level/block/CoralBlock.java
@@ -65,6 +65,7 @@ public class CoralBlock extends Block {
     }
 
     protected boolean scanForWater(BlockGetter level, BlockPos pos) {
+        if (!((net.minecraft.world.level.LevelAccessor) level).getMinecraftWorld().purpurConfig.coralDieOutsideWater) return true; // Purpur - Config to not let coral die
         for (Direction direction : Direction.values()) {
             FluidState fluidState = level.getFluidState(pos.relative(direction));
             if (fluidState.is(FluidTags.WATER)) {
diff --git a/net/minecraft/world/level/block/CropBlock.java b/net/minecraft/world/level/block/CropBlock.java
index 1cf40fafd822d976ef4822335c60d8017659916f..372559399ce8a4ce551f4403975879e365e1ad75 100644
--- a/net/minecraft/world/level/block/CropBlock.java
+++ b/net/minecraft/world/level/block/CropBlock.java
@@ -169,7 +169,7 @@ public class CropBlock extends VegetationBlock implements BonemealableBlock {
     @Override
     protected void entityInside(BlockState state, Level level, BlockPos pos, Entity entity, InsideBlockEffectApplier effectApplier, boolean pastEdges) {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(level, pos)).callEvent()) { return; } // Paper - Add EntityInsideBlockEvent
-        if (level instanceof ServerLevel serverLevel && entity instanceof Ravager && org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity, pos, Blocks.AIR.defaultBlockState(), !serverLevel.getGameRules().get(GameRules.MOB_GRIEFING))) { // CraftBukkit
+        if (level instanceof ServerLevel serverLevel && entity instanceof Ravager && serverLevel.purpurConfig.ravagerGriefableBlocks.contains(serverLevel.getBlockState(pos).getBlock()) && org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity, pos, Blocks.AIR.defaultBlockState(), !serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.ravagerMobGriefingOverride))) { // CraftBukkit // Purpur - Configurable ravager griefable blocks list // Purpur - Add mobGriefing override to everything affected
             serverLevel.destroyBlock(pos, true, entity);
         }
 
@@ -204,4 +204,15 @@ public class CropBlock extends VegetationBlock implements BonemealableBlock {
     protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
         builder.add(AGE);
     }
+
+    // Purpur start - Ability for hoe to replant crops
+    @Override
+    public void playerDestroy(Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @javax.annotation.Nullable net.minecraft.world.level.block.entity.BlockEntity blockEntity, ItemStack itemInHand, boolean includeDrops, boolean dropExp) {
+        if (world.purpurConfig.hoeReplantsCrops && itemInHand.getItem() instanceof net.minecraft.world.item.HoeItem) {
+            super.playerDestroyAndReplant(world, player, pos, state, blockEntity, itemInHand, getBaseSeedId());
+        } else {
+            super.playerDestroy(world, player, pos, state, blockEntity, itemInHand, includeDrops, dropExp);
+        }
+    }
+    // Purpur end - Ability for hoe to replant crops
 }
diff --git a/net/minecraft/world/level/block/DoorBlock.java b/net/minecraft/world/level/block/DoorBlock.java
index d4239343b15203caafa9da762cbce206cc1d9b33..523bab9194e6fa5145fbf31f0bee9a4792ad6315 100644
--- a/net/minecraft/world/level/block/DoorBlock.java
+++ b/net/minecraft/world/level/block/DoorBlock.java
@@ -198,6 +198,7 @@ public class DoorBlock extends Block {
     protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hitResult) {
         if (!this.type.canOpenByHand()) {
             return InteractionResult.PASS;
+        } else if (requiresRedstone(level, state, pos)) { return InteractionResult.CONSUME; // Purpur - Option to make doors require redstone
         } else {
             state = state.cycle(OPEN);
             level.setBlock(pos, state, Block.UPDATE_CLIENTS | Block.UPDATE_IMMEDIATE);
@@ -286,4 +287,18 @@ public class DoorBlock extends Block {
     public static boolean isWoodenDoor(BlockState state) {
         return state.getBlock() instanceof DoorBlock doorBlock && doorBlock.type().canOpenByHand();
     }
+
+    // Purpur start - Option to make doors require redstone
+    public static boolean requiresRedstone(Level level, BlockState state, BlockPos pos) {
+        if (level.purpurConfig.doorRequiresRedstone.contains(state.getBlock())) {
+            // force update client
+            BlockPos otherPos = pos.relative(state.getValue(DoorBlock.HALF) == DoubleBlockHalf.LOWER ? Direction.UP : Direction.DOWN);
+            BlockState otherState = level.getBlockState(otherPos);
+            level.sendBlockUpdated(pos, state, state, Block.UPDATE_ALL);
+            level.sendBlockUpdated(otherPos, otherState, otherState, Block.UPDATE_ALL);
+            return true;
+        }
+        return false;
+    }
+    // Purpur end - Option to make doors require redstone
 }
diff --git a/net/minecraft/world/level/block/DragonEggBlock.java b/net/minecraft/world/level/block/DragonEggBlock.java
index 52160294e39e3f0f471087a1fcb6e46763862954..c38fbff78f1acef9328c91d7b88d5db1971c9474 100644
--- a/net/minecraft/world/level/block/DragonEggBlock.java
+++ b/net/minecraft/world/level/block/DragonEggBlock.java
@@ -46,6 +46,7 @@ public class DragonEggBlock extends FallingBlock {
     }
 
     private void teleport(BlockState state, Level level, BlockPos pos) {
+        if (!level.purpurConfig.dragonEggTeleport) return; // Purpur - Option to disable dragon egg teleporting
         WorldBorder worldBorder = level.getWorldBorder();
 
         for (int i = 0; i < 1000; i++) {
diff --git a/net/minecraft/world/level/block/EnderChestBlock.java b/net/minecraft/world/level/block/EnderChestBlock.java
index 383e8285d366c7f594b0b4ff55b367970c9b69e4..077edf449d4faa41abafb94ac41dfe822f449d04 100644
--- a/net/minecraft/world/level/block/EnderChestBlock.java
+++ b/net/minecraft/world/level/block/EnderChestBlock.java
@@ -85,8 +85,8 @@ public class EnderChestBlock extends AbstractChestBlock<EnderChestBlockEntity> i
                 enderChestInventory.setActiveChest(enderChestBlockEntity); // Needs to happen before ChestMenu.threeRows as it is required for opening animations
                 if (level instanceof ServerLevel serverLevel && player.openMenu(
                     new SimpleMenuProvider(
-                        (containerId, playerInventory, player1) -> ChestMenu.threeRows(containerId, playerInventory, enderChestInventory), CONTAINER_TITLE
-                    )
+                        (containerId, playerInventory, player1) -> org.purpurmc.purpur.PurpurConfig.enderChestSixRows ? getEnderChestSixRows(containerId, playerInventory, player, enderChestInventory) : ChestMenu.threeRows(containerId, playerInventory, enderChestInventory), CONTAINER_TITLE
+                    ) // Purpur - Barrels and enderchests 6 rows
                 ).isPresent()) {
                 // Paper end - Fix InventoryOpenEvent cancellation - moved up;
                     player.awardStat(Stats.OPEN_ENDERCHEST);
@@ -100,6 +100,35 @@ public class EnderChestBlock extends AbstractChestBlock<EnderChestBlockEntity> i
         }
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    private ChestMenu getEnderChestSixRows(int syncId, net.minecraft.world.entity.player.Inventory inventory, Player player, PlayerEnderChestContainer playerEnderChestContainer) {
+        if (org.purpurmc.purpur.PurpurConfig.enderChestPermissionRows) {
+            org.bukkit.craftbukkit.entity.CraftHumanEntity bukkitPlayer = player.getBukkitEntity();
+            if (bukkitPlayer.hasPermission("purpur.enderchest.rows.six")) {
+                player.sixRowEnderchestSlotCount = 54;
+                return ChestMenu.sixRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.five")) {
+                player.sixRowEnderchestSlotCount = 45;
+                return ChestMenu.fiveRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.four")) {
+                player.sixRowEnderchestSlotCount = 36;
+                return ChestMenu.fourRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.three")) {
+                player.sixRowEnderchestSlotCount = 27;
+                return ChestMenu.threeRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.two")) {
+                player.sixRowEnderchestSlotCount = 18;
+                return ChestMenu.twoRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.one")) {
+                player.sixRowEnderchestSlotCount = 9;
+                return ChestMenu.oneRow(syncId, inventory, playerEnderChestContainer);
+            }
+        }
+        player.sixRowEnderchestSlotCount = -1;
+        return ChestMenu.sixRows(syncId, inventory, playerEnderChestContainer);
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     @Override
     public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
         return new EnderChestBlockEntity(pos, state);
diff --git a/net/minecraft/world/level/block/FarmBlock.java b/net/minecraft/world/level/block/FarmBlock.java
index da822a89e134e98696308315799d872944e7712f..7ec5ef85dbface0ff194a7112d0c4b8e25cab6fe 100644
--- a/net/minecraft/world/level/block/FarmBlock.java
+++ b/net/minecraft/world/level/block/FarmBlock.java
@@ -112,9 +112,9 @@ public class FarmBlock extends Block {
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
         super.fallOn(level, state, pos, entity, fallDistance); // CraftBukkit - moved here as game rules / events shouldn't affect fall damage.
         if (level instanceof ServerLevel serverLevel
-            && level.random.nextFloat() < fallDistance - 0.5
+            && (serverLevel.purpurConfig.farmlandTrampleHeight >= 0D ? fallDistance >= serverLevel.purpurConfig.farmlandTrampleHeight : level.random.nextFloat() < fallDistance - 0.5) // Purpur - Configurable farmland trample height
             && entity instanceof LivingEntity
-            && (entity instanceof Player || serverLevel.getGameRules().get(GameRules.MOB_GRIEFING))
+            && (entity instanceof Player || serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.farmlandMobGriefingOverride)) // Purpur - Add mobGriefing override to everything affected
             && entity.getBbWidth() * entity.getBbWidth() * entity.getBbHeight() > 0.512F) {
                 // CraftBukkit start - Interact soil
                 org.bukkit.event.Cancellable cancellable;
@@ -129,6 +129,28 @@ public class FarmBlock extends Block {
                     return;
                 }
 
+                if (level.purpurConfig.farmlandTramplingDisabled) return; // Purpur - Farmland trampling changes
+                if (level.purpurConfig.farmlandTramplingOnlyPlayers && !(entity instanceof Player)) return; // Purpur - Farmland trampling changes
+
+                // Purpur start - Ability to re-add farmland mechanics from Alpha
+                if (level.purpurConfig.farmlandAlpha) {
+                    Block block = level.getBlockState(pos.below()).getBlock();
+                    if (block instanceof FenceBlock || block instanceof WallBlock) {
+                        return;
+                    }
+                }
+                // Purpur end - Ability to re-add farmland mechanics from Alpha
+
+                // Purpur start - Farmland trampling changes
+                if (level.purpurConfig.farmlandTramplingFeatherFalling) {
+                    net.minecraft.world.item.ItemStack bootsItem = ((net.minecraft.world.entity.LivingEntity) entity).getItemBySlot(net.minecraft.world.entity.EquipmentSlot.FEET);
+
+                    if (bootsItem != net.minecraft.world.item.ItemStack.EMPTY && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.FEATHER_FALLING, bootsItem) >= (int) entity.fallDistance) {
+                        return;
+                    }
+                }
+                // Purpur end - Farmland trampling changes
+
                 if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity, pos, Blocks.DIRT.defaultBlockState())) {
                     return;
                 }
@@ -177,7 +199,7 @@ public class FarmBlock extends Block {
             }
         }
 
-        return false;
+        return ((ServerLevel) level).purpurConfig.farmlandGetsMoistFromBelow && level.getFluidState(pos.relative(Direction.DOWN)).is(FluidTags.WATER); // Purpur - Allow soil to moisten from water directly under it
         // Paper end - Perf: remove abstract block iteration
     }
 
diff --git a/net/minecraft/world/level/block/GrowingPlantHeadBlock.java b/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
index bac7f990282fd7c676c2f8c40d7fd87badb1e284..c1b22036bd3da2dc0b59551cf8e5280d055c0951 100644
--- a/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
+++ b/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
@@ -34,12 +34,12 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
 
     @Override
     public BlockState getStateForPlacement(RandomSource random) {
-        return this.defaultBlockState().setValue(AGE, random.nextInt(25));
+        return this.defaultBlockState().setValue(AGE, getMaxGrowthAge() == 0 ? 0 : random.nextInt(getMaxGrowthAge())); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     @Override
     protected boolean isRandomlyTicking(BlockState state) {
-        return state.getValue(AGE) < 25;
+        return state.getValue(AGE) < getMaxGrowthAge(); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     @Override
@@ -55,7 +55,7 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
         } else if (this == Blocks.CAVE_VINES) {
             modifier = level.spigotConfig.caveVinesModifier;
         }
-        if (state.getValue(AGE) < 25 && random.nextDouble() < ((modifier / 100.0D) * this.growPerTickProbability)) { // Spigot - SPIGOT-7159: Better modifier resolution
+        if (state.getValue(AGE) < getMaxGrowthAge() && random.nextDouble() < ((modifier / 100.0D) * this.growPerTickProbability)) { // Spigot - SPIGOT-7159: Better modifier resolution // Purpur - kelp, cave, weeping, and twisting configurable max growth age
             // Spigot end
             BlockPos blockPos = pos.relative(this.growthDirection);
             if (this.canGrowInto(level.getBlockState(blockPos))) {
@@ -75,11 +75,11 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
     }
 
     public BlockState getMaxAgeState(BlockState state) {
-        return state.setValue(AGE, 25);
+        return state.setValue(AGE, getMaxGrowthAge()); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     public boolean isMaxAge(BlockState state) {
-        return state.getValue(AGE) == 25;
+        return state.getValue(AGE) >= getMaxGrowthAge(); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     protected BlockState updateBodyAfterConvertedFromHead(BlockState head, BlockState body) {
@@ -137,13 +137,13 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
     @Override
     public void performBonemeal(ServerLevel level, RandomSource random, BlockPos pos, BlockState state) {
         BlockPos blockPos = pos.relative(this.growthDirection);
-        int min = Math.min(state.getValue(AGE) + 1, 25);
+        int min = Math.min(state.getValue(AGE) + 1, getMaxGrowthAge()); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
         int blocksToGrowWhenBonemealed = this.getBlocksToGrowWhenBonemealed(random);
 
         for (int i = 0; i < blocksToGrowWhenBonemealed && this.canGrowInto(level.getBlockState(blockPos)); i++) {
             level.setBlockAndUpdate(blockPos, state.setValue(AGE, min));
             blockPos = blockPos.relative(this.growthDirection);
-            min = Math.min(min + 1, 25);
+            min = Math.min(min + 1, getMaxGrowthAge()); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
         }
     }
 
@@ -155,4 +155,6 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
     protected GrowingPlantHeadBlock getHeadBlock() {
         return this;
     }
+
+    public abstract int getMaxGrowthAge(); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/HayBlock.java b/net/minecraft/world/level/block/HayBlock.java
index cdde0a25e0a499d7575c00796143a033feb1f22f..999ecf16180b0a862cf8527ce532acf725ba869a 100644
--- a/net/minecraft/world/level/block/HayBlock.java
+++ b/net/minecraft/world/level/block/HayBlock.java
@@ -23,6 +23,6 @@ public class HayBlock extends RotatedPillarBlock {
 
     @Override
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
-        entity.causeFallDamage(fallDistance, 0.2F, level.damageSources().fall());
+        super.fallOn(level, state, pos, entity, fallDistance); // Purpur - Configurable block fall damage modifiers
     }
 }
diff --git a/net/minecraft/world/level/block/IceBlock.java b/net/minecraft/world/level/block/IceBlock.java
index f29af8c07b80192bf8518ea6b356a52cda94b0f1..759671ad9bab4a00dcf0e970579c2be5c957e2ab 100644
--- a/net/minecraft/world/level/block/IceBlock.java
+++ b/net/minecraft/world/level/block/IceBlock.java
@@ -41,7 +41,7 @@ public class IceBlock extends HalfTransparentBlock {
     public void afterDestroy(Level level, BlockPos pos, ItemStack stack) {
         // Paper end - Improve Block#breakNaturally API
         if (!EnchantmentHelper.hasTag(stack, EnchantmentTags.PREVENTS_ICE_MELTING)) {
-            if (level.environmentAttributes().getValue(EnvironmentAttributes.WATER_EVAPORATES, pos)) {
+            if ((level.isTheEnd() && !org.purpurmc.purpur.PurpurConfig.allowWaterPlacementInTheEnd) || level.environmentAttributes().getValue(EnvironmentAttributes.WATER_EVAPORATES, pos)) { // Purpur - Add allow water in end world option
                 level.removeBlock(pos, false);
                 return;
             }
@@ -62,7 +62,7 @@ public class IceBlock extends HalfTransparentBlock {
 
     protected void melt(BlockState state, Level level, BlockPos pos) {
         // Paper start - call BlockFadeEvent
-        final boolean waterEvaporates = level.environmentAttributes().getValue(EnvironmentAttributes.WATER_EVAPORATES, pos);
+        final boolean waterEvaporates = (level.isTheEnd() && !org.purpurmc.purpur.PurpurConfig.allowWaterPlacementInTheEnd) || level.environmentAttributes().getValue(EnvironmentAttributes.WATER_EVAPORATES, pos); // Purpur - Add allow water in end
         if (org.bukkit.craftbukkit.event.CraftEventFactory.callBlockFadeEvent(level, pos, waterEvaporates ? Blocks.AIR.defaultBlockState() : Blocks.WATER.defaultBlockState()).isCancelled()) {
             return;
         }
diff --git a/net/minecraft/world/level/block/KelpBlock.java b/net/minecraft/world/level/block/KelpBlock.java
index bf040f13b9c76056ec8cbfe9e9c2481d68c9c772..0c9238df402d493f58066735406ee174bffad5b1 100644
--- a/net/minecraft/world/level/block/KelpBlock.java
+++ b/net/minecraft/world/level/block/KelpBlock.java
@@ -71,4 +71,11 @@ public class KelpBlock extends GrowingPlantHeadBlock implements LiquidBlockConta
     protected FluidState getFluidState(BlockState state) {
         return Fluids.WATER.getSource(false);
     }
+
+    // Purpur start - kelp vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.kelpMaxGrowthAge;
+    }
+    // Purpur end - kelp vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/LiquidBlock.java b/net/minecraft/world/level/block/LiquidBlock.java
index 1f62dcf2709d430e996790750a691b12938eb09a..77d1ecfd0f866f3fa5cd8fdf88eb4c147ba07d81 100644
--- a/net/minecraft/world/level/block/LiquidBlock.java
+++ b/net/minecraft/world/level/block/LiquidBlock.java
@@ -138,7 +138,7 @@ public class LiquidBlock extends Block implements BucketPickup {
 
     @Override
     protected void onPlace(BlockState state, Level level, BlockPos pos, BlockState oldState, boolean movedByPiston) {
-        if (this.shouldSpreadLiquid(level, pos, state)) {
+        if (level.purpurConfig.tickFluids && this.shouldSpreadLiquid(level, pos, state)) { // Purpur - Tick fluids config
             level.scheduleTick(pos, state.getFluidState().getType(), this.getFlowSpeed(level, pos)); // Paper - Configurable speed for water flowing over lava
         }
     }
@@ -175,7 +175,7 @@ public class LiquidBlock extends Block implements BucketPickup {
         BlockState neighborState,
         RandomSource random
     ) {
-        if (state.getFluidState().isSource() || neighborState.getFluidState().isSource()) {
+        if ((level.getWorldBorder().world == null || level.getWorldBorder().world.purpurConfig.tickFluids) && state.getFluidState().isSource() || neighborState.getFluidState().isSource()) { // Purpur - Tick fluids config
             scheduledTickAccess.scheduleTick(pos, state.getFluidState().getType(), this.fluid.getTickDelay(level));
         }
 
@@ -184,7 +184,7 @@ public class LiquidBlock extends Block implements BucketPickup {
 
     @Override
     protected void neighborChanged(BlockState state, Level level, BlockPos pos, Block neighborBlock, @Nullable Orientation orientation, boolean movedByPiston) {
-        if (this.shouldSpreadLiquid(level, pos, state)) {
+        if (level.purpurConfig.tickFluids && this.shouldSpreadLiquid(level, pos, state)) { // Purpur - Tick fluids config
             level.scheduleTick(pos, state.getFluidState().getType(), this.getFlowSpeed(level, pos)); // Paper - Configurable speed for water flowing over lava
         }
     }
diff --git a/net/minecraft/world/level/block/MagmaBlock.java b/net/minecraft/world/level/block/MagmaBlock.java
index 71344cb2580fb9a3cd523e25fb1a245711e275dd..bec06566342663479ee8342b7e5ceec61758c448 100644
--- a/net/minecraft/world/level/block/MagmaBlock.java
+++ b/net/minecraft/world/level/block/MagmaBlock.java
@@ -28,7 +28,7 @@ public class MagmaBlock extends Block {
 
     @Override
     public void stepOn(Level level, BlockPos pos, BlockState state, Entity entity) {
-        if (!entity.isSteppingCarefully() && entity instanceof LivingEntity) {
+        if ((!entity.isSteppingCarefully() || level.purpurConfig.magmaBlockDamageWhenSneaking) && entity instanceof LivingEntity) { // Purpur - Configurable damage settings for magma blocks
             entity.hurt(level.damageSources().hotFloor().eventBlockDamager(level, pos), 1.0F); // CraftBukkit
         }
 
diff --git a/net/minecraft/world/level/block/NetherPortalBlock.java b/net/minecraft/world/level/block/NetherPortalBlock.java
index 653b72855197733b33e310b0ccd4fbf04e22e95f..860e0c3ab118d8c6863936b9c2603bf6a278ca99 100644
--- a/net/minecraft/world/level/block/NetherPortalBlock.java
+++ b/net/minecraft/world/level/block/NetherPortalBlock.java
@@ -68,7 +68,7 @@ public class NetherPortalBlock extends Block implements Portal {
     protected void randomTick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
         if (level.spigotConfig.enableZombiePigmenPortalSpawns && level.isSpawningMonsters() // Spigot
             && level.environmentAttributes().getValue(EnvironmentAttributes.NETHER_PORTAL_SPAWNS_PIGLINS, pos)
-            && random.nextInt(2000) < level.getDifficulty().getId()
+            && random.nextInt(level.purpurConfig.piglinPortalSpawnModifier) < level.getDifficulty().getId() // Purpur - Piglin portal spawn modifier
             && level.anyPlayerCloseEnoughForSpawning(pos)) {
             while (level.getBlockState(pos).is(this)) {
                 pos = pos.below();
@@ -126,7 +126,7 @@ public class NetherPortalBlock extends Block implements Portal {
     @Override
     public int getPortalTransitionTime(ServerLevel level, Entity entity) {
         return entity instanceof Player player
-            ? Math.max(
+            ? player.canPortalInstant ? 1 : Math.max( // Purpur - Add portal permission bypass
                 0,
                 level.getGameRules()
                     .get(player.getAbilities().invulnerable ? GameRules.PLAYERS_NETHER_PORTAL_CREATIVE_DELAY : GameRules.PLAYERS_NETHER_PORTAL_DEFAULT_DELAY)
diff --git a/net/minecraft/world/level/block/NetherWartBlock.java b/net/minecraft/world/level/block/NetherWartBlock.java
index 40f90b2822cc1e6ddb759f38098e7dc49b53b8b8..5676fc8ff8ec4edb4d83c5a0e6529af3b5a18dc6 100644
--- a/net/minecraft/world/level/block/NetherWartBlock.java
+++ b/net/minecraft/world/level/block/NetherWartBlock.java
@@ -16,7 +16,7 @@ import net.minecraft.world.level.block.state.properties.IntegerProperty;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
-public class NetherWartBlock extends VegetationBlock {
+public class NetherWartBlock extends VegetationBlock implements BonemealableBlock { // Purpur - bonemealable netherwart
     public static final MapCodec<NetherWartBlock> CODEC = simpleCodec(NetherWartBlock::new);
     public static final int MAX_AGE = 3;
     public static final IntegerProperty AGE = BlockStateProperties.AGE_3;
@@ -65,4 +65,34 @@ public class NetherWartBlock extends VegetationBlock {
     protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
         builder.add(AGE);
     }
+
+    // Purpur start - Ability for hoe to replant nether warts
+    @Override
+    public void playerDestroy(net.minecraft.world.level.Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @javax.annotation.Nullable net.minecraft.world.level.block.entity.BlockEntity blockEntity, ItemStack itemInHand, boolean includeDrops, boolean dropExp) {
+        if (world.purpurConfig.hoeReplantsNetherWarts && itemInHand.getItem() instanceof net.minecraft.world.item.HoeItem) {
+            super.playerDestroyAndReplant(world, player, pos, state, blockEntity, itemInHand, Items.NETHER_WART);
+        } else {
+            super.playerDestroy(world, player, pos, state, blockEntity, itemInHand, includeDrops, dropExp);
+        }
+    }
+    // Purpur end - Ability for hoe to replant nether warts
+
+    // Purpur start - bonemealable netherwart
+    @Override
+    public boolean isValidBonemealTarget(final net.minecraft.world.level.LevelReader world, final BlockPos pos, final BlockState state) {
+        return ((net.minecraft.world.level.Level) world).purpurConfig.netherWartAffectedByBonemeal && state.getValue(NetherWartBlock.AGE) < 3;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(net.minecraft.world.level.Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        int i = Math.min(3, state.getValue(NetherWartBlock.AGE) + 1);
+        state = state.setValue(NetherWartBlock.AGE, i);
+        org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(world, pos, state, 2); // CraftBukkit
+    }
+    // Purpur end - bonemealable netherwart
 }
diff --git a/net/minecraft/world/level/block/NoteBlock.java b/net/minecraft/world/level/block/NoteBlock.java
index 1335e4e9953444417325bbfd9655d5b9bb004ff8..95d608ae93f0a5881cb4b789f6463268e09843b4 100644
--- a/net/minecraft/world/level/block/NoteBlock.java
+++ b/net/minecraft/world/level/block/NoteBlock.java
@@ -101,7 +101,7 @@ public class NoteBlock extends Block {
     }
 
     private void playNote(@Nullable Entity entity, BlockState state, Level level, BlockPos pos) {
-        if (state.getValue(INSTRUMENT).worksAboveNoteBlock() || level.getBlockState(pos.above()).isAir()) {
+        if (level.purpurConfig.noteBlockIgnoreAbove || state.getValue(INSTRUMENT).worksAboveNoteBlock() || level.getBlockState(pos.above()).isAir()) { // Purpur - Config to allow Note Block sounds when blocked
             level.blockEvent(pos, this, 0, 0);
             level.gameEvent(entity, GameEvent.NOTE_BLOCK_PLAY, pos);
         }
diff --git a/net/minecraft/world/level/block/ObserverBlock.java b/net/minecraft/world/level/block/ObserverBlock.java
index 3c12d8e23f20b666b0005e597ba2e803c02d5d78..df0a900c249f0fd778287d055a5ad92787c7ceb5 100644
--- a/net/minecraft/world/level/block/ObserverBlock.java
+++ b/net/minecraft/world/level/block/ObserverBlock.java
@@ -81,6 +81,7 @@ public class ObserverBlock extends DirectionalBlock {
         RandomSource random
     ) {
         if (state.getValue(FACING) == direction && !state.getValue(POWERED)) {
+            if (!(level.getWorldBorder().world != null && level.getWorldBorder().world.purpurConfig.disableObserverClocks) || !(neighborState.getBlock() instanceof ObserverBlock) || neighborState.getValue(ObserverBlock.FACING).getOpposite() != direction) // Purpur - Add Option for disable observer clocks
             this.startSignal(level, scheduledTickAccess, pos);
         }
 
diff --git a/net/minecraft/world/level/block/PointedDripstoneBlock.java b/net/minecraft/world/level/block/PointedDripstoneBlock.java
index 1510827a9d402d78cf5a6ba0a973bb7b88668aac..e9ec6c5f2dd4e0b2e2bd8f5c3e40ddc7af22fdb8 100644
--- a/net/minecraft/world/level/block/PointedDripstoneBlock.java
+++ b/net/minecraft/world/level/block/PointedDripstoneBlock.java
@@ -194,20 +194,20 @@ public class PointedDripstoneBlock extends Block implements Fallable, SimpleWate
 
     @VisibleForTesting
     public static void maybeTransferFluid(BlockState state, ServerLevel level, BlockPos pos, float randChance) {
-        if (!(randChance > 0.17578125F) || !(randChance > 0.05859375F)) {
+        if (!(randChance > level.purpurConfig.cauldronDripstoneWaterFillChance) || !(randChance > level.purpurConfig.cauldronDripstoneLavaFillChance)) { // Purpur - Cauldron fill chances
             if (isStalactiteStartPos(state, level, pos)) {
                 Optional<PointedDripstoneBlock.FluidInfo> fluidAboveStalactite = getFluidAboveStalactite(level, pos, state);
                 if (!fluidAboveStalactite.isEmpty()) {
                     Fluid fluid = fluidAboveStalactite.get().fluid;
                     float f;
                     if (fluid == Fluids.WATER) {
-                        f = 0.17578125F;
+                        f = level.purpurConfig.cauldronDripstoneWaterFillChance; // Purpur - Cauldron fill chances
                     } else {
                         if (fluid != Fluids.LAVA) {
                             return;
                         }
 
-                        f = 0.05859375F;
+                        f = level.purpurConfig.cauldronDripstoneLavaFillChance; // Purpur - Cauldron fill chances
                     }
 
                     if (!(randChance >= f)) {
diff --git a/net/minecraft/world/level/block/PowderSnowBlock.java b/net/minecraft/world/level/block/PowderSnowBlock.java
index f3a9117bd066861a1b447e8a13108ad212cc499f..b0165c839b145e82af38fe8f61bbd0161015d867 100644
--- a/net/minecraft/world/level/block/PowderSnowBlock.java
+++ b/net/minecraft/world/level/block/PowderSnowBlock.java
@@ -96,7 +96,7 @@ public class PowderSnowBlock extends Block implements BucketPickup {
                         // CraftBukkit - move down
                     && entity1.mayInteract(serverLevel, blockPos)) {
                     // CraftBukkit start
-                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity1, pos, Blocks.AIR.defaultBlockState(), !(serverLevel.getGameRules().get(GameRules.MOB_GRIEFING) || entity1 instanceof Player))) {
+                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity1, pos, Blocks.AIR.defaultBlockState(), !(serverLevel.getGameRules().get(GameRules.MOB_GRIEFING, serverLevel.purpurConfig.powderSnowMobGriefingOverride) || entity1 instanceof Player))) { // Purpur - Add mobGriefing override to everything affected
                         return;
                     }
                     // CraftBukkit end
diff --git a/net/minecraft/world/level/block/PoweredRailBlock.java b/net/minecraft/world/level/block/PoweredRailBlock.java
index 7d3997a59193f727ce750f6efe6e5d7ed35a2f3f..0a683715c52431fd8bb07b3647136a036f265435 100644
--- a/net/minecraft/world/level/block/PoweredRailBlock.java
+++ b/net/minecraft/world/level/block/PoweredRailBlock.java
@@ -28,7 +28,7 @@ public class PoweredRailBlock extends BaseRailBlock {
     }
 
     public boolean findPoweredRailSignal(Level level, BlockPos pos, BlockState state, boolean searchForward, int recursionCount) {
-        if (recursionCount >= 8) {
+        if (recursionCount >= level.purpurConfig.railActivationRange) { // Purpur - Config for powered rail activation distance
             return false;
         } else {
             int x = pos.getX();
diff --git a/net/minecraft/world/level/block/RespawnAnchorBlock.java b/net/minecraft/world/level/block/RespawnAnchorBlock.java
index e90651ae6ab072c9fa9c179ae56329e0d816c77b..2b96781a2aaaef3837e617fa982c0d35862d4f39 100644
--- a/net/minecraft/world/level/block/RespawnAnchorBlock.java
+++ b/net/minecraft/world/level/block/RespawnAnchorBlock.java
@@ -166,7 +166,7 @@ public class RespawnAnchorBlock extends Block {
         };
         Vec3 center = pos2.getCenter();
         level.explode(
-            null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), explosionDamageCalculator, center, 5.0F, true, Level.ExplosionInteraction.BLOCK // CraftBukkit - add state
+            null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), explosionDamageCalculator, center, (float) level.purpurConfig.respawnAnchorExplosionPower, level.purpurConfig.respawnAnchorExplosionFire, level.purpurConfig.respawnAnchorExplosionEffect // CraftBukkit - add state // Purpur - Implement respawn anchor explosion options
         );
     }
 
diff --git a/net/minecraft/world/level/block/SculkShriekerBlock.java b/net/minecraft/world/level/block/SculkShriekerBlock.java
index 2815fb48530de3a2f9ef0f472a0fd0a2c32140b6..39f5d04a2795d5e62a961c9fa5a23b79d9d81fa2 100644
--- a/net/minecraft/world/level/block/SculkShriekerBlock.java
+++ b/net/minecraft/world/level/block/SculkShriekerBlock.java
@@ -116,7 +116,7 @@ public class SculkShriekerBlock extends BaseEntityBlock implements SimpleWaterlo
 
     @Override
     public @Nullable BlockState getStateForPlacement(BlockPlaceContext context) {
-        return this.defaultBlockState().setValue(WATERLOGGED, context.getLevel().getFluidState(context.getClickedPos()).getType() == Fluids.WATER);
+        return this.defaultBlockState().setValue(WATERLOGGED, context.getLevel().getFluidState(context.getClickedPos()).getType() == Fluids.WATER).setValue(SculkShriekerBlock.CAN_SUMMON, context.getLevel().purpurConfig.sculkShriekerCanSummonDefault); // Purpur - Config for sculk shrieker can_summon state
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/SlabBlock.java b/net/minecraft/world/level/block/SlabBlock.java
index 6d7b63e9afd60ef7cf5332077b13941914a32109..20a7a75c5fb9171c0f8d91b09a2d2865b196ce97 100644
--- a/net/minecraft/world/level/block/SlabBlock.java
+++ b/net/minecraft/world/level/block/SlabBlock.java
@@ -143,4 +143,25 @@ public class SlabBlock extends Block implements SimpleWaterloggedBlock {
                 return false;
         }
     }
+
+    // Purpur start - Break individual slabs when sneaking
+    public boolean halfBreak(BlockState state, BlockPos pos, net.minecraft.server.level.ServerPlayer player) {
+        if (state.getValue(SlabBlock.TYPE) != SlabType.DOUBLE) {
+            return false;
+        }
+        net.minecraft.world.phys.HitResult result = player.getRayTrace(16, net.minecraft.world.level.ClipContext.Fluid.NONE);
+        if (result.getType() != net.minecraft.world.phys.HitResult.Type.BLOCK) {
+            return false;
+        }
+        double hitY = result.getLocation().y();
+        int blockY = org.bukkit.util.NumberConversions.floor(hitY);
+        player.level().setBlock(pos, state.setValue(SlabBlock.TYPE, (hitY - blockY > 0.5 || blockY - pos.getY() == 1) ? SlabType.BOTTOM : SlabType.TOP), 3);
+        if (!player.getAbilities().instabuild) {
+            net.minecraft.world.entity.item.ItemEntity item = new net.minecraft.world.entity.item.ItemEntity(player.level(), pos.getX(), pos.getY(), pos.getZ(), new ItemStack(asItem()));
+            item.setDefaultPickUpDelay();
+            player.level().addFreshEntity(item);
+        }
+        return true;
+    }
+    // Purpur end - Break individual slabs when sneaking
 }
diff --git a/net/minecraft/world/level/block/SnowLayerBlock.java b/net/minecraft/world/level/block/SnowLayerBlock.java
index de7e600ca1348b61990aaf4ffdd91c6c3ec13cf6..9967feffac868e824edf6be1b008fcd3530f3058 100644
--- a/net/minecraft/world/level/block/SnowLayerBlock.java
+++ b/net/minecraft/world/level/block/SnowLayerBlock.java
@@ -76,6 +76,7 @@ public class SnowLayerBlock extends Block {
     @Override
     protected boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
         BlockState blockState = level.getBlockState(pos.below());
+        if (blockState.is(Blocks.BLUE_ICE) && !(level.getWorldBorder().world == null || level.getWorldBorder().world.purpurConfig.snowOnBlueIce)) return false; // Purpur - Add config for snow on blue ice
         return !blockState.is(BlockTags.SNOW_LAYER_CANNOT_SURVIVE_ON)
             && (
                 blockState.is(BlockTags.SNOW_LAYER_CAN_SURVIVE_ON)
diff --git a/net/minecraft/world/level/block/SpawnerBlock.java b/net/minecraft/world/level/block/SpawnerBlock.java
index 119ed91439909d44d36c3a9822d2b11525a22f00..fbcb5183d188bc1caa74ebbbb475d15a6d19dc61 100644
--- a/net/minecraft/world/level/block/SpawnerBlock.java
+++ b/net/minecraft/world/level/block/SpawnerBlock.java
@@ -14,6 +14,7 @@ import net.minecraft.world.level.block.state.BlockState;
 import org.jspecify.annotations.Nullable;
 
 public class SpawnerBlock extends BaseEntityBlock {
+    private static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getLogger();
     public static final MapCodec<SpawnerBlock> CODEC = simpleCodec(SpawnerBlock::new);
 
     @Override
@@ -37,6 +38,62 @@ public class SpawnerBlock extends BaseEntityBlock {
         );
     }
 
+    // Purpur start - Silk touch spawners
+    @Override
+    public void playerDestroy(Level level, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @Nullable BlockEntity blockEntity, ItemStack stack, boolean includeDrops, boolean dropExp) {
+        if (level.purpurConfig.silkTouchEnabled && player.getBukkitEntity().hasPermission("purpur.drop.spawners") && isSilkTouch(level, stack)) {
+            ItemStack item = new ItemStack(Blocks.SPAWNER.asItem());
+
+            net.minecraft.world.level.SpawnData nextSpawnData = blockEntity instanceof SpawnerBlockEntity spawnerBlock ? spawnerBlock.getSpawner().nextSpawnData : null;
+            java.util.Optional<net.minecraft.world.entity.EntityType<?>> type = java.util.Optional.empty();
+            if (nextSpawnData != null) {
+                try (net.minecraft.util.ProblemReporter.ScopedCollector scopedCollector = new net.minecraft.util.ProblemReporter.ScopedCollector(blockEntity.problemPath(), LOGGER)) {
+                    net.minecraft.world.level.storage.ValueInput valueInput = net.minecraft.world.level.storage.TagValueInput.create(scopedCollector, player.level().registryAccess(), nextSpawnData.entityToSpawn());
+                    type = net.minecraft.world.entity.EntityType.by(valueInput);
+                }
+                net.minecraft.nbt.CompoundTag spawnDataTag = new net.minecraft.nbt.CompoundTag();
+                spawnDataTag.storeNullable("SpawnData", net.minecraft.world.level.SpawnData.CODEC, nextSpawnData);
+                item.set(net.minecraft.core.component.DataComponents.CUSTOM_DATA, net.minecraft.world.item.component.CustomData.EMPTY.update(compoundTag -> compoundTag.put("Purpur.SpawnData", spawnDataTag)));
+            }
+
+            if (type.isPresent()) {
+                final net.kyori.adventure.text.Component mobName = io.papermc.paper.adventure.PaperAdventure.asAdventure(type.get().getDescription());
+
+                String name = level.purpurConfig.silkTouchSpawnerName;
+                if (name != null && !name.isEmpty() && !name.equals("Monster Spawner")) {
+                    net.kyori.adventure.text.Component displayName = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(name, net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.component("mob", mobName));
+                    if (name.startsWith("<reset>")) {
+                        displayName = displayName.decoration(net.kyori.adventure.text.format.TextDecoration.ITALIC, false);
+                    }
+                    item.set(net.minecraft.core.component.DataComponents.CUSTOM_NAME, io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName));
+                }
+
+                java.util.List<String> lore = level.purpurConfig.silkTouchSpawnerLore;
+                if (lore != null && !lore.isEmpty()) {
+
+                    java.util.List<net.minecraft.network.chat.Component> loreComponentList = new java.util.ArrayList<>();
+                    for (String line : lore) {
+                        net.kyori.adventure.text.Component lineComponent = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(line, net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.component("mob", mobName));
+                        if (line.startsWith("<reset>")) {
+                            lineComponent = lineComponent.decoration(net.kyori.adventure.text.format.TextDecoration.ITALIC, false);
+                        }
+                        loreComponentList.add(io.papermc.paper.adventure.PaperAdventure.asVanilla(lineComponent));
+                    }
+
+                    item.set(net.minecraft.core.component.DataComponents.LORE, new net.minecraft.world.item.component.ItemLore(loreComponentList, loreComponentList));
+                }
+                item.set(net.minecraft.core.component.DataComponents.TOOLTIP_DISPLAY, net.minecraft.world.item.component.TooltipDisplay.DEFAULT.withHidden(net.minecraft.core.component.DataComponents.BLOCK_ENTITY_DATA, true));
+            }
+            popResource(level, pos, item);
+        }
+        super.playerDestroy(level, player, pos, state, blockEntity, stack, includeDrops, dropExp);
+    }
+
+    private boolean isSilkTouch(Level level, ItemStack stack) {
+        return stack != null && level.purpurConfig.silkTouchTools.contains(stack.getItem()) && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.SILK_TOUCH, stack) >= level.purpurConfig.minimumSilkTouchSpawnerRequire;
+    }
+    // Purpur end - Silk touch spawners
+
     @Override
     protected void spawnAfterBreak(BlockState state, ServerLevel level, BlockPos pos, ItemStack stack, boolean dropExperience) {
         super.spawnAfterBreak(state, level, pos, stack, dropExperience);
@@ -45,6 +102,7 @@ public class SpawnerBlock extends BaseEntityBlock {
 
     @Override
     public int getExpDrop(BlockState state, ServerLevel level, BlockPos pos, ItemStack stack, boolean dropExperience) {
+        if (level.purpurConfig.silkTouchEnabled && isSilkTouch(level, stack)) return 0; // Purpur - Silk touch spawners
         if (dropExperience) {
             int i = 15 + level.random.nextInt(15) + level.random.nextInt(15);
             // this.popExperience(level, pos, i);
diff --git a/net/minecraft/world/level/block/SpongeBlock.java b/net/minecraft/world/level/block/SpongeBlock.java
index 298e51da2da64fdaa860108cc34e59d214b5f9a7..0ce317ad5f3f7a08914d04ace2259f7fdb6f906e 100644
--- a/net/minecraft/world/level/block/SpongeBlock.java
+++ b/net/minecraft/world/level/block/SpongeBlock.java
@@ -53,8 +53,8 @@ public class SpongeBlock extends Block {
         org.bukkit.craftbukkit.util.BlockStateListPopulator blockList = new org.bukkit.craftbukkit.util.BlockStateListPopulator(level); // CraftBukkit - Use BlockStateListPopulator
         BlockPos.breadthFirstTraversal(
                 pos,
-                6,
-                65,
+                level.purpurConfig.spongeAbsorptionRadius, // Purpur - Configurable sponge absorption
+                level.purpurConfig.spongeAbsorptionArea, // Purpur - Configurable sponge absorption
                 (validPos, queueAdder) -> {
                     for (Direction direction : ALL_DIRECTIONS) {
                         queueAdder.accept(validPos.relative(direction));
@@ -68,7 +68,7 @@ public class SpongeBlock extends Block {
                         BlockState blockState = blockList.getBlockState(blockPos);
                         FluidState fluidState = blockList.getFluidState(blockPos);
                         // CraftBukkit end
-                        if (!fluidState.is(FluidTags.WATER)) {
+                        if (!fluidState.is(FluidTags.WATER) && (!level.purpurConfig.spongeAbsorbsLava || !fluidState.is(FluidTags.LAVA)) && (!level.purpurConfig.spongeAbsorbsWaterFromMud || !blockState.is(Blocks.MUD))) { // Purpur - Option for sponges to work on lava and mud
                             return BlockPos.TraversalNodeStatus.SKIP;
                         } else if (blockState.getBlock() instanceof BucketPickup bucketPickup
                             && !bucketPickup.pickupBlock(null, blockList, blockPos, blockState).isEmpty()) { // CraftBukkit
@@ -76,6 +76,10 @@ public class SpongeBlock extends Block {
                         } else {
                             if (blockState.getBlock() instanceof LiquidBlock) {
                                 blockList.setBlock(blockPos, Blocks.AIR.defaultBlockState(), Block.UPDATE_ALL); // CraftBukkit
+                            // Purpur start - Option for sponges to work on lava and mud
+                            } else if (blockState.is(Blocks.MUD)) {
+                                blockList.setBlock(blockPos, Blocks.CLAY.defaultBlockState(), Block.UPDATE_ALL);
+                            // Purpur end - Option for sponges to work on lava and mud
                             } else {
                                 if (!blockState.is(Blocks.KELP)
                                     && !blockState.is(Blocks.KELP_PLANT)
diff --git a/net/minecraft/world/level/block/StonecutterBlock.java b/net/minecraft/world/level/block/StonecutterBlock.java
index 19657ae67244224bc77b0a2620c097afa97dddf6..6ab51fcf42b9ca7ab46ea66498eea14250fc7444 100644
--- a/net/minecraft/world/level/block/StonecutterBlock.java
+++ b/net/minecraft/world/level/block/StonecutterBlock.java
@@ -92,4 +92,14 @@ public class StonecutterBlock extends Block {
     protected boolean isPathfindable(BlockState state, PathComputationType pathComputationType) {
         return false;
     }
+
+    // Purpur start - Stonecutter damage
+    @Override
+    public void stepOn(Level level, BlockPos pos, BlockState state, net.minecraft.world.entity.Entity entity) {
+        if (level.purpurConfig.stonecutterDamage > 0.0F && entity instanceof net.minecraft.world.entity.LivingEntity) {
+            entity.hurtServer((net.minecraft.server.level.ServerLevel) level, entity.damageSources().stonecutter().eventBlockDamager(level, pos), level.purpurConfig.stonecutterDamage);
+        }
+        super.stepOn(level, pos, state, entity);
+    }
+    // Purpur end - Stonecutter damage
 }
diff --git a/net/minecraft/world/level/block/SugarCaneBlock.java b/net/minecraft/world/level/block/SugarCaneBlock.java
index 4437fd5724e094e8d2edb97ca9bf494ef57f5b79..9e5cf7766848540a5ae2c38522e865a0b4601d00 100644
--- a/net/minecraft/world/level/block/SugarCaneBlock.java
+++ b/net/minecraft/world/level/block/SugarCaneBlock.java
@@ -19,7 +19,7 @@ import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
-public class SugarCaneBlock extends Block {
+public class SugarCaneBlock extends Block implements BonemealableBlock { // Purpur - bonemealable sugarcane
     public static final MapCodec<SugarCaneBlock> CODEC = simpleCodec(SugarCaneBlock::new);
     public static final IntegerProperty AGE = BlockStateProperties.AGE_15;
     private static final VoxelShape SHAPE = Block.column(12.0, 0.0, 16.0);
@@ -112,4 +112,34 @@ public class SugarCaneBlock extends Block {
     protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
         builder.add(AGE);
     }
+
+    // Purpur start - bonemealable sugarcane
+    @Override
+    public boolean isValidBonemealTarget(final LevelReader world, final BlockPos pos, final BlockState state) {
+        if (!((net.minecraft.world.level.Level) world).purpurConfig.sugarCanAffectedByBonemeal || !world.isEmptyBlock(pos.above())) return false;
+
+        int reedHeight = 0;
+        while (world.getBlockState(pos.below(reedHeight)).is(this)) {
+            reedHeight++;
+        }
+
+        return reedHeight < ((net.minecraft.world.level.Level) world).paperConfig().maxGrowthHeight.reeds;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(net.minecraft.world.level.Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        int reedHeight = 0;
+        while (world.getBlockState(pos.below(reedHeight)).is(this)) {
+            reedHeight++;
+        }
+        for (int i = 0; i <= world.paperConfig().maxGrowthHeight.reeds - reedHeight; i++) {
+            world.setBlockAndUpdate(pos.above(i), state.setValue(SugarCaneBlock.AGE, 0));
+        }
+    }
+    // Purpur end - bonemealable sugarcane
 }
diff --git a/net/minecraft/world/level/block/TurtleEggBlock.java b/net/minecraft/world/level/block/TurtleEggBlock.java
index 732f244b0265477434b26a47ddedab10f49b06a3..733c6ed0ce655d9ff9e03fc1a87131aa8e72eca0 100644
--- a/net/minecraft/world/level/block/TurtleEggBlock.java
+++ b/net/minecraft/world/level/block/TurtleEggBlock.java
@@ -156,7 +156,7 @@ public class TurtleEggBlock extends Block {
     }
 
     private boolean shouldUpdateHatchLevel(Level level, BlockPos pos) {
-        float value = level.environmentAttributes().getValue(EnvironmentAttributes.TURTLE_EGG_HATCH_CHANCE, pos);
+        float value = level.purpurConfig.turtleEggsRandomTickCrackChance == 500 ? level.environmentAttributes().getValue(EnvironmentAttributes.TURTLE_EGG_HATCH_CHANCE, pos) : level.purpurConfig.turtleEggsRandomTickCrackChance; // Purpur - Turtle eggs random tick crack chance
         return value > 0.0F && level.random.nextFloat() < value;
     }
 
@@ -189,9 +189,32 @@ public class TurtleEggBlock extends Block {
     }
 
     private boolean canDestroyEgg(ServerLevel level, Entity entity) {
-        return !(entity instanceof Turtle)
-            && !(entity instanceof Bat)
-            && entity instanceof LivingEntity
-            && (entity instanceof Player || level.getGameRules().get(GameRules.MOB_GRIEFING));
+        // Purpur start - Add turtle egg block options
+        if (entity instanceof Turtle || entity instanceof Bat) {
+            return false;
+        }
+        if (level.purpurConfig.turtleEggsBreakFromExpOrbs && entity instanceof net.minecraft.world.entity.ExperienceOrb) {
+            return true;
+        }
+        if (level.purpurConfig.turtleEggsBreakFromItems && entity instanceof net.minecraft.world.entity.item.ItemEntity) {
+            return true;
+        }
+        if (level.purpurConfig.turtleEggsBreakFromMinecarts && entity instanceof net.minecraft.world.entity.vehicle.minecart.AbstractMinecart) {
+            return true;
+        }
+        if (!(entity instanceof LivingEntity)) {
+            return false;
+        }
+        // Purpur start - Option to disable turtle egg trampling with feather falling
+        if (level.purpurConfig.turtleEggsTramplingFeatherFalling) {
+            net.minecraft.world.item.ItemStack bootsItem = ((net.minecraft.world.entity.LivingEntity) entity).getItemBySlot(net.minecraft.world.entity.EquipmentSlot.FEET);
+
+            return bootsItem != net.minecraft.world.item.ItemStack.EMPTY || net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.FEATHER_FALLING, bootsItem) < (int) entity.fallDistance;
+        }
+        // Purpur end - Option to disable turtle egg trampling with feather falling
+        if (entity instanceof Player) return true;
+
+        return level.getGameRules().get(GameRules.MOB_GRIEFING, level.purpurConfig.turtleEggsMobGriefingOverride); // Purpur - Add mobGriefing override to everything affected
+        // Purpur end - Add turtle egg block options
     }
 }
diff --git a/net/minecraft/world/level/block/TwistingVinesBlock.java b/net/minecraft/world/level/block/TwistingVinesBlock.java
index afb77747ea6966c435aca4b667bfbbc909f52232..361aaca76ae0375782310af0e03241625f08f7bd 100644
--- a/net/minecraft/world/level/block/TwistingVinesBlock.java
+++ b/net/minecraft/world/level/block/TwistingVinesBlock.java
@@ -34,4 +34,11 @@ public class TwistingVinesBlock extends GrowingPlantHeadBlock {
     protected boolean canGrowInto(BlockState state) {
         return NetherVines.isValidGrowthState(state);
     }
+
+    // Purpur start - twisting vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.twistingVinesMaxGrowthAge;
+    }
+    // Purpur end - twisting vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/VegetationBlock.java b/net/minecraft/world/level/block/VegetationBlock.java
index 0aa7c1084fd6ed35260469572cdd914d87f3922a..a1b5e815425fccbc601c8062fcc24598512e47dd 100644
--- a/net/minecraft/world/level/block/VegetationBlock.java
+++ b/net/minecraft/world/level/block/VegetationBlock.java
@@ -61,4 +61,24 @@ public abstract class VegetationBlock extends Block {
     protected boolean isPathfindable(BlockState state, PathComputationType pathComputationType) {
         return pathComputationType == PathComputationType.AIR && !this.hasCollision || super.isPathfindable(state, pathComputationType);
     }
+
+    // Purpur start - Ability for hoe to replant crops
+    public void playerDestroyAndReplant(net.minecraft.world.level.Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @javax.annotation.Nullable net.minecraft.world.level.block.entity.BlockEntity blockEntity, net.minecraft.world.item.ItemStack itemInHand, net.minecraft.world.level.ItemLike itemToReplant) {
+        player.awardStat(net.minecraft.stats.Stats.BLOCK_MINED.get(this));
+        player.causeFoodExhaustion(0.005F, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.BLOCK_MINED);
+        java.util.List<net.minecraft.world.item.ItemStack> dropList = Block.getDrops(state, (net.minecraft.server.level.ServerLevel) world, pos, blockEntity, player, itemInHand);
+
+        boolean planted = false;
+        for (net.minecraft.world.item.ItemStack itemToDrop : dropList) {
+            if (!planted && itemToDrop.getItem() == itemToReplant) {
+                world.setBlock(pos, defaultBlockState(), 3);
+                itemToDrop.setCount(itemToDrop.getCount() - 1);
+                planted = true;
+            }
+            Block.popResource(world, pos, itemToDrop);
+        }
+
+        state.spawnAfterBreak((net.minecraft.server.level.ServerLevel) world, pos, itemInHand, true);
+    }
+    // Purpur end - Ability for hoe to replant crops
 }
diff --git a/net/minecraft/world/level/block/WeepingVinesBlock.java b/net/minecraft/world/level/block/WeepingVinesBlock.java
index f4ff810cdd4206711312a4fffba18f4b30a5701f..96fb69aaf9ed020a328ff609d49f88ab29a69952 100644
--- a/net/minecraft/world/level/block/WeepingVinesBlock.java
+++ b/net/minecraft/world/level/block/WeepingVinesBlock.java
@@ -34,4 +34,11 @@ public class WeepingVinesBlock extends GrowingPlantHeadBlock {
     protected boolean canGrowInto(BlockState state) {
         return NetherVines.isValidGrowthState(state);
     }
+
+    // Purpur start - weeping vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.weepingVinesMaxGrowthAge;
+    }
+    // Purpur end - weeping vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/WitherSkullBlock.java b/net/minecraft/world/level/block/WitherSkullBlock.java
index 24215493601ff724032660178c1261f3c40edd61..dd4d0c2fa77fc62ce2c3dfb2be902dcde3aa9cd7 100644
--- a/net/minecraft/world/level/block/WitherSkullBlock.java
+++ b/net/minecraft/world/level/block/WitherSkullBlock.java
@@ -69,6 +69,7 @@ public class WitherSkullBlock extends SkullBlock {
                         );
                         witherBoss.yBodyRot = blockPatternMatch.getForwards().getAxis() == Direction.Axis.X ? 0.0F : 90.0F;
                         witherBoss.makeInvulnerable();
+                        witherBoss.setSummoner(blockState.getBlock().placer == null ? null : blockState.getBlock().placer.getUUID()); // Purpur - Summoner API
                         // CraftBukkit start
                         if (!level.addFreshEntity(witherBoss, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BUILD_WITHER)) {
                             return;
diff --git a/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index c8bfa1eeb847d6d9972d2f6625cc1f60063713d4..c58bc63a0e9af0088921050549cd2c0d68fa1b3e 100644
--- a/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -187,6 +187,21 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         }
 
         ItemStack itemStack = furnace.items.get(1);
+        // Purpur start - Furnace uses lava from underneath
+        boolean usedLavaFromUnderneath = false;
+        if (level.purpurConfig.furnaceUseLavaFromUnderneath && !furnace.isLit() && itemStack.isEmpty() && !furnace.items.get(0).isEmpty() && level.getGameTime() % 20 == 0) {
+            BlockPos below = furnace.getBlockPos().below();
+            BlockState belowState = level.getBlockStateIfLoaded(below);
+            if (belowState != null && belowState.is(Blocks.LAVA)) {
+                net.minecraft.world.level.material.FluidState fluidState = belowState.getFluidState();
+                if (fluidState != null && fluidState.isSource()) {
+                    level.setBlock(below, Blocks.AIR.defaultBlockState(), 3);
+                    itemStack = Items.LAVA_BUCKET.getDefaultInstance();
+                    usedLavaFromUnderneath = true;
+                }
+            }
+        }
+        // Purpur end - Furnace uses lava from underneath
         ItemStack itemStack1 = furnace.items.get(0);
         boolean flag1 = !itemStack1.isEmpty();
         boolean flag2 = !itemStack.isEmpty();
@@ -270,6 +285,8 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         if (flag) {
             setChanged(level, pos, state);
         }
+
+        if (usedLavaFromUnderneath) furnace.items.set(1, ItemStack.EMPTY); // Purpur - Furnace uses lava from underneath
     }
 
     private static boolean canBurn(
diff --git a/net/minecraft/world/level/block/entity/BarrelBlockEntity.java b/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
index 75c09a2079c89f9346391abdd01ef8790b9cbb13..04f6b3c328377091734a111f5a219379e32b5640 100644
--- a/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
@@ -59,7 +59,16 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
     }
     // CraftBukkit end
     private static final Component DEFAULT_NAME = Component.translatable("container.barrel");
-    private NonNullList<ItemStack> items = NonNullList.withSize(27, ItemStack.EMPTY);
+    // Purpur start - Barrels and enderchests 6 rows
+    private NonNullList<ItemStack> items = NonNullList.withSize(switch (org.purpurmc.purpur.PurpurConfig.barrelRows) {
+        case 6 -> 54;
+        case 5 -> 45;
+        case 4 -> 36;
+        case 2 -> 18;
+        case 1 -> 9;
+        default -> 27;
+    }, ItemStack.EMPTY);
+    // Purpur end - Barrels and enderchests 6 rows
     public final ContainerOpenersCounter openersCounter = new ContainerOpenersCounter() {
         @Override
         protected void onOpen(Level level, BlockPos pos, BlockState state) {
@@ -111,7 +120,16 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
 
     @Override
     public int getContainerSize() {
-        return 27;
+        // Purpur start - Barrels and enderchests 6 rows
+        return switch (org.purpurmc.purpur.PurpurConfig.barrelRows) {
+            case 6 -> 54;
+            case 5 -> 45;
+            case 4 -> 36;
+            case 2 -> 18;
+            case 1 -> 9;
+            default -> 27;
+        };
+        // Purpur end - Barrels and enderchests 6 rows
     }
 
     @Override
@@ -131,7 +149,16 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
 
     @Override
     protected AbstractContainerMenu createMenu(int id, Inventory player) {
-        return ChestMenu.threeRows(id, player, this);
+        // Purpur start - Barrels and enderchests 6 rows
+        return switch (org.purpurmc.purpur.PurpurConfig.barrelRows) {
+            case 6 -> ChestMenu.sixRows(id, player, this);
+            case 5 -> ChestMenu.fiveRows(id, player, this);
+            case 4 -> ChestMenu.fourRows(id, player, this);
+            case 2 -> ChestMenu.twoRows(id, player, this);
+            case 1 -> ChestMenu.oneRow(id, player, this);
+            default -> ChestMenu.threeRows(id, player, this);
+        };
+        // Purpur end - Barrels and enderchests 6 rows
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/entity/BeaconBlockEntity.java b/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
index 0db33d7e1227e914326e9eb3b50338b001872938..cc301cff64e1bf604a1432f6e36be8aa17db53e7 100644
--- a/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
@@ -138,6 +138,16 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
 
     public double getEffectRange() {
         if (this.effectRange < 0) {
+            // Purpur start - Beacon Activation Range Configurable
+            if (this.level != null) {
+                switch (this.levels) {
+                    case 1: return this.level.purpurConfig.beaconLevelOne;
+                    case 2: return this.level.purpurConfig.beaconLevelTwo;
+                    case 3: return this.level.purpurConfig.beaconLevelThree;
+                    case 4: return this.level.purpurConfig.beaconLevelFour;
+                }
+            }
+            // Purpur end - Beacon Activation Range Configurable
             return this.levels * 10 + 10;
         } else {
             return effectRange;
@@ -166,6 +176,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
         int y = pos.getY();
         int z = pos.getZ();
         BlockPos blockPos;
+        boolean isTintedGlass = false; // Purpur - allow beacon effects when covered by tinted glass
         if (blockEntity.lastCheckY < y) {
             blockPos = pos;
             blockEntity.checkingBeamSections = Lists.newArrayList();
@@ -195,11 +206,15 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
                     }
                 }
             } else {
-                if (section == null || blockState.getLightBlock() >= 15 && !blockState.is(Blocks.BEDROCK)) {
+                if (level.purpurConfig.beaconAllowEffectsWithTintedGlass && blockState.getBlock().equals(Blocks.TINTED_GLASS)) {isTintedGlass = true;} // Purpur - allow beacon effects when covered by tinted glass
+                // Purpur start - fix effects being applied when tinted glass is covered
+                if (section == null || blockState.getLightBlock() >= 15 && !blockState.is(Blocks.BEDROCK) && !(blockState.getBlock().equals(Blocks.TINTED_GLASS) && level.purpurConfig.beaconAllowEffectsWithTintedGlass)) {
                     blockEntity.checkingBeamSections.clear();
                     blockEntity.lastCheckY = height;
+                    isTintedGlass = false;
                     break;
                 }
+                // Purpur end - fix effects being applied when tinted glass is covered
 
                 section.increaseHeight();
             }
@@ -210,11 +225,11 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
 
         int i = blockEntity.levels; final int originalLevels = i; // Paper - OBFHELPER
         if (level.getGameTime() % 80L == 0L) {
-            if (!blockEntity.beamSections.isEmpty()) {
+            if (!blockEntity.beamSections.isEmpty() || (level.purpurConfig.beaconAllowEffectsWithTintedGlass && isTintedGlass)) { // Purpur - fix beacon effects persisting with broken base while tinted glass is used
                 blockEntity.levels = updateBase(level, x, y, z);
             }
 
-            if (blockEntity.levels > 0 && !blockEntity.beamSections.isEmpty()) {
+            if (blockEntity.levels > 0 && (!blockEntity.beamSections.isEmpty() || (level.purpurConfig.beaconAllowEffectsWithTintedGlass && isTintedGlass))) { // Purpur - allow beacon effects when covered by tinted glass
                 applyEffects(level, pos, blockEntity.levels, blockEntity.primaryPower, blockEntity.secondaryPower, blockEntity); // Paper - Custom beacon ranges
                 playSound(level, pos, SoundEvents.BEACON_AMBIENT);
             }
diff --git a/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java b/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
index c989b7d52e16d93e65afb0f921d514c68b814921..9261bc38258ee80aa6ec2f4bcb27a48c01f84b8f 100644
--- a/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
@@ -79,7 +79,7 @@ public class BeehiveBlockEntity extends BlockEntity {
         "leash",
         "UUID"
     );
-    public static final int MAX_OCCUPANTS = 3;
+    public static final int MAX_OCCUPANTS = org.purpurmc.purpur.PurpurConfig.beeInsideBeeHive; // Purpur - Config to change max number of bees
     private static final int MIN_TICKS_BEFORE_REENTERING_HIVE = 400;
     private static final int MIN_OCCUPATION_TICKS_NECTAR = 2400;
     public static final int MIN_OCCUPATION_TICKS_NECTARLESS = 600;
@@ -153,11 +153,33 @@ public class BeehiveBlockEntity extends BlockEntity {
         return list;
     }
 
+    // Purpur start - Stored Bee API
+    public List<Entity> releaseBee(BlockState iblockdata, BeehiveBlockEntity.BeeData data, BeehiveBlockEntity.BeeReleaseStatus tileentitybeehive_releasestatus, boolean force) {
+        List<Entity> list = Lists.newArrayList();
+
+        BeehiveBlockEntity.releaseOccupant(this.level, this.worldPosition, iblockdata, data.occupant, list, tileentitybeehive_releasestatus, this.savedFlowerPos, force);
+
+        if (!list.isEmpty()) {
+            stored.remove(data);
+
+            super.setChanged();
+        }
+
+        return list;
+    }
+    // Purpur end - Stored Bee API
+
     @VisibleForDebug
     public int getOccupantCount() {
         return this.stored.size();
     }
 
+    // Purpur start - Stored Bee API
+    public List<BeeData> getStored() {
+        return stored;
+    }
+    // Purpur end - Stored Bee API
+
     // Paper start - Add EntityBlockStorage clearEntities
     public void clearBees() {
         this.stored.clear();
@@ -398,8 +420,8 @@ public class BeehiveBlockEntity extends BlockEntity {
         registrar.register(DebugSubscriptions.BEE_HIVES, () -> DebugHiveInfo.pack(this));
     }
 
-    static class BeeData {
-        private final BeehiveBlockEntity.Occupant occupant;
+    public static class BeeData { // Purpur - make public - Stored Bee API
+        public final BeehiveBlockEntity.Occupant occupant; // Purpur - make public - Stored Bee API
         private int exitTickCounter; // Paper - Fix bees aging inside hives; separate counter for checking if bee should exit to reduce exit attempts
         private int ticksInHive;
 
diff --git a/net/minecraft/world/level/block/entity/BlockEntity.java b/net/minecraft/world/level/block/entity/BlockEntity.java
index fb22ebe9758014ebf2aebcda21155f1c4c83fafe..7cbb92c23f0b3d49b8ea6cd66ed4f377dd22ee98 100644
--- a/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -105,6 +105,10 @@ public abstract class BlockEntity implements DebugValueSource {
         input.read("PublicBukkitValues", CompoundTag.CODEC)
             .ifPresent(this.persistentDataContainer::putAll);
         // Paper end - read persistent data container
+
+
+        this.persistentLore = input.read("Purpur.persistentLore", net.minecraft.world.item.component.ItemLore.CODEC).orElse(null); // Purpur - Persistent BlockEntity Lore and DisplayName
+
     }
 
     public final void loadWithComponents(ValueInput input) {
@@ -117,6 +121,11 @@ public abstract class BlockEntity implements DebugValueSource {
     }
 
     protected void saveAdditional(ValueOutput output) {
+        // Purpur start - Persistent BlockEntity Lore and DisplayName
+        if (this.persistentLore != null) {
+            output.store("Purpur.persistentLore", net.minecraft.world.item.component.ItemLore.CODEC, this.persistentLore);
+        }
+        // Purpur end - Persistent BlockEntity Lore and DisplayName
     }
 
     public final CompoundTag saveWithFullMetadata(HolderLookup.Provider registries) {
@@ -402,4 +411,16 @@ public abstract class BlockEntity implements DebugValueSource {
             return this.blockEntity.getNameForReporting() + "@" + this.blockEntity.getBlockPos();
         }
     }
+
+    // Purpur start - Persistent BlockEntity Lore and DisplayName
+    private net.minecraft.world.item.component.@Nullable ItemLore persistentLore = null;
+
+    public void setPersistentLore(net.minecraft.world.item.component.ItemLore lore) {
+        this.persistentLore = lore;
+    }
+
+    public @org.jetbrains.annotations.Nullable net.minecraft.world.item.component.ItemLore getPersistentLore() {
+        return this.persistentLore;
+    }
+    // Purpur end - Persistent BlockEntity Lore and DisplayName
 }
diff --git a/net/minecraft/world/level/block/entity/ConduitBlockEntity.java b/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
index be4b46d56ca67cb5c0fac5e0bbc9456fb5552d78..816d9a0f7f35b95b369ffbfc02e4d1f306b814c5 100644
--- a/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
@@ -150,7 +150,7 @@ public class ConduitBlockEntity extends BlockEntity {
                         BlockPos blockPos1 = pos.offset(i, i1, i2x);
                         BlockState blockState = level.getBlockState(blockPos1);
 
-                        for (Block block : VALID_BLOCKS) {
+                        for (Block block : level.purpurConfig.conduitBlocks) { // Purpur - Conduit behavior configuration
                             if (blockState.is(block)) {
                                 positions.add(blockPos1);
                             }
@@ -165,13 +165,13 @@ public class ConduitBlockEntity extends BlockEntity {
 
     private static void applyEffects(Level level, BlockPos pos, List<BlockPos> positions) {
         // CraftBukkit start
-        ConduitBlockEntity.applyEffects(level, pos, ConduitBlockEntity.getRange(positions));
+        ConduitBlockEntity.applyEffects(level, pos, ConduitBlockEntity.getRange(positions, level)); // Purpur - Conduit behavior configuration
     }
 
-    public static int getRange(List<BlockPos> positions) {
+    public static int getRange(List<BlockPos> positions, Level level) { // Purpur - Conduit behavior configuration
         // CraftBukkit end
         int size = positions.size();
-        int i = size / 7 * 16;
+        int i = size / 7 * level.purpurConfig.conduitDistance; // Purpur - Conduit behavior configuration
         // CraftBukkit start
         return i;
     }
@@ -201,7 +201,7 @@ public class ConduitBlockEntity extends BlockEntity {
         EntityReference<LivingEntity> entityReference = updateDestroyTarget(blockEntity.destroyTarget, level, pos, canDestroy);
         LivingEntity livingEntity = EntityReference.getLivingEntity(entityReference, level);
         if (damageTarget && livingEntity != null) { // CraftBukkit
-            if (livingEntity.hurtServer(level, level.damageSources().magic().eventBlockDamager(level, pos), 4.0F)) // CraftBukkit - move up
+            if (livingEntity.hurtServer(level, level.damageSources().magic().eventBlockDamager(level, pos), level.purpurConfig.conduitDamageAmount)) // CraftBukkit - move up // Purpur - Conduit behavior configuration
             level.playSound(
                 null, livingEntity.getX(), livingEntity.getY(), livingEntity.getZ(), SoundEvents.CONDUIT_ATTACK_TARGET, SoundSource.BLOCKS, 1.0F, 1.0F
             );
@@ -222,19 +222,25 @@ public class ConduitBlockEntity extends BlockEntity {
             return selectNewTarget(level, pos);
         } else {
             LivingEntity livingEntity = EntityReference.getLivingEntity(destroyTarget, level);
-            return livingEntity != null && livingEntity.isAlive() && pos.closerThan(livingEntity.blockPosition(), 8.0) ? destroyTarget : null;
+            return livingEntity != null && livingEntity.isAlive() && pos.closerThan(livingEntity.blockPosition(), level.purpurConfig.conduitDamageDistance) ? destroyTarget : null; // Purpur - Conduit behavior configuration
         }
     }
 
     private static @Nullable EntityReference<LivingEntity> selectNewTarget(ServerLevel level, BlockPos pos) {
         List<LivingEntity> entitiesOfClass = level.getEntitiesOfClass(
-            LivingEntity.class, getDestroyRangeAABB(pos), livingEntity -> livingEntity instanceof Enemy && livingEntity.isInWaterOrRain()
+            LivingEntity.class, getDestroyRangeAABB(pos, level), livingEntity -> livingEntity instanceof Enemy && livingEntity.isInWaterOrRain() // Purpur - Conduit behavior configuration
         );
         return entitiesOfClass.isEmpty() ? null : EntityReference.of(Util.getRandom(entitiesOfClass, level.random));
     }
 
     public static AABB getDestroyRangeAABB(BlockPos pos) {
-        return new AABB(pos).inflate(8.0);
+        // Purpur start - Conduit behavior configuration
+        return getDestroyRangeAABB(pos, null);
+    }
+
+    private static AABB getDestroyRangeAABB(BlockPos pos, Level level) {
+        // Purpur end - Conduit behavior configuration
+        return new AABB(pos).inflate(level == null ? 8.0 : level.purpurConfig.conduitDamageDistance); // Purpur - Conduit behavior configuration
     }
 
     private static void animationTick(Level level, BlockPos pos, List<BlockPos> positions, @Nullable Entity entity, int tickCount) {
diff --git a/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java b/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java
index bf3b57723943e5c62071740c66c345c02a7c978f..4c98157666146ec2727f41edc6de9b3cc2d51848 100644
--- a/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java
@@ -30,6 +30,7 @@ public class EnchantingTableBlockEntity extends BlockEntity implements Nameable
     public float tRot;
     private static final RandomSource RANDOM = RandomSource.create();
     private @Nullable Component name;
+    private int lapis = 0; // Purpur - Enchantment Table Persists Lapis
 
     public EnchantingTableBlockEntity(BlockPos pos, BlockState blockState) {
         super(BlockEntityType.ENCHANTING_TABLE, pos, blockState);
@@ -39,12 +40,14 @@ public class EnchantingTableBlockEntity extends BlockEntity implements Nameable
     protected void saveAdditional(ValueOutput output) {
         super.saveAdditional(output);
         output.storeNullable("CustomName", ComponentSerialization.CODEC, this.name);
+        output.putInt("Purpur.Lapis", this.lapis); // Purpur - Enchantment Table Persists Lapis
     }
 
     @Override
     protected void loadAdditional(ValueInput input) {
         super.loadAdditional(input);
         this.name = parseCustomNameSafe(input, "CustomName");
+        this.lapis = input.getIntOr("Purpur.Lapis", 0); // Purpur - Enchantment Table Persists Lapis
     }
 
     public static void bookAnimationTick(Level level, BlockPos pos, BlockState state, EnchantingTableBlockEntity enchantingTable) {
@@ -135,4 +138,22 @@ public class EnchantingTableBlockEntity extends BlockEntity implements Nameable
     public void removeComponentsFromTag(ValueOutput output) {
         output.discard("CustomName");
     }
+
+    // Purpur start - Enchantment Table Persists Lapis
+    public int getLapis() {
+        return this.lapis;
+    }
+
+    public void setLapis(int lapis) {
+        this.lapis = lapis;
+    }
+
+    @Override
+    public void preRemoveSideEffects(BlockPos pos, BlockState state) {
+        super.preRemoveSideEffects(pos, state);
+        if (this.level != null && this.level.purpurConfig.enchantmentTableLapisPersists) {
+            net.minecraft.world.Containers.dropItemStack(this.level, pos.getX(), pos.getY(), pos.getZ(), new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.LAPIS_LAZULI, this.getLapis()));
+        }
+    }
+    // Purpur end - Enchantment Table Persists Lapis
 }
diff --git a/net/minecraft/world/level/block/entity/SignBlockEntity.java b/net/minecraft/world/level/block/entity/SignBlockEntity.java
index ce6108ea608463a28f9349010e912f23a7a1cb0c..e93f399c02aa3c47b08e33b8cf2f8b474273c33b 100644
--- a/net/minecraft/world/level/block/entity/SignBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/SignBlockEntity.java
@@ -149,16 +149,32 @@ public class SignBlockEntity extends BlockEntity {
         return this.setText(updater.apply(text), isFrontText);
     }
 
+    // Purpur start - Signs allow color codes
+    private Component translateColors(org.bukkit.entity.Player player, String line, Style style) {
+        if (level.purpurConfig.signAllowColors) {
+            if (player.hasPermission("purpur.sign.color")) line = line.replaceAll("(?i)&([0-9a-fr])", "\u00a7$1");
+            if (player.hasPermission("purpur.sign.style")) line = line.replaceAll("(?i)&([l-or])", "\u00a7$1");
+            if (player.hasPermission("purpur.sign.magic")) line = line.replaceAll("(?i)&([kr])", "\u00a7$1");
+
+            return io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(line));
+        } else {
+            return Component.literal(line).setStyle(style);
+        }
+    }
+    // Purpur end - Signs allow color codes
+
     private SignText setMessages(Player player, List<FilteredText> filteredText, SignText text, boolean front) { // CraftBukkit
         SignText originalText = text; // CraftBukkit
         for (int i = 0; i < filteredText.size(); i++) {
             FilteredText filteredText1 = filteredText.get(i);
             Style style = text.getMessage(i, player.isTextFilteringEnabled()).getStyle();
+
+            org.bukkit.entity.Player craftPlayer =  (org.bukkit.craftbukkit.entity.CraftPlayer) player.getBukkitEntity(); // Purpur - Signs allow color codes
             if (player.isTextFilteringEnabled()) {
-                text = text.setMessage(i, Component.literal(net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty())).setStyle(style)); // Paper - filter sign text to chat only
+                text = text.setMessage(i, translateColors(craftPlayer, net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty()), style)); // Paper - filter sign text to chat only // Purpur - Signs allow color codes
             } else {
                 text = text.setMessage(
-                    i, Component.literal(filteredText1.raw()).setStyle(style), Component.literal(net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty())).setStyle(style) // Paper - filter sign text to chat only
+                    i, translateColors(craftPlayer, net.minecraft.util.StringUtil.filterText(filteredText1.raw()), style), translateColors(craftPlayer, net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty()), style) // Paper - filter sign text to chat only // Purpur - Signs allow color codes
                 );
             }
         }
@@ -308,6 +324,27 @@ public class SignBlockEntity extends BlockEntity {
         return new CommandSourceStack(commandSource, Vec3.atCenterOf(pos), Vec2.ZERO, level, LevelBasedPermissionSet.GAMEMASTER, string, component, level.getServer(), player); // Paper - Fix commands from signs not firing command events
     }
 
+    // Purpur start - Signs allow color codes
+    public ClientboundBlockEntityDataPacket getTranslatedUpdatePacket(boolean filtered, boolean front) {
+        try (net.minecraft.util.ProblemReporter.ScopedCollector scopedCollector = new net.minecraft.util.ProblemReporter.ScopedCollector(this.problemPath(), LOGGER)) {
+            net.minecraft.world.level.storage.TagValueOutput tagValueOutput = net.minecraft.world.level.storage.TagValueOutput.createWithContext(scopedCollector, this.getLevel().registryAccess());
+            this.saveAdditional(tagValueOutput);
+
+            final Component[] lines = front ? frontText.getMessages(filtered) : backText.getMessages(filtered);
+            final String side = front ? "front_text" : "back_text";
+            net.minecraft.world.level.storage.ValueOutput sideNbt = tagValueOutput.child(side);
+            net.minecraft.world.level.storage.ValueOutput.TypedOutputList<String> messagesNbt = sideNbt.list("messages", com.mojang.serialization.Codec.STRING);
+            for (int i = 0; i < 4; i++) {
+                final net.kyori.adventure.text.Component component = io.papermc.paper.adventure.PaperAdventure.asAdventure(lines[i]);
+                final String line = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacyAmpersand().serialize(component);
+                messagesNbt.add(line);
+            }
+            tagValueOutput.putString("PurpurEditor", "true");
+            return ClientboundBlockEntityDataPacket.create(this, (blockEntity, registryAccess) -> tagValueOutput.buildResult());
+        }
+    }
+    // Purpur end - Signs allow color codes
+
     @Override
     public ClientboundBlockEntityDataPacket getUpdatePacket() {
         return ClientboundBlockEntityDataPacket.create(this);
diff --git a/net/minecraft/world/level/block/piston/PistonStructureResolver.java b/net/minecraft/world/level/block/piston/PistonStructureResolver.java
index ad143a92569f5b420ccaa2089758b2fb3b4ab7c5..5a3660e02bc805e9a35a81b8a61f07b3f20b5ba9 100644
--- a/net/minecraft/world/level/block/piston/PistonStructureResolver.java
+++ b/net/minecraft/world/level/block/piston/PistonStructureResolver.java
@@ -81,7 +81,7 @@ public class PistonStructureResolver {
             return true;
         } else {
             int i = 1;
-            if (i + this.toPush.size() > 12) {
+            if (i + this.toPush.size() > this.level.purpurConfig.pistonBlockPushLimit) { // Purpur - Configurable piston push limit
                 return false;
             } else {
                 while (isSticky(blockState)) {
@@ -95,7 +95,7 @@ public class PistonStructureResolver {
                         break;
                     }
 
-                    if (++i + this.toPush.size() > 12) {
+                    if (++i + this.toPush.size() > this.level.purpurConfig.pistonBlockPushLimit) { // Purpur - Configurable piston push limit
                         return false;
                     }
                 }
@@ -140,7 +140,7 @@ public class PistonStructureResolver {
                         return true;
                     }
 
-                    if (this.toPush.size() >= 12) {
+                    if (this.toPush.size() >= this.level.purpurConfig.pistonBlockPushLimit) { // Purpur - Configurable piston push limit
                         return false;
                     }
 
diff --git a/net/minecraft/world/level/chunk/storage/EntityStorage.java b/net/minecraft/world/level/chunk/storage/EntityStorage.java
index 2ce9caafffc86fee82abf0a33423a172a8158e37..65afe543c7b974b13e7da8d0c047db9fea6994f5 100644
--- a/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -108,6 +108,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
                     }
                     // Paper end - Entity load/save limit per chunk
                     TagValueOutput tagValueOutput = TagValueOutput.createWithContext(scopedCollector.forChild(entity.problemPath()), entity.registryAccess());
+                    if (!entity.canSaveToDisk()) return; // Purpur - Add canSaveToDisk to Entity
                     if (entity.save(tagValueOutput)) {
                         CompoundTag compoundTag1 = tagValueOutput.buildResult();
                         listTag.add(compoundTag1);
diff --git a/net/minecraft/world/level/gamerules/GameRules.java b/net/minecraft/world/level/gamerules/GameRules.java
index e71a9ffdb6c081baa79113f34b179671c179152d..746bc21fc09644366caa8bfd309f596c3cac59ec 100644
--- a/net/minecraft/world/level/gamerules/GameRules.java
+++ b/net/minecraft/world/level/gamerules/GameRules.java
@@ -113,6 +113,13 @@ public class GameRules {
         return this.rules.keySet().stream();
     }
 
+    public <T> boolean get(GameRule<T> rule, Boolean gameRuleOverride) {
+        if (gameRuleOverride != null) {
+            return gameRuleOverride;
+        }
+        return (Boolean) this.get(rule);
+    }
+
     public <T> T get(GameRule<T> rule) {
         T object = this.rules.get(rule);
         if (object == null) {
diff --git a/net/minecraft/world/level/levelgen/PhantomSpawner.java b/net/minecraft/world/level/levelgen/PhantomSpawner.java
index 135e8cc1b423d5a2a96ede693a306534ea45686b..84b4b68397be1766089783255845471077cc19f3 100644
--- a/net/minecraft/world/level/levelgen/PhantomSpawner.java
+++ b/net/minecraft/world/level/levelgen/PhantomSpawner.java
@@ -38,13 +38,13 @@ public class PhantomSpawner implements CustomSpawner {
                     int spawnAttemptMaxSeconds = level.paperConfig().entities.behavior.phantomsSpawnAttemptMaxSeconds;
                     this.nextTick += (spawnAttemptMinSeconds + randomSource.nextInt(spawnAttemptMaxSeconds - spawnAttemptMinSeconds + 1)) * 20;
                     // Paper end - Ability to control player's insomnia and phantoms
-                    if (level.getSkyDarken() >= 5 || !level.dimensionType().hasSkyLight()) {
+                    if (level.getSkyDarken() >= level.purpurConfig.phantomSpawnMinSkyDarkness || !level.dimensionType().hasSkyLight()) { // Purpur - Add phantom spawning options
                         for (ServerPlayer serverPlayer : level.players()) {
                             if (!serverPlayer.isSpectator() && (!level.paperConfig().entities.behavior.phantomsDoNotSpawnOnCreativePlayers || !serverPlayer.isCreative())) { // Paper - Add phantom creative and insomniac controls
                                 BlockPos blockPos = serverPlayer.blockPosition();
-                                if (!level.dimensionType().hasSkyLight() || blockPos.getY() >= level.getSeaLevel() && level.canSeeSky(blockPos)) {
+                                if (!level.dimensionType().hasSkyLight() || (!level.purpurConfig.phantomSpawnOnlyAboveSeaLevel || blockPos.getY() >= level.getSeaLevel()) && (!level.purpurConfig.phantomSpawnOnlyWithVisibleSky || level.canSeeSky(blockPos))) { // Purpur - Add phantom spawning options
                                     DifficultyInstance currentDifficultyAt = level.getCurrentDifficultyAt(blockPos);
-                                    if (currentDifficultyAt.isHarderThan(randomSource.nextFloat() * 3.0F)) {
+                                    if (currentDifficultyAt.isHarderThan(randomSource.nextFloat() * (float) level.purpurConfig.phantomSpawnLocalDifficultyChance)) { // Purpur - Add phantom spawning options
                                         ServerStatsCounter stats = serverPlayer.getStats();
                                         int i = Mth.clamp(stats.getValue(Stats.CUSTOM.get(Stats.TIME_SINCE_REST)), 1, Integer.MAX_VALUE);
                                         int i1 = 24000;
@@ -56,7 +56,7 @@ public class PhantomSpawner implements CustomSpawner {
                                             FluidState fluidState = level.getFluidState(blockPos1);
                                             if (NaturalSpawner.isValidEmptySpawnBlock(level, blockPos1, blockState, fluidState, EntityType.PHANTOM)) {
                                                 SpawnGroupData spawnGroupData = null;
-                                                int i2 = 1 + randomSource.nextInt(currentDifficultyAt.getDifficulty().getId() + 1);
+                                                int i2 = level.purpurConfig.phantomSpawnMinPerAttempt + randomSource.nextInt((level.purpurConfig.phantomSpawnMaxPerAttempt < 0 ? currentDifficultyAt.getDifficulty().getId() : level.purpurConfig.phantomSpawnMaxPerAttempt - level.purpurConfig.phantomSpawnMinPerAttempt) + 1); // Purpur - Add phantom spawning options
 
                                                 for (int i3 = 0; i3 < i2; i3++) {
                                                     // Paper start - PhantomPreSpawnEvent
diff --git a/net/minecraft/world/level/material/FlowingFluid.java b/net/minecraft/world/level/material/FlowingFluid.java
index fdd19f1f365ca8e3cb4c1dfd2ab30d8ab4a7362b..af3d41aa18fc864970961ce788ecb23f03d1bbf2 100644
--- a/net/minecraft/world/level/material/FlowingFluid.java
+++ b/net/minecraft/world/level/material/FlowingFluid.java
@@ -233,7 +233,7 @@ public abstract class FlowingFluid extends Fluid {
             }
         }
 
-        if (i1 >= 2 && this.canConvertToSource(level)) {
+        if (i1 >= this.getRequiredSources(level) && this.canConvertToSource(level)) { // Purpur - Implement infinite liquids
             BlockState blockState1 = level.getBlockState(mutableBlockPos.setWithOffset(pos, Direction.DOWN));
             FluidState fluidState1 = blockState1.getFluidState();
             if (blockState1.isSolid() || this.isSourceBlockOfThisType(fluidState1)) {
@@ -321,6 +321,12 @@ public abstract class FlowingFluid extends Fluid {
 
     protected abstract boolean canConvertToSource(ServerLevel level);
 
+    // Purpur start - Implement infinite liquids
+    protected int getRequiredSources(Level level) {
+        return 2;
+    }
+    // Purpur end - Implement infinite liquids
+
     protected void spreadTo(LevelAccessor level, BlockPos pos, BlockState state, Direction direction, FluidState fluidState) {
         if (state.getBlock() instanceof LiquidBlockContainer liquidBlockContainer) {
             liquidBlockContainer.placeLiquid(level, pos, state, fluidState);
diff --git a/net/minecraft/world/level/material/LavaFluid.java b/net/minecraft/world/level/material/LavaFluid.java
index a42878c191445ba4b0d50dd2b789a132d5cf6a3e..3e81c98e2e6b0f1424429ab52aa43d229c867cc7 100644
--- a/net/minecraft/world/level/material/LavaFluid.java
+++ b/net/minecraft/world/level/material/LavaFluid.java
@@ -190,7 +190,7 @@ public abstract class LavaFluid extends FlowingFluid {
 
     @Override
     public int getTickDelay(LevelReader level) {
-        return isFastLava(level) ? 10 : 30;
+        return level.getWorldBorder().world != null ? (isFastLava(level) ? level.getWorldBorder().world.purpurConfig.lavaSpeedNether : level.getWorldBorder().world.purpurConfig.lavaSpeedNotNether) : (isFastLava(level) ? 10 : 30); // Purpur - Make lava flow speed configurable
     }
 
     @Override
@@ -212,6 +212,13 @@ public abstract class LavaFluid extends FlowingFluid {
         level.levelEvent(LevelEvent.LAVA_FIZZ, pos, 0);
     }
 
+    // Purpur start - Implement infinite liquids
+    @Override
+    protected int getRequiredSources(Level level) {
+        return level.purpurConfig.lavaInfiniteRequiredSources;
+    }
+    // Purpur end - Implement infinite liquids
+
     @Override
     protected boolean canConvertToSource(ServerLevel level) {
         return level.getGameRules().get(GameRules.LAVA_SOURCE_CONVERSION);
diff --git a/net/minecraft/world/level/material/WaterFluid.java b/net/minecraft/world/level/material/WaterFluid.java
index 45ade22e8f69609598725a94a0581251cf3f384f..4533d9f76f4ea21cee3c3114bcfcded40fe7321b 100644
--- a/net/minecraft/world/level/material/WaterFluid.java
+++ b/net/minecraft/world/level/material/WaterFluid.java
@@ -77,6 +77,13 @@ public abstract class WaterFluid extends FlowingFluid {
         return level.getGameRules().get(GameRules.WATER_SOURCE_CONVERSION);
     }
 
+    // Purpur start - Implement infinite liquids
+    @Override
+    protected int getRequiredSources(Level level) {
+        return level.purpurConfig.waterInfiniteRequiredSources;
+    }
+    // Purpur end - Implement infinite liquids
+
     // Paper start - Add BlockBreakBlockEvent
      @Override
     protected void beforeDestroyingBlock(LevelAccessor level, BlockPos pos, BlockState state, BlockPos source) {
diff --git a/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index ca5448b2531d2f7126132723c4fa8d49835a4850..876aef8dab7187a69bcb380692d0f6a583fb38bd 100644
--- a/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -239,7 +239,7 @@ public class WalkNodeEvaluator extends NodeEvaluator {
                 if ((node == null || node.costMalus < 0.0F)
                     && verticalDeltaLimit > 0
                     && (cachedPathType != PathType.FENCE || this.canWalkOverFences())
-                    && cachedPathType != PathType.UNPASSABLE_RAIL
+                    && (this.mob.level().purpurConfig.mobsIgnoreRails || cachedPathType != PathType.UNPASSABLE_RAIL) // Purpur - Config to allow mobs to pathfind over rails
                     && cachedPathType != PathType.TRAPDOOR
                     && cachedPathType != PathType.POWDER_SNOW) {
                     node = this.tryJumpOn(x, y, z, verticalDeltaLimit, nodeFloorLevel, direction, pathType, mutableBlockPos);
@@ -490,7 +490,7 @@ public class WalkNodeEvaluator extends NodeEvaluator {
             return PathType.TRAPDOOR;
         } else if (blockState.is(Blocks.POWDER_SNOW)) {
             return PathType.POWDER_SNOW;
-        } else if (blockState.is(Blocks.CACTUS) || blockState.is(Blocks.SWEET_BERRY_BUSH)) {
+        } else if (blockState.is(Blocks.CACTUS) || blockState.is(Blocks.SWEET_BERRY_BUSH) || blockState.is(Blocks.STONECUTTER)) { // Purpur - Stonecutter damage
             return PathType.DAMAGE_OTHER;
         } else if (blockState.is(Blocks.HONEY_BLOCK)) {
             return PathType.STICKY_HONEY;
diff --git a/net/minecraft/world/level/portal/PortalShape.java b/net/minecraft/world/level/portal/PortalShape.java
index 275e98ea476a790ff3cedf19689a9538b3b2ee53..c88339479dd59a399ff4b250208311a18eea950f 100644
--- a/net/minecraft/world/level/portal/PortalShape.java
+++ b/net/minecraft/world/level/portal/PortalShape.java
@@ -29,7 +29,7 @@ public class PortalShape {
     public static final int MAX_WIDTH = 21;
     private static final int MIN_HEIGHT = 3;
     public static final int MAX_HEIGHT = 21;
-    public static final BlockBehaviour.StatePredicate FRAME = (state, level, pos) -> state.is(Blocks.OBSIDIAN);
+    public static final BlockBehaviour.StatePredicate FRAME = (state, level, pos) -> state.is(Blocks.OBSIDIAN) || (org.purpurmc.purpur.PurpurConfig.cryingObsidianValidForPortalFrame && state.is(Blocks.CRYING_OBSIDIAN)); // Purpur - Crying obsidian valid for portal frames
     private static final float SAFE_TRAVEL_MAX_ENTITY_XY = 4.0F;
     private static final double SAFE_TRAVEL_MAX_VERTICAL_DELTA = 1.0;
     private final Direction.Axis axis;
diff --git a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
index 1af585f9554278983148096c73c86e18166f5471..cd2719b0ac30654ce7e8247850f4512810b352e6 100644
--- a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -81,6 +81,7 @@ public class MapItemSavedData extends SavedData {
     public final Map<String, MapDecoration> decorations = Maps.newLinkedHashMap();
     private final Map<String, MapFrame> frameMarkers = Maps.newHashMap();
     private int trackedDecorationCount;
+    public boolean isExplorerMap; // Purpur - Explorer Map API
 
     // CraftBukkit start
     public final org.bukkit.craftbukkit.map.CraftMapView mapView;
diff --git a/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java b/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java
index c4f29da30d63deb3f9eabafcf62a946ff148b6b7..cdd2e1f1fc83cad782311ae5ba618fcf5fa9f37d 100644
--- a/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java
+++ b/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java
@@ -66,6 +66,11 @@ public class EnchantedCountIncreaseFunction extends LootItemConditionalFunction
         Entity entity = context.getOptionalParameter(LootContextParams.ATTACKING_ENTITY);
         if (entity instanceof LivingEntity livingEntity) {
             int enchantmentLevel = EnchantmentHelper.getEnchantmentLevel(this.enchantment, livingEntity);
+            // Purpur start - Add an option to fix MC-3304 projectile looting
+            if (org.purpurmc.purpur.PurpurConfig.fixProjectileLootingTransfer && context.getOptionalParameter(LootContextParams.DIRECT_ATTACKING_ENTITY) instanceof net.minecraft.world.entity.projectile.arrow.AbstractArrow arrow) {
+                enchantmentLevel = arrow.actualEnchantments.getLevel(this.enchantment);
+            }
+            // Purpur end - Add an option to fix MC-3304 projectile looting
             if (enchantmentLevel == 0) {
                 return stack;
             }
diff --git a/net/minecraft/world/phys/AABB.java b/net/minecraft/world/phys/AABB.java
index 7f0ff1bf4ddf7bfe1d3cad472416dd032806066b..120e432df71eaee94225555d24c82e6d05b34b9f 100644
--- a/net/minecraft/world/phys/AABB.java
+++ b/net/minecraft/world/phys/AABB.java
@@ -474,4 +474,10 @@ public class AABB {
             return new AABB(this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);
         }
     }
+
+    // Purpur start - Stop squids floating on top of water - tuinity added method
+    public final AABB offsetY(double dy) {
+        return new AABB(this.minX, this.minY + dy, this.minZ, this.maxX, this.maxY + dy, this.maxZ);
+    }
+    // Purpur end - Stop squids floating on top of water
 }
diff --git a/org/purpurmc/purpur/PurpurConfig.java b/org/purpurmc/purpur/PurpurConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..091cb2a5f607b71cccfc1e9f8d44627656dee397
--- /dev/null
+++ b/org/purpurmc/purpur/PurpurConfig.java
@@ -0,0 +1,592 @@
+package org.purpurmc.purpur;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Pattern;
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.Identifier;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.purpurmc.purpur.command.PurpurCommand;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import org.purpurmc.purpur.task.TPSBarTask;
+
+@SuppressWarnings("unused")
+public class PurpurConfig {
+    private static final String HEADER = "This is the main configuration file for Purpur.\n"
+            + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n"
+            + "with caution, and make sure you know what each option does before configuring.\n"
+            + "\n"
+            + "If you need help with the configuration or have any questions related to Purpur,\n"
+            + "join us in our Discord guild.\n"
+            + "\n"
+            + "Website: https://purpurmc.org \n"
+            + "Docs: https://purpurmc.org/docs \n";
+    private static File CONFIG_FILE;
+    public static YamlConfiguration config;
+
+    private static Map<String, Command> commands;
+
+    public static int version;
+    static boolean verbose;
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ignore) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load purpur.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        commands = new HashMap<>();
+        commands.put("purpur", new PurpurCommand("purpur"));
+
+        version = getInt("config-version", 47);
+        set("config-version", 47);
+
+        readConfig(PurpurConfig.class, null);
+
+        Block.BLOCK_STATE_REGISTRY.forEach(BlockBehaviour.BlockStateBase::initCache);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            log(Level.INFO, s);
+        }
+    }
+
+    protected static void log(Level level, String s) {
+        Bukkit.getLogger().log(level, s);
+    }
+
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Purpur", entry.getValue());
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static void set(String path, Object val) {
+        config.addDefault(path, val);
+        config.set(path, val);
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List<?> getList(String path, T def) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+    static Map<String, Object> getMap(String path, Map<String, Object> def) {
+        if (def != null && config.getConfigurationSection(path) == null) {
+            config.addDefault(path, def);
+            return def;
+        }
+        return toMap(config.getConfigurationSection(path));
+    }
+
+    private static Map<String, Object> toMap(ConfigurationSection section) {
+        ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Object obj = section.get(key);
+                if (obj != null) {
+                    builder.put(key, obj instanceof ConfigurationSection val ? toMap(val) : obj);
+                }
+            }
+        }
+        return builder.build();
+    }
+
+    public static String cannotRideMob = "<red>You cannot mount that mob";
+    public static String afkBroadcastAway = "<yellow><italic>%s is now AFK";
+    public static String afkBroadcastBack = "<yellow><italic>%s is no longer AFK";
+    public static boolean afkBroadcastUseDisplayName = false;
+    public static String afkTabListPrefix = "[AFK] ";
+    public static String afkTabListSuffix = "";
+    public static String creditsCommandOutput = "<green>%s has been shown the end credits";
+    public static String demoCommandOutput = "<green>%s has been shown the demo screen";
+    public static String pingCommandOutput = "<green>%s's ping is %sms";
+    public static String ramCommandOutput = "<green>Ram Usage: <used>/<xmx> (<percent>)";
+    public static String rambarCommandOutput = "<green>Rambar toggled <onoff> for <target>";
+    public static String tpsbarCommandOutput = "<green>Tpsbar toggled <onoff> for <target>";
+    public static String dontRunWithScissors = "<red><italic>Don't run with scissors!";
+    public static String uptimeCommandOutput = "<green>Server uptime is <uptime>";
+    public static String unverifiedUsername = "default";
+    public static String sleepSkippingNight = "default";
+    public static String sleepingPlayersPercent = "default";
+    public static String sleepNotPossible = "default";
+    private static void messages() {
+        cannotRideMob = getString("settings.messages.cannot-ride-mob", cannotRideMob);
+        afkBroadcastAway = getString("settings.messages.afk-broadcast-away", afkBroadcastAway);
+        afkBroadcastBack = getString("settings.messages.afk-broadcast-back", afkBroadcastBack);
+        afkBroadcastUseDisplayName = getBoolean("settings.messages.afk-broadcast-use-display-name", afkBroadcastUseDisplayName);
+        afkTabListPrefix = MiniMessage.miniMessage().serialize(MiniMessage.miniMessage().deserialize(getString("settings.messages.afk-tab-list-prefix", afkTabListPrefix)));
+        afkTabListSuffix = MiniMessage.miniMessage().serialize(MiniMessage.miniMessage().deserialize(getString("settings.messages.afk-tab-list-suffix", afkTabListSuffix)));
+        creditsCommandOutput = getString("settings.messages.credits-command-output", creditsCommandOutput);
+        demoCommandOutput = getString("settings.messages.demo-command-output", demoCommandOutput);
+        pingCommandOutput = getString("settings.messages.ping-command-output", pingCommandOutput);
+        ramCommandOutput = getString("settings.messages.ram-command-output", ramCommandOutput);
+        rambarCommandOutput = getString("settings.messages.rambar-command-output", rambarCommandOutput);
+        tpsbarCommandOutput = getString("settings.messages.tpsbar-command-output", tpsbarCommandOutput);
+        dontRunWithScissors = getString("settings.messages.dont-run-with-scissors", dontRunWithScissors);
+        uptimeCommandOutput = getString("settings.messages.uptime-command-output", uptimeCommandOutput);
+        unverifiedUsername = getString("settings.messages.unverified-username", unverifiedUsername);
+        sleepSkippingNight = getString("settings.messages.sleep-skipping-night", sleepSkippingNight);
+        sleepingPlayersPercent = getString("settings.messages.sleeping-players-percent", sleepingPlayersPercent);
+        sleepNotPossible = getString("settings.messages.sleep-not-possible", sleepNotPossible);
+    }
+
+    public static String deathMsgRunWithScissors = "<player> slipped and fell on their shears";
+    public static String deathMsgStonecutter = "<player> has sawed themself in half";
+    private static void deathMessages() {
+        deathMsgRunWithScissors = getString("settings.messages.death-message.run-with-scissors", deathMsgRunWithScissors);
+        deathMsgStonecutter = getString("settings.messages.death-message.stonecutter", deathMsgStonecutter);
+    }
+
+    public static boolean advancementOnlyBroadcastToAffectedPlayer = false;
+    public static boolean deathMessageOnlyBroadcastToAffectedPlayer = false;
+    private static void broadcastSettings() {
+        if (version < 13) {
+            boolean oldValue = getBoolean("settings.advancement.only-broadcast-to-affected-player", false);
+            set("settings.broadcasts.advancement.only-broadcast-to-affected-player", oldValue);
+            set("settings.advancement.only-broadcast-to-affected-player", null);
+        }
+        advancementOnlyBroadcastToAffectedPlayer  = getBoolean("settings.broadcasts.advancement.only-broadcast-to-affected-player", advancementOnlyBroadcastToAffectedPlayer);
+        deathMessageOnlyBroadcastToAffectedPlayer = getBoolean("settings.broadcasts.death.only-broadcast-to-affected-player", deathMessageOnlyBroadcastToAffectedPlayer);
+    }
+
+    public static double laggingThreshold = 19.0D;
+    private static void tickLoopSettings() {
+        laggingThreshold = getDouble("settings.lagging-threshold", laggingThreshold);
+    }
+
+    public static boolean disableGiveCommandDrops = false;
+    private static void disableGiveCommandDrops() {
+        disableGiveCommandDrops = getBoolean("settings.disable-give-dropping", disableGiveCommandDrops);
+    }
+
+    public static String commandRamBarTitle = "<gray>Ram<yellow>:</yellow> <used>/<xmx> (<percent>)";
+    public static BossBar.Overlay commandRamBarProgressOverlay = BossBar.Overlay.NOTCHED_20;
+    public static BossBar.Color commandRamBarProgressColorGood = BossBar.Color.GREEN;
+    public static BossBar.Color commandRamBarProgressColorMedium = BossBar.Color.YELLOW;
+    public static BossBar.Color commandRamBarProgressColorLow = BossBar.Color.RED;
+    public static String commandRamBarTextColorGood = "<gradient:#55ff55:#00aa00><text></gradient>";
+    public static String commandRamBarTextColorMedium = "<gradient:#ffff55:#ffaa00><text></gradient>";
+    public static String commandRamBarTextColorLow = "<gradient:#ff5555:#aa0000><text></gradient>";
+    public static int commandRamBarTickInterval = 20;
+    public static String commandTPSBarTitle = "<gray>TPS<yellow>:</yellow> <tps> MSPT<yellow>:</yellow> <mspt> Ping<yellow>:</yellow> <ping>ms";
+    public static BossBar.Overlay commandTPSBarProgressOverlay = BossBar.Overlay.NOTCHED_20;
+    public static TPSBarTask.FillMode commandTPSBarProgressFillMode = TPSBarTask.FillMode.MSPT;
+    public static BossBar.Color commandTPSBarProgressColorGood = BossBar.Color.GREEN;
+    public static BossBar.Color commandTPSBarProgressColorMedium = BossBar.Color.YELLOW;
+    public static BossBar.Color commandTPSBarProgressColorLow = BossBar.Color.RED;
+    public static String commandTPSBarTextColorGood = "<gradient:#55ff55:#00aa00><text></gradient>";
+    public static String commandTPSBarTextColorMedium = "<gradient:#ffff55:#ffaa00><text></gradient>";
+    public static String commandTPSBarTextColorLow = "<gradient:#ff5555:#aa0000><text></gradient>";
+    public static int commandTPSBarTickInterval = 20;
+    public static String commandCompassBarTitle = "S  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  W  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  N  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  E  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  S  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  W  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  N  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  E  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  ";
+    public static BossBar.Overlay commandCompassBarProgressOverlay = BossBar.Overlay.PROGRESS;
+    public static BossBar.Color commandCompassBarProgressColor = BossBar.Color.BLUE;
+    public static float commandCompassBarProgressPercent = 1.0F;
+    public static int commandCompassBarTickInterval = 5;
+    public static boolean commandGamemodeRequiresPermission = false;
+    public static boolean hideHiddenPlayersFromEntitySelector = false;
+    public static String uptimeFormat = "<days><hours><minutes><seconds>";
+    public static String uptimeDay = "%02d day, ";
+    public static String uptimeDays = "%02d days, ";
+    public static String uptimeHour = "%02d hour, ";
+    public static String uptimeHours = "%02d hours, ";
+    public static String uptimeMinute = "%02d minute, and ";
+    public static String uptimeMinutes = "%02d minutes, and ";
+    public static String uptimeSecond = "%02d second";
+    public static String uptimeSeconds = "%02d seconds";
+    private static void commandSettings() {
+        commandRamBarTitle = getString("settings.command.rambar.title", commandRamBarTitle);
+        commandRamBarProgressOverlay = BossBar.Overlay.valueOf(getString("settings.command.rambar.overlay", commandRamBarProgressOverlay.name()));
+        commandRamBarProgressColorGood = BossBar.Color.valueOf(getString("settings.command.rambar.progress-color.good", commandRamBarProgressColorGood.name()));
+        commandRamBarProgressColorMedium = BossBar.Color.valueOf(getString("settings.command.rambar.progress-color.medium", commandRamBarProgressColorMedium.name()));
+        commandRamBarProgressColorLow = BossBar.Color.valueOf(getString("settings.command.rambar.progress-color.low", commandRamBarProgressColorLow.name()));
+        commandRamBarTextColorGood = getString("settings.command.rambar.text-color.good", commandRamBarTextColorGood);
+        commandRamBarTextColorMedium = getString("settings.command.rambar.text-color.medium", commandRamBarTextColorMedium);
+        commandRamBarTextColorLow = getString("settings.command.rambar.text-color.low", commandRamBarTextColorLow);
+        commandRamBarTickInterval = getInt("settings.command.rambar.tick-interval", commandRamBarTickInterval);
+
+        commandTPSBarTitle = getString("settings.command.tpsbar.title", commandTPSBarTitle);
+        commandTPSBarProgressOverlay = BossBar.Overlay.valueOf(getString("settings.command.tpsbar.overlay", commandTPSBarProgressOverlay.name()));
+        commandTPSBarProgressFillMode = TPSBarTask.FillMode.valueOf(getString("settings.command.tpsbar.fill-mode", commandTPSBarProgressFillMode.name()));
+        commandTPSBarProgressColorGood = BossBar.Color.valueOf(getString("settings.command.tpsbar.progress-color.good", commandTPSBarProgressColorGood.name()));
+        commandTPSBarProgressColorMedium = BossBar.Color.valueOf(getString("settings.command.tpsbar.progress-color.medium", commandTPSBarProgressColorMedium.name()));
+        commandTPSBarProgressColorLow = BossBar.Color.valueOf(getString("settings.command.tpsbar.progress-color.low", commandTPSBarProgressColorLow.name()));
+        commandTPSBarTextColorGood = getString("settings.command.tpsbar.text-color.good", commandTPSBarTextColorGood);
+        commandTPSBarTextColorMedium = getString("settings.command.tpsbar.text-color.medium", commandTPSBarTextColorMedium);
+        commandTPSBarTextColorLow = getString("settings.command.tpsbar.text-color.low", commandTPSBarTextColorLow);
+        commandTPSBarTickInterval = getInt("settings.command.tpsbar.tick-interval", commandTPSBarTickInterval);
+
+        commandCompassBarTitle = getString("settings.command.compass.title", commandCompassBarTitle);
+        commandCompassBarProgressOverlay = BossBar.Overlay.valueOf(getString("settings.command.compass.overlay", commandCompassBarProgressOverlay.name()));
+        commandCompassBarProgressColor = BossBar.Color.valueOf(getString("settings.command.compass.progress-color", commandCompassBarProgressColor.name()));
+        commandCompassBarProgressPercent = (float) getDouble("settings.command.compass.percent", commandCompassBarProgressPercent);
+        commandCompassBarTickInterval = getInt("settings.command.compass.tick-interval", commandCompassBarTickInterval);
+
+        commandGamemodeRequiresPermission = getBoolean("settings.command.gamemode.requires-specific-permission", commandGamemodeRequiresPermission);
+        hideHiddenPlayersFromEntitySelector = getBoolean("settings.command.hide-hidden-players-from-entity-selector", hideHiddenPlayersFromEntitySelector);
+        uptimeFormat = getString("settings.command.uptime.format", uptimeFormat);
+        uptimeDay = getString("settings.command.uptime.day", uptimeDay);
+        uptimeDays = getString("settings.command.uptime.days", uptimeDays);
+        uptimeHour = getString("settings.command.uptime.hour", uptimeHour);
+        uptimeHours = getString("settings.command.uptime.hours", uptimeHours);
+        uptimeMinute = getString("settings.command.uptime.minute", uptimeMinute);
+        uptimeMinutes = getString("settings.command.uptime.minutes", uptimeMinutes);
+        uptimeSecond = getString("settings.command.uptime.second", uptimeSecond);
+        uptimeSeconds = getString("settings.command.uptime.seconds", uptimeSeconds);
+    }
+
+    public static int barrelRows = 3;
+    public static boolean enderChestSixRows = false;
+    public static boolean enderChestPermissionRows = false;
+    public static boolean cryingObsidianValidForPortalFrame = false;
+    public static int beeInsideBeeHive = 3;
+    public static boolean anvilCumulativeCost = true;
+    public static int smoothSnowAccumulationStep = 0;
+    public static int lightningRodRange = 128;
+    public static Set<Enchantment> grindstoneIgnoredEnchants = new HashSet<>();
+    public static boolean grindstoneRemoveAttributes = false;
+    public static boolean grindstoneRemoveDisplay = false;
+    public static int caveVinesMaxGrowthAge = 25;
+    public static int kelpMaxGrowthAge = 25;
+    public static int twistingVinesMaxGrowthAge = 25;
+    public static int weepingVinesMaxGrowthAge = 25;
+    public static boolean magmaBlockReverseBubbleColumnFlow = false;
+    public static boolean soulSandBlockReverseBubbleColumnFlow = false;
+    private static void blockSettings() {
+        if (version < 3) {
+            boolean oldValue = getBoolean("settings.barrel.packed-barrels", true);
+            set("settings.blocks.barrel.six-rows", oldValue);
+            set("settings.packed-barrels", null);
+            oldValue = getBoolean("settings.large-ender-chests", true);
+            set("settings.blocks.ender_chest.six-rows", oldValue);
+            set("settings.large-ender-chests", null);
+        }
+        if (version < 20) {
+            boolean oldValue = getBoolean("settings.blocks.barrel.six-rows", false);
+            set("settings.blocks.barrel.rows", oldValue ? 6 : 3);
+            set("settings.blocks.barrel.six-rows", null);
+        }
+        barrelRows = getInt("settings.blocks.barrel.rows", barrelRows);
+        if (barrelRows < 1 || barrelRows > 6) {
+            Bukkit.getLogger().severe("settings.blocks.barrel.rows must be 1-6, resetting to default");
+            barrelRows = 3;
+        }
+        org.bukkit.event.inventory.InventoryType.BARREL.setDefaultSize(switch (barrelRows) {
+            case 6 -> 54;
+            case 5 -> 45;
+            case 4 -> 36;
+            case 2 -> 18;
+            case 1 -> 9;
+            default -> 27;
+        });
+        enderChestSixRows = getBoolean("settings.blocks.ender_chest.six-rows", enderChestSixRows);
+        org.bukkit.event.inventory.InventoryType.ENDER_CHEST.setDefaultSize(enderChestSixRows ? 54 : 27);
+        enderChestPermissionRows = getBoolean("settings.blocks.ender_chest.use-permissions-for-rows", enderChestPermissionRows);
+        cryingObsidianValidForPortalFrame = getBoolean("settings.blocks.crying_obsidian.valid-for-portal-frame", cryingObsidianValidForPortalFrame);
+        beeInsideBeeHive = getInt("settings.blocks.beehive.max-bees-inside", beeInsideBeeHive);
+        anvilCumulativeCost = getBoolean("settings.blocks.anvil.cumulative-cost", anvilCumulativeCost);
+        smoothSnowAccumulationStep = getInt("settings.blocks.snow.smooth-accumulation-step", smoothSnowAccumulationStep);
+        if (smoothSnowAccumulationStep > 7) {
+            smoothSnowAccumulationStep = 7;
+            log(Level.WARNING, "blocks.snow.smooth-accumulation-step is set to above maximum allowed value of 7");
+            log(Level.WARNING, "Using value of 7 to prevent issues");
+        } else if (smoothSnowAccumulationStep < 0) {
+            smoothSnowAccumulationStep = 0;
+            log(Level.WARNING, "blocks.snow.smooth-accumulation-step is set to below minimum allowed value of 0");
+            log(Level.WARNING, "Using value of 0 to prevent issues");
+        }
+        lightningRodRange = getInt("settings.blocks.lightning_rod.range", lightningRodRange);
+        ArrayList<String> defaultCurses = new ArrayList<>(){{
+            add("minecraft:binding_curse");
+            add("minecraft:vanishing_curse");
+        }};
+        if (version < 24 && !getBoolean("settings.blocks.grindstone.ignore-curses", true)) {
+            defaultCurses.clear();
+        }
+        getList("settings.blocks.grindstone.ignored-enchants", defaultCurses).forEach(key -> {
+            Registry<Enchantment> registry = MinecraftServer.getServer().registryAccess().lookupOrThrow(Registries.ENCHANTMENT);
+            Enchantment enchantment = registry.getValue(Identifier.parse(key.toString()));
+            if (enchantment == null) return;
+            grindstoneIgnoredEnchants.add(enchantment);
+        });
+        grindstoneRemoveAttributes = getBoolean("settings.blocks.grindstone.remove-attributes", grindstoneRemoveAttributes);
+        grindstoneRemoveDisplay = getBoolean("settings.blocks.grindstone.remove-name-and-lore", grindstoneRemoveDisplay);
+        caveVinesMaxGrowthAge = getInt("settings.blocks.cave_vines.max-growth-age", caveVinesMaxGrowthAge);
+        if (caveVinesMaxGrowthAge > 25) {
+            caveVinesMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.cave_vines.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        kelpMaxGrowthAge = getInt("settings.blocks.kelp.max-growth-age", kelpMaxGrowthAge);
+        if (kelpMaxGrowthAge > 25) {
+            kelpMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.kelp.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        twistingVinesMaxGrowthAge = getInt("settings.blocks.twisting_vines.max-growth-age", twistingVinesMaxGrowthAge);
+        if (twistingVinesMaxGrowthAge > 25) {
+            twistingVinesMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.twisting_vines.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        weepingVinesMaxGrowthAge = getInt("settings.blocks.weeping_vines.max-growth-age", weepingVinesMaxGrowthAge);
+        if (weepingVinesMaxGrowthAge > 25) {
+            weepingVinesMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.weeping_vines.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        magmaBlockReverseBubbleColumnFlow = getBoolean("settings.blocks.magma-block.reverse-bubble-column-flow", magmaBlockReverseBubbleColumnFlow);
+        soulSandBlockReverseBubbleColumnFlow = getBoolean("settings.blocks.soul-sand.reverse-bubble-column-flow", soulSandBlockReverseBubbleColumnFlow);
+    }
+
+    public static boolean allowInapplicableEnchants = false;
+    public static boolean allowIncompatibleEnchants = false;
+    public static boolean allowHigherEnchantsLevels = false;
+    public static boolean allowUnsafeEnchantCommand = false;
+    public static boolean replaceIncompatibleEnchants = false;
+    public static boolean clampEnchantLevels = true;
+    private static void enchantmentSettings() {
+        if (version < 30) {
+            boolean oldValue = getBoolean("settings.enchantment.allow-unsafe-enchants", false);
+            set("settings.enchantment.anvil.allow-unsafe-enchants", oldValue);
+            set("settings.enchantment.anvil.allow-inapplicable-enchants", true);
+            set("settings.enchantment.anvil.allow-incompatible-enchants", true);
+            set("settings.enchantment.anvil.allow-higher-enchants-levels", true);
+            set("settings.enchantment.allow-unsafe-enchants", null);
+        }
+        if (version < 37) {
+            boolean allowUnsafeEnchants = getBoolean("settings.enchantment.anvil.allow-unsafe-enchants", false);
+            if (!allowUnsafeEnchants) {
+                set("settings.enchantment.anvil.allow-inapplicable-enchants", false);
+                set("settings.enchantment.anvil.allow-incompatible-enchants", false);
+                set("settings.enchantment.anvil.allow-higher-enchants-levels", false);
+            }
+            set("settings.enchantment.anvil.allow-unsafe-enchants", null);
+        }
+        allowInapplicableEnchants = getBoolean("settings.enchantment.anvil.allow-inapplicable-enchants", allowInapplicableEnchants);
+        allowIncompatibleEnchants = getBoolean("settings.enchantment.anvil.allow-incompatible-enchants", allowIncompatibleEnchants);
+        allowHigherEnchantsLevels = getBoolean("settings.enchantment.anvil.allow-higher-enchants-levels", allowHigherEnchantsLevels);
+        allowUnsafeEnchantCommand = getBoolean("settings.enchantment.allow-unsafe-enchant-command", allowUnsafeEnchantCommand);
+        replaceIncompatibleEnchants = getBoolean("settings.enchantment.anvil.replace-incompatible-enchants", replaceIncompatibleEnchants);
+        clampEnchantLevels = getBoolean("settings.enchantment.clamp-levels", clampEnchantLevels);
+    }
+
+    public static boolean endermanShortHeight = false;
+    private static void entitySettings() {
+        endermanShortHeight = getBoolean("settings.entity.enderman.short-height", endermanShortHeight);
+        if (endermanShortHeight) EntityType.ENDERMAN.dimensions = EntityDimensions.scalable(0.6F, 1.9F);
+    }
+
+    public static boolean allowWaterPlacementInTheEnd = true;
+    private static void allowWaterPlacementInEnd() {
+        allowWaterPlacementInTheEnd = getBoolean("settings.allow-water-placement-in-the-end", allowWaterPlacementInTheEnd);
+    }
+
+    public static boolean beeCountPayload = false;
+    private static void beeCountPayload() {
+        beeCountPayload = getBoolean("settings.bee-count-payload", beeCountPayload);
+    }
+
+    public static boolean tpsCatchup = true;
+    private static void tpsCatchup() {
+        tpsCatchup = getBoolean("settings.tps-catchup", tpsCatchup);
+    }
+
+    public static boolean useUPnP = false;
+    public static boolean maxJoinsPerSecond = false;
+    private static void networkSettings() {
+        useUPnP = getBoolean("settings.network.upnp-port-forwarding", useUPnP);
+        maxJoinsPerSecond = getBoolean("settings.network.max-joins-per-second", maxJoinsPerSecond);
+    }
+
+    public static Pattern usernameValidCharactersPattern;
+    private static void usernameValidationSettings() {
+        String defaultPattern = "^[a-zA-Z0-9_.]*$";
+        String setPattern = getString("settings.username-valid-characters", defaultPattern);
+        usernameValidCharactersPattern = Pattern.compile(setPattern == null || setPattern.isBlank() ? defaultPattern : setPattern);
+    }
+
+    public static boolean fixProjectileLootingTransfer = false;
+    private static void fixProjectileLootingTransfer() {
+        fixProjectileLootingTransfer = getBoolean("settings.fix-projectile-looting-transfer", fixProjectileLootingTransfer);
+    }
+
+    public static boolean clampAttributes = true;
+    private static void clampAttributes() {
+        clampAttributes = getBoolean("settings.clamp-attributes", clampAttributes);
+    }
+
+    public static boolean limitArmor = true;
+    private static void limitArmor() {
+        limitArmor = getBoolean("settings.limit-armor", limitArmor);
+    }
+
+    private static void blastResistanceSettings() {
+        getMap("settings.blast-resistance-overrides", Collections.emptyMap()).forEach((blockId, value) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(blockId));
+            if (block == Blocks.AIR) {
+                log(Level.SEVERE, "Invalid block for `settings.blast-resistance-overrides`: " + blockId);
+                return;
+            }
+            if (!(value instanceof Number blastResistance)) {
+                log(Level.SEVERE, "Invalid blast resistance for `settings.blast-resistance-overrides." + blockId + "`: " + value);
+                return;
+            }
+            block.explosionResistance = blastResistance.floatValue();
+        });
+    }
+    private static void blockFallMultiplierSettings() {
+        getMap("settings.block-fall-multipliers", Map.ofEntries(
+                Map.entry("minecraft:hay_block", Map.of("damage", 0.2F)),
+                Map.entry("minecraft:white_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:light_gray_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:gray_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:black_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:brown_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:pink_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:red_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:orange_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:yellow_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:green_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:lime_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:cyan_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:light_blue_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:blue_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:purple_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:magenta_bed", Map.of("distance", 0.5F))
+        )).forEach((blockId, value) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(blockId));
+            if (block == Blocks.AIR) {
+                log(Level.SEVERE, "Invalid block for `settings.block-fall-multipliers`: " + blockId);
+                return;
+            }
+            if (!(value instanceof Map<?, ?> map)) {
+                log(Level.SEVERE, "Invalid fall multiplier for `settings.block-fall-multipliers." + blockId + "`: " + value
+                        + ", expected a map with keys `damage` and `distance` to floats.");
+                return;
+            }
+            Object rawFallDamageMultiplier = map.get("damage");
+            if (rawFallDamageMultiplier == null) rawFallDamageMultiplier = 1F;
+            if (!(rawFallDamageMultiplier instanceof Number fallDamageMultiplier)) {
+                log(Level.SEVERE, "Invalid multiplier for `settings.block-fall-multipliers." + blockId + ".damage`: " + map.get("damage"));
+                return;
+            }
+            Object rawFallDistanceMultiplier = map.get("distance");
+            if (rawFallDistanceMultiplier == null) rawFallDistanceMultiplier = 1F;
+            if (!(rawFallDistanceMultiplier instanceof Number fallDistanceMultiplier)) {
+                log(Level.SEVERE, "Invalid multiplier for `settings.block-fall-multipliers." + blockId + ".distance`: " + map.get("distance"));
+                return;
+            }
+            block.fallDamageMultiplier = fallDamageMultiplier.floatValue();
+            block.fallDistanceMultiplier = fallDistanceMultiplier.floatValue();
+        });
+    }
+
+    public static boolean playerDeathsAlwaysShowItem = false;
+    private static void playerDeathsAlwaysShowItem() {
+        playerDeathsAlwaysShowItem = getBoolean("settings.player-deaths-always-show-item", playerDeathsAlwaysShowItem);
+    }
+
+    public static boolean registerMinecraftDebugCommands = false;
+    private static void registerMinecraftDebugCommands() {
+        registerMinecraftDebugCommands = getBoolean("settings.register-minecraft-debug-commands", registerMinecraftDebugCommands);
+    }
+
+    public static boolean registerMinecraftDisabledCommands = false;
+    private static void registerMinecraftDisabledCommands() {
+        registerMinecraftDisabledCommands = getBoolean("settings.register-minecraft-disabled-commands", registerMinecraftDebugCommands);
+    }
+
+    public static List<String> startupCommands = new ArrayList<>();
+    private static void startupCommands() {
+        startupCommands.clear();
+        getList("settings.startup-commands", new ArrayList<String>()).forEach(line -> {
+            String command = line.toString();
+            if (command.startsWith("/")) {
+                command = command.substring(1);
+            }
+            startupCommands.add(command);
+        });
+    }
+}
diff --git a/org/purpurmc/purpur/PurpurWorldConfig.java b/org/purpurmc/purpur/PurpurWorldConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..a79031ac8c4752ffc436324f14fd668537ca8f68
--- /dev/null
+++ b/org/purpurmc/purpur/PurpurWorldConfig.java
@@ -0,0 +1,3817 @@
+package org.purpurmc.purpur;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.logging.Level;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.Identifier;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.Shulker;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.properties.Tilt;
+import org.apache.commons.lang3.BooleanUtils;
+import org.bukkit.ChatColor;
+import org.bukkit.World;
+import org.bukkit.configuration.ConfigurationSection;
+import java.util.List;
+import java.util.Map;
+import org.purpurmc.purpur.tool.Flattenable;
+import org.purpurmc.purpur.tool.Strippable;
+import org.purpurmc.purpur.tool.Tillable;
+import org.purpurmc.purpur.tool.Waxable;
+import org.purpurmc.purpur.tool.Weatherable;
+
+import static org.purpurmc.purpur.PurpurConfig.log;
+
+@SuppressWarnings("unused")
+public class PurpurWorldConfig {
+
+    private final String worldName;
+    private final World.Environment environment;
+
+    public PurpurWorldConfig(String worldName, World.Environment environment) {
+        this.worldName = worldName;
+        this.environment = environment;
+        init();
+    }
+
+    public void init() {
+        log("-------- World Settings For [" + worldName + "] --------");
+        PurpurConfig.readConfig(PurpurWorldConfig.class, this);
+    }
+
+    private void set(String path, Object val) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null || val == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, val);
+            PurpurConfig.config.set("world-settings.default." + path, val);
+        }
+        if (PurpurConfig.config.get("world-settings." + worldName + "." + path) != null) {
+            PurpurConfig.config.addDefault("world-settings." + worldName + "." + path, val);
+            PurpurConfig.config.set("world-settings." + worldName + "." + path, val);
+        }
+    }
+
+    private ConfigurationSection getConfigurationSection(String path) {
+        ConfigurationSection section = PurpurConfig.config.getConfigurationSection("world-settings." + worldName + "." + path);
+        return section != null ? section : PurpurConfig.config.getConfigurationSection("world-settings.default." + path);
+    }
+
+    private String getString(String path, String def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getString("world-settings." + worldName + "." + path, PurpurConfig.config.getString("world-settings.default." + path));
+    }
+
+    private boolean getBoolean(String path, boolean def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getBoolean("world-settings." + worldName + "." + path, PurpurConfig.config.getBoolean("world-settings.default." + path));
+    }
+
+    private boolean getBoolean(String path, Predicate<Boolean> predicate) {
+        String val = getString(path, "default").toLowerCase();
+        Boolean bool = BooleanUtils.toBooleanObject(val, "true", "false", "default");
+        return predicate.test(bool);
+    }
+
+    private Boolean getBooleanOrDefault(String path, Boolean def) {
+        String val = getString(path, BooleanUtils.toString(def, "true", "false", "default")).toLowerCase();
+        return BooleanUtils.toBooleanObject(val, "true", "false", "default");
+    }
+
+    private double getDouble(String path, double def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getDouble("world-settings." + worldName + "." + path, PurpurConfig.config.getDouble("world-settings.default." + path));
+    }
+
+    private int getInt(String path, int def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getInt("world-settings." + worldName + "." + path, PurpurConfig.config.getInt("world-settings.default." + path));
+    }
+
+    private <T> List<?> getList(String path, T def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getList("world-settings." + worldName + "." + path, PurpurConfig.config.getList("world-settings.default." + path));
+    }
+
+    private Map<String, Object> getMap(String path, Map<String, Object> def) {
+        final Map<String, Object> fallback = PurpurConfig.getMap("world-settings.default." + path, def);
+        final Map<String, Object> value = PurpurConfig.getMap("world-settings." + worldName + "." + path, null);
+        return value.isEmpty() ? fallback : value;
+    }
+
+    public float armorstandStepHeight = 0.0F;
+    public boolean armorstandSetNameVisible = false;
+    public boolean armorstandFixNametags = false;
+    public boolean armorstandMovement = true;
+    public boolean armorstandWaterMovement = true;
+    public boolean armorstandWaterFence = true;
+    public boolean armorstandPlaceWithArms = false;
+    private void armorstandSettings() {
+        armorstandStepHeight = (float) getDouble("gameplay-mechanics.armorstand.step-height", armorstandStepHeight);
+        armorstandSetNameVisible = getBoolean("gameplay-mechanics.armorstand.set-name-visible-when-placing-with-custom-name", armorstandSetNameVisible);
+        armorstandFixNametags = getBoolean("gameplay-mechanics.armorstand.fix-nametags", armorstandFixNametags);
+        armorstandMovement = getBoolean("gameplay-mechanics.armorstand.can-movement-tick", armorstandMovement);
+        armorstandWaterMovement = getBoolean("gameplay-mechanics.armorstand.can-move-in-water", armorstandWaterMovement);
+        armorstandWaterFence = getBoolean("gameplay-mechanics.armorstand.can-move-in-water-over-fence", armorstandWaterFence);
+        armorstandPlaceWithArms = getBoolean("gameplay-mechanics.armorstand.place-with-arms-visible", armorstandPlaceWithArms);
+    }
+
+    public boolean useBetterMending = false;
+    public boolean alwaysTameInCreative = false;
+    public boolean boatEjectPlayersOnLand = false;
+    public boolean boatsDoFallDamage = false;
+    public boolean disableDropsOnCrammingDeath = false;
+    public boolean milkCuresBadOmen = true;
+    public double tridentLoyaltyVoidReturnHeight = 0.0D;
+    public boolean entitiesCanUsePortals = true;
+    public int raidCooldownSeconds = 0;
+    public int animalBreedingCooldownSeconds = 0;
+    public boolean persistentDroppableEntityDisplayNames = true;
+    public Boolean entitiesPickUpLootMobGriefingOverride = null;
+    public Boolean fireballsMobGriefingOverride = null;
+    public Boolean projectilesMobGriefingOverride = null;
+    public boolean noteBlockIgnoreAbove = false;
+    public boolean imposeTeleportRestrictionsOnGateways = false;
+    public boolean imposeTeleportRestrictionsOnNetherPortals = false;
+    public boolean imposeTeleportRestrictionsOnEndPortals = false;
+    public boolean tickFluids = true;
+    public double mobsBlindnessMultiplier = 1;
+    public boolean mobsIgnoreRails = false;
+    public boolean rainStopsAfterSleep = true;
+    public boolean thunderStopsAfterSleep = true;
+    public boolean persistentTileEntityLore = false;
+    public boolean persistentTileEntityDisplayName = true;
+    public int mobLastHurtByPlayerTime = 100;
+    public boolean milkClearsBeneficialEffects = true;
+    public boolean disableOxidationProximityPenalty = false;
+    private void miscGameplayMechanicsSettings() {
+        useBetterMending = getBoolean("gameplay-mechanics.use-better-mending", useBetterMending);
+        alwaysTameInCreative = getBoolean("gameplay-mechanics.always-tame-in-creative", alwaysTameInCreative);
+        boatEjectPlayersOnLand = getBoolean("gameplay-mechanics.boat.eject-players-on-land", boatEjectPlayersOnLand);
+        boatsDoFallDamage = getBoolean("gameplay-mechanics.boat.do-fall-damage", boatsDoFallDamage);
+        disableDropsOnCrammingDeath = getBoolean("gameplay-mechanics.disable-drops-on-cramming-death", disableDropsOnCrammingDeath);
+        milkCuresBadOmen = getBoolean("gameplay-mechanics.milk-cures-bad-omen", milkCuresBadOmen);
+        tridentLoyaltyVoidReturnHeight = getDouble("gameplay-mechanics.trident-loyalty-void-return-height", tridentLoyaltyVoidReturnHeight);
+        entitiesCanUsePortals = getBoolean("gameplay-mechanics.entities-can-use-portals", entitiesCanUsePortals);
+        raidCooldownSeconds = getInt("gameplay-mechanics.raid-cooldown-seconds", raidCooldownSeconds);
+        animalBreedingCooldownSeconds = getInt("gameplay-mechanics.animal-breeding-cooldown-seconds", animalBreedingCooldownSeconds);
+        persistentDroppableEntityDisplayNames = getBoolean("gameplay-mechanics.persistent-droppable-entity-display-names", persistentDroppableEntityDisplayNames);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("gameplay-mechanics.entities-pick-up-loot-bypass-mob-griefing", false);
+            set("gameplay-mechanics.entities-pick-up-loot-bypass-mob-griefing", null);
+            set("gameplay-mechanics.entities-pick-up-loot-mob-griefing-override", oldVal ? true : "default");
+            boolean oldVal2 = getBoolean("gameplay-mechanics.fireballs-bypass-mob-griefing", false);
+            set("gameplay-mechanics.fireballs-bypass-mob-griefing", null);
+            set("gameplay-mechanics.fireballs-mob-griefing-override", oldVal2 ? true : "default");
+            boolean oldVal3 = getBoolean("gameplay-mechanics.projectiles-bypass-mob-griefing", false);
+            set("gameplay-mechanics.projectiles-bypass-mob-griefing", null);
+            set("gameplay-mechanics.projectiles-mob-griefing-override", oldVal3 ? true : "default");
+        }
+        if (PurpurConfig.version < 47) {
+            boolean oldVal = getBoolean("gameplay-mechanics.entities-pick-up-loot-mob-griefing-override", false);
+            set("gameplay-mechanics.entities-pick-up-loot-mob-griefing-override", null);
+            set("mobs.allay.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.bogged.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.drowned.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.fox.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.husk.can-pick-up-loot", oldVal ? true : "default");
+            // mobs.piglin.can-pick-up-loot replaces mobs.piglin.mob-griefing-override
+            set("mobs.piglin_brute.can-pick-up-loot", oldVal ? true : "default");
+            // mobs.pillager.can-pick-up-loot replaces mobs.pillager.mob-griefing-override
+            set("mobs.skeleton.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.stray.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.villager.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.vindicator.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.wither_skeleton.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.zombie.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.zombie_villager.can-pick-up-loot", oldVal ? true : "default");
+            set("mobs.zombified_piglin.can-pick-up-loot", oldVal ? true : "default");
+        }
+        fireballsMobGriefingOverride = getBooleanOrDefault("gameplay-mechanics.fireballs-mob-griefing-override", fireballsMobGriefingOverride);
+        projectilesMobGriefingOverride = getBooleanOrDefault("gameplay-mechanics.projectiles-mob-griefing-override", projectilesMobGriefingOverride);
+        noteBlockIgnoreAbove = getBoolean("gameplay-mechanics.note-block-ignore-above", noteBlockIgnoreAbove);
+        imposeTeleportRestrictionsOnGateways = getBoolean("gameplay-mechanics.impose-teleport-restrictions-on-gateways", imposeTeleportRestrictionsOnGateways);
+        imposeTeleportRestrictionsOnNetherPortals = getBoolean("gameplay-mechanics.impose-teleport-restrictions-on-nether-portals", imposeTeleportRestrictionsOnNetherPortals);
+        imposeTeleportRestrictionsOnEndPortals = getBoolean("gameplay-mechanics.impose-teleport-restrictions-on-end-portals", imposeTeleportRestrictionsOnEndPortals);
+        tickFluids = getBoolean("gameplay-mechanics.tick-fluids", tickFluids);
+        mobsBlindnessMultiplier = getDouble("gameplay-mechanics.entity-blindness-multiplier", mobsBlindnessMultiplier);
+        mobsIgnoreRails = getBoolean("gameplay-mechanics.mobs-ignore-rails", mobsIgnoreRails);
+        rainStopsAfterSleep = getBoolean("gameplay-mechanics.rain-stops-after-sleep", rainStopsAfterSleep);
+        thunderStopsAfterSleep = getBoolean("gameplay-mechanics.thunder-stops-after-sleep", thunderStopsAfterSleep);
+        if (PurpurConfig.version < 35) {
+            boolean oldVal = getBoolean("gameplay-mechanics.persistent-tileentity-display-names-and-lore", persistentTileEntityLore);
+            set("gameplay-mechanics.persistent-tileentity-display-names-and-lore", null);
+            set("gameplay-mechanics.persistent-tileentity-lore", oldVal);
+            set("gameplay-mechanics.persistent-tileentity-display-name", !oldVal);
+        }
+        persistentTileEntityLore = getBoolean("gameplay-mechanics.persistent-tileentity-lore", persistentTileEntityLore);
+        persistentTileEntityDisplayName = getBoolean("gameplay-mechanics.persistent-tileentity-display-name", persistentTileEntityDisplayName);
+        mobLastHurtByPlayerTime = getInt("gameplay-mechanics.mob-last-hurt-by-player-time", mobLastHurtByPlayerTime);
+        milkClearsBeneficialEffects = getBoolean("gameplay-mechanics.milk-clears-beneficial-effects", milkClearsBeneficialEffects);
+        disableOxidationProximityPenalty = getBoolean("gameplay-mechanics.disable-oxidation-proximity-penalty", disableOxidationProximityPenalty);
+    }
+
+    public int daytimeTicks = 12000;
+    public int nighttimeTicks = 12000;
+    private void daytimeCycleSettings() {
+        daytimeTicks = getInt("gameplay-mechanics.daylight-cycle-ticks.daytime", daytimeTicks);
+        nighttimeTicks = getInt("gameplay-mechanics.daylight-cycle-ticks.nighttime", nighttimeTicks);
+    }
+
+    public int drowningAirTicks = 300;
+    public int drowningDamageInterval = 20;
+    public double damageFromDrowning = 2.0F;
+    private void drowningSettings() {
+        drowningAirTicks = getInt("gameplay-mechanics.drowning.air-ticks", drowningAirTicks);
+        drowningDamageInterval = getInt("gameplay-mechanics.drowning.ticks-per-damage", drowningDamageInterval);
+        damageFromDrowning = getDouble("gameplay-mechanics.drowning.damage-from-drowning", damageFromDrowning);
+    }
+
+    public int elytraDamagePerSecond = 1;
+    public double elytraDamageMultiplyBySpeed = 0;
+    public int elytraDamagePerFireworkBoost = 0;
+    public int elytraDamagePerTridentBoost = 0;
+    public boolean elytraKineticDamage = true;
+    private void elytraSettings() {
+        elytraDamagePerSecond = getInt("gameplay-mechanics.elytra.damage-per-second", elytraDamagePerSecond);
+        elytraDamageMultiplyBySpeed = getDouble("gameplay-mechanics.elytra.damage-multiplied-by-speed", elytraDamageMultiplyBySpeed);
+        elytraDamagePerFireworkBoost = getInt("gameplay-mechanics.elytra.damage-per-boost.firework", elytraDamagePerFireworkBoost);
+        elytraDamagePerTridentBoost = getInt("gameplay-mechanics.elytra.damage-per-boost.trident", elytraDamagePerTridentBoost);
+        elytraKineticDamage = getBoolean("gameplay-mechanics.elytra.kinetic-damage", elytraKineticDamage);
+    }
+
+    public int entityLifeSpan = 0;
+    public float entityLeftHandedChance = 0.05f;
+    public boolean entitySharedRandom = true;
+    private void entitySettings() {
+        entityLifeSpan = getInt("gameplay-mechanics.entity-lifespan", entityLifeSpan);
+        entityLeftHandedChance = (float) getDouble("gameplay-mechanics.entity-left-handed-chance", entityLeftHandedChance);
+        entitySharedRandom = getBoolean("settings.entity.shared-random", entitySharedRandom);
+    }
+
+    public boolean infinityWorksWithoutArrows = false;
+    private void infinityArrowsSettings() {
+        infinityWorksWithoutArrows = getBoolean("gameplay-mechanics.infinity-bow.works-without-arrows", infinityWorksWithoutArrows);
+    }
+
+    public List<Item> itemImmuneToCactus = new ArrayList<>();
+    public List<Item> itemImmuneToExplosion = new ArrayList<>();
+    public List<Item> itemImmuneToFire = new ArrayList<>();
+    public List<Item> itemImmuneToLightning = new ArrayList<>();
+    public boolean dontRunWithScissors = false;
+    public Identifier dontRunWithScissorsItemModelReference = Identifier.parse("purpurmc:scissors");
+    public boolean ignoreScissorsInWater = false;
+    public boolean ignoreScissorsInLava = false;
+    public double scissorsRunningDamage = 1D;
+    public float enderPearlDamage = 5.0F;
+    public int enderPearlCooldown = 20;
+    public int enderPearlCooldownCreative = 20;
+    public float enderPearlEndermiteChance = 0.05F;
+    public int glowBerriesEatGlowDuration = 0;
+    public boolean shulkerBoxItemDropContentsWhenDestroyed = true;
+    public boolean compassItemShowsBossBar = false;
+    public boolean snowballExtinguishesFire = false;
+    public boolean snowballExtinguishesCandles = false;
+    public boolean snowballExtinguishesCampfires = false;
+    private void itemSettings() {
+        itemImmuneToCactus.clear();
+        getList("gameplay-mechanics.item.immune.cactus", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToCactus.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToCactus.add(item);
+        });
+        itemImmuneToExplosion.clear();
+        getList("gameplay-mechanics.item.immune.explosion", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToExplosion.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToExplosion.add(item);
+        });
+        itemImmuneToFire.clear();
+        getList("gameplay-mechanics.item.immune.fire", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToFire.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToFire.add(item);
+        });
+        itemImmuneToLightning.clear();
+        getList("gameplay-mechanics.item.immune.lightning", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToLightning.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToLightning.add(item);
+        });
+        dontRunWithScissors = getBoolean("gameplay-mechanics.item.shears.damage-if-sprinting", dontRunWithScissors);
+        dontRunWithScissorsItemModelReference = Identifier.parse(getString("gameplay-mechanics.item.shears.damage-if-sprinting-item-model", "purpurmc:scissors"));
+        ignoreScissorsInWater = getBoolean("gameplay-mechanics.item.shears.ignore-in-water", ignoreScissorsInWater);
+        ignoreScissorsInLava = getBoolean("gameplay-mechanics.item.shears.ignore-in-lava", ignoreScissorsInLava);
+        scissorsRunningDamage = getDouble("gameplay-mechanics.item.shears.sprinting-damage", scissorsRunningDamage);
+        enderPearlDamage = (float) getDouble("gameplay-mechanics.item.ender-pearl.damage", enderPearlDamage);
+        enderPearlCooldown = getInt("gameplay-mechanics.item.ender-pearl.cooldown", enderPearlCooldown);
+        enderPearlCooldownCreative = getInt("gameplay-mechanics.item.ender-pearl.creative-cooldown", enderPearlCooldownCreative);
+        enderPearlEndermiteChance = (float) getDouble("gameplay-mechanics.item.ender-pearl.endermite-spawn-chance", enderPearlEndermiteChance);
+        glowBerriesEatGlowDuration = getInt("gameplay-mechanics.item.glow_berries.eat-glow-duration", glowBerriesEatGlowDuration);
+        shulkerBoxItemDropContentsWhenDestroyed = getBoolean("gameplay-mechanics.item.shulker_box.drop-contents-when-destroyed", shulkerBoxItemDropContentsWhenDestroyed);
+        compassItemShowsBossBar = getBoolean("gameplay-mechanics.item.compass.holding-shows-bossbar", compassItemShowsBossBar);
+        snowballExtinguishesFire = getBoolean("gameplay-mechanics.item.snowball.extinguish.fire", snowballExtinguishesFire);
+        snowballExtinguishesCandles = getBoolean("gameplay-mechanics.item.snowball.extinguish.candles", snowballExtinguishesCandles);
+        snowballExtinguishesCampfires = getBoolean("gameplay-mechanics.item.snowball.extinguish.campfires", snowballExtinguishesCampfires);
+    }
+
+    public double minecartMaxSpeed = 0.4D;
+    public boolean minecartPlaceAnywhere = false;
+    public boolean minecartControllable = false;
+    public float minecartControllableStepHeight = 1.0F;
+    public double minecartControllableHopBoost = 0.5D;
+    public boolean minecartControllableFallDamage = true;
+    public double minecartControllableBaseSpeed = 0.1D;
+    public Map<Block, Double> minecartControllableBlockSpeeds = new HashMap<>();
+    public double poweredRailBoostModifier = 0.06;
+    private void minecartSettings() {
+        if (PurpurConfig.version < 12) {
+            boolean oldBool = getBoolean("gameplay-mechanics.controllable-minecarts.place-anywhere", minecartPlaceAnywhere);
+            set("gameplay-mechanics.controllable-minecarts.place-anywhere", null);
+            set("gameplay-mechanics.minecart.place-anywhere", oldBool);
+            oldBool = getBoolean("gameplay-mechanics.controllable-minecarts.enabled", minecartControllable);
+            set("gameplay-mechanics.controllable-minecarts.enabled", null);
+            set("gameplay-mechanics.minecart.controllable.enabled", oldBool);
+            double oldDouble = getDouble("gameplay-mechanics.controllable-minecarts.step-height", minecartControllableStepHeight);
+            set("gameplay-mechanics.controllable-minecarts.step-height", null);
+            set("gameplay-mechanics.minecart.controllable.step-height", oldDouble);
+            oldDouble = getDouble("gameplay-mechanics.controllable-minecarts.hop-boost", minecartControllableHopBoost);
+            set("gameplay-mechanics.controllable-minecarts.hop-boost", null);
+            set("gameplay-mechanics.minecart.controllable.hop-boost", oldDouble);
+            oldBool = getBoolean("gameplay-mechanics.controllable-minecarts.fall-damage", minecartControllableFallDamage);
+            set("gameplay-mechanics.controllable-minecarts.fall-damage", null);
+            set("gameplay-mechanics.minecart.controllable.fall-damage", oldBool);
+            oldDouble = getDouble("gameplay-mechanics.controllable-minecarts.base-speed", minecartControllableBaseSpeed);
+            set("gameplay-mechanics.controllable-minecarts.base-speed", null);
+            set("gameplay-mechanics.minecart.controllable.base-speed", oldDouble);
+            ConfigurationSection section = getConfigurationSection("gameplay-mechanics.controllable-minecarts.block-speed");
+            if (section != null) {
+                for (String key : section.getKeys(false)) {
+                    if ("grass-block".equals(key)) key = "grass_block"; // oopsie
+                    oldDouble = section.getDouble(key, minecartControllableBaseSpeed);
+                    set("gameplay-mechanics.controllable-minecarts.block-speed." + key, null);
+                    set("gameplay-mechanics.minecart.controllable.block-speed." + key, oldDouble);
+                }
+                set("gameplay-mechanics.controllable-minecarts.block-speed", null);
+            }
+            set("gameplay-mechanics.controllable-minecarts", null);
+        }
+
+        minecartMaxSpeed = getDouble("gameplay-mechanics.minecart.max-speed", minecartMaxSpeed);
+        minecartPlaceAnywhere = getBoolean("gameplay-mechanics.minecart.place-anywhere", minecartPlaceAnywhere);
+        minecartControllable = getBoolean("gameplay-mechanics.minecart.controllable.enabled", minecartControllable);
+        minecartControllableStepHeight = (float) getDouble("gameplay-mechanics.minecart.controllable.step-height", minecartControllableStepHeight);
+        minecartControllableHopBoost = getDouble("gameplay-mechanics.minecart.controllable.hop-boost", minecartControllableHopBoost);
+        minecartControllableFallDamage = getBoolean("gameplay-mechanics.minecart.controllable.fall-damage", minecartControllableFallDamage);
+        minecartControllableBaseSpeed = getDouble("gameplay-mechanics.minecart.controllable.base-speed", minecartControllableBaseSpeed);
+        ConfigurationSection section = getConfigurationSection("gameplay-mechanics.minecart.controllable.block-speed");
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(key));
+                if (block != Blocks.AIR) {
+                    minecartControllableBlockSpeeds.put(block, section.getDouble(key, minecartControllableBaseSpeed));
+                }
+            }
+        } else {
+            set("gameplay-mechanics.minecart.controllable.block-speed.grass_block", 0.3D);
+            set("gameplay-mechanics.minecart.controllable.block-speed.stone", 0.5D);
+        }
+        poweredRailBoostModifier = getDouble("gameplay-mechanics.minecart.powered-rail.boost-modifier", poweredRailBoostModifier);
+    }
+
+    public float entityHealthRegenAmount = 1.0F;
+    public float entityMinimalHealthPoison = 1.0F;
+    public float entityPoisonDegenerationAmount = 1.0F;
+    public float entityWitherDegenerationAmount = 1.0F;
+    public float humanHungerExhaustionAmount = 0.005F;
+    public float humanSaturationRegenAmount = 1.0F;
+    private void mobEffectSettings() {
+        entityHealthRegenAmount = (float) getDouble("gameplay-mechanics.mob-effects.health-regen-amount", entityHealthRegenAmount);
+        entityMinimalHealthPoison = (float) getDouble("gameplay-mechanics.mob-effects.minimal-health-poison-amount", entityMinimalHealthPoison);
+        entityPoisonDegenerationAmount = (float) getDouble("gameplay-mechanics.mob-effects.poison-degeneration-amount", entityPoisonDegenerationAmount);
+        entityWitherDegenerationAmount = (float) getDouble("gameplay-mechanics.mob-effects.wither-degeneration-amount", entityWitherDegenerationAmount);
+        humanHungerExhaustionAmount = (float) getDouble("gameplay-mechanics.mob-effects.hunger-exhaustion-amount", humanHungerExhaustionAmount);
+        humanSaturationRegenAmount = (float) getDouble("gameplay-mechanics.mob-effects.saturation-regen-amount", humanSaturationRegenAmount);
+    }
+
+    public boolean catSpawning;
+    public boolean patrolSpawning;
+    public boolean phantomSpawning;
+    public boolean villagerTraderSpawning;
+    public boolean villageSiegeSpawning;
+    public boolean mobSpawningIgnoreCreativePlayers = false;
+    private void mobSpawnerSettings() {
+        // values of "default" or null will default to true only if the world environment is normal (aka overworld)
+        Predicate<Boolean> predicate = (bool) -> (bool != null && bool) || (bool == null && environment == World.Environment.NORMAL);
+        catSpawning = getBoolean("gameplay-mechanics.mob-spawning.village-cats", predicate);
+        patrolSpawning = getBoolean("gameplay-mechanics.mob-spawning.raid-patrols", predicate);
+        phantomSpawning = getBoolean("gameplay-mechanics.mob-spawning.phantoms", predicate);
+        villagerTraderSpawning = getBoolean("gameplay-mechanics.mob-spawning.wandering-traders", predicate);
+        villageSiegeSpawning = getBoolean("gameplay-mechanics.mob-spawning.village-sieges", predicate);
+        mobSpawningIgnoreCreativePlayers = getBoolean("gameplay-mechanics.mob-spawning.ignore-creative-players", mobSpawningIgnoreCreativePlayers);
+    }
+
+    public boolean disableObserverClocks = false;
+    private void observerSettings() {
+        disableObserverClocks = getBoolean("blocks.observer.disable-clock", disableObserverClocks);
+    }
+
+    public int playerNetheriteFireResistanceDuration = 0;
+    public int playerNetheriteFireResistanceAmplifier = 0;
+    public boolean playerNetheriteFireResistanceAmbient = false;
+    public boolean playerNetheriteFireResistanceShowParticles = false;
+    public boolean playerNetheriteFireResistanceShowIcon = true;
+    private void playerNetheriteFireResistance() {
+        playerNetheriteFireResistanceDuration = getInt("gameplay-mechanics.player.netherite-fire-resistance.duration", playerNetheriteFireResistanceDuration);
+        playerNetheriteFireResistanceAmplifier = getInt("gameplay-mechanics.player.netherite-fire-resistance.amplifier", playerNetheriteFireResistanceAmplifier);
+        playerNetheriteFireResistanceAmbient = getBoolean("gameplay-mechanics.player.netherite-fire-resistance.ambient", playerNetheriteFireResistanceAmbient);
+        playerNetheriteFireResistanceShowParticles = getBoolean("gameplay-mechanics.player.netherite-fire-resistance.show-particles", playerNetheriteFireResistanceShowParticles);
+        playerNetheriteFireResistanceShowIcon = getBoolean("gameplay-mechanics.player.netherite-fire-resistance.show-icon", playerNetheriteFireResistanceShowIcon);
+    }
+
+    public boolean idleTimeoutKick = true;
+    public boolean idleTimeoutTickNearbyEntities = true;
+    public boolean idleTimeoutCountAsSleeping = false;
+    public boolean idleTimeoutUpdateTabList = false;
+    public boolean idleTimeoutTargetPlayer = true;
+    public String playerDeathExpDropEquation = "expLevel * 7";
+    public int playerDeathExpDropMax = 100;
+    public boolean teleportIfOutsideBorder = false;
+    public boolean teleportOnNetherCeilingDamage = false;
+    public boolean totemOfUndyingWorksInInventory = false;
+    public boolean playerFixStuckPortal = false;
+    public boolean creativeOnePunch = false;
+    public boolean playerSleepNearMonsters = false;
+    public boolean playersSkipNight = true;
+    public double playerCriticalDamageMultiplier = 1.5D;
+    public int playerBurpDelay = 10;
+    public boolean playerBurpWhenFull = false;
+    public boolean playerRidableInWater = false;
+    public boolean playerRemoveBindingWithWeakness = false;
+    public int shiftRightClickRepairsMendingPoints = 0;
+    public int playerExpPickupDelay = 2;
+    public boolean playerVoidTrading = false;
+    private void playerSettings() {
+        if (PurpurConfig.version < 19) {
+            boolean oldVal = getBoolean("gameplay-mechanics.player.idle-timeout.mods-target", idleTimeoutTargetPlayer);
+            set("gameplay-mechanics.player.idle-timeout.mods-target", null);
+            set("gameplay-mechanics.player.idle-timeout.mobs-target", oldVal);
+        }
+        idleTimeoutKick = System.getenv("PURPUR_FORCE_IDLE_KICK") == null ? getBoolean("gameplay-mechanics.player.idle-timeout.kick-if-idle", idleTimeoutKick) : Boolean.parseBoolean(System.getenv("PURPUR_FORCE_IDLE_KICK"));
+        idleTimeoutTickNearbyEntities = getBoolean("gameplay-mechanics.player.idle-timeout.tick-nearby-entities", idleTimeoutTickNearbyEntities);
+        idleTimeoutCountAsSleeping = getBoolean("gameplay-mechanics.player.idle-timeout.count-as-sleeping", idleTimeoutCountAsSleeping);
+        idleTimeoutUpdateTabList = getBoolean("gameplay-mechanics.player.idle-timeout.update-tab-list", idleTimeoutUpdateTabList);
+        idleTimeoutTargetPlayer = getBoolean("gameplay-mechanics.player.idle-timeout.mobs-target", idleTimeoutTargetPlayer);
+        playerDeathExpDropEquation = getString("gameplay-mechanics.player.exp-dropped-on-death.equation", playerDeathExpDropEquation);
+        playerDeathExpDropMax = getInt("gameplay-mechanics.player.exp-dropped-on-death.maximum", playerDeathExpDropMax);
+        teleportIfOutsideBorder = getBoolean("gameplay-mechanics.player.teleport-if-outside-border", teleportIfOutsideBorder);
+        teleportOnNetherCeilingDamage = getBoolean("gameplay-mechanics.player.teleport-on-nether-ceiling-damage", teleportOnNetherCeilingDamage);
+        totemOfUndyingWorksInInventory = getBoolean("gameplay-mechanics.player.totem-of-undying-works-in-inventory", totemOfUndyingWorksInInventory);
+        playerFixStuckPortal = getBoolean("gameplay-mechanics.player.fix-stuck-in-portal", playerFixStuckPortal);
+        creativeOnePunch = getBoolean("gameplay-mechanics.player.one-punch-in-creative", creativeOnePunch);
+        playerSleepNearMonsters = getBoolean("gameplay-mechanics.player.sleep-ignore-nearby-mobs", playerSleepNearMonsters);
+        playersSkipNight = getBoolean("gameplay-mechanics.player.can-skip-night", playersSkipNight);
+        playerCriticalDamageMultiplier = getDouble("gameplay-mechanics.player.critical-damage-multiplier", playerCriticalDamageMultiplier);
+        playerBurpDelay = getInt("gameplay-mechanics.player.burp-delay", playerBurpDelay);
+        playerBurpWhenFull = getBoolean("gameplay-mechanics.player.burp-when-full", playerBurpWhenFull);
+        playerRidableInWater = getBoolean("gameplay-mechanics.player.ridable-in-water", playerRidableInWater);
+        playerRemoveBindingWithWeakness = getBoolean("gameplay-mechanics.player.curse-of-binding.remove-with-weakness", playerRemoveBindingWithWeakness);
+        shiftRightClickRepairsMendingPoints = getInt("gameplay-mechanics.player.shift-right-click-repairs-mending-points", shiftRightClickRepairsMendingPoints);
+        playerExpPickupDelay = getInt("gameplay-mechanics.player.exp-pickup-delay-ticks", playerExpPickupDelay);
+        playerVoidTrading = getBoolean("gameplay-mechanics.player.allow-void-trading", playerVoidTrading);
+    }
+
+    public boolean silkTouchEnabled = false;
+    public String silkTouchSpawnerName = "<reset><white>Monster Spawner";
+    public List<String> silkTouchSpawnerLore = new ArrayList<>();
+    public List<Item> silkTouchTools = new ArrayList<>();
+    public int minimumSilkTouchSpawnerRequire = 1;
+    private void silkTouchSettings() {
+        if (PurpurConfig.version < 21) {
+            String oldName = getString("gameplay-mechanics.silk-touch.spawner-name", silkTouchSpawnerName);
+            set("gameplay-mechanics.silk-touch.spawner-name", "<reset>" + ChatColor.toMM(oldName.replace("{mob}", "<mob>")));
+            List<String> list = new ArrayList<>();
+            getList("gameplay-mechanics.silk-touch.spawner-lore", List.of("Spawns a <mob>"))
+                    .forEach(line -> list.add("<reset>" + ChatColor.toMM(line.toString().replace("{mob}", "<mob>"))));
+            set("gameplay-mechanics.silk-touch.spawner-lore", list);
+        }
+        silkTouchEnabled = getBoolean("gameplay-mechanics.silk-touch.enabled", silkTouchEnabled);
+        silkTouchSpawnerName = getString("gameplay-mechanics.silk-touch.spawner-name", silkTouchSpawnerName);
+        minimumSilkTouchSpawnerRequire = getInt("gameplay-mechanics.silk-touch.minimal-level", minimumSilkTouchSpawnerRequire);
+        silkTouchSpawnerLore.clear();
+        getList("gameplay-mechanics.silk-touch.spawner-lore", List.of("Spawns a <mob>"))
+                .forEach(line -> silkTouchSpawnerLore.add(line.toString()));
+        silkTouchTools.clear();
+        getList("gameplay-mechanics.silk-touch.tools", List.of(
+                "minecraft:iron_pickaxe",
+                "minecraft:golden_pickaxe",
+                "minecraft:diamond_pickaxe",
+                "minecraft:netherite_pickaxe"
+        )).forEach(key -> {
+            Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(key.toString()));
+            if (item != Items.AIR) silkTouchTools.add(item);
+        });
+    }
+
+    public double bowProjectileOffset = 1.0D;
+    public double crossbowProjectileOffset = 1.0D;
+    public double eggProjectileOffset = 1.0D;
+    public double enderPearlProjectileOffset = 1.0D;
+    public double throwablePotionProjectileOffset = 1.0D;
+    public double tridentProjectileOffset = 1.0D;
+    public double snowballProjectileOffset = 1.0D;
+    private void projectileOffsetSettings() {
+        bowProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.bow", bowProjectileOffset);
+        crossbowProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.crossbow", crossbowProjectileOffset);
+        eggProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.egg", eggProjectileOffset);
+        enderPearlProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.ender-pearl", enderPearlProjectileOffset);
+        throwablePotionProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.throwable-potion", throwablePotionProjectileOffset);
+        tridentProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.trident", tridentProjectileOffset);
+        snowballProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.snowball", snowballProjectileOffset);
+    }
+
+    public int snowballDamage = -1;
+    private void snowballSettings() {
+        snowballDamage = getInt("gameplay-mechanics.projectile-damage.snowball", snowballDamage);
+    }
+
+    public Map<Block, Strippable> axeStrippables = new HashMap<>();
+    public Map<Block, Waxable> axeWaxables = new HashMap<>();
+    public Map<Block, Weatherable> axeWeatherables = new HashMap<>();
+    public Map<Block, Tillable> hoeTillables = new HashMap<>();
+    public Map<Block, Flattenable> shovelFlattenables = new HashMap<>();
+    public boolean hoeReplantsCrops = false;
+    public boolean hoeReplantsNetherWarts = false;
+    private void toolSettings() {
+        axeStrippables.clear();
+        axeWaxables.clear();
+        axeWeatherables.clear();
+        hoeTillables.clear();
+        shovelFlattenables.clear();
+        if (PurpurConfig.version < 18) {
+            ConfigurationSection section = PurpurConfig.config.getConfigurationSection("world-settings." + worldName + ".tools.hoe.tilling");
+            if (section != null) {
+                PurpurConfig.config.set("world-settings." + worldName + ".tools.hoe.tillables", section);
+                PurpurConfig.config.set("world-settings." + worldName + ".tools.hoe.tilling", null);
+            }
+            section = PurpurConfig.config.getConfigurationSection("world-settings.default.tools.hoe.tilling");
+            if (section != null) {
+                PurpurConfig.config.set("world-settings.default.tools.hoe.tillables", section);
+                PurpurConfig.config.set("world-settings.default.tools.hoe.tilling", null);
+            }
+        }
+        if (PurpurConfig.version < 29) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:mangrove_log", Map.of("into", "minecraft:stripped_mangrove_log", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:mangrove_wood", Map.of("into", "minecraft:stripped_mangrove_wood", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 32) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:cherry_log", Map.of("into", "minecraft:stripped_cherry_log", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:cherry_wood", Map.of("into", "minecraft:stripped_cherry_wood", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:bamboo_block", Map.of("into", "minecraft:stripped_bamboo_block", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 33) {
+            getList("gameplay-mechanics.shovel-turns-block-to-grass-path", new ArrayList<String>(){{
+                add("minecraft:coarse_dirt");
+                add("minecraft:dirt");
+                add("minecraft:grass_block");
+                add("minecraft:mycelium");
+                add("minecraft:podzol");
+                add("minecraft:rooted_dirt");
+            }}).forEach(key -> {
+                PurpurConfig.config.set("world-settings.default.tools.shovel.flattenables." + key.toString(), Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>()));
+            });
+            set("gameplay-mechanics.shovel-turns-block-to-grass-path", null);
+        }
+        if (PurpurConfig.version < 34) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_chiseled_copper", Map.of("into", "minecraft:oxidized_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_door", Map.of("into", "minecraft:oxidized_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_trapdoor", Map.of("into", "minecraft:oxidized_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_grate", Map.of("into", "minecraft:oxidized_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_bulb", Map.of("into", "minecraft:oxidized_copper_bulb", "drops", new HashMap<String, Double>()));
+
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_cut_copper_stairs", Map.of("into", "minecraft:weathered_cut_copper_stairs", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 39) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:pale_oak_wood", Map.of("into", "minecraft:stripped_pale_oak_wood", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:pale_oak_log", Map.of("into", "minecraft:stripped_pale_oak_log", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 44) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_chest", Map.of("into", "minecraft:copper_chest", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_chest", Map.of("into", "minecraft:exposed_copper_chest", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_chest", Map.of("into", "minecraft:weathered_copper_chest", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_chest", Map.of("into", "minecraft:oxidized_copper_chest", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_golem_statue", Map.of("into", "minecraft:copper_golem_statue", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_golem_statue", Map.of("into", "minecraft:exposed_copper_golem_statue", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_golem_statue", Map.of("into", "minecraft:weathered_copper_golem_statue", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_golem_statue", Map.of("into", "minecraft:oxidized_copper_golem_statue", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_lightning_rod", Map.of("into", "minecraft:lightning_rod", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_lightning_rod", Map.of("into", "minecraft:exposed_lightning_rod", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_lightning_rod", Map.of("into", "minecraft:weathered_lightning_rod", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_lightning_rod", Map.of("into", "minecraft:oxidized_lightning_rod", "drops", new HashMap<String, Double>()));
+
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_chest", Map.of("into", "minecraft:copper_chest", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_chest", Map.of("into", "minecraft:exposed_copper_chest", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_chest", Map.of("into", "minecraft:weathered_copper_chest", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_golem_statue", Map.of("into", "minecraft:copper_golem_statue", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_golem_statue", Map.of("into", "minecraft:exposed_copper_golem_statue", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_golem_statue", Map.of("into", "minecraft:weathered_copper_golem_statue", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_lightning_rod", Map.of("into", "minecraft:lightning_rod", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_lightning_rod", Map.of("into", "minecraft:exposed_lightning_rod", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_lightning_rod", Map.of("into", "minecraft:weathered_lightning_rod", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 45) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_bars", Map.of("into", "minecraft:copper_bars", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_bars", Map.of("into", "minecraft:exposed_copper_bars", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_bars", Map.of("into", "minecraft:weathered_copper_bars", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_bars", Map.of("into", "minecraft:oxidized_copper_bars", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_chain", Map.of("into", "minecraft:copper_chain", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_chain", Map.of("into", "minecraft:exposed_copper_chain", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_chain", Map.of("into", "minecraft:weathered_copper_chain", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_chain", Map.of("into", "minecraft:oxidized_copper_chain", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_lantern", Map.of("into", "minecraft:copper_lantern", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_lantern", Map.of("into", "minecraft:exposed_copper_lantern", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_lantern", Map.of("into", "minecraft:weathered_copper_lantern", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_lantern", Map.of("into", "minecraft:oxidized_copper_lantern", "drops", new HashMap<String, Double>()));
+
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_bars", Map.of("into", "minecraft:copper_bars", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_bars", Map.of("into", "minecraft:exposed_copper_bars", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_bars", Map.of("into", "minecraft:weathered_copper_bars", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_chain", Map.of("into", "minecraft:copper_chain", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_chain", Map.of("into", "minecraft:exposed_copper_chain", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_chain", Map.of("into", "minecraft:weathered_copper_chain", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_lantern", Map.of("into", "minecraft:copper_lantern", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_lantern", Map.of("into", "minecraft:exposed_copper_lantern", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_lantern", Map.of("into", "minecraft:weathered_copper_lantern", "drops", new HashMap<String, Double>()));
+        }
+        getMap("tools.axe.strippables", Map.ofEntries(
+                Map.entry("minecraft:oak_wood", Map.of("into", "minecraft:stripped_oak_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oak_log", Map.of("into", "minecraft:stripped_oak_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dark_oak_wood", Map.of("into", "minecraft:stripped_dark_oak_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dark_oak_log", Map.of("into", "minecraft:stripped_dark_oak_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:pale_oak_wood", Map.of("into", "minecraft:stripped_pale_oak_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:pale_oak_log", Map.of("into", "minecraft:stripped_pale_oak_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:acacia_wood", Map.of("into", "minecraft:stripped_acacia_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:acacia_log", Map.of("into", "minecraft:stripped_acacia_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:cherry_wood", Map.of("into", "minecraft:stripped_cherry_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:cherry_log", Map.of("into", "minecraft:stripped_cherry_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:birch_wood", Map.of("into", "minecraft:stripped_birch_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:birch_log", Map.of("into", "minecraft:stripped_birch_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:jungle_wood", Map.of("into", "minecraft:stripped_jungle_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:jungle_log", Map.of("into", "minecraft:stripped_jungle_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:spruce_wood", Map.of("into", "minecraft:stripped_spruce_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:spruce_log", Map.of("into", "minecraft:stripped_spruce_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:warped_stem", Map.of("into", "minecraft:stripped_warped_stem", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:warped_hyphae", Map.of("into", "minecraft:stripped_warped_hyphae", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:crimson_stem", Map.of("into", "minecraft:stripped_crimson_stem", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:crimson_hyphae", Map.of("into", "minecraft:stripped_crimson_hyphae", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:mangrove_wood", Map.of("into", "minecraft:stripped_mangrove_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:mangrove_log", Map.of("into", "minecraft:stripped_mangrove_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:bamboo_block", Map.of("into", "minecraft:stripped_bamboo_block", "drops", new HashMap<String, Double>()))
+            )
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.strippables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.strippables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(Identifier.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.strippables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.strippables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.axe.strippables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            axeStrippables.put(block, new Strippable(into, drops));
+        });
+        getMap("tools.axe.waxables", Map.ofEntries(
+                Map.entry("minecraft:waxed_copper_block", Map.of("into", "minecraft:copper_block", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper", Map.of("into", "minecraft:exposed_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper", Map.of("into", "minecraft:weathered_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper", Map.of("into", "minecraft:oxidized_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_cut_copper", Map.of("into", "minecraft:cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_cut_copper", Map.of("into", "minecraft:exposed_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_cut_copper", Map.of("into", "minecraft:weathered_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_cut_copper", Map.of("into", "minecraft:oxidized_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_cut_copper_slab", Map.of("into", "minecraft:cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_cut_copper_slab", Map.of("into", "minecraft:exposed_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_cut_copper_slab", Map.of("into", "minecraft:weathered_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_cut_copper_slab", Map.of("into", "minecraft:oxidized_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_cut_copper_stairs", Map.of("into", "minecraft:cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_cut_copper_stairs", Map.of("into", "minecraft:exposed_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_cut_copper_stairs", Map.of("into", "minecraft:weathered_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_cut_copper_stairs", Map.of("into", "minecraft:oxidized_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_chiseled_copper", Map.of("into", "minecraft:oxidized_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_door", Map.of("into", "minecraft:oxidized_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_trapdoor", Map.of("into", "minecraft:oxidized_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_grate", Map.of("into", "minecraft:oxidized_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_bulb", Map.of("into", "minecraft:oxidized_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_chest", Map.of("into", "minecraft:copper_chest", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_chest", Map.of("into", "minecraft:exposed_copper_chest", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_chest", Map.of("into", "minecraft:weathered_copper_chest", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_chest", Map.of("into", "minecraft:oxidized_copper_chest", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_golem_statue", Map.of("into", "minecraft:copper_golem_statue", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_golem_statue", Map.of("into", "minecraft:exposed_copper_golem_statue", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_golem_statue", Map.of("into", "minecraft:weathered_copper_golem_statue", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_golem_statue", Map.of("into", "minecraft:oxidized_copper_golem_statue", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_lightning_rod", Map.of("into", "minecraft:lightning_rod", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_lightning_rod", Map.of("into", "minecraft:exposed_lightning_rod", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_lightning_rod", Map.of("into", "minecraft:weathered_lightning_rod", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_lightning_rod", Map.of("into", "minecraft:oxidized_lightning_rod", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_bars", Map.of("into", "minecraft:copper_bars", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_bars", Map.of("into", "minecraft:exposed_copper_bars", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_bars", Map.of("into", "minecraft:weathered_copper_bars", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_bars", Map.of("into", "minecraft:oxidized_copper_bars", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_chain", Map.of("into", "minecraft:copper_chain", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_chain", Map.of("into", "minecraft:exposed_copper_chain", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_chain", Map.of("into", "minecraft:weathered_copper_chain", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_chain", Map.of("into", "minecraft:oxidized_copper_chain", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_lantern", Map.of("into", "minecraft:copper_lantern", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_lantern", Map.of("into", "minecraft:exposed_copper_lantern", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_lantern", Map.of("into", "minecraft:weathered_copper_lantern", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_lantern", Map.of("into", "minecraft:oxidized_copper_lantern", "drops", new HashMap<String, Double>())))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.waxables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.waxables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(Identifier.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.waxables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.waxables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.axe.waxables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            axeWaxables.put(block, new Waxable(into, drops));
+        });
+        getMap("tools.axe.weatherables", Map.ofEntries(
+                Map.entry("minecraft:exposed_copper", Map.of("into", "minecraft:copper_block", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper", Map.of("into", "minecraft:exposed_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper", Map.of("into", "minecraft:weathered_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_cut_copper", Map.of("into", "minecraft:cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_cut_copper", Map.of("into", "minecraft:exposed_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_cut_copper", Map.of("into", "minecraft:weathered_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_cut_copper_slab", Map.of("into", "minecraft:cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_cut_copper_slab", Map.of("into", "minecraft:exposed_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_cut_copper_slab", Map.of("into", "minecraft:weathered_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_cut_copper_stairs", Map.of("into", "minecraft:cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_cut_copper_stairs", Map.of("into", "minecraft:exposed_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_cut_copper_stairs", Map.of("into", "minecraft:weathered_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_chest", Map.of("into", "minecraft:copper_chest", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_chest", Map.of("into", "minecraft:exposed_copper_chest", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_chest", Map.of("into", "minecraft:weathered_copper_chest", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_golem_statue", Map.of("into", "minecraft:copper_golem_statue", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_golem_statue", Map.of("into", "minecraft:exposed_copper_golem_statue", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_golem_statue", Map.of("into", "minecraft:weathered_copper_golem_statue", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_lightning_rod", Map.of("into", "minecraft:lightning_rod", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_lightning_rod", Map.of("into", "minecraft:exposed_lightning_rod", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_lightning_rod", Map.of("into", "minecraft:weathered_lightning_rod", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_bars", Map.of("into", "minecraft:copper_bars", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_bars", Map.of("into", "minecraft:exposed_copper_bars", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_bars", Map.of("into", "minecraft:weathered_copper_bars", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_chain", Map.of("into", "minecraft:copper_chain", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_chain", Map.of("into", "minecraft:exposed_copper_chain", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_chain", Map.of("into", "minecraft:weathered_copper_chain", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_lantern", Map.of("into", "minecraft:copper_lantern", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_lantern", Map.of("into", "minecraft:exposed_copper_lantern", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_lantern", Map.of("into", "minecraft:weathered_copper_lantern", "drops", new HashMap<String, Double>())))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.weatherables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.weatherables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(Identifier.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.weatherables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.weatherables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.axe.weatherables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            axeWeatherables.put(block, new Weatherable(into, drops));
+        });
+        getMap("tools.hoe.tillables", Map.ofEntries(
+                Map.entry("minecraft:grass_block", Map.of("condition", "air_above", "into", "minecraft:farmland", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dirt_path", Map.of("condition", "air_above", "into", "minecraft:farmland", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dirt", Map.of("condition", "air_above", "into", "minecraft:farmland", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:coarse_dirt", Map.of("condition", "air_above", "into", "minecraft:dirt", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:rooted_dirt", Map.of("condition", "always", "into", "minecraft:dirt", "drops", Map.of("minecraft:hanging_roots", 1.0D))))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.hoe.tillables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.hoe.tillables." + blockId + "`"); return; }
+            String conditionId = (String) map.get("condition");
+            Tillable.Condition condition = Tillable.Condition.get(conditionId);
+            if (condition == null) { PurpurConfig.log(Level.SEVERE, "Invalid condition for `tools.hoe.tillables." + blockId + ".condition`: " + conditionId); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(Identifier.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.hoe.tillables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.hoe.tillables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.hoe.tillables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            hoeTillables.put(block, new Tillable(condition, into, drops));
+        });
+        getMap("tools.shovel.flattenables", Map.ofEntries(
+                Map.entry("minecraft:grass_block", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dirt", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:podzol", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:coarse_dirt", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:mycelium", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:rooted_dirt", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.shovel.flattenables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.shovel.flattenables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(Identifier.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.shovel.flattenables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.shovel.flattenables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.shovel.flattenables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            shovelFlattenables.put(block, new Flattenable(into, drops));
+        });
+        hoeReplantsCrops = getBoolean("tools.hoe.replant-crops", hoeReplantsCrops);
+        hoeReplantsNetherWarts = getBoolean("tools.hoe.replant-nether-warts", hoeReplantsNetherWarts);
+    }
+
+    public boolean anvilAllowColors = false;
+    public boolean anvilColorsUseMiniMessage;
+    public int anvilRepairIngotsAmount = 0;
+    public int anvilDamageObsidianAmount = 0;
+    private void anvilSettings() {
+        anvilAllowColors = getBoolean("blocks.anvil.allow-colors", anvilAllowColors);
+        anvilColorsUseMiniMessage = getBoolean("blocks.anvil.use-mini-message", anvilColorsUseMiniMessage);
+        anvilRepairIngotsAmount = getInt("blocks.anvil.iron-ingots-used-for-repair", anvilRepairIngotsAmount);
+        anvilDamageObsidianAmount = getInt("blocks.anvil.obsidian-used-for-damage", anvilDamageObsidianAmount);
+    }
+
+    public double azaleaGrowthChance = 0.0D;
+    private void azaleaSettings() {
+        azaleaGrowthChance = getDouble("blocks.azalea.growth-chance", azaleaGrowthChance);
+    }
+
+    public int beaconLevelOne = 20;
+    public int beaconLevelTwo = 30;
+    public int beaconLevelThree = 40;
+    public int beaconLevelFour = 50;
+    public boolean beaconAllowEffectsWithTintedGlass = false;
+    private void beaconSettings() {
+        beaconLevelOne = getInt("blocks.beacon.effect-range.level-1", beaconLevelOne);
+        beaconLevelTwo = getInt("blocks.beacon.effect-range.level-2", beaconLevelTwo);
+        beaconLevelThree = getInt("blocks.beacon.effect-range.level-3", beaconLevelThree);
+        beaconLevelFour = getInt("blocks.beacon.effect-range.level-4", beaconLevelFour);
+        beaconAllowEffectsWithTintedGlass = getBoolean("blocks.beacon.allow-effects-with-tinted-glass", beaconAllowEffectsWithTintedGlass);
+    }
+
+    public boolean bedExplode = true;
+    public boolean bedExplodeOnVillagerSleep = false;
+    public double bedExplosionPower = 5.0D;
+    public boolean bedExplosionFire = true;
+    public net.minecraft.world.level.Level.ExplosionInteraction bedExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    private void bedSettings() {
+        if (PurpurConfig.version < 31) {
+            if ("DESTROY".equals(getString("blocks.bed.explosion-effect", bedExplosionEffect.name()))) {
+                set("blocks.bed.explosion-effect", "BLOCK");
+            }
+        }
+        bedExplode = getBoolean("blocks.bed.explode", bedExplode);
+        bedExplodeOnVillagerSleep = getBoolean("blocks.bed.explode-on-villager-sleep", bedExplodeOnVillagerSleep);
+        bedExplosionPower = getDouble("blocks.bed.explosion-power", bedExplosionPower);
+        bedExplosionFire = getBoolean("blocks.bed.explosion-fire", bedExplosionFire);
+        try {
+            bedExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.bed.explosion-effect", bedExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.bed.explosion-effect`! Using default of `BLOCK`");
+            bedExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+    }
+
+    public Map<Tilt, Integer> bigDripleafTiltDelay = new HashMap<>();
+    private void bigDripleafSettings() {
+        bigDripleafTiltDelay.clear();
+        getMap("blocks.big_dripleaf.tilt-delay", Map.ofEntries(
+                Map.entry("UNSTABLE", 10),
+                Map.entry("PARTIAL", 10),
+                Map.entry("FULL", 100))
+        ).forEach((tilt, delay) -> {
+            try {
+                bigDripleafTiltDelay.put(Tilt.valueOf(tilt), (int) delay);
+            } catch (IllegalArgumentException e) {
+                PurpurConfig.log(Level.SEVERE, "Invalid big_dripleaf tilt key: " + tilt);
+            }
+        });
+    }
+
+    public boolean cactusBreaksFromSolidNeighbors = true;
+    public boolean cactusAffectedByBonemeal = false;
+    private void cactusSettings() {
+        cactusBreaksFromSolidNeighbors = getBoolean("blocks.cactus.breaks-from-solid-neighbors", cactusBreaksFromSolidNeighbors);
+        cactusAffectedByBonemeal = getBoolean("blocks.cactus.affected-by-bonemeal", cactusAffectedByBonemeal);
+    }
+
+    public boolean sugarCanAffectedByBonemeal = false;
+    private void sugarCaneSettings() {
+        sugarCanAffectedByBonemeal = getBoolean("blocks.sugar_cane.affected-by-bonemeal", sugarCanAffectedByBonemeal);
+    }
+
+    public boolean netherWartAffectedByBonemeal = false;
+    private void netherWartSettings() {
+        netherWartAffectedByBonemeal = getBoolean("blocks.nether_wart.affected-by-bonemeal", netherWartAffectedByBonemeal);
+    }
+
+    public boolean campFireLitWhenPlaced = true;
+    private void campFireSettings() {
+        campFireLitWhenPlaced = getBoolean("blocks.campfire.lit-when-placed", campFireLitWhenPlaced);
+    }
+
+    public boolean chestOpenWithBlockOnTop = false;
+    private void chestSettings() {
+        chestOpenWithBlockOnTop = getBoolean("blocks.chest.open-with-solid-block-on-top", chestOpenWithBlockOnTop);
+    }
+
+    public boolean composterBulkProcess = false;
+    private void composterSettings() {
+        composterBulkProcess = getBoolean("blocks.composter.sneak-to-bulk-process", composterBulkProcess);
+    }
+
+    public boolean coralDieOutsideWater = true;
+    private void coralSettings() {
+        coralDieOutsideWater = getBoolean("blocks.coral.die-outside-water", coralDieOutsideWater);
+    }
+
+    public boolean dispenserApplyCursedArmor = true;
+    public boolean dispenserPlaceAnvils = false;
+    private void dispenserSettings() {
+        dispenserApplyCursedArmor = getBoolean("blocks.dispenser.apply-cursed-to-armor-slots", dispenserApplyCursedArmor);
+        dispenserPlaceAnvils = getBoolean("blocks.dispenser.place-anvils", dispenserPlaceAnvils);
+    }
+
+    public List<Block> doorRequiresRedstone = new ArrayList<>();
+    private void doorSettings() {
+        getList("blocks.door.requires-redstone", new ArrayList<String>()).forEach(key -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(key.toString()));
+            if (!block.defaultBlockState().isAir()) {
+                doorRequiresRedstone.add(block);
+            }
+        });
+    }
+
+    public boolean dragonEggTeleport = true;
+    private void dragonEggSettings() {
+        dragonEggTeleport = getBoolean("blocks.dragon_egg.teleport", dragonEggTeleport);
+    }
+
+    public boolean baselessEndCrystalExplode = true;
+    public double baselessEndCrystalExplosionPower = 6.0D;
+    public boolean baselessEndCrystalExplosionFire = false;
+    public net.minecraft.world.level.Level.ExplosionInteraction baselessEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    public boolean basedEndCrystalExplode = true;
+    public double basedEndCrystalExplosionPower = 6.0D;
+    public boolean basedEndCrystalExplosionFire = false;
+    public net.minecraft.world.level.Level.ExplosionInteraction basedEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    public int endCrystalCramming = 0;
+    public boolean endCrystalPlaceAnywhere = false;
+    private void endCrystalSettings() {
+        if (PurpurConfig.version < 31) {
+            if ("DESTROY".equals(getString("blocks.end-crystal.baseless.explosion-effect", baselessEndCrystalExplosionEffect.name()))) {
+                set("blocks.end-crystal.baseless.explosion-effect", "BLOCK");
+            }
+            if ("DESTROY".equals(getString("blocks.end-crystal.base.explosion-effect", basedEndCrystalExplosionEffect.name()))) {
+                set("blocks.end-crystal.base.explosion-effect", "BLOCK");
+            }
+        }
+        baselessEndCrystalExplode = getBoolean("blocks.end-crystal.baseless.explode", baselessEndCrystalExplode);
+        baselessEndCrystalExplosionPower = getDouble("blocks.end-crystal.baseless.explosion-power", baselessEndCrystalExplosionPower);
+        baselessEndCrystalExplosionFire = getBoolean("blocks.end-crystal.baseless.explosion-fire", baselessEndCrystalExplosionFire);
+        try {
+            baselessEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.end-crystal.baseless.explosion-effect", baselessEndCrystalExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.end-crystal.baseless.explosion-effect`! Using default of `BLOCK`");
+            baselessEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+        basedEndCrystalExplode = getBoolean("blocks.end-crystal.base.explode", basedEndCrystalExplode);
+        basedEndCrystalExplosionPower = getDouble("blocks.end-crystal.base.explosion-power", basedEndCrystalExplosionPower);
+        basedEndCrystalExplosionFire = getBoolean("blocks.end-crystal.base.explosion-fire", basedEndCrystalExplosionFire);
+        try {
+            basedEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.end-crystal.base.explosion-effect", basedEndCrystalExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.end-crystal.base.explosion-effect`! Using default of `BLOCK`");
+            basedEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+        endCrystalCramming = getInt("blocks.end-crystal.cramming-amount", endCrystalCramming);
+        endCrystalPlaceAnywhere = getBoolean("gameplay-mechanics.item.end-crystal.place-anywhere", endCrystalPlaceAnywhere);
+    }
+
+    public Boolean farmlandMobGriefingOverride = null;
+    public boolean farmlandGetsMoistFromBelow = false;
+    public boolean farmlandAlpha = false;
+    public boolean farmlandTramplingDisabled = false;
+    public boolean farmlandTramplingOnlyPlayers = false;
+    public boolean farmlandTramplingFeatherFalling = false;
+    public double farmlandTrampleHeight = -1D;
+    private void farmlandSettings() {
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("blocks.farmland.bypass-mob-griefing", false);
+            set("blocks.farmland.bypass-mob-griefing", null);
+            set("blocks.farmland.mob-griefing-override", oldVal ? true : "default");
+        }
+        farmlandMobGriefingOverride = getBooleanOrDefault("blocks.farmland.mob-griefing-override", farmlandMobGriefingOverride);
+        farmlandGetsMoistFromBelow = getBoolean("blocks.farmland.gets-moist-from-below", farmlandGetsMoistFromBelow);
+        farmlandAlpha = getBoolean("blocks.farmland.use-alpha-farmland", farmlandAlpha);
+        farmlandTramplingDisabled = getBoolean("blocks.farmland.disable-trampling", farmlandTramplingDisabled);
+        farmlandTramplingOnlyPlayers = getBoolean("blocks.farmland.only-players-trample", farmlandTramplingOnlyPlayers);
+        farmlandTramplingFeatherFalling = getBoolean("blocks.farmland.feather-fall-distance-affects-trampling", farmlandTramplingFeatherFalling);
+        farmlandTrampleHeight = getDouble("blocks.farmland.trample-height", farmlandTrampleHeight);
+    }
+
+    public double floweringAzaleaGrowthChance = 0.0D;
+    private void floweringAzaleaSettings() {
+        floweringAzaleaGrowthChance = getDouble("blocks.flowering_azalea.growth-chance", floweringAzaleaGrowthChance);
+    }
+
+    public boolean furnaceUseLavaFromUnderneath = false;
+    private void furnaceSettings() {
+        if (PurpurConfig.version < 17) {
+            furnaceUseLavaFromUnderneath = getBoolean("blocks.furnace.infinite-fuel", furnaceUseLavaFromUnderneath);
+            boolean oldValue = getBoolean("blocks.furnace.infinite-fuel", furnaceUseLavaFromUnderneath);
+            set("blocks.furnace.infinite-fuel", null);
+            set("blocks.furnace.use-lava-from-underneath", oldValue);
+        }
+        furnaceUseLavaFromUnderneath = getBoolean("blocks.furnace.use-lava-from-underneath", furnaceUseLavaFromUnderneath);
+    }
+
+    public boolean mobsSpawnOnPackedIce = true;
+    public boolean mobsSpawnOnBlueIce = true;
+    public boolean snowOnBlueIce = true;
+    private void iceSettings() {
+        mobsSpawnOnPackedIce = getBoolean("blocks.packed_ice.allow-mob-spawns", mobsSpawnOnPackedIce);
+        mobsSpawnOnBlueIce = getBoolean("blocks.blue_ice.allow-mob-spawns", mobsSpawnOnBlueIce);
+        snowOnBlueIce = getBoolean("blocks.blue_ice.allow-snow-formation", snowOnBlueIce);
+    }
+
+    public int lavaInfiniteRequiredSources = 2;
+    public int lavaSpeedNether = 10;
+    public int lavaSpeedNotNether = 30;
+    private void lavaSettings() {
+        lavaInfiniteRequiredSources = getInt("blocks.lava.infinite-required-sources", lavaInfiniteRequiredSources);
+        lavaSpeedNether = getInt("blocks.lava.speed.nether", lavaSpeedNether);
+        lavaSpeedNotNether = getInt("blocks.lava.speed.not-nether", lavaSpeedNotNether);
+    }
+
+    public int pistonBlockPushLimit = 12;
+    private void pistonSettings() {
+        pistonBlockPushLimit = getInt("blocks.piston.block-push-limit", pistonBlockPushLimit);
+    }
+
+    public boolean magmaBlockDamageWhenSneaking = false;
+    private void magmaBlockSettings() {
+        magmaBlockDamageWhenSneaking = getBoolean("blocks.magma-block.damage-when-sneaking", magmaBlockDamageWhenSneaking);
+    }
+
+    public Boolean powderSnowMobGriefingOverride = null;
+    private void powderSnowSettings() {
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("blocks.powder_snow.bypass-mob-griefing", false);
+            set("blocks.powder_snow.bypass-mob-griefing", null);
+            set("blocks.powder_snow.mob-griefing-override", oldVal ? true : "default");
+        }
+        powderSnowMobGriefingOverride = getBooleanOrDefault("blocks.powder_snow.mob-griefing-override", powderSnowMobGriefingOverride);
+    }
+
+    public int railActivationRange = 8;
+    private void railSettings() {
+        railActivationRange = getInt("blocks.powered-rail.activation-range", railActivationRange);
+    }
+
+    public boolean respawnAnchorExplode = true;
+    public double respawnAnchorExplosionPower = 5.0D;
+    public boolean respawnAnchorExplosionFire = true;
+    public net.minecraft.world.level.Level.ExplosionInteraction respawnAnchorExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    private void respawnAnchorSettings() {
+        if (PurpurConfig.version < 31) {
+            if ("DESTROY".equals(getString("blocks.respawn_anchor.explosion-effect", respawnAnchorExplosionEffect.name()))) {
+                set("blocks.respawn_anchor.explosion-effect", "BLOCK");
+            }
+        }
+        respawnAnchorExplode = getBoolean("blocks.respawn_anchor.explode", respawnAnchorExplode);
+        respawnAnchorExplosionPower = getDouble("blocks.respawn_anchor.explosion-power", respawnAnchorExplosionPower);
+        respawnAnchorExplosionFire = getBoolean("blocks.respawn_anchor.explosion-fire", respawnAnchorExplosionFire);
+        try {
+            respawnAnchorExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.respawn_anchor.explosion-effect", respawnAnchorExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.respawn_anchor.explosion-effect`! Using default of `BLOCK`");
+            respawnAnchorExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+    }
+
+    public boolean sculkShriekerCanSummonDefault = false;
+    private void sculkShriekerSettings() {
+        sculkShriekerCanSummonDefault = getBoolean("blocks.sculk_shrieker.can-summon-default", sculkShriekerCanSummonDefault);
+    }
+
+    public boolean signAllowColors = false;
+    private void signSettings() {
+        signAllowColors = getBoolean("blocks.sign.allow-colors", signAllowColors);
+    }
+
+    public boolean slabHalfBreak = false;
+    private void slabSettings() {
+        slabHalfBreak = getBoolean("blocks.slab.break-individual-slabs-when-sneaking", slabHalfBreak);
+    }
+
+    public boolean spawnerDeactivateByRedstone = false;
+    public boolean spawnerFixMC238526 = false;
+    private void spawnerSettings() {
+        spawnerDeactivateByRedstone = getBoolean("blocks.spawner.deactivate-by-redstone", spawnerDeactivateByRedstone);
+        spawnerFixMC238526 = getBoolean("blocks.spawner.fix-mc-238526", spawnerFixMC238526);
+    }
+
+    public int spongeAbsorptionArea = 65;
+    public int spongeAbsorptionRadius = 6;
+    public boolean spongeAbsorbsLava = false;
+    public boolean spongeAbsorbsWaterFromMud = false;
+    private void spongeSettings() {
+        spongeAbsorptionArea = getInt("blocks.sponge.absorption.area", spongeAbsorptionArea);
+        spongeAbsorptionRadius = getInt("blocks.sponge.absorption.radius", spongeAbsorptionRadius);
+        spongeAbsorbsLava = getBoolean("blocks.sponge.absorbs-lava", spongeAbsorbsLava);
+        spongeAbsorbsWaterFromMud = getBoolean("blocks.sponge.absorbs-water-from-mud", spongeAbsorbsWaterFromMud);
+    }
+
+    public float stonecutterDamage = 0.0F;
+    private void stonecutterSettings() {
+        stonecutterDamage = (float) getDouble("blocks.stonecutter.damage", stonecutterDamage);
+    }
+
+    public boolean turtleEggsBreakFromExpOrbs = false;
+    public boolean turtleEggsBreakFromItems = false;
+    public boolean turtleEggsBreakFromMinecarts = false;
+    public Boolean turtleEggsMobGriefingOverride = null;
+    public int turtleEggsRandomTickCrackChance = 500;
+    public boolean turtleEggsTramplingFeatherFalling = false;
+    private void turtleEggSettings() {
+        turtleEggsBreakFromExpOrbs = getBoolean("blocks.turtle_egg.break-from-exp-orbs", turtleEggsBreakFromExpOrbs);
+        turtleEggsBreakFromItems = getBoolean("blocks.turtle_egg.break-from-items", turtleEggsBreakFromItems);
+        turtleEggsBreakFromMinecarts = getBoolean("blocks.turtle_egg.break-from-minecarts", turtleEggsBreakFromMinecarts);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("blocks.turtle_egg.bypass-mob-griefing", false);
+            set("blocks.turtle_egg.bypass-mob-griefing", null);
+            set("blocks.turtle_egg.mob-griefing-override", oldVal ? true : "default");
+        }
+        turtleEggsMobGriefingOverride = getBooleanOrDefault("blocks.turtle_egg.mob-griefing-override", turtleEggsMobGriefingOverride);
+        turtleEggsRandomTickCrackChance = getInt("blocks.turtle_egg.random-tick-crack-chance", turtleEggsRandomTickCrackChance);
+        turtleEggsTramplingFeatherFalling = getBoolean("blocks.turtle_egg.feather-fall-distance-affects-trampling", turtleEggsTramplingFeatherFalling);
+    }
+
+    public int waterInfiniteRequiredSources = 2;
+    private void waterSources() {
+        waterInfiniteRequiredSources = getInt("blocks.water.infinite-required-sources", waterInfiniteRequiredSources);
+    }
+
+    public boolean babiesAreRidable = true;
+    public boolean untamedTamablesAreRidable = true;
+    public boolean useNightVisionWhenRiding = false;
+    public boolean useDismountsUnderwaterTag = true;
+    private void ridableSettings() {
+        babiesAreRidable = getBoolean("ridable-settings.babies-are-ridable", babiesAreRidable);
+        untamedTamablesAreRidable = getBoolean("ridable-settings.untamed-tamables-are-ridable", untamedTamablesAreRidable);
+        useNightVisionWhenRiding = getBoolean("ridable-settings.use-night-vision", useNightVisionWhenRiding);
+        useDismountsUnderwaterTag = getBoolean("ridable-settings.use-dismounts-underwater-tag", useDismountsUnderwaterTag);
+    }
+
+    public boolean allayRidable = false;
+    public boolean allayRidableInWater = true;
+    public boolean allayControllable = true;
+    public double allayMaxHealth = 20.0D;
+    public double allayScale = 1.0D;
+    public Boolean allayCanPickUpLoot = null;
+    private void allaySettings() {
+        allayRidable = getBoolean("mobs.allay.ridable", allayRidable);
+        allayRidableInWater = getBoolean("mobs.allay.ridable-in-water", allayRidableInWater);
+        allayControllable = getBoolean("mobs.allay.controllable", allayControllable);
+        allayMaxHealth = getDouble("mobs.allay.attributes.max_health", allayMaxHealth);
+        allayScale = Mth.clamp(getDouble("mobs.allay.attributes.scale", allayScale), 0.0625D, 16.0D);
+        allayCanPickUpLoot = getBooleanOrDefault("mobs.allay.can-pick-up-loot", allayCanPickUpLoot);
+    }
+
+    public boolean armadilloRidable = false;
+    public boolean armadilloRidableInWater = true;
+    public boolean armadilloControllable = true;
+    public double armadilloMaxHealth = 12.0D;
+    public double armadilloScale = 1.0D;
+    public int armadilloBreedingTicks = 6000;
+    private void armadilloSettings() {
+        armadilloRidable = getBoolean("mobs.armadillo.ridable", armadilloRidable);
+        armadilloRidableInWater = getBoolean("mobs.armadillo.ridable-in-water", armadilloRidableInWater);
+        armadilloControllable = getBoolean("mobs.armadillo.controllable", armadilloControllable);
+        armadilloMaxHealth = getDouble("mobs.armadillo.attributes.max_health", armadilloMaxHealth);
+        armadilloScale = Mth.clamp(getDouble("mobs.armadillo.attributes.scale", armadilloScale), 0.0625D, 16.0D);
+        armadilloBreedingTicks = getInt("mobs.armadillo.breeding-delay-ticks", armadilloBreedingTicks);
+    }
+
+    public boolean axolotlRidable = false;
+    public boolean axolotlControllable = true;
+    public double axolotlMaxHealth = 14.0D;
+    public double axolotlScale = 1.0D;
+    public int axolotlBreedingTicks = 6000;
+    public boolean axolotlTakeDamageFromWater = false;
+    public boolean axolotlAlwaysDropExp = false;
+    private void axolotlSettings() {
+        axolotlRidable = getBoolean("mobs.axolotl.ridable", axolotlRidable);
+        axolotlControllable = getBoolean("mobs.axolotl.controllable", axolotlControllable);
+        axolotlMaxHealth = getDouble("mobs.axolotl.attributes.max_health", axolotlMaxHealth);
+        axolotlScale = Mth.clamp(getDouble("mobs.axolotl.attributes.scale", axolotlScale), 0.0625D, 16.0D);
+        axolotlBreedingTicks = getInt("mobs.axolotl.breeding-delay-ticks", axolotlBreedingTicks);
+        axolotlTakeDamageFromWater = getBoolean("mobs.axolotl.takes-damage-from-water", axolotlTakeDamageFromWater);
+        axolotlAlwaysDropExp = getBoolean("mobs.axolotl.always-drop-exp", axolotlAlwaysDropExp);
+    }
+
+    public boolean batRidable = false;
+    public boolean batRidableInWater = true;
+    public boolean batControllable = true;
+    public double batMaxY = 320D;
+    public double batMaxHealth = 6.0D;
+    public double batScale = 1.0D;
+    public double batFollowRange = 16.0D;
+    public double batKnockbackResistance = 0.0D;
+    public double batMovementSpeed = 0.6D;
+    public double batFlyingSpeed = 0.6D;
+    public double batArmor = 0.0D;
+    public double batArmorToughness = 0.0D;
+    public double batAttackKnockback = 0.0D;
+    public boolean batTakeDamageFromWater = false;
+    public boolean batAlwaysDropExp = false;
+    private void batSettings() {
+        batRidable = getBoolean("mobs.bat.ridable", batRidable);
+        batRidableInWater = getBoolean("mobs.bat.ridable-in-water", batRidableInWater);
+        batControllable = getBoolean("mobs.bat.controllable", batControllable);
+        batMaxY = getDouble("mobs.bat.ridable-max-y", batMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.bat.attributes.max-health", batMaxHealth);
+            set("mobs.bat.attributes.max-health", null);
+            set("mobs.bat.attributes.max_health", oldValue);
+        }
+        batMaxHealth = getDouble("mobs.bat.attributes.max_health", batMaxHealth);
+        batScale = Mth.clamp(getDouble("mobs.bat.attributes.scale", batScale), 0.0625D, 16.0D);
+        batFollowRange = getDouble("mobs.bat.attributes.follow_range", batFollowRange);
+        batKnockbackResistance = getDouble("mobs.bat.attributes.knockback_resistance", batKnockbackResistance);
+        batMovementSpeed = getDouble("mobs.bat.attributes.movement_speed", batMovementSpeed);
+        batFlyingSpeed = getDouble("mobs.bat.attributes.flying_speed", batFlyingSpeed);
+        batArmor = getDouble("mobs.bat.attributes.armor", batArmor);
+        batArmorToughness = getDouble("mobs.bat.attributes.armor_toughness", batArmorToughness);
+        batAttackKnockback = getDouble("mobs.bat.attributes.attack_knockback", batAttackKnockback);
+        batTakeDamageFromWater = getBoolean("mobs.bat.takes-damage-from-water", batTakeDamageFromWater);
+        batAlwaysDropExp = getBoolean("mobs.bat.always-drop-exp", batAlwaysDropExp);
+    }
+
+    public boolean beeRidable = false;
+    public boolean beeRidableInWater = true;
+    public boolean beeControllable = true;
+    public double beeMaxY = 320D;
+    public double beeMaxHealth = 10.0D;
+    public double beeScale = 1.0D;
+    public int beeBreedingTicks = 6000;
+    public boolean beeTakeDamageFromWater = false;
+    public boolean beeCanInstantlyStartDrowning = true;
+    public boolean beeCanWorkAtNight = false;
+    public boolean beeCanWorkInRain = false;
+    public boolean beeAlwaysDropExp = false;
+    public boolean beeDiesAfterSting = true;
+    private void beeSettings() {
+        beeRidable = getBoolean("mobs.bee.ridable", beeRidable);
+        beeRidableInWater = getBoolean("mobs.bee.ridable-in-water", beeRidableInWater);
+        beeControllable = getBoolean("mobs.bee.controllable", beeControllable);
+        beeMaxY = getDouble("mobs.bee.ridable-max-y", beeMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.bee.attributes.max-health", beeMaxHealth);
+            set("mobs.bee.attributes.max-health", null);
+            set("mobs.bee.attributes.max_health", oldValue);
+        }
+        beeMaxHealth = getDouble("mobs.bee.attributes.max_health", beeMaxHealth);
+        beeScale = Mth.clamp(getDouble("mobs.bee.attributes.scale", beeScale), 0.0625D, 16.0D);
+        beeBreedingTicks = getInt("mobs.bee.breeding-delay-ticks", beeBreedingTicks);
+        if (PurpurConfig.version < 40) {
+            set("mobs.bee.takes-damage-from-water", false);
+        }
+        beeTakeDamageFromWater = getBoolean("mobs.bee.takes-damage-from-water", beeTakeDamageFromWater);
+        beeCanWorkAtNight = getBoolean("mobs.bee.can-work-at-night", beeCanWorkAtNight);
+        beeCanWorkInRain = getBoolean("mobs.bee.can-work-in-rain", beeCanWorkInRain);
+        beeCanInstantlyStartDrowning = getBoolean("mobs.bee.can-instantly-start-drowning", beeCanInstantlyStartDrowning);
+        beeAlwaysDropExp = getBoolean("mobs.bee.always-drop-exp", beeAlwaysDropExp);
+        beeDiesAfterSting = getBoolean("mobs.bee.dies-after-sting", beeDiesAfterSting);
+    }
+
+    public boolean blazeRidable = false;
+    public boolean blazeRidableInWater = true;
+    public boolean blazeControllable = true;
+    public double blazeMaxY = 320D;
+    public double blazeMaxHealth = 20.0D;
+    public double blazeScale = 1.0D;
+    public boolean blazeTakeDamageFromWater = true;
+    public boolean blazeAlwaysDropExp = false;
+    private void blazeSettings() {
+        blazeRidable = getBoolean("mobs.blaze.ridable", blazeRidable);
+        blazeRidableInWater = getBoolean("mobs.blaze.ridable-in-water", blazeRidableInWater);
+        blazeControllable = getBoolean("mobs.blaze.controllable", blazeControllable);
+        blazeMaxY = getDouble("mobs.blaze.ridable-max-y", blazeMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.blaze.attributes.max-health", blazeMaxHealth);
+            set("mobs.blaze.attributes.max-health", null);
+            set("mobs.blaze.attributes.max_health", oldValue);
+        }
+        blazeMaxHealth = getDouble("mobs.blaze.attributes.max_health", blazeMaxHealth);
+        blazeScale = Mth.clamp(getDouble("mobs.blaze.attributes.scale", blazeScale), 0.0625D, 16.0D);
+        blazeTakeDamageFromWater = getBoolean("mobs.blaze.takes-damage-from-water", blazeTakeDamageFromWater);
+        blazeAlwaysDropExp = getBoolean("mobs.blaze.always-drop-exp", blazeAlwaysDropExp);
+    }
+
+    public boolean boggedRidable = false;
+    public boolean boggedRidableInWater = true;
+    public boolean boggedControllable = true;
+    public double boggedMaxHealth = 16.0D;
+    public double boggedScale = 1.0D;
+    public Boolean boggedCanPickUpLoot = null;
+    private void boggedSettings() {
+        boggedRidable = getBoolean("mobs.bogged.ridable", boggedRidable);
+        boggedRidableInWater = getBoolean("mobs.bogged.ridable-in-water", boggedRidableInWater);
+        boggedControllable = getBoolean("mobs.bogged.controllable", boggedControllable);
+        boggedMaxHealth = getDouble("mobs.bogged.attributes.max_health", boggedMaxHealth);
+        boggedScale = Mth.clamp(getDouble("mobs.bogged.attributes.scale", boggedScale), 0.0625D, 16.0D);
+        boggedCanPickUpLoot = getBooleanOrDefault("mobs.bogged.can-pick-up-loot", boggedCanPickUpLoot);
+    }
+
+    public boolean camelRidableInWater = false;
+    public double camelMaxHealthMin = 32.0D;
+    public double camelMaxHealthMax = 32.0D;
+    public double camelJumpStrengthMin = 0.42D;
+    public double camelJumpStrengthMax = 0.42D;
+    public double camelMovementSpeedMin = 0.09D;
+    public double camelMovementSpeedMax = 0.09D;
+    public int camelBreedingTicks = 6000;
+    private void camelSettings() {
+        camelRidableInWater = getBoolean("mobs.camel.ridable-in-water", camelRidableInWater);
+        camelMaxHealthMin = getDouble("mobs.camel.attributes.max_health.min", camelMaxHealthMin);
+        camelMaxHealthMax = getDouble("mobs.camel.attributes.max_health.max", camelMaxHealthMax);
+        camelJumpStrengthMin = getDouble("mobs.camel.attributes.jump_strength.min", camelJumpStrengthMin);
+        camelJumpStrengthMax = getDouble("mobs.camel.attributes.jump_strength.max", camelJumpStrengthMax);
+        camelMovementSpeedMin = getDouble("mobs.camel.attributes.movement_speed.min", camelMovementSpeedMin);
+        camelMovementSpeedMax = getDouble("mobs.camel.attributes.movement_speed.max", camelMovementSpeedMax);
+        camelBreedingTicks = getInt("mobs.camel.breeding-delay-ticks", camelBreedingTicks);
+    }
+
+    public boolean catRidable = false;
+    public boolean catRidableInWater = true;
+    public boolean catControllable = true;
+    public double catMaxHealth = 10.0D;
+    public double catScale = 1.0D;
+    public int catSpawnDelay = 1200;
+    public int catSpawnSwampHutScanRange = 16;
+    public int catSpawnVillageScanRange = 48;
+    public int catBreedingTicks = 6000;
+    public DyeColor catDefaultCollarColor = DyeColor.RED;
+    public boolean catTakeDamageFromWater = false;
+    public boolean catAlwaysDropExp = false;
+    private void catSettings() {
+        catRidable = getBoolean("mobs.cat.ridable", catRidable);
+        catRidableInWater = getBoolean("mobs.cat.ridable-in-water", catRidableInWater);
+        catControllable = getBoolean("mobs.cat.controllable", catControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cat.attributes.max-health", catMaxHealth);
+            set("mobs.cat.attributes.max-health", null);
+            set("mobs.cat.attributes.max_health", oldValue);
+        }
+        catMaxHealth = getDouble("mobs.cat.attributes.max_health", catMaxHealth);
+        catScale = Mth.clamp(getDouble("mobs.cat.attributes.scale", catScale), 0.0625D, 16.0D);
+        catSpawnDelay = getInt("mobs.cat.spawn-delay", catSpawnDelay);
+        catSpawnSwampHutScanRange = getInt("mobs.cat.scan-range-for-other-cats.swamp-hut", catSpawnSwampHutScanRange);
+        catSpawnVillageScanRange = getInt("mobs.cat.scan-range-for-other-cats.village", catSpawnVillageScanRange);
+        catBreedingTicks = getInt("mobs.cat.breeding-delay-ticks", catBreedingTicks);
+        try {
+            catDefaultCollarColor = DyeColor.valueOf(getString("mobs.cat.default-collar-color", catDefaultCollarColor.name()));
+        } catch (IllegalArgumentException ignore) {
+            catDefaultCollarColor = DyeColor.RED;
+        }
+        catTakeDamageFromWater = getBoolean("mobs.cat.takes-damage-from-water", catTakeDamageFromWater);
+        catAlwaysDropExp = getBoolean("mobs.cat.always-drop-exp", catAlwaysDropExp);
+    }
+
+    public boolean caveSpiderRidable = false;
+    public boolean caveSpiderRidableInWater = true;
+    public boolean caveSpiderControllable = true;
+    public double caveSpiderMaxHealth = 12.0D;
+    public double caveSpiderScale = 1.0D;
+    public boolean caveSpiderTakeDamageFromWater = false;
+    public boolean caveSpiderAlwaysDropExp = false;
+    private void caveSpiderSettings() {
+        caveSpiderRidable = getBoolean("mobs.cave_spider.ridable", caveSpiderRidable);
+        caveSpiderRidableInWater = getBoolean("mobs.cave_spider.ridable-in-water", caveSpiderRidableInWater);
+        caveSpiderControllable = getBoolean("mobs.cave_spider.controllable", caveSpiderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cave_spider.attributes.max-health", caveSpiderMaxHealth);
+            set("mobs.cave_spider.attributes.max-health", null);
+            set("mobs.cave_spider.attributes.max_health", oldValue);
+        }
+        caveSpiderMaxHealth = getDouble("mobs.cave_spider.attributes.max_health", caveSpiderMaxHealth);
+        caveSpiderScale = Mth.clamp(getDouble("mobs.cave_spider.attributes.scale", caveSpiderScale), 0.0625D, 16.0D);
+        caveSpiderTakeDamageFromWater = getBoolean("mobs.cave_spider.takes-damage-from-water", caveSpiderTakeDamageFromWater);
+        caveSpiderAlwaysDropExp = getBoolean("mobs.cave_spider.always-drop-exp", caveSpiderAlwaysDropExp);
+    }
+
+    public boolean chickenRidable = false;
+    public boolean chickenRidableInWater = false;
+    public boolean chickenControllable = true;
+    public double chickenMaxHealth = 4.0D;
+    public double chickenScale = 1.0D;
+    public boolean chickenRetaliate = false;
+    public int chickenBreedingTicks = 6000;
+    public boolean chickenTakeDamageFromWater = false;
+    public boolean chickenAlwaysDropExp = false;
+    private void chickenSettings() {
+        chickenRidable = getBoolean("mobs.chicken.ridable", chickenRidable);
+        chickenRidableInWater = getBoolean("mobs.chicken.ridable-in-water", chickenRidableInWater);
+        chickenControllable = getBoolean("mobs.chicken.controllable", chickenControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.chicken.attributes.max-health", chickenMaxHealth);
+            set("mobs.chicken.attributes.max-health", null);
+            set("mobs.chicken.attributes.max_health", oldValue);
+        }
+        chickenMaxHealth = getDouble("mobs.chicken.attributes.max_health", chickenMaxHealth);
+        chickenScale = Mth.clamp(getDouble("mobs.chicken.attributes.scale", chickenScale), 0.0625D, 16.0D);
+        chickenRetaliate = getBoolean("mobs.chicken.retaliate", chickenRetaliate);
+        chickenBreedingTicks = getInt("mobs.chicken.breeding-delay-ticks", chickenBreedingTicks);
+        chickenTakeDamageFromWater = getBoolean("mobs.chicken.takes-damage-from-water", chickenTakeDamageFromWater);
+        chickenAlwaysDropExp = getBoolean("mobs.chicken.always-drop-exp", chickenAlwaysDropExp);
+    }
+
+    public boolean codRidable = false;
+    public boolean codControllable = true;
+    public double codMaxHealth = 3.0D;
+    public double codScale = 1.0D;
+    public boolean codTakeDamageFromWater = false;
+    public boolean codAlwaysDropExp = false;
+    private void codSettings() {
+        codRidable = getBoolean("mobs.cod.ridable", codRidable);
+        codControllable = getBoolean("mobs.cod.controllable", codControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cod.attributes.max-health", codMaxHealth);
+            set("mobs.cod.attributes.max-health", null);
+            set("mobs.cod.attributes.max_health", oldValue);
+        }
+        codMaxHealth = getDouble("mobs.cod.attributes.max_health", codMaxHealth);
+        codScale = Mth.clamp(getDouble("mobs.cod.attributes.scale", codScale), 0.0625D, 16.0D);
+        codTakeDamageFromWater = getBoolean("mobs.cod.takes-damage-from-water", codTakeDamageFromWater);
+        codAlwaysDropExp = getBoolean("mobs.cod.always-drop-exp", codAlwaysDropExp);
+    }
+
+    public boolean copperGolemRidable = false;
+    public boolean copperGolemRidableInWater = true;
+    public boolean copperGolemControllable = true;
+    public boolean copperGolemCanSwim = false;
+    public double copperGolemMaxHealth = 12.0D;
+    public double copperGolemStepHeight = 1.0D;
+    public double copperGolemMovementSpeed = 0.2D;
+    public double copperGolemScale = 1.0D;
+    public boolean copperGolemTakeDamageFromWater = false;
+    public boolean copperGolemAlwaysDropExp = false;
+    public boolean copperGolemCanOpenBarrel = false;
+    public boolean copperGolemCanOpenShulker = false;
+    private void copperGolemSettings() {
+        copperGolemRidable = getBoolean("mobs.copper_golem.ridable", copperGolemRidable);
+        copperGolemRidableInWater = getBoolean("mobs.copper_golem.ridable-in-water", copperGolemRidableInWater);
+        copperGolemControllable = getBoolean("mobs.copper_golem.controllable", copperGolemControllable);
+        copperGolemCanSwim = getBoolean("mobs.copper_golem.can-swim", copperGolemCanSwim);
+        copperGolemMaxHealth = getDouble("mobs.copper_golem.attributes.max_health", copperGolemMaxHealth);
+        copperGolemStepHeight = getDouble("mobs.copper_golem.attributes.step_height", copperGolemStepHeight);
+        copperGolemMovementSpeed = getDouble("mobs.copper_golem.attributes.movement_speed", copperGolemMovementSpeed);
+        copperGolemScale = Mth.clamp(getDouble("mobs.copper_golem.attributes.scale", copperGolemScale), 0.0625D, 16.0D);
+        copperGolemTakeDamageFromWater = getBoolean("mobs.copper_golem.takes-damage-from-water", copperGolemTakeDamageFromWater);
+        copperGolemAlwaysDropExp = getBoolean("mobs.copper_golem.always-drop-exp", copperGolemAlwaysDropExp);
+        copperGolemCanOpenBarrel = getBoolean("mobs.copper_golem.can-open-barrel", copperGolemCanOpenBarrel);
+        copperGolemCanOpenShulker = getBoolean("mobs.copper_golem.can-open-shulker", copperGolemCanOpenShulker);
+    }
+
+    public boolean cowRidable = false;
+    public boolean cowRidableInWater = true;
+    public boolean cowControllable = true;
+    public double cowMaxHealth = 10.0D;
+    public double cowScale = 1.0D;
+    public int cowFeedMushrooms = 0;
+    public int cowBreedingTicks = 6000;
+    public boolean cowTakeDamageFromWater = false;
+    public double cowNaturallyAggressiveToPlayersChance = 0.0D;
+    public double cowNaturallyAggressiveToPlayersDamage = 2.0D;
+    public boolean cowAlwaysDropExp = false;
+    private void cowSettings() {
+        if (PurpurConfig.version < 22) {
+            double oldValue = getDouble("mobs.cow.naturally-aggressive-to-players-chance", cowNaturallyAggressiveToPlayersChance);
+            set("mobs.cow.naturally-aggressive-to-players-chance", null);
+            set("mobs.cow.naturally-aggressive-to-players.chance", oldValue);
+        }
+        cowRidable = getBoolean("mobs.cow.ridable", cowRidable);
+        cowRidableInWater = getBoolean("mobs.cow.ridable-in-water", cowRidableInWater);
+        cowControllable = getBoolean("mobs.cow.controllable", cowControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cow.attributes.max-health", cowMaxHealth);
+            set("mobs.cow.attributes.max-health", null);
+            set("mobs.cow.attributes.max_health", oldValue);
+        }
+        cowMaxHealth = getDouble("mobs.cow.attributes.max_health", cowMaxHealth);
+        cowScale = Mth.clamp(getDouble("mobs.cow.attributes.scale", cowScale), 0.0625D, 16.0D);
+        cowFeedMushrooms = getInt("mobs.cow.feed-mushrooms-for-mooshroom", cowFeedMushrooms);
+        cowBreedingTicks = getInt("mobs.cow.breeding-delay-ticks", cowBreedingTicks);
+        cowTakeDamageFromWater = getBoolean("mobs.cow.takes-damage-from-water", cowTakeDamageFromWater);
+        cowNaturallyAggressiveToPlayersChance = getDouble("mobs.cow.naturally-aggressive-to-players.chance", cowNaturallyAggressiveToPlayersChance);
+        cowNaturallyAggressiveToPlayersDamage = getDouble("mobs.cow.naturally-aggressive-to-players.damage", cowNaturallyAggressiveToPlayersDamage);
+        cowAlwaysDropExp = getBoolean("mobs.cow.always-drop-exp", cowAlwaysDropExp);
+    }
+
+    public boolean creakingRidable = false;
+    public boolean creakingRidableInWater = true;
+    public boolean creakingControllable = true;
+    public double creakingMaxHealth = 1.0D;
+    public double creakingScale = 1.0D;
+    private void creakingSettings() {
+        creakingRidable = getBoolean("mobs.creaking.ridable", creakingRidable);
+        creakingRidableInWater = getBoolean("mobs.creaking.ridable-in-water", creakingRidableInWater);
+        creakingControllable = getBoolean("mobs.creaking.controllable", creakingControllable);
+        creakingMaxHealth = getDouble("mobs.creaking.attributes.max_health", creakingMaxHealth);
+        creakingScale = Mth.clamp(getDouble("mobs.creaking.attributes.scale", creakingScale), 0.0625D, 16.0D);
+    }
+
+    public boolean creeperRidable = false;
+    public boolean creeperRidableInWater = true;
+    public boolean creeperControllable = true;
+    public double creeperMaxHealth = 20.0D;
+    public double creeperScale = 1.0D;
+    public double creeperChargedChance = 0.0D;
+    public boolean creeperAllowGriefing = true;
+    public Boolean creeperMobGriefingOverride = null;
+    public boolean creeperTakeDamageFromWater = false;
+    public boolean creeperExplodeWhenKilled = false;
+    public boolean creeperHealthRadius = false;
+    public boolean creeperAlwaysDropExp = false;
+    public double creeperHeadVisibilityPercent = 0.5D;
+    public boolean creeperEncircleTarget = false;
+    private void creeperSettings() {
+        creeperRidable = getBoolean("mobs.creeper.ridable", creeperRidable);
+        creeperRidableInWater = getBoolean("mobs.creeper.ridable-in-water", creeperRidableInWater);
+        creeperControllable = getBoolean("mobs.creeper.controllable", creeperControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.creeper.attributes.max-health", creeperMaxHealth);
+            set("mobs.creeper.attributes.max-health", null);
+            set("mobs.creeper.attributes.max_health", oldValue);
+        }
+        creeperMaxHealth = getDouble("mobs.creeper.attributes.max_health", creeperMaxHealth);
+        creeperScale = Mth.clamp(getDouble("mobs.creeper.attributes.scale", creeperScale), 0.0625D, 16.0D);
+        creeperChargedChance = getDouble("mobs.creeper.naturally-charged-chance", creeperChargedChance);
+        creeperAllowGriefing = getBoolean("mobs.creeper.allow-griefing", creeperAllowGriefing);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.creeper.bypass-mob-griefing", false);
+            set("mobs.creeper.bypass-mob-griefing", null);
+            set("mobs.creeper.mob-griefing-override", oldVal ? true : "default");
+        }
+        creeperMobGriefingOverride = getBooleanOrDefault("mobs.creeper.mob-griefing-override", creeperMobGriefingOverride);
+        creeperTakeDamageFromWater = getBoolean("mobs.creeper.takes-damage-from-water", creeperTakeDamageFromWater);
+        creeperExplodeWhenKilled = getBoolean("mobs.creeper.explode-when-killed", creeperExplodeWhenKilled);
+        creeperHealthRadius = getBoolean("mobs.creeper.health-impacts-explosion", creeperHealthRadius);
+        creeperAlwaysDropExp = getBoolean("mobs.creeper.always-drop-exp", creeperAlwaysDropExp);
+        creeperHeadVisibilityPercent = getDouble("mobs.creeper.head-visibility-percent", creeperHeadVisibilityPercent);
+        creeperEncircleTarget = getBoolean("mobs.creeper.encircle-target", creeperEncircleTarget);
+    }
+
+    public boolean dolphinRidable = false;
+    public boolean dolphinControllable = true;
+    public int dolphinSpitCooldown = 20;
+    public float dolphinSpitSpeed = 1.0F;
+    public float dolphinSpitDamage = 2.0F;
+    public double dolphinMaxHealth = 10.0D;
+    public double dolphinScale = 1.0D;
+    public boolean dolphinDisableTreasureSearching = false;
+    public boolean dolphinTakeDamageFromWater = false;
+    public double dolphinNaturallyAggressiveToPlayersChance = 0.0D;
+    public boolean dolphinAlwaysDropExp = false;
+    private void dolphinSettings() {
+        dolphinRidable = getBoolean("mobs.dolphin.ridable", dolphinRidable);
+        dolphinControllable = getBoolean("mobs.dolphin.controllable", dolphinControllable);
+        dolphinSpitCooldown = getInt("mobs.dolphin.spit.cooldown", dolphinSpitCooldown);
+        dolphinSpitSpeed = (float) getDouble("mobs.dolphin.spit.speed", dolphinSpitSpeed);
+        dolphinSpitDamage = (float) getDouble("mobs.dolphin.spit.damage", dolphinSpitDamage);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.dolphin.attributes.max-health", dolphinMaxHealth);
+            set("mobs.dolphin.attributes.max-health", null);
+            set("mobs.dolphin.attributes.max_health", oldValue);
+        }
+        dolphinMaxHealth = getDouble("mobs.dolphin.attributes.max_health", dolphinMaxHealth);
+        dolphinScale = Mth.clamp(getDouble("mobs.dolphin.attributes.scale", dolphinScale), 0.0625D, 16.0D);
+        dolphinDisableTreasureSearching = getBoolean("mobs.dolphin.disable-treasure-searching", dolphinDisableTreasureSearching);
+        dolphinTakeDamageFromWater = getBoolean("mobs.dolphin.takes-damage-from-water", dolphinTakeDamageFromWater);
+        dolphinNaturallyAggressiveToPlayersChance = getDouble("mobs.dolphin.naturally-aggressive-to-players-chance", dolphinNaturallyAggressiveToPlayersChance);
+        dolphinAlwaysDropExp = getBoolean("mobs.dolphin.always-drop-exp", dolphinAlwaysDropExp);
+    }
+
+    public boolean donkeyRidableInWater = false;
+    public double donkeyMaxHealthMin = 15.0D;
+    public double donkeyMaxHealthMax = 30.0D;
+    public double donkeyJumpStrengthMin = 0.5D;
+    public double donkeyJumpStrengthMax = 0.5D;
+    public double donkeyMovementSpeedMin = 0.175D;
+    public double donkeyMovementSpeedMax = 0.175D;
+    public int donkeyBreedingTicks = 6000;
+    public boolean donkeyTakeDamageFromWater = false;
+    public boolean donkeyAlwaysDropExp = false;
+    private void donkeySettings() {
+        donkeyRidableInWater = getBoolean("mobs.donkey.ridable-in-water", donkeyRidableInWater);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.donkey.attributes.max-health.min", donkeyMaxHealthMin);
+            double oldMax = getDouble("mobs.donkey.attributes.max-health.max", donkeyMaxHealthMax);
+            set("mobs.donkey.attributes.max-health", null);
+            set("mobs.donkey.attributes.max_health.min", oldMin);
+            set("mobs.donkey.attributes.max_health.max", oldMax);
+        }
+        donkeyMaxHealthMin = getDouble("mobs.donkey.attributes.max_health.min", donkeyMaxHealthMin);
+        donkeyMaxHealthMax = getDouble("mobs.donkey.attributes.max_health.max", donkeyMaxHealthMax);
+        donkeyJumpStrengthMin = getDouble("mobs.donkey.attributes.jump_strength.min", donkeyJumpStrengthMin);
+        donkeyJumpStrengthMax = getDouble("mobs.donkey.attributes.jump_strength.max", donkeyJumpStrengthMax);
+        donkeyMovementSpeedMin = getDouble("mobs.donkey.attributes.movement_speed.min", donkeyMovementSpeedMin);
+        donkeyMovementSpeedMax = getDouble("mobs.donkey.attributes.movement_speed.max", donkeyMovementSpeedMax);
+        donkeyBreedingTicks = getInt("mobs.donkey.breeding-delay-ticks", donkeyBreedingTicks);
+        donkeyTakeDamageFromWater = getBoolean("mobs.donkey.takes-damage-from-water", donkeyTakeDamageFromWater);
+        donkeyAlwaysDropExp = getBoolean("mobs.donkey.always-drop-exp", donkeyAlwaysDropExp);
+    }
+
+    public boolean drownedRidable = false;
+    public boolean drownedRidableInWater = true;
+    public boolean drownedControllable = true;
+    public double drownedMaxHealth = 20.0D;
+    public double drownedScale = 1.0D;
+    public double drownedSpawnReinforcements = 0.1D;
+    public boolean drownedJockeyOnlyBaby = true;
+    public double drownedJockeyChance = 0.05D;
+    public boolean drownedJockeyTryExistingChickens = true;
+    public boolean drownedTakeDamageFromWater = false;
+    public boolean drownedBreakDoors = false;
+    public boolean drownedAlwaysDropExp = false;
+    public Boolean drownedCanPickUpLoot = null;
+    private void drownedSettings() {
+        drownedRidable = getBoolean("mobs.drowned.ridable", drownedRidable);
+        drownedRidableInWater = getBoolean("mobs.drowned.ridable-in-water", drownedRidableInWater);
+        drownedControllable = getBoolean("mobs.drowned.controllable", drownedControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.drowned.attributes.max-health", drownedMaxHealth);
+            set("mobs.drowned.attributes.max-health", null);
+            set("mobs.drowned.attributes.max_health", oldValue);
+        }
+        drownedMaxHealth = getDouble("mobs.drowned.attributes.max_health", drownedMaxHealth);
+        drownedScale = Mth.clamp(getDouble("mobs.drowned.attributes.scale", drownedScale), 0.0625D, 16.0D);
+        drownedSpawnReinforcements = getDouble("mobs.drowned.attributes.spawn_reinforcements", drownedSpawnReinforcements);
+        drownedJockeyOnlyBaby = getBoolean("mobs.drowned.jockey.only-babies", drownedJockeyOnlyBaby);
+        drownedJockeyChance = getDouble("mobs.drowned.jockey.chance", drownedJockeyChance);
+        drownedJockeyTryExistingChickens = getBoolean("mobs.drowned.jockey.try-existing-chickens", drownedJockeyTryExistingChickens);
+        drownedTakeDamageFromWater = getBoolean("mobs.drowned.takes-damage-from-water", drownedTakeDamageFromWater);
+        drownedBreakDoors = getBoolean("mobs.drowned.can-break-doors", drownedBreakDoors);
+        drownedAlwaysDropExp = getBoolean("mobs.drowned.always-drop-exp", drownedAlwaysDropExp);
+        drownedCanPickUpLoot = getBooleanOrDefault("mobs.drowned.can-pick-up-loot", drownedCanPickUpLoot);
+    }
+
+    public boolean elderGuardianRidable = false;
+    public boolean elderGuardianControllable = true;
+    public double elderGuardianMaxHealth = 80.0D;
+    public double elderGuardianScale = 1.0D;
+    public boolean elderGuardianTakeDamageFromWater = false;
+    public boolean elderGuardianAlwaysDropExp = false;
+    private void elderGuardianSettings() {
+        elderGuardianRidable = getBoolean("mobs.elder_guardian.ridable", elderGuardianRidable);
+        elderGuardianControllable = getBoolean("mobs.elder_guardian.controllable", elderGuardianControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.elder_guardian.attributes.max-health", elderGuardianMaxHealth);
+            set("mobs.elder_guardian.attributes.max-health", null);
+            set("mobs.elder_guardian.attributes.max_health", oldValue);
+        }
+        elderGuardianMaxHealth = getDouble("mobs.elder_guardian.attributes.max_health", elderGuardianMaxHealth);
+        elderGuardianScale = Mth.clamp(getDouble("mobs.elder_guardian.attributes.scale", elderGuardianScale), 0.0625D, 16.0D);
+        elderGuardianTakeDamageFromWater = getBoolean("mobs.elder_guardian.takes-damage-from-water", elderGuardianTakeDamageFromWater);
+        elderGuardianAlwaysDropExp = getBoolean("mobs.elder_guardian.always-drop-exp", elderGuardianAlwaysDropExp);
+    }
+
+    public boolean enchantmentTableLapisPersists = false;
+    private void enchantmentTableSettings() {
+        enchantmentTableLapisPersists = getBoolean("blocks.enchantment-table.lapis-persists", enchantmentTableLapisPersists);
+    }
+
+    public boolean enderDragonRidable = false;
+    public boolean enderDragonRidableInWater = true;
+    public boolean enderDragonControllable = true;
+    public double enderDragonMaxY = 320D;
+    public double enderDragonMaxHealth = 200.0D;
+    public boolean enderDragonAlwaysDropsFullExp = false;
+    public Boolean enderDragonMobGriefingOverride = null;
+    public boolean enderDragonTakeDamageFromWater = false;
+    public boolean enderDragonCanRideVehicles = false;
+    private void enderDragonSettings() {
+        enderDragonRidable = getBoolean("mobs.ender_dragon.ridable", enderDragonRidable);
+        enderDragonRidableInWater = getBoolean("mobs.ender_dragon.ridable-in-water", enderDragonRidableInWater);
+        enderDragonControllable = getBoolean("mobs.ender_dragon.controllable", enderDragonControllable);
+        enderDragonMaxY = getDouble("mobs.ender_dragon.ridable-max-y", enderDragonMaxY);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.ender_dragon.max-health", enderDragonMaxHealth);
+            set("mobs.ender_dragon.max-health", null);
+            set("mobs.ender_dragon.attributes.max_health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ender_dragon.attributes.max-health", enderDragonMaxHealth);
+            set("mobs.ender_dragon.attributes.max-health", null);
+            set("mobs.ender_dragon.attributes.max_health", oldValue);
+        }
+        enderDragonMaxHealth = getDouble("mobs.ender_dragon.attributes.max_health", enderDragonMaxHealth);
+        enderDragonAlwaysDropsFullExp = getBoolean("mobs.ender_dragon.always-drop-full-exp", enderDragonAlwaysDropsFullExp);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.ender_dragon.bypass-mob-griefing", false);
+            set("mobs.ender_dragon.bypass-mob-griefing", null);
+            set("mobs.ender_dragon.mob-griefing-override", oldVal ? true : "default");
+        }
+        enderDragonMobGriefingOverride = getBooleanOrDefault("mobs.ender_dragon.mob-griefing-override", enderDragonMobGriefingOverride);
+        enderDragonTakeDamageFromWater = getBoolean("mobs.ender_dragon.takes-damage-from-water", enderDragonTakeDamageFromWater);
+        enderDragonCanRideVehicles = getBoolean("mobs.ender_dragon.can-ride-vehicles", enderDragonCanRideVehicles);
+    }
+
+    public boolean endermanRidable = false;
+    public boolean endermanRidableInWater = true;
+    public boolean endermanControllable = true;
+    public double endermanMaxHealth = 40.0D;
+    public double endermanScale = 1.0D;
+    public boolean endermanAllowGriefing = true;
+    public boolean endermanDespawnEvenWithBlock = false;
+    public Boolean endermanMobGriefingOverride = null;
+    public boolean endermanTakeDamageFromWater = true;
+    public boolean endermanAggroEndermites = true;
+    public boolean endermanAggroEndermitesOnlyIfPlayerSpawned = false;
+    public boolean endermanDisableStareAggro = false;
+    public boolean endermanIgnoreProjectiles = false;
+    public boolean endermanAlwaysDropExp = false;
+    private void endermanSettings() {
+        endermanRidable = getBoolean("mobs.enderman.ridable", endermanRidable);
+        endermanRidableInWater = getBoolean("mobs.enderman.ridable-in-water", endermanRidableInWater);
+        endermanControllable = getBoolean("mobs.enderman.controllable", endermanControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.enderman.attributes.max-health", endermanMaxHealth);
+            set("mobs.enderman.attributes.max-health", null);
+            set("mobs.enderman.attributes.max_health", oldValue);
+        }
+        if (PurpurConfig.version < 15) {
+            // remove old option
+            set("mobs.enderman.aggressive-towards-spawned-endermites", null);
+        }
+        endermanMaxHealth = getDouble("mobs.enderman.attributes.max_health", endermanMaxHealth);
+        endermanScale = Mth.clamp(getDouble("mobs.enderman.attributes.scale", endermanScale), 0.0625D, 16.0D);
+        endermanAllowGriefing = getBoolean("mobs.enderman.allow-griefing", endermanAllowGriefing);
+        endermanDespawnEvenWithBlock = getBoolean("mobs.enderman.can-despawn-with-held-block", endermanDespawnEvenWithBlock);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.enderman.bypass-mob-griefing", false);
+            set("mobs.enderman.bypass-mob-griefing", null);
+            set("mobs.enderman.mob-griefing-override", oldVal ? true : "default");
+        }
+        endermanMobGriefingOverride = getBooleanOrDefault("mobs.enderman.mob-griefing-override", endermanMobGriefingOverride);
+        endermanTakeDamageFromWater = getBoolean("mobs.enderman.takes-damage-from-water", endermanTakeDamageFromWater);
+        endermanAggroEndermites = getBoolean("mobs.enderman.aggressive-towards-endermites", endermanAggroEndermites);
+        endermanAggroEndermitesOnlyIfPlayerSpawned = getBoolean("mobs.enderman.aggressive-towards-endermites-only-spawned-by-player-thrown-ender-pearls", endermanAggroEndermitesOnlyIfPlayerSpawned);
+        endermanDisableStareAggro = getBoolean("mobs.enderman.disable-player-stare-aggression", endermanDisableStareAggro);
+        endermanIgnoreProjectiles = getBoolean("mobs.enderman.ignore-projectiles", endermanIgnoreProjectiles);
+        endermanAlwaysDropExp = getBoolean("mobs.enderman.always-drop-exp", endermanAlwaysDropExp);
+    }
+
+    public boolean endermiteRidable = false;
+    public boolean endermiteRidableInWater = true;
+    public boolean endermiteControllable = true;
+    public double endermiteMaxHealth = 8.0D;
+    public double endermiteScale = 1.0D;
+    public boolean endermiteTakeDamageFromWater = false;
+    public boolean endermiteAlwaysDropExp = false;
+    private void endermiteSettings() {
+        endermiteRidable = getBoolean("mobs.endermite.ridable", endermiteRidable);
+        endermiteRidableInWater = getBoolean("mobs.endermite.ridable-in-water", endermiteRidableInWater);
+        endermiteControllable = getBoolean("mobs.endermite.controllable", endermiteControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.endermite.attributes.max-health", endermiteMaxHealth);
+            set("mobs.endermite.attributes.max-health", null);
+            set("mobs.endermite.attributes.max_health", oldValue);
+        }
+        endermiteMaxHealth = getDouble("mobs.endermite.attributes.max_health", endermiteMaxHealth);
+        endermiteScale = Mth.clamp(getDouble("mobs.endermite.attributes.scale", endermiteScale), 0.0625D, 16.0D);
+        endermiteTakeDamageFromWater = getBoolean("mobs.endermite.takes-damage-from-water", endermiteTakeDamageFromWater);
+        endermiteAlwaysDropExp = getBoolean("mobs.endermite.always-drop-exp", endermiteAlwaysDropExp);
+    }
+
+    public boolean evokerRidable = false;
+    public boolean evokerRidableInWater = true;
+    public boolean evokerControllable = true;
+    public double evokerMaxHealth = 24.0D;
+    public double evokerScale = 1.0D;
+    public Boolean evokerMobGriefingOverride = null;
+    public boolean evokerTakeDamageFromWater = false;
+    public boolean evokerAlwaysDropExp = false;
+    private void evokerSettings() {
+        evokerRidable = getBoolean("mobs.evoker.ridable", evokerRidable);
+        evokerRidableInWater = getBoolean("mobs.evoker.ridable-in-water", evokerRidableInWater);
+        evokerControllable = getBoolean("mobs.evoker.controllable", evokerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.evoker.attributes.max-health", evokerMaxHealth);
+            set("mobs.evoker.attributes.max-health", null);
+            set("mobs.evoker.attributes.max_health", oldValue);
+        }
+        evokerMaxHealth = getDouble("mobs.evoker.attributes.max_health", evokerMaxHealth);
+        evokerScale = Mth.clamp(getDouble("mobs.evoker.attributes.scale", evokerScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.evoker.bypass-mob-griefing", false);
+            set("mobs.evoker.bypass-mob-griefing", null);
+            set("mobs.evoker.mob-griefing-override", oldVal ? true : "default");
+        }
+        evokerMobGriefingOverride = getBooleanOrDefault("mobs.evoker.mob-griefing-override", evokerMobGriefingOverride);
+        evokerTakeDamageFromWater = getBoolean("mobs.evoker.takes-damage-from-water", evokerTakeDamageFromWater);
+        evokerAlwaysDropExp = getBoolean("mobs.evoker.always-drop-exp", evokerAlwaysDropExp);
+    }
+
+    public boolean foxRidable = false;
+    public boolean foxRidableInWater = true;
+    public boolean foxControllable = true;
+    public double foxMaxHealth = 10.0D;
+    public double foxScale = 1.0D;
+    public boolean foxTypeChangesWithTulips = false;
+    public int foxBreedingTicks = 6000;
+    public Boolean foxMobGriefingOverride = null;
+    public boolean foxTakeDamageFromWater = false;
+    public boolean foxAlwaysDropExp = false;
+    public Boolean foxCanPickUpLoot = null;
+    private void foxSettings() {
+        foxRidable = getBoolean("mobs.fox.ridable", foxRidable);
+        foxRidableInWater = getBoolean("mobs.fox.ridable-in-water", foxRidableInWater);
+        foxControllable = getBoolean("mobs.fox.controllable", foxControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.fox.attributes.max-health", foxMaxHealth);
+            set("mobs.fox.attributes.max-health", null);
+            set("mobs.fox.attributes.max_health", oldValue);
+        }
+        foxMaxHealth = getDouble("mobs.fox.attributes.max_health", foxMaxHealth);
+        foxScale = Mth.clamp(getDouble("mobs.fox.attributes.scale", foxScale), 0.0625D, 16.0D);
+        foxTypeChangesWithTulips = getBoolean("mobs.fox.tulips-change-type", foxTypeChangesWithTulips);
+        foxBreedingTicks = getInt("mobs.fox.breeding-delay-ticks", foxBreedingTicks);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.fox.bypass-mob-griefing", false);
+            set("mobs.fox.bypass-mob-griefing", null);
+            set("mobs.fox.mob-griefing-override", oldVal ? true : "default");
+        }
+        foxMobGriefingOverride = getBooleanOrDefault("mobs.fox.mob-griefing-override", foxMobGriefingOverride);
+        foxTakeDamageFromWater = getBoolean("mobs.fox.takes-damage-from-water", foxTakeDamageFromWater);
+        foxAlwaysDropExp = getBoolean("mobs.fox.always-drop-exp", foxAlwaysDropExp);
+        foxCanPickUpLoot = getBooleanOrDefault("mobs.fox.can-pick-up-loot", foxCanPickUpLoot);
+    }
+
+    public boolean frogRidable = false;
+    public boolean frogRidableInWater = true;
+    public boolean frogControllable = true;
+    public float frogRidableJumpHeight = 0.65F;
+    public int frogBreedingTicks = 6000;
+    private void frogSettings() {
+        frogRidable = getBoolean("mobs.frog.ridable", frogRidable);
+        frogRidableInWater = getBoolean("mobs.frog.ridable-in-water", frogRidableInWater);
+        frogControllable = getBoolean("mobs.frog.controllable", frogControllable);
+        frogRidableJumpHeight = (float) getDouble("mobs.frog.ridable-jump-height", frogRidableJumpHeight);
+        frogBreedingTicks = getInt("mobs.frog.breeding-delay-ticks", frogBreedingTicks);
+    }
+
+    public boolean ghastRidable = false;
+    public boolean ghastRidableInWater = true;
+    public boolean ghastControllable = true;
+    public double ghastMaxY = 320D;
+    public double ghastMaxHealth = 10.0D;
+    public double ghastScale = 1.0D;
+    public boolean ghastTakeDamageFromWater = false;
+    public boolean ghastAlwaysDropExp = false;
+    private void ghastSettings() {
+        ghastRidable = getBoolean("mobs.ghast.ridable", ghastRidable);
+        ghastRidableInWater = getBoolean("mobs.ghast.ridable-in-water", ghastRidableInWater);
+        ghastControllable = getBoolean("mobs.ghast.controllable", ghastControllable);
+        ghastMaxY = getDouble("mobs.ghast.ridable-max-y", ghastMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ghast.attributes.max-health", ghastMaxHealth);
+            set("mobs.ghast.attributes.max-health", null);
+            set("mobs.ghast.attributes.max_health", oldValue);
+        }
+        ghastMaxHealth = getDouble("mobs.ghast.attributes.max_health", ghastMaxHealth);
+        ghastScale = Mth.clamp(getDouble("mobs.ghast.attributes.scale", ghastScale), 0.0625D, 16.0D);
+        ghastTakeDamageFromWater = getBoolean("mobs.ghast.takes-damage-from-water", ghastTakeDamageFromWater);
+        ghastAlwaysDropExp = getBoolean("mobs.ghast.always-drop-exp", ghastAlwaysDropExp);
+    }
+
+    public boolean giantRidable = false;
+    public boolean giantRidableInWater = true;
+    public boolean giantControllable = true;
+    public double giantMovementSpeed = 0.5D;
+    public double giantAttackDamage = 50.0D;
+    public double giantMaxHealth = 100.0D;
+    public double giantScale = 1.0D;
+    public float giantStepHeight = 2.0F;
+    public float giantJumpHeight = 1.0F;
+    public boolean giantHaveAI = false;
+    public boolean giantHaveHostileAI = false;
+    public boolean giantTakeDamageFromWater = false;
+    public boolean giantAlwaysDropExp = false;
+    private void giantSettings() {
+        giantRidable = getBoolean("mobs.giant.ridable", giantRidable);
+        giantRidableInWater = getBoolean("mobs.giant.ridable-in-water", giantRidableInWater);
+        giantControllable = getBoolean("mobs.giant.controllable", giantControllable);
+        giantMovementSpeed = getDouble("mobs.giant.movement-speed", giantMovementSpeed);
+        giantAttackDamage = getDouble("mobs.giant.attack-damage", giantAttackDamage);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.giant.max-health", giantMaxHealth);
+            set("mobs.giant.max-health", null);
+            set("mobs.giant.attributes.max_health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.giant.attributes.max-health", giantMaxHealth);
+            set("mobs.giant.attributes.max-health", null);
+            set("mobs.giant.attributes.max_health", oldValue);
+        }
+        giantMaxHealth = getDouble("mobs.giant.attributes.max_health", giantMaxHealth);
+        giantScale = Mth.clamp(getDouble("mobs.giant.attributes.scale", giantScale), 0.0625D, 16.0D);
+        giantStepHeight = (float) getDouble("mobs.giant.step-height", giantStepHeight);
+        giantJumpHeight = (float) getDouble("mobs.giant.jump-height", giantJumpHeight);
+        giantHaveAI = getBoolean("mobs.giant.have-ai", giantHaveAI);
+        giantHaveHostileAI = getBoolean("mobs.giant.have-hostile-ai", giantHaveHostileAI);
+        giantTakeDamageFromWater = getBoolean("mobs.giant.takes-damage-from-water", giantTakeDamageFromWater);
+        giantAlwaysDropExp = getBoolean("mobs.giant.always-drop-exp", giantAlwaysDropExp);
+    }
+
+    public boolean glowSquidRidable = false;
+    public boolean glowSquidControllable = true;
+    public double glowSquidMaxHealth = 10.0D;
+    public double glowSquidScale = 1.0D;
+    public boolean glowSquidsCanFly = false;
+    public boolean glowSquidTakeDamageFromWater = false;
+    public boolean glowSquidAlwaysDropExp = false;
+    private void glowSquidSettings() {
+        glowSquidRidable = getBoolean("mobs.glow_squid.ridable", glowSquidRidable);
+        glowSquidControllable = getBoolean("mobs.glow_squid.controllable", glowSquidControllable);
+        glowSquidMaxHealth = getDouble("mobs.glow_squid.attributes.max_health", glowSquidMaxHealth);
+        glowSquidScale = Mth.clamp(getDouble("mobs.glow_squid.attributes.scale", glowSquidScale), 0.0625D, 16.0D);
+        glowSquidsCanFly = getBoolean("mobs.glow_squid.can-fly", glowSquidsCanFly);
+        glowSquidTakeDamageFromWater = getBoolean("mobs.glow_squid.takes-damage-from-water", glowSquidTakeDamageFromWater);
+        glowSquidAlwaysDropExp = getBoolean("mobs.glow_squid.always-drop-exp", glowSquidAlwaysDropExp);
+    }
+
+    public boolean goatRidable = false;
+    public boolean goatRidableInWater = true;
+    public boolean goatControllable = true;
+    public double goatMaxHealth = 10.0D;
+    public double goatScale = 1.0D;
+    public int goatBreedingTicks = 6000;
+    public boolean goatTakeDamageFromWater = false;
+    public boolean goatAlwaysDropExp = false;
+    private void goatSettings() {
+        goatRidable = getBoolean("mobs.goat.ridable", goatRidable);
+        goatRidableInWater = getBoolean("mobs.goat.ridable-in-water", goatRidableInWater);
+        goatControllable = getBoolean("mobs.goat.controllable", goatControllable);
+        goatMaxHealth = getDouble("mobs.goat.attributes.max_health", goatMaxHealth);
+        goatScale = Mth.clamp(getDouble("mobs.goat.attributes.scale", goatScale), 0.0625D, 16.0D);
+        goatBreedingTicks = getInt("mobs.goat.breeding-delay-ticks", goatBreedingTicks);
+        goatTakeDamageFromWater = getBoolean("mobs.goat.takes-damage-from-water", goatTakeDamageFromWater);
+        goatAlwaysDropExp = getBoolean("mobs.goat.always-drop-exp", goatAlwaysDropExp);
+    }
+
+    public boolean guardianRidable = false;
+    public boolean guardianControllable = true;
+    public double guardianMaxHealth = 30.0D;
+    public double guardianScale = 1.0D;
+    public boolean guardianTakeDamageFromWater = false;
+    public boolean guardianAlwaysDropExp = false;
+    private void guardianSettings() {
+        guardianRidable = getBoolean("mobs.guardian.ridable", guardianRidable);
+        guardianControllable = getBoolean("mobs.guardian.controllable", guardianControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.guardian.attributes.max-health", guardianMaxHealth);
+            set("mobs.guardian.attributes.max-health", null);
+            set("mobs.guardian.attributes.max_health", oldValue);
+        }
+        guardianMaxHealth = getDouble("mobs.guardian.attributes.max_health", guardianMaxHealth);
+        guardianScale = Mth.clamp(getDouble("mobs.guardian.attributes.scale", guardianScale), 0.0625D, 16.0D);
+        guardianTakeDamageFromWater = getBoolean("mobs.guardian.takes-damage-from-water", guardianTakeDamageFromWater);
+        guardianAlwaysDropExp = getBoolean("mobs.guardian.always-drop-exp", guardianAlwaysDropExp);
+    }
+
+    public boolean forceHalloweenSeason = false;
+    public float chanceHeadHalloweenOnEntity = 0.25F;
+    private void halloweenSetting() {
+        forceHalloweenSeason = getBoolean("gameplay-mechanics.halloween.force", forceHalloweenSeason);
+        chanceHeadHalloweenOnEntity = (float) getDouble("gameplay-mechanics.halloween.head-chance", chanceHeadHalloweenOnEntity);
+    }
+
+    public boolean happyGhastRidableInWater = false;
+    public double happyGhastMaxHealth = 20.0D;
+    public double happyGhastTemptRange = 16.0D;
+    public double happyGhastFlyingSpeed = 0.05D;
+    public double happyGhastMovementSpeed = 0.05D;
+    public double happyGhastFollowRange = 16.0D;
+    public double happyGhastCameraDistance = 8.0D;
+    public double happyGhastScale = 1.0D;
+    public boolean happyGhastTakeDamageFromWater = false;
+    public boolean happyGhastAlwaysDropExp = false;
+    private void happyGhastSettings() {
+        happyGhastRidableInWater = getBoolean("mobs.happy_ghast.ridable-in-water", happyGhastRidableInWater);
+        happyGhastMaxHealth = getDouble("mobs.happy_ghast.attributes.max_health", happyGhastMaxHealth);
+        happyGhastTemptRange = getDouble("mobs.happy_ghast.attributes.tempt_range", happyGhastTemptRange);
+        happyGhastFlyingSpeed = getDouble("mobs.happy_ghast.attributes.flying_speed", happyGhastFlyingSpeed);
+        happyGhastMovementSpeed = getDouble("mobs.happy_ghast.attributes.movement_speed", happyGhastMovementSpeed);
+        happyGhastFollowRange = getDouble("mobs.happy_ghast.attributes.follow_range", happyGhastFollowRange);
+        happyGhastCameraDistance = getDouble("mobs.happy_ghast.attributes.camera_distance", happyGhastCameraDistance);
+        happyGhastScale = Mth.clamp(getDouble("mobs.happy_ghast.attributes.scale", happyGhastScale), 0.0625D, 1.0D);
+        happyGhastTakeDamageFromWater = getBoolean("mobs.happy_ghast.takes-damage-from-water", happyGhastTakeDamageFromWater);
+        happyGhastAlwaysDropExp = getBoolean("mobs.happy_ghast.always-drop-exp", happyGhastAlwaysDropExp);
+    }
+
+    public boolean hoglinRidable = false;
+    public boolean hoglinRidableInWater = true;
+    public boolean hoglinControllable = true;
+    public double hoglinMaxHealth = 40.0D;
+    public double hoglinScale = 1.0D;
+    public int hoglinBreedingTicks = 6000;
+    public boolean hoglinTakeDamageFromWater = false;
+    public boolean hoglinAlwaysDropExp = false;
+    private void hoglinSettings() {
+        hoglinRidable = getBoolean("mobs.hoglin.ridable", hoglinRidable);
+        hoglinRidableInWater = getBoolean("mobs.hoglin.ridable-in-water", hoglinRidableInWater);
+        hoglinControllable = getBoolean("mobs.hoglin.controllable", hoglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.hoglin.attributes.max-health", hoglinMaxHealth);
+            set("mobs.hoglin.attributes.max-health", null);
+            set("mobs.hoglin.attributes.max_health", oldValue);
+        }
+        hoglinMaxHealth = getDouble("mobs.hoglin.attributes.max_health", hoglinMaxHealth);
+        hoglinScale = Mth.clamp(getDouble("mobs.hoglin.attributes.scale", hoglinScale), 0.0625D, 16.0D);
+        hoglinBreedingTicks = getInt("mobs.hoglin.breeding-delay-ticks", hoglinBreedingTicks);
+        hoglinTakeDamageFromWater = getBoolean("mobs.hoglin.takes-damage-from-water", hoglinTakeDamageFromWater);
+        hoglinAlwaysDropExp = getBoolean("mobs.hoglin.always-drop-exp", hoglinAlwaysDropExp);
+    }
+
+    public boolean horseRidableInWater = false;
+    public double horseMaxHealthMin = 15.0D;
+    public double horseMaxHealthMax = 30.0D;
+    public double horseJumpStrengthMin = 0.4D;
+    public double horseJumpStrengthMax = 1.0D;
+    public double horseMovementSpeedMin = 0.1125D;
+    public double horseMovementSpeedMax = 0.3375D;
+    public int horseBreedingTicks = 6000;
+    public boolean horseTakeDamageFromWater = false;
+    public boolean horseAlwaysDropExp = false;
+    private void horseSettings() {
+        horseRidableInWater = getBoolean("mobs.horse.ridable-in-water", horseRidableInWater);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.horse.attributes.max-health.min", horseMaxHealthMin);
+            double oldMax = getDouble("mobs.horse.attributes.max-health.max", horseMaxHealthMax);
+            set("mobs.horse.attributes.max-health", null);
+            set("mobs.horse.attributes.max_health.min", oldMin);
+            set("mobs.horse.attributes.max_health.max", oldMax);
+        }
+        horseMaxHealthMin = getDouble("mobs.horse.attributes.max_health.min", horseMaxHealthMin);
+        horseMaxHealthMax = getDouble("mobs.horse.attributes.max_health.max", horseMaxHealthMax);
+        horseJumpStrengthMin = getDouble("mobs.horse.attributes.jump_strength.min", horseJumpStrengthMin);
+        horseJumpStrengthMax = getDouble("mobs.horse.attributes.jump_strength.max", horseJumpStrengthMax);
+        horseMovementSpeedMin = getDouble("mobs.horse.attributes.movement_speed.min", horseMovementSpeedMin);
+        horseMovementSpeedMax = getDouble("mobs.horse.attributes.movement_speed.max", horseMovementSpeedMax);
+        horseBreedingTicks = getInt("mobs.horse.breeding-delay-ticks", horseBreedingTicks);
+        horseTakeDamageFromWater = getBoolean("mobs.horse.takes-damage-from-water", horseTakeDamageFromWater);
+        horseAlwaysDropExp = getBoolean("mobs.horse.always-drop-exp", horseAlwaysDropExp);
+    }
+
+    public boolean huskRidable = false;
+    public boolean huskRidableInWater = true;
+    public boolean huskControllable = true;
+    public double huskMaxHealth = 20.0D;
+    public double huskScale = 1.0D;
+    public double huskSpawnReinforcements = 0.1D;
+    public boolean huskJockeyOnlyBaby = true;
+    public double huskJockeyChance = 0.05D;
+    public boolean huskJockeyTryExistingChickens = true;
+    public boolean huskTakeDamageFromWater = false;
+    public boolean huskAlwaysDropExp = false;
+    public Boolean huskCanPickUpLoot = null;
+    private void huskSettings() {
+        huskRidable = getBoolean("mobs.husk.ridable", huskRidable);
+        huskRidableInWater = getBoolean("mobs.husk.ridable-in-water", huskRidableInWater);
+        huskControllable = getBoolean("mobs.husk.controllable", huskControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.husk.attributes.max-health", huskMaxHealth);
+            set("mobs.husk.attributes.max-health", null);
+            set("mobs.husk.attributes.max_health", oldValue);
+        }
+        huskMaxHealth = getDouble("mobs.husk.attributes.max_health", huskMaxHealth);
+        huskScale = Mth.clamp(getDouble("mobs.husk.attributes.scale", huskScale), 0.0625D, 16.0D);
+        huskSpawnReinforcements = getDouble("mobs.husk.attributes.spawn_reinforcements", huskSpawnReinforcements);
+        huskJockeyOnlyBaby = getBoolean("mobs.husk.jockey.only-babies", huskJockeyOnlyBaby);
+        huskJockeyChance = getDouble("mobs.husk.jockey.chance", huskJockeyChance);
+        huskJockeyTryExistingChickens = getBoolean("mobs.husk.jockey.try-existing-chickens", huskJockeyTryExistingChickens);
+        huskTakeDamageFromWater = getBoolean("mobs.husk.takes-damage-from-water", huskTakeDamageFromWater);
+        huskAlwaysDropExp = getBoolean("mobs.husk.always-drop-exp", huskAlwaysDropExp);
+        huskCanPickUpLoot = getBooleanOrDefault("mobs.husk.can-pick-up-loot", huskCanPickUpLoot);
+    }
+
+    public boolean illusionerRidable = false;
+    public boolean illusionerRidableInWater = true;
+    public boolean illusionerControllable = true;
+    public double illusionerMovementSpeed = 0.5D;
+    public double illusionerFollowRange = 18.0D;
+    public double illusionerMaxHealth = 32.0D;
+    public double illusionerScale = 1.0D;
+    public boolean illusionerTakeDamageFromWater = false;
+    public boolean illusionerAlwaysDropExp = false;
+    private void illusionerSettings() {
+        illusionerRidable = getBoolean("mobs.illusioner.ridable", illusionerRidable);
+        illusionerRidableInWater = getBoolean("mobs.illusioner.ridable-in-water", illusionerRidableInWater);
+        illusionerControllable = getBoolean("mobs.illusioner.controllable", illusionerControllable);
+        illusionerMovementSpeed = getDouble("mobs.illusioner.movement-speed", illusionerMovementSpeed);
+        illusionerFollowRange = getDouble("mobs.illusioner.follow-range", illusionerFollowRange);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.illusioner.max-health", illusionerMaxHealth);
+            set("mobs.illusioner.max-health", null);
+            set("mobs.illusioner.attributes.max_health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.illusioner.attributes.max-health", illusionerMaxHealth);
+            set("mobs.illusioner.attributes.max-health", null);
+            set("mobs.illusioner.attributes.max_health", oldValue);
+        }
+        illusionerMaxHealth = getDouble("mobs.illusioner.attributes.max_health", illusionerMaxHealth);
+        illusionerScale = Mth.clamp(getDouble("mobs.illusioner.attributes.scale", illusionerScale), 0.0625D, 16.0D);
+        illusionerTakeDamageFromWater = getBoolean("mobs.illusioner.takes-damage-from-water", illusionerTakeDamageFromWater);
+        illusionerAlwaysDropExp = getBoolean("mobs.illusioner.always-drop-exp", illusionerAlwaysDropExp);
+    }
+
+    public boolean ironGolemRidable = false;
+    public boolean ironGolemRidableInWater = true;
+    public boolean ironGolemControllable = true;
+    public boolean ironGolemCanSwim = false;
+    public double ironGolemMaxHealth = 100.0D;
+    public double ironGolemScale = 1.0D;
+    public boolean ironGolemTakeDamageFromWater = false;
+    public boolean ironGolemPoppyCalm = false;
+    public boolean ironGolemHealCalm = false;
+    public boolean ironGolemAlwaysDropExp = false;
+    private void ironGolemSettings() {
+        ironGolemRidable = getBoolean("mobs.iron_golem.ridable", ironGolemRidable);
+        ironGolemRidableInWater = getBoolean("mobs.iron_golem.ridable-in-water", ironGolemRidableInWater);
+        ironGolemControllable = getBoolean("mobs.iron_golem.controllable", ironGolemControllable);
+        ironGolemCanSwim = getBoolean("mobs.iron_golem.can-swim", ironGolemCanSwim);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.iron_golem.attributes.max-health", ironGolemMaxHealth);
+            set("mobs.iron_golem.attributes.max-health", null);
+            set("mobs.iron_golem.attributes.max_health", oldValue);
+        }
+        ironGolemMaxHealth = getDouble("mobs.iron_golem.attributes.max_health", ironGolemMaxHealth);
+        ironGolemScale = Mth.clamp(getDouble("mobs.iron_golem.attributes.scale", ironGolemScale), 0.0625D, 16.0D);
+        ironGolemTakeDamageFromWater = getBoolean("mobs.iron_golem.takes-damage-from-water", ironGolemTakeDamageFromWater);
+        ironGolemPoppyCalm = getBoolean("mobs.iron_golem.poppy-calms-anger", ironGolemPoppyCalm);
+        ironGolemHealCalm = getBoolean("mobs.iron_golem.healing-calms-anger", ironGolemHealCalm);
+        ironGolemAlwaysDropExp = getBoolean("mobs.iron_golem.always-drop-exp", ironGolemAlwaysDropExp);
+    }
+
+    public boolean llamaRidable = false;
+    public boolean llamaRidableInWater = false;
+    public boolean llamaControllable = true;
+    public double llamaMaxHealthMin = 15.0D;
+    public double llamaMaxHealthMax = 30.0D;
+    public double llamaJumpStrengthMin = 0.5D;
+    public double llamaJumpStrengthMax = 0.5D;
+    public double llamaMovementSpeedMin = 0.175D;
+    public double llamaMovementSpeedMax = 0.175D;
+    public int llamaBreedingTicks = 6000;
+    public boolean llamaTakeDamageFromWater = false;
+    public boolean llamaJoinCaravans = true;
+    public boolean llamaAlwaysDropExp = false;
+    private void llamaSettings() {
+        llamaRidable = getBoolean("mobs.llama.ridable", llamaRidable);
+        llamaRidableInWater = getBoolean("mobs.llama.ridable-in-water", llamaRidableInWater);
+        llamaControllable = getBoolean("mobs.llama.controllable", llamaControllable);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.llama.attributes.max-health.min", llamaMaxHealthMin);
+            double oldMax = getDouble("mobs.llama.attributes.max-health.max", llamaMaxHealthMax);
+            set("mobs.llama.attributes.max-health", null);
+            set("mobs.llama.attributes.max_health.min", oldMin);
+            set("mobs.llama.attributes.max_health.max", oldMax);
+        }
+        llamaMaxHealthMin = getDouble("mobs.llama.attributes.max_health.min", llamaMaxHealthMin);
+        llamaMaxHealthMax = getDouble("mobs.llama.attributes.max_health.max", llamaMaxHealthMax);
+        llamaJumpStrengthMin = getDouble("mobs.llama.attributes.jump_strength.min", llamaJumpStrengthMin);
+        llamaJumpStrengthMax = getDouble("mobs.llama.attributes.jump_strength.max", llamaJumpStrengthMax);
+        llamaMovementSpeedMin = getDouble("mobs.llama.attributes.movement_speed.min", llamaMovementSpeedMin);
+        llamaMovementSpeedMax = getDouble("mobs.llama.attributes.movement_speed.max", llamaMovementSpeedMax);
+        llamaBreedingTicks = getInt("mobs.llama.breeding-delay-ticks", llamaBreedingTicks);
+        llamaTakeDamageFromWater = getBoolean("mobs.llama.takes-damage-from-water", llamaTakeDamageFromWater);
+        llamaJoinCaravans = getBoolean("mobs.llama.join-caravans", llamaJoinCaravans);
+        llamaAlwaysDropExp = getBoolean("mobs.llama.always-drop-exp", llamaAlwaysDropExp);
+    }
+
+    public boolean magmaCubeRidable = false;
+    public boolean magmaCubeRidableInWater = true;
+    public boolean magmaCubeControllable = true;
+    public String magmaCubeMaxHealth = "size * size";
+    public String magmaCubeAttackDamage = "size";
+    public Map<Integer, Double> magmaCubeMaxHealthCache = new HashMap<>();
+    public Map<Integer, Double> magmaCubeAttackDamageCache = new HashMap<>();
+    public boolean magmaCubeTakeDamageFromWater = false;
+    public boolean magmaCubeAlwaysDropExp = false;
+    private void magmaCubeSettings() {
+        magmaCubeRidable = getBoolean("mobs.magma_cube.ridable", magmaCubeRidable);
+        magmaCubeRidableInWater = getBoolean("mobs.magma_cube.ridable-in-water", magmaCubeRidableInWater);
+        magmaCubeControllable = getBoolean("mobs.magma_cube.controllable", magmaCubeControllable);
+        if (PurpurConfig.version < 10) {
+            String oldValue = getString("mobs.magma_cube.attributes.max-health", magmaCubeMaxHealth);
+            set("mobs.magma_cube.attributes.max-health", null);
+            set("mobs.magma_cube.attributes.max_health", oldValue);
+        }
+        magmaCubeMaxHealth = getString("mobs.magma_cube.attributes.max_health", magmaCubeMaxHealth);
+        magmaCubeAttackDamage = getString("mobs.magma_cube.attributes.attack_damage", magmaCubeAttackDamage);
+        magmaCubeMaxHealthCache.clear();
+        magmaCubeAttackDamageCache.clear();
+        magmaCubeTakeDamageFromWater = getBoolean("mobs.magma_cube.takes-damage-from-water", magmaCubeTakeDamageFromWater);
+        magmaCubeAlwaysDropExp = getBoolean("mobs.magma_cube.always-drop-exp", magmaCubeAlwaysDropExp);
+    }
+
+    public boolean mooshroomRidable = false;
+    public boolean mooshroomRidableInWater = true;
+    public boolean mooshroomControllable = true;
+    public double mooshroomMaxHealth = 10.0D;
+    public double mooshroomScale = 1.0D;
+    public int mooshroomBreedingTicks = 6000;
+    public boolean mooshroomTakeDamageFromWater = false;
+    public boolean mooshroomAlwaysDropExp = false;
+    private void mooshroomSettings() {
+        mooshroomRidable = getBoolean("mobs.mooshroom.ridable", mooshroomRidable);
+        mooshroomRidableInWater = getBoolean("mobs.mooshroom.ridable-in-water", mooshroomRidableInWater);
+        mooshroomControllable = getBoolean("mobs.mooshroom.controllable", mooshroomControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.mooshroom.attributes.max-health", mooshroomMaxHealth);
+            set("mobs.mooshroom.attributes.max-health", null);
+            set("mobs.mooshroom.attributes.max_health", oldValue);
+        }
+        mooshroomMaxHealth = getDouble("mobs.mooshroom.attributes.max_health", mooshroomMaxHealth);
+        mooshroomScale = Mth.clamp(getDouble("mobs.mooshroom.attributes.scale", mooshroomScale), 0.0625D, 16.0D);
+        mooshroomBreedingTicks = getInt("mobs.mooshroom.breeding-delay-ticks", mooshroomBreedingTicks);
+        mooshroomTakeDamageFromWater = getBoolean("mobs.mooshroom.takes-damage-from-water", mooshroomTakeDamageFromWater);
+        mooshroomAlwaysDropExp = getBoolean("mobs.mooshroom.always-drop-exp", mooshroomAlwaysDropExp);
+    }
+
+    public boolean muleRidableInWater = false;
+    public double muleMaxHealthMin = 15.0D;
+    public double muleMaxHealthMax = 30.0D;
+    public double muleJumpStrengthMin = 0.5D;
+    public double muleJumpStrengthMax = 0.5D;
+    public double muleMovementSpeedMin = 0.175D;
+    public double muleMovementSpeedMax = 0.175D;
+    public int muleBreedingTicks = 6000;
+    public boolean muleTakeDamageFromWater = false;
+    public boolean muleAlwaysDropExp = false;
+    private void muleSettings() {
+        muleRidableInWater = getBoolean("mobs.mule.ridable-in-water", muleRidableInWater);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.mule.attributes.max-health.min", muleMaxHealthMin);
+            double oldMax = getDouble("mobs.mule.attributes.max-health.max", muleMaxHealthMax);
+            set("mobs.mule.attributes.max-health", null);
+            set("mobs.mule.attributes.max_health.min", oldMin);
+            set("mobs.mule.attributes.max_health.max", oldMax);
+        }
+        muleMaxHealthMin = getDouble("mobs.mule.attributes.max_health.min", muleMaxHealthMin);
+        muleMaxHealthMax = getDouble("mobs.mule.attributes.max_health.max", muleMaxHealthMax);
+        muleJumpStrengthMin = getDouble("mobs.mule.attributes.jump_strength.min", muleJumpStrengthMin);
+        muleJumpStrengthMax = getDouble("mobs.mule.attributes.jump_strength.max", muleJumpStrengthMax);
+        muleMovementSpeedMin = getDouble("mobs.mule.attributes.movement_speed.min", muleMovementSpeedMin);
+        muleMovementSpeedMax = getDouble("mobs.mule.attributes.movement_speed.max", muleMovementSpeedMax);
+        muleBreedingTicks = getInt("mobs.mule.breeding-delay-ticks", muleBreedingTicks);
+        muleTakeDamageFromWater = getBoolean("mobs.mule.takes-damage-from-water", muleTakeDamageFromWater);
+        muleAlwaysDropExp = getBoolean("mobs.mule.always-drop-exp", muleAlwaysDropExp);
+    }
+
+    public double nautilusMaxHealth = 15.0D;
+    public double nautilusMovementSpeed = 1.0D;
+    public double nautilusAttackDamage = 3.0D;
+    public double nautilusKnockbackResistance = 0.3D;
+    public double nautilusScale = 1.0D;
+    public int nautilusBreedingTicks = 6000;
+    public boolean nautilusAlwaysDropExp = false;
+    private void nautilusSettings() {
+        nautilusMaxHealth = getDouble("mobs.nautilus.attributes.max_health", nautilusMaxHealth);
+        nautilusMovementSpeed = getDouble("mobs.nautilus.attributes.movement_speed", nautilusMovementSpeed);
+        nautilusAttackDamage = getDouble("mobs.nautilus.attributes.attack_damage", nautilusAttackDamage);
+        nautilusKnockbackResistance = getDouble("mobs.nautilus.attributes.knockback_resistance", nautilusKnockbackResistance);
+        nautilusScale = Mth.clamp(getDouble("mobs.nautilus.attributes.scale", nautilusScale), 0.0625D, 16.0D);
+        nautilusBreedingTicks = getInt("mobs.nautilus.breeding-delay-ticks", nautilusBreedingTicks);
+        nautilusAlwaysDropExp = getBoolean("mobs.nautilus.always-drop-exp", nautilusAlwaysDropExp);
+    }
+
+    public boolean ocelotRidable = false;
+    public boolean ocelotRidableInWater = true;
+    public boolean ocelotControllable = true;
+    public double ocelotMaxHealth = 10.0D;
+    public double ocelotScale = 1.0D;
+    public int ocelotBreedingTicks = 6000;
+    public boolean ocelotTakeDamageFromWater = false;
+    public boolean ocelotAlwaysDropExp = false;
+    public boolean ocelotSpawnUnderSeaLevel = false;
+    private void ocelotSettings() {
+        ocelotRidable = getBoolean("mobs.ocelot.ridable", ocelotRidable);
+        ocelotRidableInWater = getBoolean("mobs.ocelot.ridable-in-water", ocelotRidableInWater);
+        ocelotControllable = getBoolean("mobs.ocelot.controllable", ocelotControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ocelot.attributes.max-health", ocelotMaxHealth);
+            set("mobs.ocelot.attributes.max-health", null);
+            set("mobs.ocelot.attributes.max_health", oldValue);
+        }
+        ocelotMaxHealth = getDouble("mobs.ocelot.attributes.max_health", ocelotMaxHealth);
+        ocelotScale = Mth.clamp(getDouble("mobs.ocelot.attributes.scale", ocelotScale), 0.0625D, 16.0D);
+        ocelotBreedingTicks = getInt("mobs.ocelot.breeding-delay-ticks", ocelotBreedingTicks);
+        ocelotTakeDamageFromWater = getBoolean("mobs.ocelot.takes-damage-from-water", ocelotTakeDamageFromWater);
+        ocelotAlwaysDropExp = getBoolean("mobs.ocelot.always-drop-exp", ocelotAlwaysDropExp);
+        ocelotSpawnUnderSeaLevel = getBoolean("mobs.ocelot.spawn-below-sea-level", ocelotSpawnUnderSeaLevel);
+    }
+
+    public boolean pandaRidable = false;
+    public boolean pandaRidableInWater = true;
+    public boolean pandaControllable = true;
+    public double pandaMaxHealth = 20.0D;
+    public double pandaScale = 1.0D;
+    public int pandaBreedingTicks = 6000;
+    public boolean pandaTakeDamageFromWater = false;
+    public boolean pandaAlwaysDropExp = false;
+    private void pandaSettings() {
+        pandaRidable = getBoolean("mobs.panda.ridable", pandaRidable);
+        pandaRidableInWater = getBoolean("mobs.panda.ridable-in-water", pandaRidableInWater);
+        pandaControllable = getBoolean("mobs.panda.controllable", pandaControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.panda.attributes.max-health", pandaMaxHealth);
+            set("mobs.panda.attributes.max-health", null);
+            set("mobs.panda.attributes.max_health", oldValue);
+        }
+        pandaMaxHealth = getDouble("mobs.panda.attributes.max_health", pandaMaxHealth);
+        pandaScale = Mth.clamp(getDouble("mobs.panda.attributes.scale", pandaScale), 0.0625D, 16.0D);
+        pandaBreedingTicks = getInt("mobs.panda.breeding-delay-ticks", pandaBreedingTicks);
+        pandaTakeDamageFromWater = getBoolean("mobs.panda.takes-damage-from-water", pandaTakeDamageFromWater);
+        pandaAlwaysDropExp = getBoolean("mobs.panda.always-drop-exp", pandaAlwaysDropExp);
+    }
+
+    public boolean parrotRidable = false;
+    public boolean parrotRidableInWater = true;
+    public boolean parrotControllable = true;
+    public double parrotMaxY = 320D;
+    public double parrotMaxHealth = 6.0D;
+    public double parrotScale = 1.0D;
+    public boolean parrotTakeDamageFromWater = false;
+    public boolean parrotBreedable = false;
+    public boolean parrotAlwaysDropExp = false;
+    private void parrotSettings() {
+        parrotRidable = getBoolean("mobs.parrot.ridable", parrotRidable);
+        parrotRidableInWater = getBoolean("mobs.parrot.ridable-in-water", parrotRidableInWater);
+        parrotControllable = getBoolean("mobs.parrot.controllable", parrotControllable);
+        parrotMaxY = getDouble("mobs.parrot.ridable-max-y", parrotMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.parrot.attributes.max-health", parrotMaxHealth);
+            set("mobs.parrot.attributes.max-health", null);
+            set("mobs.parrot.attributes.max_health", oldValue);
+        }
+        parrotMaxHealth = getDouble("mobs.parrot.attributes.max_health", parrotMaxHealth);
+        parrotScale = Mth.clamp(getDouble("mobs.parrot.attributes.scale", parrotScale), 0.0625D, 16.0D);
+        parrotTakeDamageFromWater = getBoolean("mobs.parrot.takes-damage-from-water", parrotTakeDamageFromWater);
+        parrotBreedable = getBoolean("mobs.parrot.can-breed", parrotBreedable);
+        parrotAlwaysDropExp = getBoolean("mobs.parrot.always-drop-exp", parrotAlwaysDropExp);
+    }
+
+    public boolean phantomRidable = false;
+    public boolean phantomRidableInWater = true;
+    public boolean phantomControllable = true;
+    public double phantomMaxY = 320D;
+    public float phantomFlameDamage = 1.0F;
+    public int phantomFlameFireTime = 8;
+    public boolean phantomAllowGriefing = false;
+    public String phantomMaxHealth = "20.0";
+    public String phantomAttackDamage = "6 + size";
+    public Map<Integer, Double> phantomMaxHealthCache = new HashMap<>();
+    public Map<Integer, Double> phantomAttackDamageCache = new HashMap<>();
+    public double phantomAttackedByCrystalRadius = 0.0D;
+    public float phantomAttackedByCrystalDamage = 1.0F;
+    public double phantomOrbitCrystalRadius = 0.0D;
+    public int phantomSpawnMinSkyDarkness = 5;
+    public boolean phantomSpawnOnlyAboveSeaLevel = true;
+    public boolean phantomSpawnOnlyWithVisibleSky = true;
+    public double phantomSpawnLocalDifficultyChance = 3.0D;
+    public int phantomSpawnMinPerAttempt = 1;
+    public int phantomSpawnMaxPerAttempt = -1;
+    public int phantomBurnInLight = 0;
+    public boolean phantomIgnorePlayersWithTorch = false;
+    public boolean phantomBurnInDaylight = true;
+    public boolean phantomFlamesOnSwoop = false;
+    public boolean phantomTakeDamageFromWater = false;
+    public boolean phantomAlwaysDropExp = false;
+    public int phantomMinSize = 0;
+    public int phantomMaxSize = 0;
+    private void phantomSettings() {
+        phantomRidable = getBoolean("mobs.phantom.ridable", phantomRidable);
+        phantomRidableInWater = getBoolean("mobs.phantom.ridable-in-water", phantomRidableInWater);
+        phantomControllable = getBoolean("mobs.phantom.controllable", phantomControllable);
+        phantomMaxY = getDouble("mobs.phantom.ridable-max-y", phantomMaxY);
+        phantomFlameDamage = (float) getDouble("mobs.phantom.flames.damage", phantomFlameDamage);
+        phantomFlameFireTime = getInt("mobs.phantom.flames.fire-time", phantomFlameFireTime);
+        phantomAllowGriefing = getBoolean("mobs.phantom.allow-griefing", phantomAllowGriefing);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.phantom.attributes.max-health", Double.parseDouble(phantomMaxHealth));
+            set("mobs.phantom.attributes.max-health", null);
+            set("mobs.phantom.attributes.max_health", String.valueOf(oldValue));
+        }
+        if (PurpurConfig.version < 25) {
+            double oldValue = getDouble("mobs.phantom.attributes.max_health", Double.parseDouble(phantomMaxHealth));
+            set("mobs.phantom.attributes.max_health", String.valueOf(oldValue));
+        }
+        phantomMaxHealth = getString("mobs.phantom.attributes.max_health", phantomMaxHealth);
+        phantomAttackDamage = getString("mobs.phantom.attributes.attack_damage", phantomAttackDamage);
+        phantomMaxHealthCache.clear();
+        phantomAttackDamageCache.clear();
+        phantomAttackedByCrystalRadius = getDouble("mobs.phantom.attacked-by-crystal-range", phantomAttackedByCrystalRadius);
+        phantomAttackedByCrystalDamage = (float) getDouble("mobs.phantom.attacked-by-crystal-damage", phantomAttackedByCrystalDamage);
+        phantomOrbitCrystalRadius = getDouble("mobs.phantom.orbit-crystal-radius", phantomOrbitCrystalRadius);
+        phantomSpawnMinSkyDarkness = getInt("mobs.phantom.spawn.min-sky-darkness", phantomSpawnMinSkyDarkness);
+        phantomSpawnOnlyAboveSeaLevel = getBoolean("mobs.phantom.spawn.only-above-sea-level", phantomSpawnOnlyAboveSeaLevel);
+        phantomSpawnOnlyWithVisibleSky = getBoolean("mobs.phantom.spawn.only-with-visible-sky", phantomSpawnOnlyWithVisibleSky);
+        phantomSpawnLocalDifficultyChance = getDouble("mobs.phantom.spawn.local-difficulty-chance", phantomSpawnLocalDifficultyChance);
+        phantomSpawnMinPerAttempt = getInt("mobs.phantom.spawn.per-attempt.min", phantomSpawnMinPerAttempt);
+        phantomSpawnMaxPerAttempt = getInt("mobs.phantom.spawn.per-attempt.max", phantomSpawnMaxPerAttempt);
+        phantomBurnInLight = getInt("mobs.phantom.burn-in-light", phantomBurnInLight);
+        phantomBurnInDaylight = getBoolean("mobs.phantom.burn-in-daylight", phantomBurnInDaylight);
+        phantomIgnorePlayersWithTorch = getBoolean("mobs.phantom.ignore-players-with-torch", phantomIgnorePlayersWithTorch);
+        phantomFlamesOnSwoop = getBoolean("mobs.phantom.flames-on-swoop", phantomFlamesOnSwoop);
+        phantomTakeDamageFromWater = getBoolean("mobs.phantom.takes-damage-from-water", phantomTakeDamageFromWater);
+        phantomAlwaysDropExp = getBoolean("mobs.phantom.always-drop-exp", phantomAlwaysDropExp);
+        phantomMinSize = Mth.clamp(getInt("mobs.phantom.size.min", phantomMinSize), 0, 64);
+        phantomMaxSize = Mth.clamp(getInt("mobs.phantom.size.max", phantomMaxSize), 0, 64);
+        if (phantomMinSize > phantomMaxSize) {
+            phantomMinSize = phantomMinSize ^ phantomMaxSize;
+            phantomMaxSize = phantomMinSize ^ phantomMaxSize;
+            phantomMinSize = phantomMinSize ^ phantomMaxSize;
+        }
+    }
+
+    public boolean pigRidable = false;
+    public boolean pigRidableInWater = false;
+    public boolean pigControllable = true;
+    public double pigMaxHealth = 10.0D;
+    public double pigScale = 1.0D;
+    public boolean pigGiveSaddleBack = false;
+    public int pigBreedingTicks = 6000;
+    public boolean pigTakeDamageFromWater = false;
+    public boolean pigAlwaysDropExp = false;
+    private void pigSettings() {
+        pigRidable = getBoolean("mobs.pig.ridable", pigRidable);
+        pigRidableInWater = getBoolean("mobs.pig.ridable-in-water", pigRidableInWater);
+        pigControllable = getBoolean("mobs.pig.controllable", pigControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.pig.attributes.max-health", pigMaxHealth);
+            set("mobs.pig.attributes.max-health", null);
+            set("mobs.pig.attributes.max_health", oldValue);
+        }
+        pigMaxHealth = getDouble("mobs.pig.attributes.max_health", pigMaxHealth);
+        pigScale = Mth.clamp(getDouble("mobs.pig.attributes.scale", pigScale), 0.0625D, 16.0D);
+        pigGiveSaddleBack = getBoolean("mobs.pig.give-saddle-back", pigGiveSaddleBack);
+        pigBreedingTicks = getInt("mobs.pig.breeding-delay-ticks", pigBreedingTicks);
+        pigTakeDamageFromWater = getBoolean("mobs.pig.takes-damage-from-water", pigTakeDamageFromWater);
+        pigAlwaysDropExp = getBoolean("mobs.pig.always-drop-exp", pigAlwaysDropExp);
+    }
+
+    public boolean piglinRidable = false;
+    public boolean piglinRidableInWater = true;
+    public boolean piglinControllable = true;
+    public double piglinMaxHealth = 16.0D;
+    public double piglinScale = 1.0D;
+    public boolean piglinTakeDamageFromWater = false;
+    public int piglinPortalSpawnModifier = 2000;
+    public boolean piglinAlwaysDropExp = false;
+    public double piglinHeadVisibilityPercent = 0.5D;
+    public boolean piglinIgnoresArmorWithGoldTrim = false;
+    public Boolean piglinCanPickUpLoot = null;
+    private void piglinSettings() {
+        piglinRidable = getBoolean("mobs.piglin.ridable", piglinRidable);
+        piglinRidableInWater = getBoolean("mobs.piglin.ridable-in-water", piglinRidableInWater);
+        piglinControllable = getBoolean("mobs.piglin.controllable", piglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.piglin.attributes.max-health", piglinMaxHealth);
+            set("mobs.piglin.attributes.max-health", null);
+            set("mobs.piglin.attributes.max_health", oldValue);
+        }
+        piglinMaxHealth = getDouble("mobs.piglin.attributes.max_health", piglinMaxHealth);
+        piglinScale = Mth.clamp(getDouble("mobs.piglin.attributes.scale", piglinScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.piglin.bypass-mob-griefing", false);
+            set("mobs.piglin.bypass-mob-griefing", null);
+            set("mobs.piglin.mob-griefing-override", oldVal ? true : "default");
+        }
+        piglinTakeDamageFromWater = getBoolean("mobs.piglin.takes-damage-from-water", piglinTakeDamageFromWater);
+        piglinPortalSpawnModifier = getInt("mobs.piglin.portal-spawn-modifier", piglinPortalSpawnModifier);
+        piglinAlwaysDropExp = getBoolean("mobs.piglin.always-drop-exp", piglinAlwaysDropExp);
+        piglinHeadVisibilityPercent = getDouble("mobs.piglin.head-visibility-percent", piglinHeadVisibilityPercent);
+        piglinIgnoresArmorWithGoldTrim = getBoolean("mobs.piglin.ignores-armor-with-gold-trim", piglinIgnoresArmorWithGoldTrim);
+        if (PurpurConfig.version < 47) {
+            boolean oldVal = getBoolean("mobs.piglin.mob-griefing-override", false);
+            set("mobs.piglin.mob-griefing-override", null);
+            set("mobs.piglin.can-pick-up-loot", oldVal ? true : "default");
+        }
+        piglinCanPickUpLoot = getBooleanOrDefault("mobs.piglin.can-pick-up-loot", piglinCanPickUpLoot);
+    }
+
+    public boolean piglinBruteRidable = false;
+    public boolean piglinBruteRidableInWater = true;
+    public boolean piglinBruteControllable = true;
+    public double piglinBruteMaxHealth = 50.0D;
+    public double piglinBruteScale = 1.0D;
+    public boolean piglinBruteTakeDamageFromWater = false;
+    public boolean piglinBruteAlwaysDropExp = false;
+    public Boolean piglinBruteCanPickUpLoot = null;
+    private void piglinBruteSettings() {
+        piglinBruteRidable = getBoolean("mobs.piglin_brute.ridable", piglinBruteRidable);
+        piglinBruteRidableInWater = getBoolean("mobs.piglin_brute.ridable-in-water", piglinBruteRidableInWater);
+        piglinBruteControllable = getBoolean("mobs.piglin_brute.controllable", piglinBruteControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.piglin_brute.attributes.max-health", piglinBruteMaxHealth);
+            set("mobs.piglin_brute.attributes.max-health", null);
+            set("mobs.piglin_brute.attributes.max_health", oldValue);
+        }
+        piglinBruteMaxHealth = getDouble("mobs.piglin_brute.attributes.max_health", piglinBruteMaxHealth);
+        piglinBruteScale = Mth.clamp(getDouble("mobs.piglin_brute.attributes.scale", piglinBruteScale), 0.0625D, 16.0D);
+        piglinBruteTakeDamageFromWater = getBoolean("mobs.piglin_brute.takes-damage-from-water", piglinBruteTakeDamageFromWater);
+        piglinBruteAlwaysDropExp = getBoolean("mobs.piglin_brute.always-drop-exp", piglinBruteAlwaysDropExp);
+        piglinBruteCanPickUpLoot = getBooleanOrDefault("mobs.piglin_brute.can-pick-up-loot", piglinBruteCanPickUpLoot);
+    }
+
+    public boolean pillagerRidable = false;
+    public boolean pillagerRidableInWater = true;
+    public boolean pillagerControllable = true;
+    public double pillagerMaxHealth = 24.0D;
+    public double pillagerScale = 1.0D;
+    public boolean pillagerTakeDamageFromWater = false;
+    public boolean pillagerAlwaysDropExp = false;
+    public Boolean pillagerCanPickUpLoot = null;
+    private void pillagerSettings() {
+        pillagerRidable = getBoolean("mobs.pillager.ridable", pillagerRidable);
+        pillagerRidableInWater = getBoolean("mobs.pillager.ridable-in-water", pillagerRidableInWater);
+        pillagerControllable = getBoolean("mobs.pillager.controllable", pillagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.pillager.attributes.max-health", pillagerMaxHealth);
+            set("mobs.pillager.attributes.max-health", null);
+            set("mobs.pillager.attributes.max_health", oldValue);
+        }
+        pillagerMaxHealth = getDouble("mobs.pillager.attributes.max_health", pillagerMaxHealth);
+        pillagerScale = Mth.clamp(getDouble("mobs.pillager.attributes.scale", pillagerScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.pillager.bypass-mob-griefing", false);
+            set("mobs.pillager.bypass-mob-griefing", null);
+            set("mobs.pillager.mob-griefing-override", oldVal ? true : "default");
+        }
+        pillagerTakeDamageFromWater = getBoolean("mobs.pillager.takes-damage-from-water", pillagerTakeDamageFromWater);
+        pillagerAlwaysDropExp = getBoolean("mobs.pillager.always-drop-exp", pillagerAlwaysDropExp);
+        if (PurpurConfig.version < 47) {
+            boolean oldVal = getBoolean("mobs.pillager.mob-griefing-override", false);
+            set("mobs.pillager.mob-griefing-override", null);
+            set("mobs.pillager.can-pick-up-loot", oldVal ? true : "default");
+        }
+        pillagerCanPickUpLoot = getBooleanOrDefault("mobs.pillager.can-pick-up-loot", pillagerCanPickUpLoot);
+    }
+
+    public boolean polarBearRidable = false;
+    public boolean polarBearRidableInWater = true;
+    public boolean polarBearControllable = true;
+    public double polarBearMaxHealth = 30.0D;
+    public double polarBearScale = 1.0D;
+    public String polarBearBreedableItemString = "";
+    public Item polarBearBreedableItem = null;
+    public int polarBearBreedingTicks = 6000;
+    public boolean polarBearTakeDamageFromWater = false;
+    public boolean polarBearAlwaysDropExp = false;
+    private void polarBearSettings() {
+        polarBearRidable = getBoolean("mobs.polar_bear.ridable", polarBearRidable);
+        polarBearRidableInWater = getBoolean("mobs.polar_bear.ridable-in-water", polarBearRidableInWater);
+        polarBearControllable = getBoolean("mobs.polar_bear.controllable", polarBearControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.polar_bear.attributes.max-health", polarBearMaxHealth);
+            set("mobs.polar_bear.attributes.max-health", null);
+            set("mobs.polar_bear.attributes.max_health", oldValue);
+        }
+        polarBearMaxHealth = getDouble("mobs.polar_bear.attributes.max_health", polarBearMaxHealth);
+        polarBearScale = Mth.clamp(getDouble("mobs.polar_bear.attributes.scale", polarBearScale), 0.0625D, 16.0D);
+        polarBearBreedableItemString = getString("mobs.polar_bear.breedable-item", polarBearBreedableItemString);
+        Item item = BuiltInRegistries.ITEM.getValue(Identifier.parse(polarBearBreedableItemString));
+        if (item != Items.AIR) polarBearBreedableItem = item;
+        polarBearBreedingTicks = getInt("mobs.polar_bear.breeding-delay-ticks", polarBearBreedingTicks);
+        polarBearTakeDamageFromWater = getBoolean("mobs.polar_bear.takes-damage-from-water", polarBearTakeDamageFromWater);
+        polarBearAlwaysDropExp = getBoolean("mobs.polar_bear.always-drop-exp", polarBearAlwaysDropExp);
+    }
+
+    public boolean pufferfishRidable = false;
+    public boolean pufferfishControllable = true;
+    public double pufferfishMaxHealth = 3.0D;
+    public double pufferfishScale = 1.0D;
+    public boolean pufferfishTakeDamageFromWater = false;
+    public boolean pufferfishAlwaysDropExp = false;
+    private void pufferfishSettings() {
+        pufferfishRidable = getBoolean("mobs.pufferfish.ridable", pufferfishRidable);
+        pufferfishControllable = getBoolean("mobs.pufferfish.controllable", pufferfishControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.pufferfish.attributes.max-health", pufferfishMaxHealth);
+            set("mobs.pufferfish.attributes.max-health", null);
+            set("mobs.pufferfish.attributes.max_health", oldValue);
+        }
+        pufferfishMaxHealth = getDouble("mobs.pufferfish.attributes.max_health", pufferfishMaxHealth);
+        pufferfishScale = Mth.clamp(getDouble("mobs.pufferfish.attributes.scale", pufferfishScale), 0.0625D, 16.0D);
+        pufferfishTakeDamageFromWater = getBoolean("mobs.pufferfish.takes-damage-from-water", pufferfishTakeDamageFromWater);
+        pufferfishAlwaysDropExp = getBoolean("mobs.pufferfish.always-drop-exp", pufferfishAlwaysDropExp);
+    }
+
+    public boolean rabbitRidable = false;
+    public boolean rabbitRidableInWater = true;
+    public boolean rabbitControllable = true;
+    public double rabbitMaxHealth = 3.0D;
+    public double rabbitScale = 1.0D;
+    public double rabbitNaturalToast = 0.0D;
+    public double rabbitNaturalKiller = 0.0D;
+    public int rabbitBreedingTicks = 6000;
+    public Boolean rabbitMobGriefingOverride = null;
+    public boolean rabbitTakeDamageFromWater = false;
+    public boolean rabbitAlwaysDropExp = false;
+    private void rabbitSettings() {
+        rabbitRidable = getBoolean("mobs.rabbit.ridable", rabbitRidable);
+        rabbitRidableInWater = getBoolean("mobs.rabbit.ridable-in-water", rabbitRidableInWater);
+        rabbitControllable = getBoolean("mobs.rabbit.controllable", rabbitControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.rabbit.attributes.max-health", rabbitMaxHealth);
+            set("mobs.rabbit.attributes.max-health", null);
+            set("mobs.rabbit.attributes.max_health", oldValue);
+        }
+        rabbitMaxHealth = getDouble("mobs.rabbit.attributes.max_health", rabbitMaxHealth);
+        rabbitScale = Mth.clamp(getDouble("mobs.rabbit.attributes.scale", rabbitScale), 0.0625D, 16.0D);
+        rabbitNaturalToast = getDouble("mobs.rabbit.spawn-toast-chance", rabbitNaturalToast);
+        rabbitNaturalKiller = getDouble("mobs.rabbit.spawn-killer-rabbit-chance", rabbitNaturalKiller);
+        rabbitBreedingTicks = getInt("mobs.rabbit.breeding-delay-ticks", rabbitBreedingTicks);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.rabbit.bypass-mob-griefing", false);
+            set("mobs.rabbit.bypass-mob-griefing", null);
+            set("mobs.rabbit.mob-griefing-override", oldVal ? true : "default");
+        }
+        rabbitMobGriefingOverride = getBooleanOrDefault("mobs.rabbit.mob-griefing-override", rabbitMobGriefingOverride);
+        rabbitTakeDamageFromWater = getBoolean("mobs.rabbit.takes-damage-from-water", rabbitTakeDamageFromWater);
+        rabbitAlwaysDropExp = getBoolean("mobs.rabbit.always-drop-exp", rabbitAlwaysDropExp);
+    }
+
+    public boolean ravagerRidable = false;
+    public boolean ravagerRidableInWater = false;
+    public boolean ravagerControllable = true;
+    public double ravagerMaxHealth = 100.0D;
+    public double ravagerScale = 1.0D;
+    public Boolean ravagerMobGriefingOverride = null;
+    public boolean ravagerTakeDamageFromWater = false;
+    public List<Block> ravagerGriefableBlocks = new ArrayList<>();
+    public boolean ravagerAlwaysDropExp = false;
+    public boolean ravagerAvoidRabbits = false;
+    private void ravagerSettings() {
+        ravagerRidable = getBoolean("mobs.ravager.ridable", ravagerRidable);
+        ravagerRidableInWater = getBoolean("mobs.ravager.ridable-in-water", ravagerRidableInWater);
+        ravagerControllable = getBoolean("mobs.ravager.controllable", ravagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ravager.attributes.max-health", ravagerMaxHealth);
+            set("mobs.ravager.attributes.max-health", null);
+            set("mobs.ravager.attributes.max_health", oldValue);
+        }
+        ravagerMaxHealth = getDouble("mobs.ravager.attributes.max_health", ravagerMaxHealth);
+        ravagerScale = Mth.clamp(getDouble("mobs.ravager.attributes.scale", ravagerScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.ravager.bypass-mob-griefing", false);
+            set("mobs.ravager.bypass-mob-griefing", null);
+            set("mobs.ravager.mob-griefing-override", oldVal ? true : "default");
+        }
+        ravagerMobGriefingOverride = getBooleanOrDefault("mobs.ravager.mob-griefing-override", ravagerMobGriefingOverride);
+        ravagerTakeDamageFromWater = getBoolean("mobs.ravager.takes-damage-from-water", ravagerTakeDamageFromWater);
+        List<String> defaultRavagerGriefableBlocks = List.of(
+            "minecraft:oak_leaves",
+            "minecraft:spruce_leaves",
+            "minecraft:birch_leaves",
+            "minecraft:jungle_leaves",
+            "minecraft:acacia_leaves",
+            "minecraft:cherry_leaves",
+            "minecraft:dark_oak_leaves",
+            "minecraft:pale_oak_leaves",
+            "minecraft:mangrove_leaves",
+            "minecraft:azalea_leaves",
+            "minecraft:flowering_azalea_leaves",
+            "minecraft:wheat",
+            "minecraft:carrots",
+            "minecraft:potatoes",
+            "minecraft:torchflower_crop",
+            "minecraft:pitcher_crop",
+            "minecraft:beetroots"
+        );
+        if (PurpurConfig.version < 41) {
+            Set<String> set = new HashSet<>();
+            getList("mobs.ravager.griefable-blocks", defaultRavagerGriefableBlocks)
+                .forEach(key -> set.add(key.toString()));
+            set.add("minecraft:cherry_leaves");
+            set.add("minecraft:pale_oak_leaves");
+            set.add("minecraft:mangrove_leaves");
+            set.add("minecraft:azalea_leaves");
+            set.add("minecraft:flowering_azalea_leaves");
+            set.add("minecraft:torchflower_crop");
+            set.add("minecraft:pitcher_crop");
+            set("mobs.ravager.griefable-blocks", new ArrayList<>(set));
+        }
+        getList("mobs.ravager.griefable-blocks", defaultRavagerGriefableBlocks).forEach(key -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(key.toString()));
+            if (!block.defaultBlockState().isAir()) {
+                ravagerGriefableBlocks.add(block);
+            }
+        });
+        ravagerAlwaysDropExp = getBoolean("mobs.ravager.always-drop-exp", ravagerAlwaysDropExp);
+        ravagerAvoidRabbits = getBoolean("mobs.ravager.avoid-rabbits", ravagerAvoidRabbits);
+    }
+
+    public boolean salmonRidable = false;
+    public boolean salmonControllable = true;
+    public double salmonMaxHealth = 3.0D;
+    public double salmonScale = 1.0D;
+    public boolean salmonTakeDamageFromWater = false;
+    public boolean salmonAlwaysDropExp = false;
+    private void salmonSettings() {
+        salmonRidable = getBoolean("mobs.salmon.ridable", salmonRidable);
+        salmonControllable = getBoolean("mobs.salmon.controllable", salmonControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.salmon.attributes.max-health", salmonMaxHealth);
+            set("mobs.salmon.attributes.max-health", null);
+            set("mobs.salmon.attributes.max_health", oldValue);
+        }
+        salmonMaxHealth = getDouble("mobs.salmon.attributes.max_health", salmonMaxHealth);
+        salmonScale = Mth.clamp(getDouble("mobs.salmon.attributes.scale", salmonScale), 0.0625D, 16.0D);
+        salmonTakeDamageFromWater = getBoolean("mobs.salmon.takes-damage-from-water", salmonTakeDamageFromWater);
+        salmonAlwaysDropExp = getBoolean("mobs.salmon.always-drop-exp", salmonAlwaysDropExp);
+    }
+
+    public boolean sheepRidable = false;
+    public boolean sheepRidableInWater = true;
+    public boolean sheepControllable = true;
+    public double sheepMaxHealth = 8.0D;
+    public double sheepScale = 1.0D;
+    public int sheepBreedingTicks = 6000;
+    public Boolean sheepMobGriefingOverride = null;
+    public boolean sheepTakeDamageFromWater = false;
+    public boolean sheepAlwaysDropExp = false;
+    private void sheepSettings() {
+        sheepRidable = getBoolean("mobs.sheep.ridable", sheepRidable);
+        sheepRidableInWater = getBoolean("mobs.sheep.ridable-in-water", sheepRidableInWater);
+        sheepControllable = getBoolean("mobs.sheep.controllable", sheepControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.sheep.attributes.max-health", sheepMaxHealth);
+            set("mobs.sheep.attributes.max-health", null);
+            set("mobs.sheep.attributes.max_health", oldValue);
+        }
+        sheepMaxHealth = getDouble("mobs.sheep.attributes.max_health", sheepMaxHealth);
+        sheepScale = Mth.clamp(getDouble("mobs.sheep.attributes.scale", sheepScale), 0.0625D, 16.0D);
+        sheepBreedingTicks = getInt("mobs.sheep.breeding-delay-ticks", sheepBreedingTicks);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.sheep.bypass-mob-griefing", false);
+            set("mobs.sheep.bypass-mob-griefing", null);
+            set("mobs.sheep.mob-griefing-override", oldVal ? true : "default");
+        }
+        sheepMobGriefingOverride = getBooleanOrDefault("mobs.sheep.mob-griefing-override", sheepMobGriefingOverride);
+        sheepTakeDamageFromWater = getBoolean("mobs.sheep.takes-damage-from-water", sheepTakeDamageFromWater);
+        sheepAlwaysDropExp = getBoolean("mobs.sheep.always-drop-exp", sheepAlwaysDropExp);
+    }
+
+    public boolean shulkerRidable = false;
+    public boolean shulkerRidableInWater = true;
+    public boolean shulkerControllable = true;
+    public double shulkerMaxHealth = 30.0D;
+    public double shulkerScale = 1.0D;
+    public boolean shulkerTakeDamageFromWater = false;
+    public float shulkerSpawnFromBulletBaseChance = 1.0F;
+    public boolean shulkerSpawnFromBulletRequireOpenLid = true;
+    public double shulkerSpawnFromBulletNearbyRange = 8.0D;
+    public String shulkerSpawnFromBulletNearbyEquation = "(nearby - 1) / 5.0";
+    public boolean shulkerSpawnFromBulletRandomColor = false;
+    public boolean shulkerChangeColorWithDye = false;
+    public boolean shulkerAlwaysDropExp = false;
+    private void shulkerSettings() {
+        shulkerRidable = getBoolean("mobs.shulker.ridable", shulkerRidable);
+        shulkerRidableInWater = getBoolean("mobs.shulker.ridable-in-water", shulkerRidableInWater);
+        shulkerControllable = getBoolean("mobs.shulker.controllable", shulkerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.shulker.attributes.max-health", shulkerMaxHealth);
+            set("mobs.shulker.attributes.max-health", null);
+            set("mobs.shulker.attributes.max_health", oldValue);
+        }
+        shulkerMaxHealth = getDouble("mobs.shulker.attributes.max_health", shulkerMaxHealth);
+        shulkerScale = Mth.clamp(getDouble("mobs.shulker.attributes.scale", shulkerScale), 0.0625D, Shulker.MAX_SCALE);
+        shulkerTakeDamageFromWater = getBoolean("mobs.shulker.takes-damage-from-water", shulkerTakeDamageFromWater);
+        shulkerSpawnFromBulletBaseChance = (float) getDouble("mobs.shulker.spawn-from-bullet.base-chance", shulkerSpawnFromBulletBaseChance);
+        shulkerSpawnFromBulletRequireOpenLid = getBoolean("mobs.shulker.spawn-from-bullet.require-open-lid", shulkerSpawnFromBulletRequireOpenLid);
+        shulkerSpawnFromBulletNearbyRange = getDouble("mobs.shulker.spawn-from-bullet.nearby-range", shulkerSpawnFromBulletNearbyRange);
+        shulkerSpawnFromBulletNearbyEquation = getString("mobs.shulker.spawn-from-bullet.nearby-equation", shulkerSpawnFromBulletNearbyEquation);
+        shulkerSpawnFromBulletRandomColor = getBoolean("mobs.shulker.spawn-from-bullet.random-color", shulkerSpawnFromBulletRandomColor);
+        shulkerChangeColorWithDye = getBoolean("mobs.shulker.change-color-with-dye", shulkerChangeColorWithDye);
+        shulkerAlwaysDropExp = getBoolean("mobs.shulker.always-drop-exp", shulkerAlwaysDropExp);
+    }
+
+    public boolean silverfishRidable = false;
+    public boolean silverfishRidableInWater = true;
+    public boolean silverfishControllable = true;
+    public double silverfishMaxHealth = 8.0D;
+    public double silverfishScale = 1.0D;
+    public double silverfishMovementSpeed = 0.25D;
+    public double silverfishAttackDamage = 1.0D;
+    public Boolean silverfishMobGriefingOverride = null;
+    public boolean silverfishTakeDamageFromWater = false;
+    public boolean silverfishAlwaysDropExp = false;
+    private void silverfishSettings() {
+        silverfishRidable = getBoolean("mobs.silverfish.ridable", silverfishRidable);
+        silverfishRidableInWater = getBoolean("mobs.silverfish.ridable-in-water", silverfishRidableInWater);
+        silverfishControllable = getBoolean("mobs.silverfish.controllable", silverfishControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.silverfish.attributes.max-health", silverfishMaxHealth);
+            set("mobs.silverfish.attributes.max-health", null);
+            set("mobs.silverfish.attributes.max_health", oldValue);
+        }
+        silverfishMaxHealth = getDouble("mobs.silverfish.attributes.max_health", silverfishMaxHealth);
+        silverfishScale = Mth.clamp(getDouble("mobs.silverfish.attributes.scale", silverfishScale), 0.0625D, 16.0D);
+        silverfishMovementSpeed = getDouble("mobs.silverfish.attributes.movement_speed", silverfishMovementSpeed);
+        silverfishAttackDamage = getDouble("mobs.silverfish.attributes.attack_damage", silverfishAttackDamage);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.silverfish.bypass-mob-griefing", false);
+            set("mobs.silverfish.bypass-mob-griefing", null);
+            set("mobs.silverfish.mob-griefing-override", oldVal ? true : "default");
+        }
+        silverfishMobGriefingOverride = getBooleanOrDefault("mobs.silverfish.mob-griefing-override", silverfishMobGriefingOverride);
+        silverfishTakeDamageFromWater = getBoolean("mobs.silverfish.takes-damage-from-water", silverfishTakeDamageFromWater);
+        silverfishAlwaysDropExp = getBoolean("mobs.silverfish.always-drop-exp", silverfishAlwaysDropExp);
+    }
+
+    public boolean skeletonRidable = false;
+    public boolean skeletonRidableInWater = true;
+    public boolean skeletonControllable = true;
+    public double skeletonMaxHealth = 20.0D;
+    public double skeletonScale = 1.0D;
+    public boolean skeletonTakeDamageFromWater = false;
+    public boolean skeletonAlwaysDropExp = false;
+    public double skeletonHeadVisibilityPercent = 0.5D;
+    public int skeletonFeedWitherRoses = 0;
+    public String skeletonBowAccuracy = "14 - difficulty * 4";
+    public Map<Integer, Float> skeletonBowAccuracyMap = new HashMap<>();
+    public Boolean skeletonCanPickUpLoot = null;
+    private void skeletonSettings() {
+        skeletonRidable = getBoolean("mobs.skeleton.ridable", skeletonRidable);
+        skeletonRidableInWater = getBoolean("mobs.skeleton.ridable-in-water", skeletonRidableInWater);
+        skeletonControllable = getBoolean("mobs.skeleton.controllable", skeletonControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.skeleton.attributes.max-health", skeletonMaxHealth);
+            set("mobs.skeleton.attributes.max-health", null);
+            set("mobs.skeleton.attributes.max_health", oldValue);
+        }
+        skeletonMaxHealth = getDouble("mobs.skeleton.attributes.max_health", skeletonMaxHealth);
+        skeletonScale = Mth.clamp(getDouble("mobs.skeleton.attributes.scale", skeletonScale), 0.0625D, 16.0D);
+        skeletonTakeDamageFromWater = getBoolean("mobs.skeleton.takes-damage-from-water", skeletonTakeDamageFromWater);
+        skeletonAlwaysDropExp = getBoolean("mobs.skeleton.always-drop-exp", skeletonAlwaysDropExp);
+        skeletonHeadVisibilityPercent = getDouble("mobs.skeleton.head-visibility-percent", skeletonHeadVisibilityPercent);
+        skeletonFeedWitherRoses = getInt("mobs.skeleton.feed-wither-roses", skeletonFeedWitherRoses);
+        final String defaultSkeletonBowAccuracy = skeletonBowAccuracy;
+        skeletonBowAccuracy = getString("mobs.skeleton.bow-accuracy", skeletonBowAccuracy);
+        for (int i = 1; i < 4; i++) {
+            final float divergence;
+            try {
+                divergence = ((Number) Entity.scriptEngine.eval("let difficulty = " + i + "; " + skeletonBowAccuracy)).floatValue();
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                break;
+            }
+            skeletonBowAccuracyMap.put(i, divergence);
+        }
+        skeletonCanPickUpLoot = getBooleanOrDefault("mobs.skeleton.can-pick-up-loot", skeletonCanPickUpLoot);
+    }
+
+    public boolean skeletonHorseRidable = false;
+    public boolean skeletonHorseRidableInWater = true;
+    public boolean skeletonHorseCanSwim = false;
+    public double skeletonHorseMaxHealthMin = 15.0D;
+    public double skeletonHorseMaxHealthMax = 15.0D;
+    public double skeletonHorseJumpStrengthMin = 0.4D;
+    public double skeletonHorseJumpStrengthMax = 1.0D;
+    public double skeletonHorseMovementSpeedMin = 0.2D;
+    public double skeletonHorseMovementSpeedMax = 0.2D;
+    public boolean skeletonHorseTakeDamageFromWater = false;
+    public boolean skeletonHorseAlwaysDropExp = false;
+    private void skeletonHorseSettings() {
+        skeletonHorseRidable = getBoolean("mobs.skeleton_horse.ridable", skeletonHorseRidable);
+        skeletonHorseRidableInWater = getBoolean("mobs.skeleton_horse.ridable-in-water", skeletonHorseRidableInWater);
+        skeletonHorseCanSwim = getBoolean("mobs.skeleton_horse.can-swim", skeletonHorseCanSwim);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.skeleton_horse.attributes.max-health", skeletonHorseMaxHealthMin);
+            set("mobs.skeleton_horse.attributes.max-health", null);
+            set("mobs.skeleton_horse.attributes.max_health.min", oldValue);
+            set("mobs.skeleton_horse.attributes.max_health.max", oldValue);
+        }
+        skeletonHorseMaxHealthMin = getDouble("mobs.skeleton_horse.attributes.max_health.min", skeletonHorseMaxHealthMin);
+        skeletonHorseMaxHealthMax = getDouble("mobs.skeleton_horse.attributes.max_health.max", skeletonHorseMaxHealthMax);
+        skeletonHorseJumpStrengthMin = getDouble("mobs.skeleton_horse.attributes.jump_strength.min", skeletonHorseJumpStrengthMin);
+        skeletonHorseJumpStrengthMax = getDouble("mobs.skeleton_horse.attributes.jump_strength.max", skeletonHorseJumpStrengthMax);
+        skeletonHorseMovementSpeedMin = getDouble("mobs.skeleton_horse.attributes.movement_speed.min", skeletonHorseMovementSpeedMin);
+        skeletonHorseMovementSpeedMax = getDouble("mobs.skeleton_horse.attributes.movement_speed.max", skeletonHorseMovementSpeedMax);
+        skeletonHorseTakeDamageFromWater = getBoolean("mobs.skeleton_horse.takes-damage-from-water", skeletonHorseTakeDamageFromWater);
+        skeletonHorseAlwaysDropExp = getBoolean("mobs.skeleton_horse.always-drop-exp", skeletonHorseAlwaysDropExp);
+    }
+
+    public boolean slimeRidable = false;
+    public boolean slimeRidableInWater = true;
+    public boolean slimeControllable = true;
+    public String slimeMaxHealth = "size * size";
+    public String slimeAttackDamage = "size";
+    public Map<Integer, Double> slimeMaxHealthCache = new HashMap<>();
+    public Map<Integer, Double> slimeAttackDamageCache = new HashMap<>();
+    public boolean slimeTakeDamageFromWater = false;
+    public boolean slimeAlwaysDropExp = false;
+    private void slimeSettings() {
+        slimeRidable = getBoolean("mobs.slime.ridable", slimeRidable);
+        slimeRidableInWater = getBoolean("mobs.slime.ridable-in-water", slimeRidableInWater);
+        slimeControllable = getBoolean("mobs.slime.controllable", slimeControllable);
+        if (PurpurConfig.version < 10) {
+            String oldValue = getString("mobs.slime.attributes.max-health", slimeMaxHealth);
+            set("mobs.slime.attributes.max-health", null);
+            set("mobs.slime.attributes.max_health", oldValue);
+        }
+        slimeMaxHealth = getString("mobs.slime.attributes.max_health", slimeMaxHealth);
+        slimeAttackDamage = getString("mobs.slime.attributes.attack_damage", slimeAttackDamage);
+        slimeMaxHealthCache.clear();
+        slimeAttackDamageCache.clear();
+        slimeTakeDamageFromWater = getBoolean("mobs.slime.takes-damage-from-water", slimeTakeDamageFromWater);
+        slimeAlwaysDropExp = getBoolean("mobs.slime.always-drop-exp", slimeAlwaysDropExp);
+    }
+
+    public boolean snowGolemRidable = false;
+    public boolean snowGolemRidableInWater = true;
+    public boolean snowGolemControllable = true;
+    public boolean snowGolemLeaveTrailWhenRidden = false;
+    public double snowGolemMaxHealth = 4.0D;
+    public double snowGolemScale = 1.0D;
+    public boolean snowGolemPutPumpkinBack = false;
+    public int snowGolemSnowBallMin = 20;
+    public int snowGolemSnowBallMax = 20;
+    public float snowGolemSnowBallModifier = 10.0F;
+    public double snowGolemAttackDistance = 1.25D;
+    public Boolean snowGolemMobGriefingOverride = null;
+    public boolean snowGolemTakeDamageFromWater = true;
+    public boolean snowGolemAlwaysDropExp = false;
+    private void snowGolemSettings() {
+        snowGolemRidable = getBoolean("mobs.snow_golem.ridable", snowGolemRidable);
+        snowGolemRidableInWater = getBoolean("mobs.snow_golem.ridable-in-water", snowGolemRidableInWater);
+        snowGolemControllable = getBoolean("mobs.snow_golem.controllable", snowGolemControllable);
+        snowGolemLeaveTrailWhenRidden = getBoolean("mobs.snow_golem.leave-trail-when-ridden", snowGolemLeaveTrailWhenRidden);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.snow_golem.attributes.max-health", snowGolemMaxHealth);
+            set("mobs.snow_golem.attributes.max-health", null);
+            set("mobs.snow_golem.attributes.max_health", oldValue);
+        }
+        snowGolemMaxHealth = getDouble("mobs.snow_golem.attributes.max_health", snowGolemMaxHealth);
+        snowGolemScale = Mth.clamp(getDouble("mobs.snow_golem.attributes.scale", snowGolemScale), 0.0625D, 16.0D);
+        snowGolemPutPumpkinBack = getBoolean("mobs.snow_golem.pumpkin-can-be-added-back", snowGolemPutPumpkinBack);
+        snowGolemSnowBallMin = getInt("mobs.snow_golem.min-shoot-interval-ticks", snowGolemSnowBallMin);
+        snowGolemSnowBallMax = getInt("mobs.snow_golem.max-shoot-interval-ticks", snowGolemSnowBallMax);
+        snowGolemSnowBallModifier = (float) getDouble("mobs.snow_golem.snow-ball-modifier", snowGolemSnowBallModifier);
+        snowGolemAttackDistance = getDouble("mobs.snow_golem.attack-distance", snowGolemAttackDistance);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.snow_golem.bypass-mob-griefing", false);
+            set("mobs.snow_golem.bypass-mob-griefing", null);
+            set("mobs.snow_golem.mob-griefing-override", oldVal ? true : "default");
+        }
+        snowGolemMobGriefingOverride = getBooleanOrDefault("mobs.snow_golem.mob-griefing-override", snowGolemMobGriefingOverride);
+        snowGolemTakeDamageFromWater = getBoolean("mobs.snow_golem.takes-damage-from-water", snowGolemTakeDamageFromWater);
+        snowGolemAlwaysDropExp = getBoolean("mobs.snow_golem.always-drop-exp", snowGolemAlwaysDropExp);
+    }
+
+    public boolean snifferRidable = false;
+    public boolean snifferRidableInWater = true;
+    public boolean snifferControllable = true;
+    public double snifferMaxHealth = 14.0D;
+    public double snifferScale = 1.0D;
+    public int snifferBreedingTicks = 6000;
+    private void snifferSettings() {
+        snifferRidable = getBoolean("mobs.sniffer.ridable", snifferRidable);
+        snifferRidableInWater = getBoolean("mobs.sniffer.ridable-in-water", snifferRidableInWater);
+        snifferControllable = getBoolean("mobs.sniffer.controllable", snifferControllable);
+        snifferMaxHealth = getDouble("mobs.sniffer.attributes.max_health", snifferMaxHealth);
+        snifferScale = Mth.clamp(getDouble("mobs.sniffer.attributes.scale", snifferScale), 0.0625D, 16.0D);
+        snifferBreedingTicks = getInt("mobs.sniffer.breeding-delay-ticks", snifferBreedingTicks);
+    }
+
+    public boolean squidRidable = false;
+    public boolean squidControllable = true;
+    public double squidMaxHealth = 10.0D;
+    public double squidScale = 1.0D;
+    public boolean squidImmuneToEAR = true;
+    public double squidOffsetWaterCheck = 0.0D;
+    public boolean squidsCanFly = false;
+    public boolean squidTakeDamageFromWater = false;
+    public boolean squidAlwaysDropExp = false;
+    private void squidSettings() {
+        squidRidable = getBoolean("mobs.squid.ridable", squidRidable);
+        squidControllable = getBoolean("mobs.squid.controllable", squidControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.squid.attributes.max-health", squidMaxHealth);
+            set("mobs.squid.attributes.max-health", null);
+            set("mobs.squid.attributes.max_health", oldValue);
+        }
+        squidMaxHealth = getDouble("mobs.squid.attributes.max_health", squidMaxHealth);
+        squidScale = Mth.clamp(getDouble("mobs.squid.attributes.scale", squidScale), 0.0625D, 16.0D);
+        squidImmuneToEAR = getBoolean("mobs.squid.immune-to-EAR", squidImmuneToEAR);
+        squidOffsetWaterCheck = getDouble("mobs.squid.water-offset-check", squidOffsetWaterCheck);
+        squidsCanFly = getBoolean("mobs.squid.can-fly", squidsCanFly);
+        squidTakeDamageFromWater = getBoolean("mobs.squid.takes-damage-from-water", squidTakeDamageFromWater);
+        squidAlwaysDropExp = getBoolean("mobs.squid.always-drop-exp", squidAlwaysDropExp);
+    }
+
+    public boolean spiderRidable = false;
+    public boolean spiderRidableInWater = false;
+    public boolean spiderControllable = true;
+    public double spiderMaxHealth = 16.0D;
+    public double spiderScale = 1.0D;
+    public boolean spiderTakeDamageFromWater = false;
+    public boolean spiderAlwaysDropExp = false;
+    private void spiderSettings() {
+        spiderRidable = getBoolean("mobs.spider.ridable", spiderRidable);
+        spiderRidableInWater = getBoolean("mobs.spider.ridable-in-water", spiderRidableInWater);
+        spiderControllable = getBoolean("mobs.spider.controllable", spiderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.spider.attributes.max-health", spiderMaxHealth);
+            set("mobs.spider.attributes.max-health", null);
+            set("mobs.spider.attributes.max_health", oldValue);
+        }
+        spiderMaxHealth = getDouble("mobs.spider.attributes.max_health", spiderMaxHealth);
+        spiderScale = Mth.clamp(getDouble("mobs.spider.attributes.scale", spiderScale), 0.0625D, 16.0D);
+        spiderTakeDamageFromWater = getBoolean("mobs.spider.takes-damage-from-water", spiderTakeDamageFromWater);
+        spiderAlwaysDropExp = getBoolean("mobs.spider.always-drop-exp", spiderAlwaysDropExp);
+    }
+
+    public boolean strayRidable = false;
+    public boolean strayRidableInWater = true;
+    public boolean strayControllable = true;
+    public double strayMaxHealth = 20.0D;
+    public double strayScale = 1.0D;
+    public boolean strayTakeDamageFromWater = false;
+    public boolean strayAlwaysDropExp = false;
+    public Boolean strayCanPickUpLoot = null;
+    private void straySettings() {
+        strayRidable = getBoolean("mobs.stray.ridable", strayRidable);
+        strayRidableInWater = getBoolean("mobs.stray.ridable-in-water", strayRidableInWater);
+        strayControllable = getBoolean("mobs.stray.controllable", strayControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.stray.attributes.max-health", strayMaxHealth);
+            set("mobs.stray.attributes.max-health", null);
+            set("mobs.stray.attributes.max_health", oldValue);
+        }
+        strayMaxHealth = getDouble("mobs.stray.attributes.max_health", strayMaxHealth);
+        strayScale = Mth.clamp(getDouble("mobs.stray.attributes.scale", strayScale), 0.0625D, 16.0D);
+        strayTakeDamageFromWater = getBoolean("mobs.stray.takes-damage-from-water", strayTakeDamageFromWater);
+        strayAlwaysDropExp = getBoolean("mobs.stray.always-drop-exp", strayAlwaysDropExp);
+        strayCanPickUpLoot = getBooleanOrDefault("mobs.stray.can-pick-up-loot", strayCanPickUpLoot);
+    }
+
+    public boolean striderRidable = false;
+    public boolean striderRidableInWater = false;
+    public boolean striderControllable = true;
+    public double striderMaxHealth = 20.0D;
+    public double striderScale = 1.0D;
+    public int striderBreedingTicks = 6000;
+    public boolean striderGiveSaddleBack = false;
+    public boolean striderTakeDamageFromWater = true;
+    public boolean striderAlwaysDropExp = false;
+    private void striderSettings() {
+        striderRidable = getBoolean("mobs.strider.ridable", striderRidable);
+        striderRidableInWater = getBoolean("mobs.strider.ridable-in-water", striderRidableInWater);
+        striderControllable = getBoolean("mobs.strider.controllable", striderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.strider.attributes.max-health", striderMaxHealth);
+            set("mobs.strider.attributes.max-health", null);
+            set("mobs.strider.attributes.max_health", oldValue);
+        }
+        striderMaxHealth = getDouble("mobs.strider.attributes.max_health", striderMaxHealth);
+        striderScale = Mth.clamp(getDouble("mobs.strider.attributes.scale", striderScale), 0.0625D, 16.0D);
+        striderBreedingTicks = getInt("mobs.strider.breeding-delay-ticks", striderBreedingTicks);
+        striderGiveSaddleBack = getBoolean("mobs.strider.give-saddle-back", striderGiveSaddleBack);
+        striderTakeDamageFromWater = getBoolean("mobs.strider.takes-damage-from-water", striderTakeDamageFromWater);
+        striderAlwaysDropExp = getBoolean("mobs.strider.always-drop-exp", striderAlwaysDropExp);
+    }
+
+    public boolean tadpoleRidable = false;
+    public boolean tadpoleRidableInWater = true;
+    public boolean tadpoleControllable = true;
+    private void tadpoleSettings() {
+        tadpoleRidable = getBoolean("mobs.tadpole.ridable", tadpoleRidable);
+        tadpoleRidableInWater = getBoolean("mobs.tadpole.ridable-in-water", tadpoleRidableInWater);
+        tadpoleControllable = getBoolean("mobs.tadpole.controllable", tadpoleControllable);
+    }
+
+    public boolean traderLlamaRidable = false;
+    public boolean traderLlamaRidableInWater = false;
+    public boolean traderLlamaControllable = true;
+    public double traderLlamaMaxHealthMin = 15.0D;
+    public double traderLlamaMaxHealthMax = 30.0D;
+    public double traderLlamaJumpStrengthMin = 0.5D;
+    public double traderLlamaJumpStrengthMax = 0.5D;
+    public double traderLlamaMovementSpeedMin = 0.175D;
+    public double traderLlamaMovementSpeedMax = 0.175D;
+    public int traderLlamaBreedingTicks = 6000;
+    public boolean traderLlamaTakeDamageFromWater = false;
+    public boolean traderLlamaAlwaysDropExp = false;
+    private void traderLlamaSettings() {
+        traderLlamaRidable = getBoolean("mobs.trader_llama.ridable", traderLlamaRidable);
+        traderLlamaRidableInWater = getBoolean("mobs.trader_llama.ridable-in-water", traderLlamaRidableInWater);
+        traderLlamaControllable = getBoolean("mobs.trader_llama.controllable", traderLlamaControllable);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.trader_llama.attributes.max-health.min", traderLlamaMaxHealthMin);
+            double oldMax = getDouble("mobs.trader_llama.attributes.max-health.max", traderLlamaMaxHealthMax);
+            set("mobs.trader_llama.attributes.max-health", null);
+            set("mobs.trader_llama.attributes.max_health.min", oldMin);
+            set("mobs.trader_llama.attributes.max_health.max", oldMax);
+        }
+        traderLlamaMaxHealthMin = getDouble("mobs.trader_llama.attributes.max_health.min", traderLlamaMaxHealthMin);
+        traderLlamaMaxHealthMax = getDouble("mobs.trader_llama.attributes.max_health.max", traderLlamaMaxHealthMax);
+        traderLlamaJumpStrengthMin = getDouble("mobs.trader_llama.attributes.jump_strength.min", traderLlamaJumpStrengthMin);
+        traderLlamaJumpStrengthMax = getDouble("mobs.trader_llama.attributes.jump_strength.max", traderLlamaJumpStrengthMax);
+        traderLlamaMovementSpeedMin = getDouble("mobs.trader_llama.attributes.movement_speed.min", traderLlamaMovementSpeedMin);
+        traderLlamaMovementSpeedMax = getDouble("mobs.trader_llama.attributes.movement_speed.max", traderLlamaMovementSpeedMax);
+        traderLlamaBreedingTicks = getInt("mobs.trader_llama.breeding-delay-ticks", traderLlamaBreedingTicks);
+        traderLlamaTakeDamageFromWater = getBoolean("mobs.trader_llama.takes-damage-from-water", traderLlamaTakeDamageFromWater);
+        traderLlamaAlwaysDropExp = getBoolean("mobs.trader_llama.always-drop-exp", traderLlamaAlwaysDropExp);
+    }
+
+    public boolean tropicalFishRidable = false;
+    public boolean tropicalFishControllable = true;
+    public double tropicalFishMaxHealth = 3.0D;
+    public double tropicalFishScale = 1.0D;
+    public boolean tropicalFishTakeDamageFromWater = false;
+    public boolean tropicalFishAlwaysDropExp = false;
+    private void tropicalFishSettings() {
+        tropicalFishRidable = getBoolean("mobs.tropical_fish.ridable", tropicalFishRidable);
+        tropicalFishControllable = getBoolean("mobs.tropical_fish.controllable", tropicalFishControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.tropical_fish.attributes.max-health", tropicalFishMaxHealth);
+            set("mobs.tropical_fish.attributes.max-health", null);
+            set("mobs.tropical_fish.attributes.max_health", oldValue);
+        }
+        tropicalFishMaxHealth = getDouble("mobs.tropical_fish.attributes.max_health", tropicalFishMaxHealth);
+        tropicalFishScale = Mth.clamp(getDouble("mobs.tropical_fish.attributes.scale", tropicalFishScale), 0.0625D, 16.0D);
+        tropicalFishTakeDamageFromWater = getBoolean("mobs.tropical_fish.takes-damage-from-water", tropicalFishTakeDamageFromWater);
+        tropicalFishAlwaysDropExp = getBoolean("mobs.tropical_fish.always-drop-exp", tropicalFishAlwaysDropExp);
+    }
+
+    public boolean turtleRidable = false;
+    public boolean turtleRidableInWater = true;
+    public boolean turtleControllable = true;
+    public double turtleMaxHealth = 30.0D;
+    public double turtleScale = 1.0D;
+    public int turtleBreedingTicks = 6000;
+    public boolean turtleTakeDamageFromWater = false;
+    public boolean turtleAlwaysDropExp = false;
+    private void turtleSettings() {
+        turtleRidable = getBoolean("mobs.turtle.ridable", turtleRidable);
+        turtleRidableInWater = getBoolean("mobs.turtle.ridable-in-water", turtleRidableInWater);
+        turtleControllable = getBoolean("mobs.turtle.controllable", turtleControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.turtle.attributes.max-health", turtleMaxHealth);
+            set("mobs.turtle.attributes.max-health", null);
+            set("mobs.turtle.attributes.max_health", oldValue);
+        }
+        turtleMaxHealth = getDouble("mobs.turtle.attributes.max_health", turtleMaxHealth);
+        turtleScale = Mth.clamp(getDouble("mobs.turtle.attributes.scale", turtleScale), 0.0625D, 16.0D);
+        turtleBreedingTicks = getInt("mobs.turtle.breeding-delay-ticks", turtleBreedingTicks);
+        turtleTakeDamageFromWater = getBoolean("mobs.turtle.takes-damage-from-water", turtleTakeDamageFromWater);
+        turtleAlwaysDropExp = getBoolean("mobs.turtle.always-drop-exp", turtleAlwaysDropExp);
+    }
+
+    public boolean vexRidable = false;
+    public boolean vexRidableInWater = true;
+    public boolean vexControllable = true;
+    public double vexMaxY = 320D;
+    public double vexMaxHealth = 14.0D;
+    public double vexScale = 1.0D;
+    public boolean vexTakeDamageFromWater = false;
+    public boolean vexAlwaysDropExp = false;
+    private void vexSettings() {
+        vexRidable = getBoolean("mobs.vex.ridable", vexRidable);
+        vexRidableInWater = getBoolean("mobs.vex.ridable-in-water", vexRidableInWater);
+        vexControllable = getBoolean("mobs.vex.controllable", vexControllable);
+        vexMaxY = getDouble("mobs.vex.ridable-max-y", vexMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.vex.attributes.max-health", vexMaxHealth);
+            set("mobs.vex.attributes.max-health", null);
+            set("mobs.vex.attributes.max_health", oldValue);
+        }
+        vexMaxHealth = getDouble("mobs.vex.attributes.max_health", vexMaxHealth);
+        vexScale = Mth.clamp(getDouble("mobs.vex.attributes.scale", vexScale), 0.0625D, 16.0D);
+        vexTakeDamageFromWater = getBoolean("mobs.vex.takes-damage-from-water", vexTakeDamageFromWater);
+        vexAlwaysDropExp = getBoolean("mobs.vex.always-drop-exp", vexAlwaysDropExp);
+    }
+
+    public boolean villagerRidable = false;
+    public boolean villagerRidableInWater = true;
+    public boolean villagerControllable = true;
+    public double villagerMaxHealth = 20.0D;
+    public double villagerScale = 1.0D;
+    public boolean villagerFollowEmeraldBlock = false;
+    public double villagerTemptRange = 10.0D;
+    public boolean villagerCanBeLeashed = false;
+    public boolean villagerCanBreed = true;
+    public int villagerBreedingTicks = 6000;
+    public boolean villagerClericsFarmWarts = false;
+    public boolean villagerClericFarmersThrowWarts = true;
+    public Boolean villagerMobGriefingOverride = null;
+    public boolean villagerTakeDamageFromWater = false;
+    public boolean villagerAllowTrading = true;
+    public boolean villagerAlwaysDropExp = false;
+    public int villagerMinimumDemand = 0;
+    public boolean villagerLobotomizeEnabled = false;
+    public int villagerLobotomizeCheckInterval = 100;
+    public boolean villagerLobotomizeWaitUntilTradeLocked = false;
+    public boolean villagerDisplayTradeItem = true;
+    public int villagerSpawnIronGolemRadius = 0;
+    public int villagerSpawnIronGolemLimit = 0;
+    public int villagerAcquirePoiSearchRadius = 48;
+    public int villagerNearestBedSensorSearchRadius = 48;
+    public Boolean villagerCanPickUpLoot = null;
+    private void villagerSettings() {
+        villagerRidable = getBoolean("mobs.villager.ridable", villagerRidable);
+        villagerRidableInWater = getBoolean("mobs.villager.ridable-in-water", villagerRidableInWater);
+        villagerControllable = getBoolean("mobs.villager.controllable", villagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.villager.attributes.max-health", villagerMaxHealth);
+            set("mobs.villager.attributes.max-health", null);
+            set("mobs.villager.attributes.max_health", oldValue);
+        }
+        villagerMaxHealth = getDouble("mobs.villager.attributes.max_health", villagerMaxHealth);
+        villagerScale = Mth.clamp(getDouble("mobs.villager.attributes.scale", villagerScale), 0.0625D, 16.0D);
+        villagerFollowEmeraldBlock = getBoolean("mobs.villager.follow-emerald-blocks", villagerFollowEmeraldBlock);
+        villagerTemptRange = getDouble("mobs.villager.attributes.tempt_range", villagerTemptRange);
+        villagerCanBeLeashed = getBoolean("mobs.villager.can-be-leashed", villagerCanBeLeashed);
+        villagerCanBreed = getBoolean("mobs.villager.can-breed", villagerCanBreed);
+        villagerBreedingTicks = getInt("mobs.villager.breeding-delay-ticks", villagerBreedingTicks);
+        villagerClericsFarmWarts = getBoolean("mobs.villager.clerics-farm-warts", villagerClericsFarmWarts);
+        villagerClericFarmersThrowWarts = getBoolean("mobs.villager.cleric-wart-farmers-throw-warts-at-villagers", villagerClericFarmersThrowWarts);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.villager.bypass-mob-griefing", false);
+            set("mobs.villager.bypass-mob-griefing", null);
+            set("mobs.villager.mob-griefing-override", oldVal ? true : "default");
+        }
+        villagerMobGriefingOverride = getBooleanOrDefault("mobs.villager.mob-griefing-override", villagerMobGriefingOverride);
+        villagerTakeDamageFromWater = getBoolean("mobs.villager.takes-damage-from-water", villagerTakeDamageFromWater);
+        villagerAllowTrading = getBoolean("mobs.villager.allow-trading", villagerAllowTrading);
+        villagerAlwaysDropExp = getBoolean("mobs.villager.always-drop-exp", villagerAlwaysDropExp);
+        villagerMinimumDemand = getInt("mobs.villager.minimum-demand", villagerMinimumDemand);
+        if (PurpurConfig.version < 9) {
+            boolean oldValue = getBoolean("mobs.villager.lobotomize-1x1", villagerLobotomizeEnabled);
+            set("mobs.villager.lobotomize.enabled", oldValue);
+            set("mobs.villager.lobotomize-1x1", null);
+        }
+        if (PurpurConfig.version < 27) {
+            int oldValue = getInt("mobs.villager.lobotomize.check-interval", villagerLobotomizeCheckInterval);
+            set("mobs.villager.lobotomize.check-interval", oldValue == 60 ? 100 : oldValue);
+        }
+        villagerLobotomizeEnabled = getBoolean("mobs.villager.lobotomize.enabled", villagerLobotomizeEnabled);
+        villagerLobotomizeCheckInterval = getInt("mobs.villager.lobotomize.check-interval", villagerLobotomizeCheckInterval);
+        villagerLobotomizeWaitUntilTradeLocked = getBoolean("mobs.villager.lobotomize.wait-until-trade-locked", villagerLobotomizeWaitUntilTradeLocked);
+        villagerDisplayTradeItem = getBoolean("mobs.villager.display-trade-item", villagerDisplayTradeItem);
+        villagerSpawnIronGolemRadius = getInt("mobs.villager.spawn-iron-golem.radius", villagerSpawnIronGolemRadius);
+        villagerSpawnIronGolemLimit = getInt("mobs.villager.spawn-iron-golem.limit", villagerSpawnIronGolemLimit);
+        villagerAcquirePoiSearchRadius = getInt("mobs.villager.search-radius.acquire-poi", villagerAcquirePoiSearchRadius);
+        villagerNearestBedSensorSearchRadius = getInt("mobs.villager.search-radius.nearest-bed-sensor", villagerNearestBedSensorSearchRadius);
+        villagerCanPickUpLoot = getBooleanOrDefault("mobs.villager.can-pick-up-loot", villagerCanPickUpLoot);
+    }
+
+    public boolean vindicatorRidable = false;
+    public boolean vindicatorRidableInWater = true;
+    public boolean vindicatorControllable = true;
+    public double vindicatorMaxHealth = 24.0D;
+    public double vindicatorScale = 1.0D;
+    public double vindicatorJohnnySpawnChance = 0D;
+    public boolean vindicatorTakeDamageFromWater = false;
+    public boolean vindicatorAlwaysDropExp = false;
+    public Boolean vindicatorCanPickUpLoot = null;
+    private void vindicatorSettings() {
+        vindicatorRidable = getBoolean("mobs.vindicator.ridable", vindicatorRidable);
+        vindicatorRidableInWater = getBoolean("mobs.vindicator.ridable-in-water", vindicatorRidableInWater);
+        vindicatorControllable = getBoolean("mobs.vindicator.controllable", vindicatorControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.vindicator.attributes.max-health", vindicatorMaxHealth);
+            set("mobs.vindicator.attributes.max-health", null);
+            set("mobs.vindicator.attributes.max_health", oldValue);
+        }
+        vindicatorMaxHealth = getDouble("mobs.vindicator.attributes.max_health", vindicatorMaxHealth);
+        vindicatorScale = Mth.clamp(getDouble("mobs.vindicator.attributes.scale", vindicatorScale), 0.0625D, 16.0D);
+        vindicatorJohnnySpawnChance = getDouble("mobs.vindicator.johnny.spawn-chance", vindicatorJohnnySpawnChance);
+        vindicatorTakeDamageFromWater = getBoolean("mobs.vindicator.takes-damage-from-water", vindicatorTakeDamageFromWater);
+        vindicatorAlwaysDropExp = getBoolean("mobs.vindicator.always-drop-exp", vindicatorAlwaysDropExp);
+        vindicatorCanPickUpLoot = getBooleanOrDefault("mobs.vindicator.can-pick-up-loot", vindicatorCanPickUpLoot);
+    }
+
+    public boolean wanderingTraderRidable = false;
+    public boolean wanderingTraderRidableInWater = true;
+    public boolean wanderingTraderControllable = true;
+    public double wanderingTraderMaxHealth = 20.0D;
+    public double wanderingTraderScale = 1.0D;
+    public boolean wanderingTraderFollowEmeraldBlock = false;
+    public double wanderingTraderTemptRange = 10.0D;
+    public boolean wanderingTraderCanBeLeashed = false;
+    public boolean wanderingTraderTakeDamageFromWater = false;
+    public boolean wanderingTraderAllowTrading = true;
+    public boolean wanderingTraderAlwaysDropExp = false;
+    private void wanderingTraderSettings() {
+        wanderingTraderRidable = getBoolean("mobs.wandering_trader.ridable", wanderingTraderRidable);
+        wanderingTraderRidableInWater = getBoolean("mobs.wandering_trader.ridable-in-water", wanderingTraderRidableInWater);
+        wanderingTraderControllable = getBoolean("mobs.wandering_trader.controllable", wanderingTraderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wandering_trader.attributes.max-health", wanderingTraderMaxHealth);
+            set("mobs.wandering_trader.attributes.max-health", null);
+            set("mobs.wandering_trader.attributes.max_health", oldValue);
+        }
+        wanderingTraderMaxHealth = getDouble("mobs.wandering_trader.attributes.max_health", wanderingTraderMaxHealth);
+        wanderingTraderScale = Mth.clamp(getDouble("mobs.wandering_trader.attributes.scale", wanderingTraderScale), 0.0625D, 16.0D);
+        wanderingTraderFollowEmeraldBlock = getBoolean("mobs.wandering_trader.follow-emerald-blocks", wanderingTraderFollowEmeraldBlock);
+        wanderingTraderTemptRange = getDouble("mobs.wandering_trader.attributes.tempt_range", wanderingTraderTemptRange);
+        wanderingTraderCanBeLeashed = getBoolean("mobs.wandering_trader.can-be-leashed", wanderingTraderCanBeLeashed);
+        wanderingTraderTakeDamageFromWater = getBoolean("mobs.wandering_trader.takes-damage-from-water", wanderingTraderTakeDamageFromWater);
+        wanderingTraderAllowTrading = getBoolean("mobs.wandering_trader.allow-trading", wanderingTraderAllowTrading);
+        wanderingTraderAlwaysDropExp = getBoolean("mobs.wandering_trader.always-drop-exp", wanderingTraderAlwaysDropExp);
+    }
+
+    public boolean wardenRidable = false;
+    public boolean wardenRidableInWater = true;
+    public boolean wardenControllable = true;
+    public boolean wardenCanUseSonicBoom = true;
+    private void wardenSettings() {
+        wardenRidable = getBoolean("mobs.warden.ridable", wardenRidable);
+        wardenRidableInWater = getBoolean("mobs.warden.ridable-in-water", wardenRidableInWater);
+        wardenControllable = getBoolean("mobs.warden.controllable", wardenControllable);
+        wardenCanUseSonicBoom = getBoolean("mobs.warden.can-use-sonic-boom", wardenCanUseSonicBoom);
+    }
+
+    public boolean witchRidable = false;
+    public boolean witchRidableInWater = true;
+    public boolean witchControllable = true;
+    public double witchMaxHealth = 26.0D;
+    public double witchScale = 1.0D;
+    public boolean witchTakeDamageFromWater = false;
+    public boolean witchAlwaysDropExp = false;
+    private void witchSettings() {
+        witchRidable = getBoolean("mobs.witch.ridable", witchRidable);
+        witchRidableInWater = getBoolean("mobs.witch.ridable-in-water", witchRidableInWater);
+        witchControllable = getBoolean("mobs.witch.controllable", witchControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.witch.attributes.max-health", witchMaxHealth);
+            set("mobs.witch.attributes.max-health", null);
+            set("mobs.witch.attributes.max_health", oldValue);
+        }
+        witchMaxHealth = getDouble("mobs.witch.attributes.max_health", witchMaxHealth);
+        witchScale = Mth.clamp(getDouble("mobs.witch.attributes.scale", witchScale), 0.0625D, 16.0D);
+        witchTakeDamageFromWater = getBoolean("mobs.witch.takes-damage-from-water", witchTakeDamageFromWater);
+        witchAlwaysDropExp = getBoolean("mobs.witch.always-drop-exp", witchAlwaysDropExp);
+    }
+
+    public boolean witherRidable = false;
+    public boolean witherRidableInWater = true;
+    public boolean witherControllable = true;
+    public double witherMaxY = 320D;
+    public double witherMaxHealth = 300.0D;
+    public double witherScale = 1.0D;
+    public float witherHealthRegenAmount = 1.0f;
+    public int witherHealthRegenDelay = 20;
+    public Boolean witherMobGriefingOverride = null;
+    public boolean witherTakeDamageFromWater = false;
+    public boolean witherCanRideVehicles = false;
+    public float witherExplosionRadius = 1.0F;
+    public boolean witherPlaySpawnSound = true;
+    public boolean witherAlwaysDropExp = false;
+    private void witherSettings() {
+        witherRidable = getBoolean("mobs.wither.ridable", witherRidable);
+        witherRidableInWater = getBoolean("mobs.wither.ridable-in-water", witherRidableInWater);
+        witherControllable = getBoolean("mobs.wither.controllable", witherControllable);
+        witherMaxY = getDouble("mobs.wither.ridable-max-y", witherMaxY);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.wither.max-health", witherMaxHealth);
+            set("mobs.wither.max_health", null);
+            set("mobs.wither.attributes.max-health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wither.attributes.max-health", witherMaxHealth);
+            set("mobs.wither.attributes.max-health", null);
+            set("mobs.wither.attributes.max_health", oldValue);
+        }
+        witherMaxHealth = getDouble("mobs.wither.attributes.max_health", witherMaxHealth);
+        witherScale = Mth.clamp(getDouble("mobs.wither.attributes.scale", witherScale), 0.0625D, 16.0D);
+        witherHealthRegenAmount = (float) getDouble("mobs.wither.health-regen-amount", witherHealthRegenAmount);
+        witherHealthRegenDelay = getInt("mobs.wither.health-regen-delay", witherHealthRegenDelay);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.wither.bypass-mob-griefing", false);
+            set("mobs.wither.bypass-mob-griefing", null);
+            set("mobs.wither.mob-griefing-override", oldVal ? true : "default");
+        }
+        witherMobGriefingOverride = getBooleanOrDefault("mobs.wither.mob-griefing-override", witherMobGriefingOverride);
+        witherTakeDamageFromWater = getBoolean("mobs.wither.takes-damage-from-water", witherTakeDamageFromWater);
+        witherCanRideVehicles = getBoolean("mobs.wither.can-ride-vehicles", witherCanRideVehicles);
+        witherExplosionRadius = (float) getDouble("mobs.wither.explosion-radius", witherExplosionRadius);
+        witherPlaySpawnSound = getBoolean("mobs.wither.play-spawn-sound", witherPlaySpawnSound);
+        witherAlwaysDropExp = getBoolean("mobs.wither.always-drop-exp", witherAlwaysDropExp);
+    }
+
+    public boolean witherSkeletonRidable = false;
+    public boolean witherSkeletonRidableInWater = true;
+    public boolean witherSkeletonControllable = true;
+    public double witherSkeletonMaxHealth = 20.0D;
+    public double witherSkeletonScale = 1.0D;
+    public boolean witherSkeletonTakeDamageFromWater = false;
+    public boolean witherSkeletonAlwaysDropExp = false;
+    public Boolean witherSkeletonCanPickUpLoot = null;
+    private void witherSkeletonSettings() {
+        witherSkeletonRidable = getBoolean("mobs.wither_skeleton.ridable", witherSkeletonRidable);
+        witherSkeletonRidableInWater = getBoolean("mobs.wither_skeleton.ridable-in-water", witherSkeletonRidableInWater);
+        witherSkeletonControllable = getBoolean("mobs.wither_skeleton.controllable", witherSkeletonControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wither_skeleton.attributes.max-health", witherSkeletonMaxHealth);
+            set("mobs.wither_skeleton.attributes.max-health", null);
+            set("mobs.wither_skeleton.attributes.max_health", oldValue);
+        }
+        witherSkeletonMaxHealth = getDouble("mobs.wither_skeleton.attributes.max_health", witherSkeletonMaxHealth);
+        witherSkeletonScale = Mth.clamp(getDouble("mobs.wither_skeleton.attributes.scale", witherSkeletonScale), 0.0625D, 16.0D);
+        witherSkeletonTakeDamageFromWater = getBoolean("mobs.wither_skeleton.takes-damage-from-water", witherSkeletonTakeDamageFromWater);
+        witherSkeletonAlwaysDropExp = getBoolean("mobs.wither_skeleton.always-drop-exp", witherSkeletonAlwaysDropExp);
+        witherSkeletonCanPickUpLoot = getBooleanOrDefault("mobs.wither_skeleton.can-pick-up-loot", witherSkeletonCanPickUpLoot);
+    }
+
+    public boolean wolfRidable = false;
+    public boolean wolfRidableInWater = true;
+    public boolean wolfControllable = true;
+    public double wolfMaxHealth = 8.0D;
+    public double wolfScale = 1.0D;
+    public DyeColor wolfDefaultCollarColor = DyeColor.RED;
+    public boolean wolfMilkCuresRabies = true;
+    public double wolfNaturalRabid = 0.0D;
+    public int wolfBreedingTicks = 6000;
+    public boolean wolfTakeDamageFromWater = false;
+    public boolean wolfAlwaysDropExp = false;
+    private void wolfSettings() {
+        wolfRidable = getBoolean("mobs.wolf.ridable", wolfRidable);
+        wolfRidableInWater = getBoolean("mobs.wolf.ridable-in-water", wolfRidableInWater);
+        wolfControllable = getBoolean("mobs.wolf.controllable", wolfControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wolf.attributes.max-health", wolfMaxHealth);
+            set("mobs.wolf.attributes.max-health", null);
+            set("mobs.wolf.attributes.max_health", oldValue);
+        }
+        wolfMaxHealth = getDouble("mobs.wolf.attributes.max_health", wolfMaxHealth);
+        wolfScale = Mth.clamp(getDouble("mobs.wolf.attributes.scale", wolfScale), 0.0625D, 16.0D);
+        try {
+            wolfDefaultCollarColor = DyeColor.valueOf(getString("mobs.wolf.default-collar-color", wolfDefaultCollarColor.name()));
+        } catch (IllegalArgumentException ignore) {
+            wolfDefaultCollarColor = DyeColor.RED;
+        }
+        wolfMilkCuresRabies = getBoolean("mobs.wolf.milk-cures-rabid-wolves", wolfMilkCuresRabies);
+        wolfNaturalRabid = getDouble("mobs.wolf.spawn-rabid-chance", wolfNaturalRabid);
+        wolfBreedingTicks = getInt("mobs.wolf.breeding-delay-ticks", wolfBreedingTicks);
+        wolfTakeDamageFromWater = getBoolean("mobs.wolf.takes-damage-from-water", wolfTakeDamageFromWater);
+        wolfAlwaysDropExp = getBoolean("mobs.wolf.always-drop-exp", wolfAlwaysDropExp);
+    }
+
+    public boolean zoglinRidable = false;
+    public boolean zoglinRidableInWater = true;
+    public boolean zoglinControllable = true;
+    public double zoglinMaxHealth = 40.0D;
+    public double zoglinScale = 1.0D;
+    public boolean zoglinTakeDamageFromWater = false;
+    public boolean zoglinAlwaysDropExp = false;
+    private void zoglinSettings() {
+        zoglinRidable = getBoolean("mobs.zoglin.ridable", zoglinRidable);
+        zoglinRidableInWater = getBoolean("mobs.zoglin.ridable-in-water", zoglinRidableInWater);
+        zoglinControllable = getBoolean("mobs.zoglin.controllable", zoglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zoglin.attributes.max-health", zoglinMaxHealth);
+            set("mobs.zoglin.attributes.max-health", null);
+            set("mobs.zoglin.attributes.max_health", oldValue);
+        }
+        zoglinMaxHealth = getDouble("mobs.zoglin.attributes.max_health", zoglinMaxHealth);
+        zoglinScale = Mth.clamp(getDouble("mobs.zoglin.attributes.scale", zoglinScale), 0.0625D, 16.0D);
+        zoglinTakeDamageFromWater = getBoolean("mobs.zoglin.takes-damage-from-water", zoglinTakeDamageFromWater);
+        zoglinAlwaysDropExp = getBoolean("mobs.zoglin.always-drop-exp", zoglinAlwaysDropExp);
+    }
+
+    public boolean zombieRidable = false;
+    public boolean zombieRidableInWater = true;
+    public boolean zombieControllable = true;
+    public double zombieMaxHealth = 20.0D;
+    public double zombieScale = 1.0D;
+    public double zombieSpawnReinforcements = 0.1D;
+    public boolean zombieJockeyOnlyBaby = true;
+    public double zombieJockeyChance = 0.05D;
+    public boolean zombieJockeyTryExistingChickens = true;
+    public boolean zombieAggressiveTowardsVillagerWhenLagging = true;
+    public Boolean zombieMobGriefingOverride = null;
+    public boolean zombieTakeDamageFromWater = false;
+    public boolean zombieAlwaysDropExp = false;
+    public double zombieHeadVisibilityPercent = 0.5D;
+    public Boolean zombieCanPickUpLoot = null;
+    private void zombieSettings() {
+        zombieRidable = getBoolean("mobs.zombie.ridable", zombieRidable);
+        zombieRidableInWater = getBoolean("mobs.zombie.ridable-in-water", zombieRidableInWater);
+        zombieControllable = getBoolean("mobs.zombie.controllable", zombieControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombie.attributes.max-health", zombieMaxHealth);
+            set("mobs.zombie.attributes.max-health", null);
+            set("mobs.zombie.attributes.max_health", oldValue);
+        }
+        zombieMaxHealth = getDouble("mobs.zombie.attributes.max_health", zombieMaxHealth);
+        zombieScale = Mth.clamp(getDouble("mobs.zombie.attributes.scale", zombieScale), 0.0625D, 16.0D);
+        zombieSpawnReinforcements = getDouble("mobs.zombie.attributes.spawn_reinforcements", zombieSpawnReinforcements);
+        zombieJockeyOnlyBaby = getBoolean("mobs.zombie.jockey.only-babies", zombieJockeyOnlyBaby);
+        zombieJockeyChance = getDouble("mobs.zombie.jockey.chance", zombieJockeyChance);
+        zombieJockeyTryExistingChickens = getBoolean("mobs.zombie.jockey.try-existing-chickens", zombieJockeyTryExistingChickens);
+        zombieAggressiveTowardsVillagerWhenLagging = getBoolean("mobs.zombie.aggressive-towards-villager-when-lagging", zombieAggressiveTowardsVillagerWhenLagging);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.zombie.bypass-mob-griefing", false);
+            set("mobs.zombie.bypass-mob-griefing", null);
+            set("mobs.zombie.mob-griefing-override", oldVal ? true : "default");
+        }
+        zombieMobGriefingOverride = getBooleanOrDefault("mobs.zombie.mob-griefing-override", zombieMobGriefingOverride);
+        zombieTakeDamageFromWater = getBoolean("mobs.zombie.takes-damage-from-water", zombieTakeDamageFromWater);
+        zombieAlwaysDropExp = getBoolean("mobs.zombie.always-drop-exp", zombieAlwaysDropExp);
+        zombieHeadVisibilityPercent = getDouble("mobs.zombie.head-visibility-percent", zombieHeadVisibilityPercent);
+        zombieCanPickUpLoot = getBooleanOrDefault("mobs.zombie.can-pick-up-loot", zombieCanPickUpLoot);
+    }
+
+    public boolean zombieHorseRidable = false;
+    public boolean zombieHorseRidableInWater = false;
+    public boolean zombieHorseCanSwim = false;
+    public double zombieHorseMaxHealthMin = 15.0D;
+    public double zombieHorseMaxHealthMax = 15.0D;
+    public double zombieHorseJumpStrengthMin = 0.4D;
+    public double zombieHorseJumpStrengthMax = 1.0D;
+    public double zombieHorseMovementSpeedMin = 0.2D;
+    public double zombieHorseMovementSpeedMax = 0.2D;
+    public double zombieHorseSpawnChance = 0.0D;
+    public boolean zombieHorseTakeDamageFromWater = false;
+    public boolean zombieHorseAlwaysDropExp = false;
+    private void zombieHorseSettings() {
+        zombieHorseRidable = getBoolean("mobs.zombie_horse.ridable", zombieHorseRidable);
+        zombieHorseRidableInWater = getBoolean("mobs.zombie_horse.ridable-in-water", zombieHorseRidableInWater);
+        zombieHorseCanSwim = getBoolean("mobs.zombie_horse.can-swim", zombieHorseCanSwim);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombie_horse.attributes.max-health", zombieHorseMaxHealthMin);
+            set("mobs.zombie_horse.attributes.max-health", null);
+            set("mobs.zombie_horse.attributes.max_health.min", oldValue);
+            set("mobs.zombie_horse.attributes.max_health.max", oldValue);
+        }
+        zombieHorseMaxHealthMin = getDouble("mobs.zombie_horse.attributes.max_health.min", zombieHorseMaxHealthMin);
+        zombieHorseMaxHealthMax = getDouble("mobs.zombie_horse.attributes.max_health.max", zombieHorseMaxHealthMax);
+        zombieHorseJumpStrengthMin = getDouble("mobs.zombie_horse.attributes.jump_strength.min", zombieHorseJumpStrengthMin);
+        zombieHorseJumpStrengthMax = getDouble("mobs.zombie_horse.attributes.jump_strength.max", zombieHorseJumpStrengthMax);
+        zombieHorseMovementSpeedMin = getDouble("mobs.zombie_horse.attributes.movement_speed.min", zombieHorseMovementSpeedMin);
+        zombieHorseMovementSpeedMax = getDouble("mobs.zombie_horse.attributes.movement_speed.max", zombieHorseMovementSpeedMax);
+        zombieHorseSpawnChance = getDouble("mobs.zombie_horse.spawn-chance", zombieHorseSpawnChance);
+        zombieHorseTakeDamageFromWater = getBoolean("mobs.zombie_horse.takes-damage-from-water", zombieHorseTakeDamageFromWater);
+        zombieHorseAlwaysDropExp = getBoolean("mobs.zombie_horse.always-drop-exp", zombieHorseAlwaysDropExp);
+    }
+
+    public double zombieNautilusMaxHealth = 15.0D;
+    public double zombieNautilusMovementSpeed = 1.1D;
+    public double zombieNautilusAttackDamage = 3.0D;
+    public double zombieNautilusKnockbackResistance = 0.3D;
+    public double zombieNautilusScale = 1.0D;
+    public boolean zombieNautilusAlwaysDropExp = false;
+    private void zombieNautilusSettings() {
+        zombieNautilusMaxHealth = getDouble("mobs.zombie_nautilus.attributes.max_health", zombieNautilusMaxHealth);
+        zombieNautilusMovementSpeed = getDouble("mobs.zombie_nautilus.attributes.movement_speed", zombieNautilusMovementSpeed);
+        zombieNautilusAttackDamage = getDouble("mobs.zombie_nautilus.attributes.attack_damage", zombieNautilusAttackDamage);
+        zombieNautilusKnockbackResistance = getDouble("mobs.zombie_nautilus.attributes.knockback_resistance", zombieNautilusKnockbackResistance);
+        zombieNautilusScale = Mth.clamp(getDouble("mobs.zombie_nautilus.attributes.scale", zombieNautilusScale), 0.0625D, 16.0D);
+        zombieNautilusAlwaysDropExp = getBoolean("mobs.zombie_nautilus.always-drop-exp", zombieNautilusAlwaysDropExp);
+    }
+
+    public boolean zombieVillagerRidable = false;
+    public boolean zombieVillagerRidableInWater = true;
+    public boolean zombieVillagerControllable = true;
+    public double zombieVillagerMaxHealth = 20.0D;
+    public double zombieVillagerScale = 1.0D;
+    public double zombieVillagerSpawnReinforcements = 0.1D;
+    public boolean zombieVillagerJockeyOnlyBaby = true;
+    public double zombieVillagerJockeyChance = 0.05D;
+    public boolean zombieVillagerJockeyTryExistingChickens = true;
+    public boolean zombieVillagerTakeDamageFromWater = false;
+    public int zombieVillagerCuringTimeMin = 3600;
+    public int zombieVillagerCuringTimeMax = 6000;
+    public boolean zombieVillagerCureEnabled = true;
+    public boolean zombieVillagerAlwaysDropExp = false;
+    public Boolean zombieVillagerCanPickUpLoot = null;
+    private void zombieVillagerSettings() {
+        zombieVillagerRidable = getBoolean("mobs.zombie_villager.ridable", zombieVillagerRidable);
+        zombieVillagerRidableInWater = getBoolean("mobs.zombie_villager.ridable-in-water", zombieVillagerRidableInWater);
+        zombieVillagerControllable = getBoolean("mobs.zombie_villager.controllable", zombieVillagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombie_villager.attributes.max-health", zombieVillagerMaxHealth);
+            set("mobs.zombie_villager.attributes.max-health", null);
+            set("mobs.zombie_villager.attributes.max_health", oldValue);
+        }
+        zombieVillagerMaxHealth = getDouble("mobs.zombie_villager.attributes.max_health", zombieVillagerMaxHealth);
+        zombieVillagerScale = Mth.clamp(getDouble("mobs.zombie_villager.attributes.scale", zombieVillagerScale), 0.0625D, 16.0D);
+        zombieVillagerSpawnReinforcements = getDouble("mobs.zombie_villager.attributes.spawn_reinforcements", zombieVillagerSpawnReinforcements);
+        zombieVillagerJockeyOnlyBaby = getBoolean("mobs.zombie_villager.jockey.only-babies", zombieVillagerJockeyOnlyBaby);
+        zombieVillagerJockeyChance = getDouble("mobs.zombie_villager.jockey.chance", zombieVillagerJockeyChance);
+        zombieVillagerJockeyTryExistingChickens = getBoolean("mobs.zombie_villager.jockey.try-existing-chickens", zombieVillagerJockeyTryExistingChickens);
+        zombieVillagerTakeDamageFromWater = getBoolean("mobs.zombie_villager.takes-damage-from-water", zombieVillagerTakeDamageFromWater);
+        zombieVillagerCuringTimeMin = getInt("mobs.zombie_villager.curing_time.min", zombieVillagerCuringTimeMin);
+        zombieVillagerCuringTimeMax = getInt("mobs.zombie_villager.curing_time.max", zombieVillagerCuringTimeMax);
+        zombieVillagerCureEnabled = getBoolean("mobs.zombie_villager.cure.enabled", zombieVillagerCureEnabled);
+        zombieVillagerAlwaysDropExp = getBoolean("mobs.zombie_villager.always-drop-exp", zombieVillagerAlwaysDropExp);
+        zombieVillagerCanPickUpLoot = getBooleanOrDefault("mobs.zombie_villager.can-pick-up-loot", zombieVillagerCanPickUpLoot);
+    }
+
+    public boolean zombifiedPiglinRidable = false;
+    public boolean zombifiedPiglinRidableInWater = true;
+    public boolean zombifiedPiglinControllable = true;
+    public double zombifiedPiglinMaxHealth = 20.0D;
+    public double zombifiedPiglinScale = 1.0D;
+    public double zombifiedPiglinSpawnReinforcements = 0.0D;
+    public boolean zombifiedPiglinJockeyOnlyBaby = true;
+    public double zombifiedPiglinJockeyChance = 0.05D;
+    public boolean zombifiedPiglinJockeyTryExistingChickens = true;
+    public boolean zombifiedPiglinCountAsPlayerKillWhenAngry = false;
+    public boolean zombifiedPiglinTakeDamageFromWater = false;
+    public boolean zombifiedPiglinAlwaysDropExp = false;
+    public Boolean zombifiedPiglinCanPickUpLoot = null;
+    private void zombifiedPiglinSettings() {
+        zombifiedPiglinRidable = getBoolean("mobs.zombified_piglin.ridable", zombifiedPiglinRidable);
+        zombifiedPiglinRidableInWater = getBoolean("mobs.zombified_piglin.ridable-in-water", zombifiedPiglinRidableInWater);
+        zombifiedPiglinControllable = getBoolean("mobs.zombified_piglin.controllable", zombifiedPiglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombified_piglin.attributes.max-health", zombifiedPiglinMaxHealth);
+            set("mobs.zombified_piglin.attributes.max-health", null);
+            set("mobs.zombified_piglin.attributes.max_health", oldValue);
+        }
+        zombifiedPiglinMaxHealth = getDouble("mobs.zombified_piglin.attributes.max_health", zombifiedPiglinMaxHealth);
+        zombifiedPiglinScale = Mth.clamp(getDouble("mobs.zombified_piglin.attributes.scale", zombifiedPiglinScale), 0.0625D, 16.0D);
+        zombifiedPiglinSpawnReinforcements = getDouble("mobs.zombified_piglin.attributes.spawn_reinforcements", zombifiedPiglinSpawnReinforcements);
+        zombifiedPiglinJockeyOnlyBaby = getBoolean("mobs.zombified_piglin.jockey.only-babies", zombifiedPiglinJockeyOnlyBaby);
+        zombifiedPiglinJockeyChance = getDouble("mobs.zombified_piglin.jockey.chance", zombifiedPiglinJockeyChance);
+        zombifiedPiglinJockeyTryExistingChickens = getBoolean("mobs.zombified_piglin.jockey.try-existing-chickens", zombifiedPiglinJockeyTryExistingChickens);
+        if (PurpurConfig.version < 42) {
+            set("mobs.zombified_piglin.count-as-player-kill-when-angry", false);
+        }
+        zombifiedPiglinCountAsPlayerKillWhenAngry = getBoolean("mobs.zombified_piglin.count-as-player-kill-when-angry", zombifiedPiglinCountAsPlayerKillWhenAngry);
+        zombifiedPiglinTakeDamageFromWater = getBoolean("mobs.zombified_piglin.takes-damage-from-water", zombifiedPiglinTakeDamageFromWater);
+        zombifiedPiglinAlwaysDropExp = getBoolean("mobs.zombified_piglin.always-drop-exp", zombifiedPiglinAlwaysDropExp);
+        zombifiedPiglinCanPickUpLoot = getBooleanOrDefault("mobs.zombified_piglin.can-pick-up-loot", zombifiedPiglinCanPickUpLoot);
+    }
+
+    public float hungerStarvationDamage = 1.0F;
+    private void hungerSettings() {
+        hungerStarvationDamage = (float) getDouble("hunger.starvation-damage", hungerStarvationDamage);
+    }
+
+    public int conduitDistance = 16;
+    public double conduitDamageDistance = 8;
+    public float conduitDamageAmount = 4;
+    public Block[] conduitBlocks;
+    private void conduitSettings() {
+        conduitDistance = getInt("blocks.conduit.effect-distance", conduitDistance);
+        conduitDamageDistance = getDouble("blocks.conduit.mob-damage.distance", conduitDamageDistance);
+        conduitDamageAmount = (float) getDouble("blocks.conduit.mob-damage.damage-amount", conduitDamageAmount);
+        List<Block> conduitBlockList = new ArrayList<>();
+        getList("blocks.conduit.valid-ring-blocks", new ArrayList<String>(){{
+            add("minecraft:prismarine");
+            add("minecraft:prismarine_bricks");
+            add("minecraft:sea_lantern");
+            add("minecraft:dark_prismarine");
+        }}).forEach(key -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(Identifier.parse(key.toString()));
+            if (!block.defaultBlockState().isAir()) {
+                conduitBlockList.add(block);
+            }
+        });
+        conduitBlocks = conduitBlockList.toArray(Block[]::new);
+    }
+
+    public float cauldronRainChance = 0.05F;
+    public float cauldronPowderSnowChance = 0.1F;
+    public float cauldronDripstoneWaterFillChance = 0.17578125F;
+    public float cauldronDripstoneLavaFillChance = 0.05859375F;
+    private void cauldronSettings() {
+        cauldronRainChance = (float) getDouble("blocks.cauldron.fill-chances.rain", cauldronRainChance);
+        cauldronPowderSnowChance = (float) getDouble("blocks.cauldron.fill-chances.powder-snow", cauldronPowderSnowChance);
+        cauldronDripstoneWaterFillChance = (float) getDouble("blocks.cauldron.fill-chances.dripstone-water", cauldronDripstoneWaterFillChance);
+        cauldronDripstoneLavaFillChance = (float) getDouble("blocks.cauldron.fill-chances.dripstone-lava", cauldronDripstoneLavaFillChance);
+    }
+
+    public float shearsCanDefuseTntChance = 0.00F;
+    public boolean shearsCanDefuseTnt = false;
+    private void shearsCanDefuseTntSettings() {
+        shearsCanDefuseTntChance = (float) getDouble("gameplay-mechanics.item.shears.defuse-tnt-chance", 0.00D);
+        shearsCanDefuseTnt = shearsCanDefuseTntChance > 0.00F;
+    }
+}
diff --git a/org/purpurmc/purpur/command/CompassCommand.java b/org/purpurmc/purpur/command/CompassCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..99d344d7f906fbe9855ccd25a6cf937b97766516
--- /dev/null
+++ b/org/purpurmc/purpur/command/CompassCommand.java
@@ -0,0 +1,28 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.task.CompassTask;
+
+public class CompassCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("compass")
+                .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.compass"))
+                .executes(context -> {
+                    ServerPlayer player = context.getSource().getPlayerOrException();
+                    CompassTask task = CompassTask.instance();
+                    if (player.compassBar()) {
+                        task.removePlayer(player.getBukkitEntity());
+                        player.compassBar(false);
+                    } else {
+                        task.addPlayer(player.getBukkitEntity());
+                        player.compassBar(true);
+                    }
+                    return 1;
+                })
+        );
+    }
+}
diff --git a/org/purpurmc/purpur/command/CreditsCommand.java b/org/purpurmc/purpur/command/CreditsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..01c6be4eff952ac1c67a1ffafbd1c06ea3c0b959
--- /dev/null
+++ b/org/purpurmc/purpur/command/CreditsCommand.java
@@ -0,0 +1,36 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class CreditsCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("credits")
+                .requires((listener) -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.credits"))
+                .executes((context) -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.credits.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            ClientboundGameEventPacket packet = new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 1F);
+            player.connection.send(packet);
+            String output = String.format(PurpurConfig.creditsCommandOutput, player.getGameProfile().name());
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/DemoCommand.java b/org/purpurmc/purpur/command/DemoCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..30259ea943d66625ddf05e1a80dde83a44fbdb3d
--- /dev/null
+++ b/org/purpurmc/purpur/command/DemoCommand.java
@@ -0,0 +1,36 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class DemoCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("demo")
+                .requires((listener) -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.demo"))
+                .executes((context) -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.demo.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            ClientboundGameEventPacket packet = new ClientboundGameEventPacket(ClientboundGameEventPacket.DEMO_EVENT, 0);
+            player.connection.send(packet);
+            String output = String.format(PurpurConfig.demoCommandOutput, player.getGameProfile().name());
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/PingCommand.java b/org/purpurmc/purpur/command/PingCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..ae32b99e095bd48ee05f6fa761fe6ccc73b677c2
--- /dev/null
+++ b/org/purpurmc/purpur/command/PingCommand.java
@@ -0,0 +1,33 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class PingCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("ping")
+                .requires((listener) -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.ping"))
+                .executes((context) -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.ping.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            String output = String.format(PurpurConfig.pingCommandOutput, player.getGameProfile().name(), player.connection.latency());
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/PurpurCommand.java b/org/purpurmc/purpur/command/PurpurCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..63e5ae61a763883d93f2dd800ab48a54c9e71077
--- /dev/null
+++ b/org/purpurmc/purpur/command/PurpurCommand.java
@@ -0,0 +1,70 @@
+package org.purpurmc.purpur.command;
+
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import org.purpurmc.purpur.PurpurConfig;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class PurpurCommand extends Command {
+    public PurpurCommand(String name) {
+        super(name);
+        this.description = "Purpur related commands";
+        this.usageMessage = "/purpur [reload | version]";
+        this.setPermission("bukkit.command.purpur");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload", "version")
+                    .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+                    .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length != 1) {
+            sender.sendMessage(Component.text("Usage: " + usageMessage, NamedTextColor.RED));
+            return false;
+        }
+
+        if (args[0].equalsIgnoreCase("reload")) {
+            Command.broadcastCommandMessage(sender, Component.text("Please note that this command is not supported and may cause issues", NamedTextColor.RED));
+            Command.broadcastCommandMessage(sender, Component.text("If you encounter any issues please use the /stop command to restart your server.", NamedTextColor.RED));
+
+            MinecraftServer console = MinecraftServer.getServer();
+            PurpurConfig.init((File) console.options.valueOf("purpur-settings"));
+            for (ServerLevel level : console.getAllLevels()) {
+                level.purpurConfig.init();
+                level.resetBreedingCooldowns(); // Purpur - Add adjustable breeding cooldown to config
+            }
+            console.server.reloadCount++;
+
+            Command.broadcastCommandMessage(sender, Component.text("Purpur config reload complete.", NamedTextColor.GREEN));
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command verCmd = org.bukkit.Bukkit.getServer().getCommandMap().getCommand("version");
+            if (verCmd != null) {
+                return verCmd.execute(sender, commandLabel, new String[0]);
+            }
+        } else {
+            sender.sendMessage(Component.text("Usage: " + usageMessage, NamedTextColor.RED));
+            return false;
+        }
+
+        return true;
+    }
+}
diff --git a/org/purpurmc/purpur/command/RamBarCommand.java b/org/purpurmc/purpur/command/RamBarCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..78ae578aacf69f5c8577a68d0bba8add75adf574
--- /dev/null
+++ b/org/purpurmc/purpur/command/RamBarCommand.java
@@ -0,0 +1,45 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.PurpurConfig;
+import org.purpurmc.purpur.task.RamBarTask;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class RamBarCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("rambar")
+                .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.rambar"))
+                .executes(context -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.rambar.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            boolean result = RamBarTask.instance().togglePlayer(player.getBukkitEntity());
+            player.ramBar(result);
+
+            Component output = MiniMessage.miniMessage().deserialize(PurpurConfig.rambarCommandOutput,
+                    Placeholder.component("onoff", Component.translatable(result ? "options.on" : "options.off")
+                            .color(result ? NamedTextColor.GREEN : NamedTextColor.RED)),
+                    Placeholder.parsed("target", player.getGameProfile().name()));
+
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/RamCommand.java b/org/purpurmc/purpur/command/RamCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a1d6eecfb02d55ad0262256229a751c112887ee
--- /dev/null
+++ b/org/purpurmc/purpur/command/RamCommand.java
@@ -0,0 +1,31 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.PurpurConfig;
+import org.purpurmc.purpur.task.RamBarTask;
+
+public class RamCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("ram")
+                .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.ram"))
+                .executes(context -> {
+                    CommandSourceStack sender = context.getSource();
+                    RamBarTask ramBar = RamBarTask.instance();
+                    sender.sendSuccess(() -> PaperAdventure.asVanilla(MiniMessage.miniMessage().deserialize(PurpurConfig.ramCommandOutput,
+                            Placeholder.component("allocated", ramBar.format(ramBar.getAllocated())),
+                            Placeholder.component("used", ramBar.format(ramBar.getUsed())),
+                            Placeholder.component("xmx", ramBar.format(ramBar.getXmx())),
+                            Placeholder.component("xms", ramBar.format(ramBar.getXms())),
+                            Placeholder.unparsed("percent", ((int) (ramBar.getPercent() * 100)) + "%")
+                    )), false);
+                    return 1;
+                })
+        );
+    }
+}
diff --git a/org/purpurmc/purpur/command/TPSBarCommand.java b/org/purpurmc/purpur/command/TPSBarCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..668b633c7ab7f450feb012db53db8a1e2f79a987
--- /dev/null
+++ b/org/purpurmc/purpur/command/TPSBarCommand.java
@@ -0,0 +1,45 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.PurpurConfig;
+import org.purpurmc.purpur.task.TPSBarTask;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class TPSBarCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("tpsbar")
+                .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.tpsbar"))
+                .executes(context -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.tpsbar.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            boolean result = TPSBarTask.instance().togglePlayer(player.getBukkitEntity());
+            player.tpsBar(result);
+
+            Component output = MiniMessage.miniMessage().deserialize(PurpurConfig.tpsbarCommandOutput,
+                    Placeholder.component("onoff", Component.translatable(result ? "options.on" : "options.off")
+                            .color(result ? NamedTextColor.GREEN : NamedTextColor.RED)),
+                            Placeholder.parsed("target", player.getGameProfile().name()));
+
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/UptimeCommand.java b/org/purpurmc/purpur/command/UptimeCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb0ca957f439e49d22457a7753bab8f504907d74
--- /dev/null
+++ b/org/purpurmc/purpur/command/UptimeCommand.java
@@ -0,0 +1,56 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.permissions.Permissions;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+
+public class UptimeCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("uptime")
+                .requires((listener) -> listener.hasPermission(Permissions.COMMANDS_GAMEMASTER, "bukkit.command.uptime"))
+                .executes((context) -> execute(context.getSource()))
+        );
+    }
+
+    private static int execute(CommandSourceStack sender) {
+        Data data = new Data();
+
+        data.format = PurpurConfig.uptimeFormat;
+        data.hide = true;
+        data.millis = System.currentTimeMillis() - MinecraftServer.startTimeMillis;
+
+        process(data, "<days>", PurpurConfig.uptimeDay, PurpurConfig.uptimeDays, TimeUnit.DAYS, TimeUnit.MILLISECONDS::toDays);
+        process(data, "<hours>", PurpurConfig.uptimeHour, PurpurConfig.uptimeHours, TimeUnit.HOURS, TimeUnit.MILLISECONDS::toHours);
+        process(data, "<minutes>", PurpurConfig.uptimeMinute, PurpurConfig.uptimeMinutes, TimeUnit.MINUTES, TimeUnit.MILLISECONDS::toMinutes);
+        data.hide = false; // never hide seconds
+        process(data, "<seconds>", PurpurConfig.uptimeSecond, PurpurConfig.uptimeSeconds, TimeUnit.SECONDS, TimeUnit.MILLISECONDS::toSeconds);
+
+        Component output = MiniMessage.miniMessage().deserialize(PurpurConfig.uptimeCommandOutput, Placeholder.unparsed("uptime", data.format));
+        sender.sendSuccess(output, false);
+        return 1;
+    }
+
+    private static void process(Data data, String replace, String singular, String plural, TimeUnit unit, Function<Long, Long> func) {
+        if (data.format.contains(replace)) {
+            long val = func.apply(data.millis);
+            if (data.hide) data.hide = val == 0;
+            if (!data.hide) data.millis -= unit.toMillis(val);
+            data.format = data.format.replace(replace, data.hide ? "" : String.format(val == 1 ? singular : plural, val));
+        }
+    }
+
+    private static class Data {
+        String format;
+        boolean hide;
+        long millis;
+    }
+}
diff --git a/org/purpurmc/purpur/configuration/transformation/FarEndTerrainGenerationMigration.java b/org/purpurmc/purpur/configuration/transformation/FarEndTerrainGenerationMigration.java
new file mode 100644
index 0000000000000000000000000000000000000000..eaa3e8a7ac99f7b2e713c07bb30e4704b1d7637a
--- /dev/null
+++ b/org/purpurmc/purpur/configuration/transformation/FarEndTerrainGenerationMigration.java
@@ -0,0 +1,41 @@
+package org.purpurmc.purpur.configuration.transformation;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.purpurmc.purpur.PurpurConfig;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.NodePath;
+import org.spongepowered.configurate.transformation.ConfigurationTransformation;
+import org.spongepowered.configurate.transformation.TransformAction;
+
+import static org.spongepowered.configurate.NodePath.path;
+
+public class FarEndTerrainGenerationMigration implements TransformAction {
+
+    public static boolean HAS_BEEN_REGISTERED = false;
+
+    public static final String MISC_KEY = "misc";
+    public static final String FIX_FAR_END_TERRAIN_GENERATION_KEY = "fix-far-end-terrain-generation";
+
+    @Override
+    public Object @Nullable [] visitPath(final NodePath path, final ConfigurationNode value) throws ConfigurateException {
+        String purpurGenerateEndVoidRingsPath = "settings.generate-end-void-rings";
+        ConfigurationNode fixFarEndTerrainGenerationNode = value.node(MISC_KEY, FIX_FAR_END_TERRAIN_GENERATION_KEY);
+        if (PurpurConfig.config.contains(purpurGenerateEndVoidRingsPath)) {
+            boolean purpurGenerateEndVoidRings = PurpurConfig.config.getBoolean(purpurGenerateEndVoidRingsPath);
+            if (purpurGenerateEndVoidRings) {
+                fixFarEndTerrainGenerationNode.set(false);
+            }
+            PurpurConfig.config.set(purpurGenerateEndVoidRingsPath, null);
+        }
+
+        return null;
+    }
+
+    public static void apply(final ConfigurationTransformation.Builder builder) {
+        if (PurpurConfig.version < 46) {
+            HAS_BEEN_REGISTERED = true;
+            builder.addAction(path(), new FarEndTerrainGenerationMigration());
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/controller/FlyingMoveControllerWASD.java b/org/purpurmc/purpur/controller/FlyingMoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..940bcc6f79b59cb3cce578912eb789efd394f456
--- /dev/null
+++ b/org/purpurmc/purpur/controller/FlyingMoveControllerWASD.java
@@ -0,0 +1,74 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+
+public class FlyingMoveControllerWASD extends MoveControllerWASD {
+    protected final float groundSpeedModifier;
+    protected final float flyingSpeedModifier;
+    protected int tooHighCooldown = 0;
+    protected boolean setNoGravityFlag;
+
+    public FlyingMoveControllerWASD(Mob entity) {
+        this(entity, 1.0F);
+    }
+
+    public FlyingMoveControllerWASD(Mob entity, float groundSpeedModifier) {
+        this(entity, groundSpeedModifier, 1.0F, true);
+    }
+
+    public FlyingMoveControllerWASD(Mob entity, float groundSpeedModifier, float flyingSpeedModifier) {
+        this(entity, groundSpeedModifier, flyingSpeedModifier, true);
+    }
+
+    public FlyingMoveControllerWASD(Mob entity, float groundSpeedModifier, float flyingSpeedModifier, boolean setNoGravityFlag) {
+        super(entity);
+        this.groundSpeedModifier = groundSpeedModifier;
+        this.flyingSpeedModifier = flyingSpeedModifier;
+        this.setNoGravityFlag = setNoGravityFlag;
+    }
+
+    @Override
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : 0.0F;
+        float vertical = forward == 0.0F ? 0.0F : -(rider.xRotO / 45.0F);
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F);
+
+        if (lastClientInput.jump() && spacebarEvent(entity)) {
+            entity.onSpacebar();
+        }
+
+        if (entity.getY() >= entity.getMaxY() || --tooHighCooldown > 0) {
+            if (tooHighCooldown <= 0) {
+                tooHighCooldown = 20;
+            }
+            entity.setDeltaMovement(entity.getDeltaMovement().add(0.0D, -0.05D, 0.0D));
+            vertical = 0.0F;
+        }
+
+        setSpeedModifier(entity.getAttributeValue(Attributes.MOVEMENT_SPEED));
+        float speed = (float) getSpeedModifier();
+
+        if (entity.onGround) {
+            speed *= groundSpeedModifier; // TODO = fix this!
+        } else {
+            speed *= flyingSpeedModifier;
+        }
+
+        if (setNoGravityFlag) {
+            entity.setNoGravity(forward > 0);
+        }
+
+        entity.setSpeed(speed);
+        entity.setVerticalMot(vertical);
+        entity.setStrafeMot(strafe);
+        entity.setForwardMot(forward);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+    }
+}
diff --git a/org/purpurmc/purpur/controller/FlyingWithSpacebarMoveControllerWASD.java b/org/purpurmc/purpur/controller/FlyingWithSpacebarMoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0bbaec05afa0ae67ed486b14ea1fbadbbe90d9b
--- /dev/null
+++ b/org/purpurmc/purpur/controller/FlyingWithSpacebarMoveControllerWASD.java
@@ -0,0 +1,66 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.Vec3;
+
+public class FlyingWithSpacebarMoveControllerWASD extends FlyingMoveControllerWASD {
+    public FlyingWithSpacebarMoveControllerWASD(Mob entity) {
+        super(entity);
+    }
+
+    public FlyingWithSpacebarMoveControllerWASD(Mob entity, float groundSpeedModifier) {
+        super(entity, groundSpeedModifier);
+    }
+
+    @Override
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F);
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F) * 0.5F;
+        float vertical = 0;
+
+        if (forward < 0.0F) {
+            forward *= 0.5F;
+            strafe *= 0.5F;
+        }
+
+        float speed = (float) entity.getAttributeValue(Attributes.MOVEMENT_SPEED);
+
+        if (entity.onGround) {
+            speed *= groundSpeedModifier;
+        }
+
+        if (lastClientInput.jump() && spacebarEvent(entity) && !entity.onSpacebar()) {
+            entity.setNoGravity(true);
+            vertical = 1.0F;
+        } else {
+            entity.setNoGravity(false);
+        }
+
+        if (entity.getY() >= entity.getMaxY() || --tooHighCooldown > 0) {
+            if (tooHighCooldown <= 0) {
+                tooHighCooldown = 20;
+            }
+            entity.setDeltaMovement(entity.getDeltaMovement().add(0.0D, -0.2D, 0.0D));
+            vertical = 0.0F;
+        }
+
+        setSpeedModifier(speed);
+        entity.setSpeed((float) getSpeedModifier());
+        entity.setVerticalMot(vertical);
+        entity.setStrafeMot(strafe);
+        entity.setForwardMot(forward);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+
+        Vec3 mot = entity.getDeltaMovement();
+        if (mot.y > 0.2D) {
+            entity.setDeltaMovement(mot.x, 0.2D, mot.z);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/controller/LookControllerWASD.java b/org/purpurmc/purpur/controller/LookControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b177a9a2b06eb238cd95ae3c6332bea3a24549b
--- /dev/null
+++ b/org/purpurmc/purpur/controller/LookControllerWASD.java
@@ -0,0 +1,79 @@
+package org.purpurmc.purpur.controller;
+
+
+import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.control.LookControl;
+import net.minecraft.world.entity.player.Player;
+
+public class LookControllerWASD extends LookControl {
+    protected final Mob entity;
+    private float yOffset = 0;
+    private float xOffset = 0;
+
+    public LookControllerWASD(Mob entity) {
+        super(entity);
+        this.entity = entity;
+    }
+
+    // tick
+    @Override
+    public void tick() {
+        if (entity.getRider() != null && entity.isControllable()) {
+            purpurTick(entity.getRider());
+        } else {
+            vanillaTick();
+        }
+    }
+
+    protected void purpurTick(Player rider) {
+        setYawPitch(rider.getYRot(), rider.getXRot());
+    }
+
+    public void vanillaTick() {
+        super.tick();
+    }
+
+    public void setYawPitch(float yRot, float xRot) {
+        entity.setXRot(normalizePitch(xRot + xOffset));
+        entity.setYRot(normalizeYaw(yRot + yOffset));
+        entity.setYHeadRot(entity.getYRot());
+        entity.xRotO = entity.getXRot();
+        entity.yRotO = entity.getYRot();
+
+        ClientboundMoveEntityPacket.PosRot entityPacket = new ClientboundMoveEntityPacket.PosRot(
+            entity.getId(),
+            (short) 0, (short) 0, (short) 0,
+            (byte) Mth.floor(entity.getYRot() * 256.0F / 360.0F),
+            (byte) Mth.floor(entity.getXRot() * 256.0F / 360.0F),
+            entity.onGround
+        );
+        ((ServerLevel) entity.level()).getChunkSource().sendToTrackingPlayers(entity, entityPacket);
+    }
+
+    public void setOffsets(float yaw, float pitch) {
+        yOffset = yaw;
+        xOffset = pitch;
+    }
+
+    public float normalizeYaw(float yaw) {
+        yaw %= 360.0f;
+        if (yaw >= 180.0f) {
+            yaw -= 360.0f;
+        } else if (yaw < -180.0f) {
+            yaw += 360.0f;
+        }
+        return yaw;
+    }
+
+    public float normalizePitch(float pitch) {
+        if (pitch > 90.0f) {
+            pitch = 90.0f;
+        } else if (pitch < -90.0f) {
+            pitch = -90.0f;
+        }
+        return pitch;
+    }
+}
diff --git a/org/purpurmc/purpur/controller/MoveControllerWASD.java b/org/purpurmc/purpur/controller/MoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..34f3c43fa16e950326ac5e3d93faee0466ffedc6
--- /dev/null
+++ b/org/purpurmc/purpur/controller/MoveControllerWASD.java
@@ -0,0 +1,92 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.ai.control.MoveControl;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+import org.purpurmc.purpur.event.entity.RidableSpacebarEvent;
+
+public class MoveControllerWASD extends MoveControl {
+    protected final Mob entity;
+    private final double speedModifier;
+
+    public MoveControllerWASD(Mob entity) {
+        this(entity, 1.0D);
+    }
+
+    public MoveControllerWASD(Mob entity, double speedModifier) {
+        super(entity);
+        this.entity = entity;
+        this.speedModifier = speedModifier;
+    }
+
+    @Override
+    public boolean hasWanted() {
+        return entity.getRider() != null ? strafeForwards != 0 || strafeRight != 0 : super.hasWanted();
+    }
+
+    @Override
+    public void tick() {
+        if (entity.getRider() != null && entity.isControllable()) {
+            purpurTick(entity.getRider());
+        } else {
+            vanillaTick();
+        }
+    }
+
+    public void vanillaTick() {
+        super.tick();
+    }
+
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F) * 0.5F;
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F) * 0.25F;
+
+        if (forward <= 0.0F) {
+            forward *= 0.5F;
+        }
+
+        float yawOffset = 0;
+        if (strafe != 0) {
+            if (forward == 0) {
+                yawOffset += strafe > 0 ? -90 : 90;
+                forward = Math.abs(strafe * 2);
+            } else {
+                yawOffset += strafe > 0 ? -30 : 30;
+                strafe /= 2;
+                if (forward < 0) {
+                    yawOffset += strafe > 0 ? -110 : 110;
+                    forward *= -1;
+                }
+            }
+        } else if (forward < 0) {
+            yawOffset -= 180;
+            forward *= -1;
+        }
+
+        ((LookControllerWASD) entity.getLookControl()).setOffsets(yawOffset, 0);
+
+        if (lastClientInput.jump() && spacebarEvent(entity) && !entity.onSpacebar() && entity.onGround) {
+            entity.jumpFromGround();
+        }
+
+        setSpeedModifier(entity.getAttributeValue(Attributes.MOVEMENT_SPEED) * speedModifier);
+
+        entity.setSpeed((float) getSpeedModifier());
+        entity.setForwardMot(forward);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+    }
+
+    public static boolean spacebarEvent(Mob entity) {
+        if (RidableSpacebarEvent.getHandlerList().getRegisteredListeners().length > 0) {
+            return new RidableSpacebarEvent(entity.getBukkitEntity()).callEvent();
+        } else {
+            return true;
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/controller/WaterMoveControllerWASD.java b/org/purpurmc/purpur/controller/WaterMoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..922e48799c43ca322a8f550c98a26e1e2959439c
--- /dev/null
+++ b/org/purpurmc/purpur/controller/WaterMoveControllerWASD.java
@@ -0,0 +1,53 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+
+public class WaterMoveControllerWASD extends MoveControllerWASD {
+    private final double speedModifier;
+
+    public WaterMoveControllerWASD(Mob entity) {
+        this(entity, 1.0D);
+    }
+
+    public WaterMoveControllerWASD(Mob entity, double speedModifier) {
+        super(entity);
+        this.speedModifier = speedModifier;
+    }
+
+    @Override
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F);
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F) * 0.5F; // strafe slower by default
+        float vertical = -(rider.xRotO / 90);
+
+        if (forward == 0.0F) {
+            // strafe slower if not moving forward
+            strafe *= 0.5F;
+            // do not move vertically if not moving forward
+            vertical = 0.0F;
+        } else if (forward < 0.0F) {
+            // water animals can't swim backwards
+            forward = 0.0F;
+            vertical = 0.0F;
+        }
+
+        if (rider.jumping && spacebarEvent(entity)) {
+            entity.onSpacebar();
+        }
+
+        setSpeedModifier(entity.getAttributeValue(Attributes.MOVEMENT_SPEED) * speedModifier);
+        entity.setSpeed((float) getSpeedModifier() * 0.1F);
+
+        entity.setForwardMot(forward * (float) speedModifier);
+        entity.setStrafeMot(strafe * (float) speedModifier);
+        entity.setVerticalMot(vertical * (float) speedModifier);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+    }
+}
diff --git a/org/purpurmc/purpur/entity/PurpurStoredBee.java b/org/purpurmc/purpur/entity/PurpurStoredBee.java
new file mode 100644
index 0000000000000000000000000000000000000000..c468cfa59117835c7008eac71c057149aeaa7cc9
--- /dev/null
+++ b/org/purpurmc/purpur/entity/PurpurStoredBee.java
@@ -0,0 +1,116 @@
+package org.purpurmc.purpur.entity;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.util.ProblemReporter;
+import net.minecraft.world.level.block.entity.BeehiveBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.storage.TagValueInput;
+import net.minecraft.world.level.storage.ValueInput;
+import org.bukkit.block.EntityBlockStorage;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.entity.Bee;
+import org.bukkit.entity.EntityType;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.slf4j.Logger;
+import java.util.Locale;
+
+public class PurpurStoredBee implements StoredEntity<Bee> {
+    static final Logger LOGGER = LogUtils.getLogger();
+
+    private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
+
+    private final EntityBlockStorage<Bee> blockStorage;
+    private final BeehiveBlockEntity.BeeData handle;
+    private final CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(PurpurStoredBee.DATA_TYPE_REGISTRY);
+
+    private Component customName;
+
+    public PurpurStoredBee(BeehiveBlockEntity.BeeData data, EntityBlockStorage<Bee> blockStorage, final BeehiveBlockEntity blockEntity) {
+        this.handle = data;
+        this.blockStorage = blockStorage;
+
+        CompoundTag customData = handle.occupant.entityData().copyTagWithEntityId();
+
+        try (ProblemReporter.ScopedCollector scopedCollector = new ProblemReporter.ScopedCollector(blockEntity.problemPath(), LOGGER)) {
+            ValueInput valueInput = TagValueInput.create(scopedCollector, RegistryAccess.EMPTY, customData);
+
+            net.minecraft.network.chat.Component customNameMinecraft = BlockEntity.parseCustomNameSafe(valueInput, "CustomName");
+            this.customName = customNameMinecraft == null ? null : PaperAdventure.asAdventure(customNameMinecraft);
+
+            if (customData.get("BukkitValues") instanceof CompoundTag compoundTag) {
+                this.persistentDataContainer.putAll(compoundTag);
+            }
+        }
+    }
+
+    public BeehiveBlockEntity.BeeData getHandle() {
+        return handle;
+    }
+
+    @Override
+    public @Nullable Component customName() {
+        return customName;
+    }
+
+    @Override
+    public void customName(@Nullable Component customName) {
+        this.customName = customName;
+    }
+
+    @Override
+    public @Nullable String getCustomName() {
+        return PaperAdventure.asPlain(customName, Locale.US);
+    }
+
+    @Override
+    public void setCustomName(@Nullable String name) {
+        customName(name != null ? Component.text(name) : null);
+    }
+
+    @Override
+    public @NotNull PersistentDataContainer getPersistentDataContainer() {
+        return persistentDataContainer;
+    }
+
+    @Override
+    public boolean hasBeenReleased() {
+        return !blockStorage.getEntities().contains(this);
+    }
+
+    @Override
+    public @Nullable Bee release() {
+        return blockStorage.releaseEntity(this);
+    }
+
+    @Override
+    public @Nullable EntityBlockStorage<Bee> getBlockStorage() {
+        if(hasBeenReleased()) {
+            return null;
+        }
+
+        return blockStorage;
+    }
+
+    @Override
+    public @NotNull EntityType getType() {
+        return EntityType.BEE;
+    }
+
+    @Override
+    public void update() {
+        handle.occupant.entityData().copyTagWithEntityId().put("BukkitValues", this.persistentDataContainer.toTagCompound());
+        if(customName == null) {
+            handle.occupant.entityData().copyTagWithEntityId().remove("CustomName");
+        } else {
+            handle.occupant.entityData().copyTagWithEntityId().putString("CustomName", CraftChatMessage.toJSON(PaperAdventure.asVanilla(customName)));
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/HasRider.java b/org/purpurmc/purpur/entity/ai/HasRider.java
new file mode 100644
index 0000000000000000000000000000000000000000..8babdaddd8b33278aea0369dbbeeb445abe45016
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/HasRider.java
@@ -0,0 +1,20 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.goal.Goal;
+
+import java.util.EnumSet;
+
+public class HasRider extends Goal {
+    public final Mob entity;
+
+    public HasRider(Mob entity) {
+        this.entity = entity;
+        setFlags(EnumSet.of(Flag.MOVE, Flag.LOOK, Flag.TARGET, Flag.UNKNOWN_BEHAVIOR));
+    }
+
+    @Override
+    public boolean canUse() {
+        return entity.getRider() != null && entity.isControllable();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/HorseHasRider.java b/org/purpurmc/purpur/entity/ai/HorseHasRider.java
new file mode 100644
index 0000000000000000000000000000000000000000..121b78edd207da2a98a3d79967bf30719002b807
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/HorseHasRider.java
@@ -0,0 +1,17 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.world.entity.animal.equine.AbstractHorse;
+
+public class HorseHasRider extends HasRider {
+    public final AbstractHorse horse;
+
+    public HorseHasRider(AbstractHorse entity) {
+        super(entity);
+        this.horse = entity;
+    }
+
+    @Override
+    public boolean canUse() {
+        return super.canUse() && horse.isSaddled();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/LlamaHasRider.java b/org/purpurmc/purpur/entity/ai/LlamaHasRider.java
new file mode 100644
index 0000000000000000000000000000000000000000..c7fc343272235ba590619c61bbd8a66a003370e0
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/LlamaHasRider.java
@@ -0,0 +1,17 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.world.entity.animal.equine.Llama;
+
+public class LlamaHasRider extends HasRider {
+    public final Llama llama;
+
+    public LlamaHasRider(Llama entity) {
+        super(entity);
+        this.llama = entity;
+    }
+
+    @Override
+    public boolean canUse() {
+        return super.canUse() && llama.isSaddled() && llama.isControllable();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/ReceiveFlower.java b/org/purpurmc/purpur/entity/ai/ReceiveFlower.java
new file mode 100644
index 0000000000000000000000000000000000000000..39c3b4d55373ae51db85e929882cbbc68056724e
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/ReceiveFlower.java
@@ -0,0 +1,95 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityReference;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.goal.Goal;
+import net.minecraft.world.entity.animal.golem.IronGolem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Blocks;
+
+import java.util.EnumSet;
+import java.util.UUID;
+import org.jetbrains.annotations.NotNull;
+
+public class ReceiveFlower extends Goal {
+    private final IronGolem irongolem;
+    private ServerPlayer target;
+    private int cooldown;
+
+    public ReceiveFlower(IronGolem entity) {
+        this.irongolem = entity;
+        setFlags(EnumSet.of(Flag.MOVE, Flag.LOOK));
+    }
+
+    @Override
+    public boolean canUse() {
+        if (this.irongolem.getOfferFlowerTick() > 0) {
+            return false;
+        }
+        if (!this.irongolem.isAngry()) {
+            return false;
+        }
+        EntityReference<LivingEntity> persistentAngerTarget = this.irongolem.getPersistentAngerTarget();
+        if (persistentAngerTarget == null) {
+            return false;
+        }
+
+        LivingEntity target = EntityReference.getLivingEntity(persistentAngerTarget, this.irongolem.level());
+        if (!(target instanceof ServerPlayer player)) {
+            return false;
+        }
+        InteractionHand hand = getPoppyHand(player);
+        if (hand == null) {
+            return false;
+        }
+        removeFlower(player, hand);
+        this.target = player;
+        return true;
+    }
+
+    @Override
+    public boolean canContinueToUse() {
+        return this.cooldown > 0;
+    }
+
+    @Override
+    public void start() {
+        this.cooldown = 100;
+        this.irongolem.stopBeingAngry();
+        this.irongolem.offerFlower(true);
+    }
+
+    @Override
+    public void stop() {
+        this.irongolem.offerFlower(false);
+        this.target = null;
+    }
+
+    @Override
+    public void tick() {
+        this.irongolem.getLookControl().setLookAt(this.target, 30.0F, 30.0F);
+        --this.cooldown;
+    }
+
+    private InteractionHand getPoppyHand(ServerPlayer player) {
+        if (isPoppy(player.getMainHandItem())) {
+            return InteractionHand.MAIN_HAND;
+        }
+        if (isPoppy(player.getOffhandItem())) {
+            return InteractionHand.OFF_HAND;
+        }
+        return null;
+    }
+
+    private void removeFlower(ServerPlayer player, InteractionHand hand) {
+        player.setItemInHand(hand, ItemStack.EMPTY);
+    }
+
+    private boolean isPoppy(ItemStack item) {
+        return item.getItem() == Blocks.POPPY.asItem();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/projectile/DolphinSpit.java b/org/purpurmc/purpur/entity/projectile/DolphinSpit.java
new file mode 100644
index 0000000000000000000000000000000000000000..6bd739353a3b35ada3d340c964b27769ca25e2bd
--- /dev/null
+++ b/org/purpurmc/purpur/entity/projectile/DolphinSpit.java
@@ -0,0 +1,105 @@
+package org.purpurmc.purpur.entity.projectile;
+
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.animal.dolphin.Dolphin;
+import net.minecraft.world.entity.projectile.LlamaSpit;
+import net.minecraft.world.entity.projectile.ProjectileUtil;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.event.entity.EntityRemoveEvent;
+
+public class DolphinSpit extends LlamaSpit {
+    public LivingEntity dolphin;
+    public int ticksLived;
+
+    public DolphinSpit(EntityType<? extends LlamaSpit> type, Level world) {
+        super(type, world);
+    }
+
+    public DolphinSpit(Level world, Dolphin dolphin) {
+        this(EntityType.LLAMA_SPIT, world);
+        this.setOwner(dolphin.getRider() != null ? dolphin.getRider() : dolphin);
+        this.dolphin = dolphin;
+        this.setPos(
+                dolphin.getX() - (double) (dolphin.getBbWidth() + 1.0F) * 0.5 * (double) Mth.sin(dolphin.yBodyRot * (float) (Math.PI / 180.0)),
+                dolphin.getEyeY() - 0.1F,
+                dolphin.getZ() + (double) (dolphin.getBbWidth() + 1.0F) * 0.5 * (double) Mth.cos(dolphin.yBodyRot * (float) (Math.PI / 180.0)));
+    }
+
+    @Override
+    public boolean canSaveToDisk() {
+        return false;
+    }
+
+    public void tick() {
+        projectileTick();
+
+        Vec3 mot = this.getDeltaMovement();
+        HitResult hitResult = ProjectileUtil.getHitResultOnMoveVector(this, this::canHitEntity);
+
+        this.preHitTargetOrDeflectSelf(hitResult);
+
+        double x = this.getX() + mot.x;
+        double y = this.getY() + mot.y;
+        double z = this.getZ() + mot.z;
+
+        this.updateRotation();
+
+        Vec3 motDouble = mot.scale(2.0);
+        for (int i = 0; i < 5; i++) {
+            ((ServerLevel) level()).sendParticlesSource(null, ParticleTypes.BUBBLE,
+                    true, false,
+                    getX() + random.nextFloat() / 2 - 0.25F,
+                    getY() + random.nextFloat() / 2 - 0.25F,
+                    getZ() + random.nextFloat() / 2 - 0.25F,
+                    0, motDouble.x(), motDouble.y(), motDouble.z(), 0.1D);
+        }
+
+        if (++ticksLived > 20) {
+            this.discard(EntityRemoveEvent.Cause.DISCARD);
+        } else {
+            this.setDeltaMovement(mot.scale(0.99D));
+            if (!this.isNoGravity()) {
+                this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.06D, 0.0D));
+            }
+
+            this.setPos(x, y, z);
+        }
+    }
+
+    @Override
+    public void shoot(double x, double y, double z, float speed, float inaccuracy) {
+        setDeltaMovement(new Vec3(x, y, z).normalize().add(
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy)
+                .scale(speed));
+    }
+
+    @Override
+    protected void onHitEntity(EntityHitResult entityHitResult) {
+        Entity shooter = this.getOwner();
+        if (shooter instanceof LivingEntity) {
+            entityHitResult.getEntity().hurt(entityHitResult.getEntity().damageSources().mobProjectile(this, (LivingEntity) shooter), level().purpurConfig.dolphinSpitDamage);
+        }
+    }
+
+    @Override
+    protected void onHitBlock(BlockHitResult blockHitResult) {
+        if (this.hitCancelled) {
+            return;
+        }
+        BlockState state = this.level().getBlockState(blockHitResult.getBlockPos());
+        state.onProjectileHit(this.level(), state, blockHitResult, this);
+        this.discard(EntityRemoveEvent.Cause.DISCARD);
+    }
+}
diff --git a/org/purpurmc/purpur/entity/projectile/PhantomFlames.java b/org/purpurmc/purpur/entity/projectile/PhantomFlames.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3fe215e163373641a11c0ab2f5fd5e666434055
--- /dev/null
+++ b/org/purpurmc/purpur/entity/projectile/PhantomFlames.java
@@ -0,0 +1,127 @@
+package org.purpurmc.purpur.entity.projectile;
+
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.decoration.ArmorStand;
+import net.minecraft.world.entity.monster.Phantom;
+import net.minecraft.world.entity.projectile.LlamaSpit;
+import net.minecraft.world.entity.projectile.ProjectileUtil;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+
+public class PhantomFlames extends LlamaSpit {
+    public Phantom phantom;
+    public int ticksLived;
+    public boolean canGrief = false;
+
+    public PhantomFlames(EntityType<? extends LlamaSpit> type, Level world) {
+        super(type, world);
+    }
+
+    public PhantomFlames(Level world, Phantom phantom) {
+        this(EntityType.LLAMA_SPIT, world);
+        setOwner(phantom.getRider() != null ? phantom.getRider() : phantom);
+        this.phantom = phantom;
+        this.setPos(
+                phantom.getX() - (double) (phantom.getBbWidth() + 1.0F) * 0.5D * (double) Mth.sin(phantom.yBodyRot * (float) (Math.PI / 180.0)),
+                phantom.getEyeY() - 0.10000000149011612D,
+                phantom.getZ() + (double) (phantom.getBbWidth() + 1.0F) * 0.5D * (double) Mth.cos(phantom.yBodyRot * (float) (Math.PI / 180.0)));
+    }
+
+    @Override
+    public boolean canSaveToDisk() {
+        return false;
+    }
+
+    public void tick() {
+        projectileTick();
+
+        Vec3 mot = this.getDeltaMovement();
+        HitResult hitResult = ProjectileUtil.getHitResultOnMoveVector(this, this::canHitEntity);
+
+        this.preHitTargetOrDeflectSelf(hitResult);
+
+        double x = this.getX() + mot.x;
+        double y = this.getY() + mot.y;
+        double z = this.getZ() + mot.z;
+
+        this.updateRotation();
+
+        Vec3 motDouble = mot.scale(2.0);
+        for (int i = 0; i < 5; i++) {
+            ((ServerLevel) level()).sendParticlesSource(null, ParticleTypes.FLAME,
+                    true, false,
+                    getX() + random.nextFloat() / 2 - 0.25F,
+                    getY() + random.nextFloat() / 2 - 0.25F,
+                    getZ() + random.nextFloat() / 2 - 0.25F,
+                    0, motDouble.x(), motDouble.y(), motDouble.z(), 0.1D);
+        }
+
+        if (++ticksLived > 20) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        } else if (this.level().getBlockStates(this.getBoundingBox()).noneMatch(BlockBehaviour.BlockStateBase::isAir)) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        } else if (this.isInWater()) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        } else {
+            this.setDeltaMovement(mot.scale(0.99D));
+            if (!this.isNoGravity()) {
+                this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.06D, 0.0D));
+            }
+
+            this.setPos(x, y, z);
+        }
+    }
+
+    @Override
+    public void shoot(double x, double y, double z, float speed, float inaccuracy) {
+        setDeltaMovement(new Vec3(x, y, z).normalize().add(
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy)
+                .scale(speed));
+    }
+
+    @Override
+    protected void onHitEntity(EntityHitResult entityHitResult) {
+        Level world = this.level();
+
+        if (world instanceof ServerLevel worldserver) {
+            Entity shooter = this.getOwner();
+            if (shooter instanceof LivingEntity) {
+                Entity target = entityHitResult.getEntity();
+                if (canGrief || (target instanceof LivingEntity && !(target instanceof ArmorStand))) {
+                    boolean hurt = target.hurtServer(worldserver, target.damageSources().mobProjectile(this, (LivingEntity) shooter), worldserver.purpurConfig.phantomFlameDamage);
+                    if (hurt && worldserver.purpurConfig.phantomFlameFireTime > 0) {
+                        target.igniteForSeconds(worldserver.purpurConfig.phantomFlameFireTime);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void onHitBlock(BlockHitResult blockHitResult) {
+        Level world = this.level();
+
+        if (world instanceof ServerLevel worldserver) {
+            if (this.hitCancelled) {
+                return;
+            }
+            if (this.canGrief) {
+                BlockState state = worldserver.getBlockState(blockHitResult.getBlockPos());
+                state.onProjectileHit(worldserver, state, blockHitResult, this);
+            }
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/gui/GUIColor.java b/org/purpurmc/purpur/gui/GUIColor.java
new file mode 100644
index 0000000000000000000000000000000000000000..550222758bf0e7deff26a6e813a860b7be365e87
--- /dev/null
+++ b/org/purpurmc/purpur/gui/GUIColor.java
@@ -0,0 +1,58 @@
+package org.purpurmc.purpur.gui;
+
+import net.md_5.bungee.api.ChatColor;
+
+import java.awt.Color;
+import java.util.HashMap;
+import java.util.Map;
+
+public enum GUIColor {
+    BLACK(ChatColor.BLACK, new Color(0x000000)),
+    DARK_BLUE(ChatColor.DARK_BLUE, new Color(0x0000AA)),
+    DARK_GREEN(ChatColor.DARK_GREEN, new Color(0x00AA00)),
+    DARK_AQUA(ChatColor.DARK_AQUA, new Color(0x009999)),
+    DARK_RED(ChatColor.DARK_RED, new Color(0xAA0000)),
+    DARK_PURPLE(ChatColor.DARK_PURPLE, new Color(0xAA00AA)),
+    GOLD(ChatColor.GOLD, new Color(0xBB8800)),
+    GRAY(ChatColor.GRAY, new Color(0x888888)),
+    DARK_GRAY(ChatColor.DARK_GRAY, new Color(0x444444)),
+    BLUE(ChatColor.BLUE, new Color(0x5555FF)),
+    GREEN(ChatColor.GREEN, new Color(0x55FF55)),
+    AQUA(ChatColor.AQUA, new Color(0x55DDDD)),
+    RED(ChatColor.RED, new Color(0xFF5555)),
+    LIGHT_PURPLE(ChatColor.LIGHT_PURPLE, new Color(0xFF55FF)),
+    YELLOW(ChatColor.YELLOW, new Color(0xFFBB00)),
+    WHITE(ChatColor.WHITE, new Color(0xBBBBBB));
+
+    private final ChatColor chat;
+    private final Color color;
+
+    private static final Map<ChatColor, GUIColor> BY_CHAT = new HashMap<>();
+
+    GUIColor(ChatColor chat, Color color) {
+        this.chat = chat;
+        this.color = color;
+    }
+
+    public Color getColor() {
+        return color;
+    }
+
+    public ChatColor getChatColor() {
+        return chat;
+    }
+
+    public String getCode() {
+        return chat.toString();
+    }
+
+    public static GUIColor getColor(ChatColor chat) {
+        return BY_CHAT.get(chat);
+    }
+
+    static {
+        for (GUIColor color : values()) {
+            BY_CHAT.put(color.chat, color);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/gui/JColorTextPane.java b/org/purpurmc/purpur/gui/JColorTextPane.java
new file mode 100644
index 0000000000000000000000000000000000000000..d75fb5e77eff27d86135ed7d605dbc250b660f7d
--- /dev/null
+++ b/org/purpurmc/purpur/gui/JColorTextPane.java
@@ -0,0 +1,83 @@
+package org.purpurmc.purpur.gui;
+
+import com.google.common.collect.Sets;
+import javax.swing.UIManager;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+
+import javax.swing.JTextPane;
+import javax.swing.Timer;
+import javax.swing.text.AttributeSet;
+import javax.swing.text.BadLocationException;
+import javax.swing.text.SimpleAttributeSet;
+import javax.swing.text.StyleConstants;
+import javax.swing.text.StyleContext;
+import java.util.Set;
+
+public class JColorTextPane extends JTextPane {
+    private static final GUIColor DEFAULT_COLOR;
+    static {
+        DEFAULT_COLOR = UIManager.getSystemLookAndFeelClassName().equals("com.sun.java.swing.plaf.gtk.GTKLookAndFeel")
+            ? GUIColor.WHITE : GUIColor.BLACK;
+    }
+
+
+    public void append(String msg) {
+        // TODO: update to use adventure instead
+        BaseComponent[] components = TextComponent.fromLegacyText(DEFAULT_COLOR.getCode() + msg, DEFAULT_COLOR.getChatColor());
+        for (BaseComponent component : components) {
+            String text = component.toPlainText();
+            if (text == null || text.isEmpty()) {
+                continue;
+            }
+
+            GUIColor guiColor = GUIColor.getColor(component.getColor());
+
+            StyleContext context = StyleContext.getDefaultStyleContext();
+            AttributeSet attr = context.addAttribute(SimpleAttributeSet.EMPTY, StyleConstants.Foreground, guiColor.getColor());
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Bold, component.isBold() || guiColor != DEFAULT_COLOR);
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Italic, component.isItalic());
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Underline, component.isUnderlined());
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.StrikeThrough, component.isStrikethrough());
+            //attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Blink, component.isObfuscated()); // no such thing as Blink, sadly
+
+            try {
+                int pos = getDocument().getLength();
+                getDocument().insertString(pos, text, attr);
+
+                if (component.isObfuscated()) {
+                    // dirty hack to blink some text
+                    Blink blink = new Blink(pos, text.length(), attr, context.addAttribute(attr, StyleConstants.Foreground, getBackground()));
+                    BLINKS.add(blink);
+                }
+            } catch (BadLocationException ignore) {
+            }
+        }
+    }
+
+    private static final Set<Blink> BLINKS = Sets.newHashSet();
+    private static boolean SYNC_BLINK;
+
+    static {
+        new Timer(500, e -> {
+            SYNC_BLINK = !SYNC_BLINK;
+            BLINKS.forEach(Blink::blink);
+        }).start();
+    }
+
+    public class Blink {
+        private final int start, length;
+        private final AttributeSet attr1, attr2;
+
+        private Blink(int start, int length, AttributeSet attr1, AttributeSet attr2) {
+            this.start = start;
+            this.length = length;
+            this.attr1 = attr1;
+            this.attr2 = attr2;
+        }
+
+        private void blink() {
+            getStyledDocument().setCharacterAttributes(start, length, SYNC_BLINK ? attr1 : attr2, true);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/item/GlowBerryItem.java b/org/purpurmc/purpur/item/GlowBerryItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..b257f35caa13b660854cf17f41fd8fba1d56c458
--- /dev/null
+++ b/org/purpurmc/purpur/item/GlowBerryItem.java
@@ -0,0 +1,26 @@
+package org.purpurmc.purpur.item;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import org.bukkit.event.entity.EntityPotionEffectEvent;
+
+public class GlowBerryItem extends BlockItem {
+    public GlowBerryItem(Block block, Properties settings) {
+        super(block, settings);
+    }
+
+    @Override
+    public ItemStack finishUsingItem(ItemStack stack, Level world, LivingEntity user) {
+        ItemStack result = super.finishUsingItem(stack, world, user);
+        if (world.purpurConfig.glowBerriesEatGlowDuration > 0 && user instanceof ServerPlayer player) {
+            player.addEffect(new MobEffectInstance(MobEffects.GLOWING, world.purpurConfig.glowBerriesEatGlowDuration), EntityPotionEffectEvent.Cause.FOOD);
+        }
+        return result;
+    }
+}
diff --git a/org/purpurmc/purpur/item/SpawnerItem.java b/org/purpurmc/purpur/item/SpawnerItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..cfa02aa027a049af982a05a69ce7f682580e6153
--- /dev/null
+++ b/org/purpurmc/purpur/item/SpawnerItem.java
@@ -0,0 +1,43 @@
+package org.purpurmc.purpur.item;
+
+import java.util.Optional;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.CustomData;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.SpawnerBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+
+public class SpawnerItem extends BlockItem {
+
+    public SpawnerItem(Block block, Properties settings) {
+        super(block, settings);
+    }
+
+    @Override
+    protected boolean updateCustomBlockEntityTag(BlockPos pos, Level level, Player player, ItemStack stack, BlockState state) {
+        boolean handled = super.updateCustomBlockEntityTag(pos, level, player, stack, state);
+        if (level.purpurConfig.silkTouchEnabled && player.getBukkitEntity().hasPermission("purpur.place.spawners")) {
+            BlockEntity blockEntity = level.getBlockEntity(pos);
+            if (blockEntity instanceof SpawnerBlockEntity spawner) {
+                CompoundTag customData = stack.getOrDefault(DataComponents.CUSTOM_DATA, CustomData.EMPTY).copyTag();
+                Optional<String> mobTypeStringOptional = customData.getString("Purpur.mob_type");
+                if (mobTypeStringOptional.isPresent()) {
+                    EntityType.byString(mobTypeStringOptional.get()).ifPresent(type -> spawner.getSpawner().setEntityId(type, level, level.random, pos));
+                } else if (customData.contains("Purpur.SpawnData")) {
+                    customData.getCompound("Purpur.SpawnData")
+                        .flatMap(spawnerData -> spawnerData.read("SpawnData", net.minecraft.world.level.SpawnData.CODEC))
+                        .ifPresent(spawnData -> spawner.getSpawner().nextSpawnData = spawnData);
+                }
+            }
+        }
+        return handled;
+    }
+}
diff --git a/org/purpurmc/purpur/network/ClientboundBeehivePayload.java b/org/purpurmc/purpur/network/ClientboundBeehivePayload.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc0c7b4a42fb68c9bc54100c8c0ac70c2050a244
--- /dev/null
+++ b/org/purpurmc/purpur/network/ClientboundBeehivePayload.java
@@ -0,0 +1,27 @@
+package org.purpurmc.purpur.network;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
+import net.minecraft.resources.Identifier;
+import org.jetbrains.annotations.NotNull;
+
+public record ClientboundBeehivePayload(BlockPos pos, int numOfBees) implements CustomPacketPayload {
+    public static final StreamCodec<FriendlyByteBuf, ClientboundBeehivePayload> STREAM_CODEC = CustomPacketPayload.codec(ClientboundBeehivePayload::write, ClientboundBeehivePayload::new);
+    public static final Type<ClientboundBeehivePayload> TYPE = new Type<>(Identifier.fromNamespaceAndPath("purpur", "beehive_s2c"));
+
+    public ClientboundBeehivePayload(FriendlyByteBuf friendlyByteBuf) {
+        this(friendlyByteBuf.readBlockPos(),  friendlyByteBuf.readInt());
+    }
+
+    private void write(FriendlyByteBuf friendlyByteBuf) {
+        friendlyByteBuf.writeBlockPos(this.pos);
+        friendlyByteBuf.writeInt(this.numOfBees);
+    }
+
+    @Override
+    public @NotNull Type<? extends CustomPacketPayload> type() {
+        return TYPE;
+    }
+}
diff --git a/org/purpurmc/purpur/network/ServerboundBeehivePayload.java b/org/purpurmc/purpur/network/ServerboundBeehivePayload.java
new file mode 100644
index 0000000000000000000000000000000000000000..6b980e8266c7cb743c83d3b7b498e4c0dd4e6bec
--- /dev/null
+++ b/org/purpurmc/purpur/network/ServerboundBeehivePayload.java
@@ -0,0 +1,26 @@
+package org.purpurmc.purpur.network;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
+import net.minecraft.resources.Identifier;
+import org.jetbrains.annotations.NotNull;
+
+public record ServerboundBeehivePayload(BlockPos pos) implements CustomPacketPayload {
+    public static final StreamCodec<FriendlyByteBuf, ServerboundBeehivePayload> STREAM_CODEC = CustomPacketPayload.codec(ServerboundBeehivePayload::write, ServerboundBeehivePayload::new);
+    public static final Type<ServerboundBeehivePayload> TYPE = new Type<>(Identifier.fromNamespaceAndPath("purpur", "beehive_c2s"));
+
+    public ServerboundBeehivePayload(FriendlyByteBuf friendlyByteBuf) {
+        this(friendlyByteBuf.readBlockPos());
+    }
+
+    private void write(FriendlyByteBuf friendlyByteBuf) {
+        friendlyByteBuf.writeBlockPos(this.pos);
+    }
+
+    @Override
+    public @NotNull Type<? extends CustomPacketPayload> type() {
+        return TYPE;
+    }
+}
diff --git a/org/purpurmc/purpur/task/BeehiveTask.java b/org/purpurmc/purpur/task/BeehiveTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..664f9d5e1ce5e2787bf699bd11758b9e3aa8ed3a
--- /dev/null
+++ b/org/purpurmc/purpur/task/BeehiveTask.java
@@ -0,0 +1,67 @@
+package org.purpurmc.purpur.task;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.block.entity.BeehiveBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.PluginBase;
+import org.bukkit.plugin.messaging.PluginMessageListener;
+import org.jetbrains.annotations.NotNull;
+import org.purpurmc.purpur.network.ClientboundBeehivePayload;
+import org.purpurmc.purpur.network.ServerboundBeehivePayload;
+import org.purpurmc.purpur.util.MinecraftInternalPlugin;
+
+public class BeehiveTask implements PluginMessageListener {
+
+    private static BeehiveTask instance;
+
+    public static BeehiveTask instance() {
+        if (instance == null) {
+            instance = new BeehiveTask();
+        }
+        return instance;
+    }
+
+    private final PluginBase plugin = new MinecraftInternalPlugin();
+
+    private BeehiveTask() {
+    }
+
+    public void register() {
+        Bukkit.getMessenger().registerOutgoingPluginChannel(this.plugin, ClientboundBeehivePayload.TYPE.id().toString());
+        Bukkit.getMessenger().registerIncomingPluginChannel(this.plugin, ServerboundBeehivePayload.TYPE.id().toString(), this);
+    }
+
+    public void unregister() {
+        Bukkit.getMessenger().unregisterOutgoingPluginChannel(this.plugin, ClientboundBeehivePayload.TYPE.id().toString());
+        Bukkit.getMessenger().unregisterIncomingPluginChannel(this.plugin, ServerboundBeehivePayload.TYPE.id().toString());
+    }
+
+    @Override
+    public void onPluginMessageReceived(@NotNull String channel, @NotNull Player player, byte[] bytes) {
+        FriendlyByteBuf byteBuf = new FriendlyByteBuf(Unpooled.copiedBuffer(bytes));
+        ServerboundBeehivePayload payload = ServerboundBeehivePayload.STREAM_CODEC.decode(byteBuf);
+
+        ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+
+        // targeted block info max range specified in client at net.minecraft.client.gui.hud.DebugHud#render
+        if (!payload.pos().getCenter().closerThan(serverPlayer.position(), 20)) return; // Targeted Block info max range is 20
+        if (serverPlayer.level().getChunkIfLoaded(payload.pos()) == null) return;
+
+        BlockEntity blockEntity = serverPlayer.level().getBlockEntity(payload.pos());
+        if (!(blockEntity instanceof BeehiveBlockEntity beehive)) {
+            return;
+        }
+
+        ClientboundBeehivePayload customPacketPayload = new ClientboundBeehivePayload(payload.pos(), beehive.getOccupantCount());
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        ClientboundBeehivePayload.STREAM_CODEC.encode(friendlyByteBuf, customPacketPayload);
+        byte[] byteArray = new byte[friendlyByteBuf.readableBytes()];
+        friendlyByteBuf.readBytes(byteArray);
+        player.sendPluginMessage(this.plugin, customPacketPayload.type().id().toString(), byteArray);
+    }
+}
diff --git a/org/purpurmc/purpur/task/BossBarTask.java b/org/purpurmc/purpur/task/BossBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c3d4cd52db93b97a40321030a70ebc282c9636b
--- /dev/null
+++ b/org/purpurmc/purpur/task/BossBarTask.java
@@ -0,0 +1,121 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.scheduler.BukkitRunnable;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.UUID;
+import org.purpurmc.purpur.util.MinecraftInternalPlugin;
+
+public abstract class BossBarTask extends BukkitRunnable {
+    private final Map<UUID, BossBar> bossbars = new HashMap<>();
+    private boolean started;
+
+    abstract BossBar createBossBar();
+
+    abstract void updateBossBar(BossBar bossbar, Player player);
+
+    @Override
+    public void run() {
+        Iterator<Map.Entry<UUID, BossBar>> iter = bossbars.entrySet().iterator();
+        while (iter.hasNext()) {
+            Map.Entry<UUID, BossBar> entry = iter.next();
+            Player player = Bukkit.getPlayer(entry.getKey());
+            if (player == null) {
+                iter.remove();
+                continue;
+            }
+            updateBossBar(entry.getValue(), player);
+        }
+    }
+
+    @Override
+    public void cancel() {
+        super.cancel();
+        new HashSet<>(this.bossbars.keySet()).forEach(uuid -> {
+            Player player = Bukkit.getPlayer(uuid);
+            if (player != null) {
+                removePlayer(player);
+            }
+        });
+        this.bossbars.clear();
+    }
+
+    public boolean removePlayer(Player player) {
+        BossBar bossbar = this.bossbars.remove(player.getUniqueId());
+        if (bossbar != null) {
+            player.hideBossBar(bossbar);
+            return true;
+        }
+        return false;
+    }
+
+    public void addPlayer(Player player) {
+        removePlayer(player);
+        BossBar bossbar = createBossBar();
+        this.bossbars.put(player.getUniqueId(), bossbar);
+        this.updateBossBar(bossbar, player);
+        player.showBossBar(bossbar);
+    }
+
+    public boolean hasPlayer(UUID uuid) {
+        return this.bossbars.containsKey(uuid);
+    }
+
+    public boolean togglePlayer(Player player) {
+        if (removePlayer(player)) {
+            return false;
+        }
+        addPlayer(player);
+        return true;
+    }
+
+    public void start() {
+        stop();
+        this.runTaskTimerAsynchronously(new MinecraftInternalPlugin(), 1, 1);
+        started = true;
+    }
+
+    public void stop() {
+        if (started) {
+            cancel();
+        }
+    }
+
+    public static void startAll() {
+        RamBarTask.instance().start();
+        TPSBarTask.instance().start();
+        CompassTask.instance().start();
+    }
+
+    public static void stopAll() {
+        RamBarTask.instance().stop();
+        TPSBarTask.instance().stop();
+        CompassTask.instance().stop();
+    }
+
+    public static void addToAll(ServerPlayer player) {
+        Player bukkit = player.getBukkitEntity();
+        if (player.ramBar()) {
+            RamBarTask.instance().addPlayer(bukkit);
+        }
+        if (player.tpsBar()) {
+            TPSBarTask.instance().addPlayer(bukkit);
+        }
+        if (player.compassBar()) {
+            CompassTask.instance().addPlayer(bukkit);
+        }
+    }
+
+    public static void removeFromAll(Player player) {
+        RamBarTask.instance().removePlayer(player);
+        TPSBarTask.instance().removePlayer(player);
+        CompassTask.instance().removePlayer(player);
+    }
+}
diff --git a/org/purpurmc/purpur/task/CompassTask.java b/org/purpurmc/purpur/task/CompassTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..bece7eefc8ba8822b433835526251d2fb916c025
--- /dev/null
+++ b/org/purpurmc/purpur/task/CompassTask.java
@@ -0,0 +1,68 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Items;
+import org.bukkit.entity.Player;
+import org.purpurmc.purpur.PurpurConfig;
+
+public class CompassTask extends BossBarTask {
+    private static CompassTask instance;
+
+    private int tick = 0;
+
+    public static CompassTask instance() {
+        if (instance == null) {
+            instance = new CompassTask();
+        }
+        return instance;
+    }
+
+    @Override
+    public void run() {
+        if (++tick < PurpurConfig.commandCompassBarTickInterval) {
+            return;
+        }
+        tick = 0;
+
+        MinecraftServer.getServer().getAllLevels().forEach((level) -> {
+            if (level.purpurConfig.compassItemShowsBossBar) {
+                level.players().forEach(player -> {
+                    if (!player.compassBar()) {
+                        if (player.getMainHandItem().getItem() != Items.COMPASS && player.getOffhandItem().getItem() != Items.COMPASS) {
+                            removePlayer(player.getBukkitEntity());
+                        } else if (!hasPlayer(player.getUUID())) {
+                            addPlayer(player.getBukkitEntity());
+                        }
+                    }
+                });
+            }
+        });
+
+        super.run();
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), PurpurConfig.commandCompassBarProgressPercent, PurpurConfig.commandCompassBarProgressColor, PurpurConfig.commandCompassBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        float yaw = player.getLocation().getYaw();
+        int length = PurpurConfig.commandCompassBarTitle.length();
+        int pos = (int) ((normalize(yaw) * (length / 720F)) + (length / 2F));
+        bossbar.name(Component.text(PurpurConfig.commandCompassBarTitle.substring(pos - 25, pos + 25)));
+    }
+
+    private float normalize(float yaw) {
+        while (yaw < -180.0F) {
+            yaw += 360.0F;
+        }
+        while (yaw > 180.0F) {
+            yaw -= 360.0F;
+        }
+        return yaw;
+    }
+}
diff --git a/org/purpurmc/purpur/task/RamBarTask.java b/org/purpurmc/purpur/task/RamBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e98c0ae73e2c40002a72b5d0d246ffa0c3ab38f
--- /dev/null
+++ b/org/purpurmc/purpur/task/RamBarTask.java
@@ -0,0 +1,117 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import org.bukkit.entity.Player;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.MemoryUsage;
+
+public class RamBarTask extends BossBarTask {
+    private static RamBarTask instance;
+    private long allocated = 0L;
+    private long used = 0L;
+    private long xmx = 0L;
+    private long xms = 0L;
+    private float percent = 0F;
+    private int tick = 0;
+
+    public static RamBarTask instance() {
+        if (instance == null) {
+            instance = new RamBarTask();
+        }
+        return instance;
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), 0.0F, instance().getBossBarColor(), PurpurConfig.commandRamBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        bossbar.progress(getBossBarProgress());
+        bossbar.color(getBossBarColor());
+        bossbar.name(MiniMessage.miniMessage().deserialize(PurpurConfig.commandRamBarTitle,
+                Placeholder.component("allocated", format(this.allocated)),
+                Placeholder.component("used", format(this.used)),
+                Placeholder.component("xmx", format(this.xmx)),
+                Placeholder.component("xms", format(this.xms)),
+                Placeholder.unparsed("percent", ((int) (this.percent * 100)) + "%")
+        ));
+    }
+
+    @Override
+    public void run() {
+        if (++this.tick < PurpurConfig.commandRamBarTickInterval) {
+            return;
+        }
+        this.tick = 0;
+
+        MemoryUsage heap = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
+
+        this.allocated = heap.getCommitted();
+        this.used = heap.getUsed();
+        this.xmx = heap.getMax();
+        this.xms = heap.getInit();
+        this.percent = Math.max(Math.min((float) this.used / this.xmx, 1.0F), 0.0F);
+
+        super.run();
+    }
+
+    private float getBossBarProgress() {
+        return this.percent;
+    }
+
+    private BossBar.Color getBossBarColor() {
+        if (this.percent < 0.5F) {
+            return PurpurConfig.commandRamBarProgressColorGood;
+        } else if (this.percent < 0.75F) {
+            return PurpurConfig.commandRamBarProgressColorMedium;
+        } else {
+            return PurpurConfig.commandRamBarProgressColorLow;
+        }
+    }
+
+    public Component format(long v) {
+        String color;
+        if (this.percent < 0.60F) {
+            color = PurpurConfig.commandRamBarTextColorGood;
+        } else if (this.percent < 0.85F) {
+            color = PurpurConfig.commandRamBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandRamBarTextColorLow;
+        }
+        String value;
+        if (v < 1024) {
+            value = v + "B";
+        } else {
+            int z = (63 - Long.numberOfLeadingZeros(v)) / 10;
+            value = String.format("%.1f%s", (double) v / (1L << (z * 10)), "BKMGTPE".charAt(z));
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.unparsed("text", value));
+    }
+
+    public long getAllocated() {
+        return this.allocated;
+    }
+
+    public long getUsed() {
+        return this.used;
+    }
+
+    public long getXmx() {
+        return this.xmx;
+    }
+
+    public long getXms() {
+        return this.xms;
+    }
+
+    public float getPercent() {
+        return this.percent;
+    }
+}
diff --git a/org/purpurmc/purpur/task/TPSBarTask.java b/org/purpurmc/purpur/task/TPSBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..8769993e7ca59da309087051a3cd38fc562c15d1
--- /dev/null
+++ b/org/purpurmc/purpur/task/TPSBarTask.java
@@ -0,0 +1,142 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import org.purpurmc.purpur.PurpurConfig;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+
+public class TPSBarTask extends BossBarTask {
+    private static TPSBarTask instance;
+    private double tps = 20.0D;
+    private double mspt = 0.0D;
+    private int tick = 0;
+
+    public static TPSBarTask instance() {
+        if (instance == null) {
+            instance = new TPSBarTask();
+        }
+        return instance;
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), 0.0F, instance().getBossBarColor(), PurpurConfig.commandTPSBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        bossbar.progress(getBossBarProgress());
+        bossbar.color(getBossBarColor());
+        bossbar.name(MiniMessage.miniMessage().deserialize(PurpurConfig.commandTPSBarTitle,
+                Placeholder.component("tps", getTPSColor()),
+                Placeholder.component("mspt", getMSPTColor()),
+                Placeholder.component("ping", getPingColor(player.getPing()))
+        ));
+    }
+
+    @Override
+    public void run() {
+        if (++tick < PurpurConfig.commandTPSBarTickInterval) {
+            return;
+        }
+        tick = 0;
+
+        this.tps = Math.max(Math.min(Bukkit.getTPS()[0], 20.0D), 0.0D);
+        this.mspt = Bukkit.getAverageTickTime();
+
+        super.run();
+    }
+
+    private float getBossBarProgress() {
+        if (PurpurConfig.commandTPSBarProgressFillMode == FillMode.MSPT) {
+            return Math.max(Math.min((float) mspt / 50.0F, 1.0F), 0.0F);
+        } else {
+            return Math.max(Math.min((float) tps / 20.0F, 1.0F), 0.0F);
+        }
+    }
+
+    private BossBar.Color getBossBarColor() {
+        if (isGood(PurpurConfig.commandTPSBarProgressFillMode)) {
+            return PurpurConfig.commandTPSBarProgressColorGood;
+        } else if (isMedium(PurpurConfig.commandTPSBarProgressFillMode)) {
+            return PurpurConfig.commandTPSBarProgressColorMedium;
+        } else {
+            return PurpurConfig.commandTPSBarProgressColorLow;
+        }
+    }
+
+    private boolean isGood(FillMode mode) {
+        return isGood(mode, 0);
+    }
+
+    private boolean isGood(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt < 40;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 19;
+        } else if (mode == FillMode.PING) {
+            return ping < 100;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean isMedium(FillMode mode) {
+        return isMedium(mode, 0);
+    }
+
+    private boolean isMedium(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt < 50;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 15;
+        } else if (mode == FillMode.PING) {
+            return ping < 200;
+        } else {
+            return false;
+        }
+    }
+
+    private Component getTPSColor() {
+        String color;
+        if (isGood(FillMode.TPS)) {
+            color = PurpurConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.TPS)) {
+            color = PurpurConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", tps)));
+    }
+
+    private Component getMSPTColor() {
+        String color;
+        if (isGood(FillMode.MSPT)) {
+            color = PurpurConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.MSPT)) {
+            color = PurpurConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", mspt)));
+    }
+
+    private Component getPingColor(int ping) {
+        String color;
+        if (isGood(FillMode.PING, ping)) {
+            color = PurpurConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.PING, ping)) {
+            color = PurpurConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%s", ping)));
+    }
+
+    public enum FillMode {
+        TPS, MSPT, PING
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Actionable.java b/org/purpurmc/purpur/tool/Actionable.java
new file mode 100644
index 0000000000000000000000000000000000000000..e18c37f06730da9d3055d5215e813b1477c1e70e
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Actionable.java
@@ -0,0 +1,24 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public abstract class Actionable {
+    private final Block into;
+    private final Map<Item, Double> drops;
+
+    public Actionable(Block into, Map<Item, Double> drops) {
+        this.into = into;
+        this.drops = drops;
+    }
+
+    public Block into() {
+        return into;
+    }
+
+    public Map<Item, Double> drops() {
+        return drops;
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Flattenable.java b/org/purpurmc/purpur/tool/Flattenable.java
new file mode 100644
index 0000000000000000000000000000000000000000..345d4ee4ff0b78bd1050959711a4f5d16a5e8aee
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Flattenable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Flattenable extends Actionable {
+    public Flattenable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Strippable.java b/org/purpurmc/purpur/tool/Strippable.java
new file mode 100644
index 0000000000000000000000000000000000000000..bf5402214f41af9c09bd6c5c4f45d330516d742e
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Strippable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Strippable extends Actionable {
+    public Strippable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Tillable.java b/org/purpurmc/purpur/tool/Tillable.java
new file mode 100644
index 0000000000000000000000000000000000000000..715f6dd44480347eebced43c11bc364e05727498
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Tillable.java
@@ -0,0 +1,50 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.HoeItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.level.block.Block;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Predicate;
+
+public class Tillable extends Actionable {
+    private final Condition condition;
+
+    public Tillable(Condition condition, Block into, Map<Item, Double> drops) {
+        super(into, drops);
+        this.condition = condition;
+    }
+
+    public Condition condition() {
+        return condition;
+    }
+
+    public enum Condition {
+        AIR_ABOVE(HoeItem::onlyIfAirAbove),
+        ALWAYS((useOnContext) -> true);
+
+        private final Predicate<UseOnContext> predicate;
+
+        Condition(Predicate<UseOnContext> predicate) {
+            this.predicate = predicate;
+        }
+
+        public Predicate<UseOnContext> predicate() {
+            return predicate;
+        }
+
+        private static final Map<String, Condition> BY_NAME = new HashMap<>();
+
+        static {
+            for (Condition condition : values()) {
+                BY_NAME.put(condition.name(), condition);
+            }
+        }
+
+        public static Condition get(String name) {
+            return BY_NAME.get(name.toUpperCase(java.util.Locale.ROOT));
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Waxable.java b/org/purpurmc/purpur/tool/Waxable.java
new file mode 100644
index 0000000000000000000000000000000000000000..64adb13b29b6757dcf227a55588da70ecabe083f
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Waxable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Waxable extends Actionable {
+    public Waxable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Weatherable.java b/org/purpurmc/purpur/tool/Weatherable.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7586f494528f30eb0da82420d3bcf5b83a1a902
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Weatherable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Weatherable extends Actionable {
+    public Weatherable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/util/MinecraftInternalPlugin.java b/org/purpurmc/purpur/util/MinecraftInternalPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..77a18f3048b18d38c5bd0129065efff27fa774fa
--- /dev/null
+++ b/org/purpurmc/purpur/util/MinecraftInternalPlugin.java
@@ -0,0 +1,149 @@
+package org.purpurmc.purpur.util;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.BiomeProvider;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginBase;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.PluginLogger;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+
+public class MinecraftInternalPlugin extends PluginBase {
+    private boolean enabled = true;
+
+    private final String pluginName;
+    private PluginDescriptionFile pdf;
+
+    public MinecraftInternalPlugin() {
+        this.pluginName = "Minecraft";
+        pdf = new PluginDescriptionFile(pluginName, "1.0", "nms");
+    }
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    @Override
+    public File getDataFolder() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginDescriptionFile getDescription() {
+        return pdf;
+    }
+
+    @Override
+    public io.papermc.paper.plugin.configuration.PluginMeta getPluginMeta() {
+        return pdf;
+    }
+
+    @Override
+    public FileConfiguration getConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public InputStream getResource(String filename) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveResource(String resourcePath, boolean replace) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void reloadConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginLogger getLogger() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginLoader getPluginLoader() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public Server getServer() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    @Override
+    public void onDisable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onLoad() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onEnable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isNaggable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @Nullable BiomeProvider getDefaultBiomeProvider(@NotNull String worldName, @Nullable String id) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull LifecycleEventManager<Plugin> getLifecycleManager() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+}
