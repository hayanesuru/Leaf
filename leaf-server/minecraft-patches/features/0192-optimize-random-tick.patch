From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hayanesuru <hayanesuru@outlook.jp>
Date: Fri, 6 Jun 2025 20:46:10 +0900
Subject: [PATCH] optimize random tick


diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index c80e6669013d3cf87b51d0cb0b62fcf5466d702c..9d132c88629976cc00d470980308571ac3222284 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -693,6 +693,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 this.level.tickChunk(levelChunk, _int);
             }
         }
+        this.level.randomTickSystem.tick(this.level); // Leaf - optimize random tick
 
         if (flagAndHasNaturalSpawn) { // Gale - MultiPaper - skip unnecessary mob spawning computations
             this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 7cbcc2dd8533973108841d3989265a392a6f6214..bc0c80ed78bbb594cf7281e8d87f27dd06a1fcbb 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1120,6 +1120,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     private int currentIceAndSnowTick = 0; protected void resetIceAndSnowTick() { this.currentIceAndSnowTick = this.simpleRandom.nextInt(16); } // Gale - Airplane - optimize random calls in chunk ticking
 
+    public org.dreeam.leaf.world.RandomTickSystem randomTickSystem = new org.dreeam.leaf.world.RandomTickSystem(); // Leaf - optimize random tick
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
         final net.minecraft.world.level.levelgen.BitRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Leaf - Faster random generator - upcasting
         ChunkPos pos = chunk.getPos();
@@ -1169,7 +1170,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         } // Paper - Option to disable ice and snow
 
         if (randomTickSpeed > 0) {
-            this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
+            if (org.dreeam.leaf.config.modules.opt.OptimizeRandomTick.enabled) randomTickSystem.tickChunk(this.simpleRandom, chunk, randomTickSpeed); // Leaf - random tick
+            else this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking // Leaf - random tick
         }
     }
 
diff --git a/net/minecraft/world/level/chunk/LevelChunk.java b/net/minecraft/world/level/chunk/LevelChunk.java
index a90bf0d80ae4dac9b19b8e467b402917cc19a271..44b672671e0bea6a5f91e9b8573f9a8225a20f6a 100644
--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -149,6 +149,48 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
     }
     // Gale end - Airplane - optimize random calls in chunk ticking - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
 
+    // Leaf start - optimize random tick
+    private boolean leaf$tickingBlocksDirty = true;
+    private int leaf$tickingBlocksCount;
+    private int leaf$firstTickingSectionIndex = -1;
+    public final int leaf$tickingBlocksCount() {
+        if (!leaf$tickingBlocksDirty) {
+            return leaf$tickingBlocksCount;
+        }
+        leaf$tickingBlocksDirty = false;
+        int sum = 0;
+        leaf$firstTickingSectionIndex = -1;
+        for (int i = 0; i < sections.length; i++) {
+            LevelChunkSection section = sections[i];
+            int size = section.moonrise$getTickingBlockList().size();
+            if (size != 0 && leaf$firstTickingSectionIndex == -1) {
+                leaf$firstTickingSectionIndex = i;
+            }
+            sum += size;
+        }
+        leaf$tickingBlocksCount = sum;
+        return sum;
+    }
+    public final java.util.OptionalLong leaf$getTickingPos(int idx) {
+        if (leaf$firstTickingSectionIndex != -1) {
+            for (int i = leaf$firstTickingSectionIndex; i < sections.length; i++) {
+                LevelChunkSection section = sections[i];
+                var l = section.moonrise$getTickingBlockList();
+                int size = l.size();
+                if (idx < size) {
+                    short loc = l.getRaw(idx);
+                    int x = (loc & 15) | (chunkPos.x << 4);
+                    int y = (loc >>> 8) | ((getMinSectionY() + i) << 4);
+                    int z = ((loc >>> 4) & 15) | (chunkPos.z << 4);
+                    return java.util.OptionalLong.of(BlockPos.asLong(x, y, z));
+                }
+                idx -= size;
+            }
+        }
+        leaf$tickingBlocksDirty = true;
+        return java.util.OptionalLong.empty();
+    }
+    // Leaf end - optimize random tick
     public LevelChunk(Level level, ChunkPos pos) {
         this(level, pos, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, null, null, null);
     }
@@ -417,6 +459,11 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
             if (blockState == state) {
                 return null;
             } else {
+                // Leaf start - optimize random tick
+                if (blockState.isRandomlyTicking() != state.isRandomlyTicking()) {
+                    leaf$tickingBlocksDirty = true;
+                }
+                // Leaf end - optimize random tick
                 Block block = state.getBlock();
                 this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING).update(i, y, i2, state);
                 this.heightmaps.get(Heightmap.Types.MOTION_BLOCKING_NO_LEAVES).update(i, y, i2, state);
