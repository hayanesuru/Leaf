From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hayanesuru <hayanesuru@outlook.jp>
Date: Fri, 6 Jun 2025 20:46:10 +0900
Subject: [PATCH] optimize random tick


diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 2f927b422c2c4f2f65d822befe3cbfd9e3bb3708..d0fcfeaf093b718c8acd6e057176d569651299f2 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -693,6 +693,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 this.level.tickChunk(levelChunk, _int);
             }
         }
+        this.level.randomTickSystem.tick(this.level); // Leaf - random tick
 
         if (flagAndHasNaturalSpawn) { // Gale - MultiPaper - skip unnecessary mob spawning computations
             this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index eb849c57992658005e0f514c6f7923f8ca43bebf..2efcdb9bc91b9106b4aef9e24cc20596be4a5661 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1128,6 +1128,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     private int currentIceAndSnowTick = 0; protected void resetIceAndSnowTick() { this.currentIceAndSnowTick = this.simpleRandom.nextInt(16); } // Gale - Airplane - optimize random calls in chunk ticking
 
+    public org.dreeam.leaf.world.RandomTickSystem randomTickSystem = new org.dreeam.leaf.world.RandomTickSystem(); // Leaf
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
         final net.minecraft.world.level.levelgen.BitRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Leaf - Faster random generator - upcasting
         ChunkPos pos = chunk.getPos();
@@ -1177,7 +1178,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         } // Paper - Option to disable ice and snow
 
         if (randomTickSpeed > 0) {
-            this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
+            if (org.dreeam.leaf.config.modules.opt.OptimizeRandomTick.enabled) randomTickSystem.randomTickChunk(chunk, randomTickSpeed); // Leaf - random tick
+            else this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking // Leaf - random tick
         }
     }
 
diff --git a/net/minecraft/world/level/chunk/LevelChunk.java b/net/minecraft/world/level/chunk/LevelChunk.java
index 624a177695580510c0a49d4503dee72da7fd7114..affe9fff1ff2f7e221f8cfe345d40d707e0f3dbc 100644
--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -151,6 +151,52 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
     }
     // Gale end - Airplane - optimize random calls in chunk ticking - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
 
+    // Leaf start - random tick
+    private long leaf$randomTickChance;
+    private long leaf$countTickingBlocks;
+    private long leaf$countTickingSections;
+
+    public final long leaf$randomTickChance() {
+        return leaf$randomTickChance;
+    }
+    public final void leaf$setRandomTickChance(long chance) {
+        leaf$randomTickChance = chance;
+    }
+    public final long leaf$countTickingBlocks() {
+        return leaf$countTickingBlocks;
+    }
+    public final long leaf$countTickingSections() {
+        return leaf$countTickingSections;
+    }
+    public final void leaf$recompute() {
+        long total1 = 0L;
+        long total2 = 0L;
+        for (LevelChunkSection section : sections) {
+            total1 += section.moonrise$getTickingBlockList().size();
+            if (section.isRandomlyTickingBlocks()) {
+                total2++;
+            }
+        }
+        leaf$countTickingBlocks = total1;
+        leaf$countTickingSections = total2;
+    }
+    public final java.util.OptionalLong leaf$tickingPos(int idx) {
+        for (int i = 0; i < sections.length; i++) {
+            LevelChunkSection section = sections[i];
+            var l = section.moonrise$getTickingBlockList();
+            int size = l.size();
+            if (idx < size) {
+                short loc = l.getRaw(idx);
+                int x = (loc & 15) | (chunkPos.x << 4);
+                int y = (loc >>> 8) | ((getMinSectionY() + i) << 4);
+                int z = ((loc >>> 4) & 15) | (chunkPos.z << 4);
+                return java.util.OptionalLong.of(BlockPos.asLong(x, y, z));
+            }
+            idx -= size;
+        }
+        return java.util.OptionalLong.empty();
+    }
+    // Leaf end - random tick
     public LevelChunk(Level level, ChunkPos pos) {
         this(level, pos, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, null, null, null);
     }
