From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Wed, 19 Mar 2025 15:18:58 +0100
Subject: [PATCH] Remove streams on InsideBrownianWalk

This method is maninly visible when ton of villagers suddenly wants to sleep
Safe optimization, no need to provide any numbers.

diff --git a/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java b/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java
index cbde74f4b6d586a5f80cdd675573441636bf682d..3ac3059ce23d6291aa4e96ed5441159133d3e965 100644
--- a/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java
+++ b/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java
@@ -2,6 +2,7 @@ package net.minecraft.world.entity.ai.behavior;
 
 import java.util.Collections;
 import java.util.List;
+import java.util.ArrayList;
 import net.minecraft.Util;
 import net.minecraft.core.BlockPos;
 import net.minecraft.world.entity.PathfinderMob;
@@ -20,16 +21,29 @@ public class InsideBrownianWalk {
                             return false;
                         } else {
                             BlockPos blockPos = mob.blockPosition();
-                            List<BlockPos> list = BlockPos.betweenClosedStream(blockPos.offset(-1, -1, -1), blockPos.offset(1, 1, 1))
-                                .map(BlockPos::immutable)
-                                .collect(Util.toMutableList());
+                            BlockPos minPos = blockPos.offset(-1, -1, -1);
+                            BlockPos maxPos = blockPos.offset(1, 1, 1);
+                            List<BlockPos> list = new ArrayList<>();
+
+                            for (int x = minPos.getX(); x <= maxPos.getX(); x++) {
+                                for (int y = minPos.getY(); y <= maxPos.getY(); y++) {
+                                    for (int z = minPos.getZ(); z <= maxPos.getZ(); z++) {
+                                        list.add(new BlockPos(x, y, z).immutable());
+                                    }
+                                }
+                            }
+
                             Collections.shuffle(list);
-                            list.stream()
-                                .filter(pos -> !level.canSeeSky(pos))
-                                .filter(pos -> level.loadedAndEntityCanStandOn(pos, mob))
-                                .filter(pos -> level.noCollision(mob))
-                                .findFirst()
-                                .ifPresent(pos -> walkTarget.set(new WalkTarget(pos, speedModifier, 0)));
+
+                            for (BlockPos pos : list) {
+                                if (!level.canSeeSky(pos) &&
+                                    level.loadedAndEntityCanStandOn(pos, mob) &&
+                                    level.noCollision(mob)) {
+                                    walkTarget.set(new WalkTarget(pos, speedModifier, 0));
+                                    break;
+                                }
+                            }
+
                             return true;
                         }
                     }
