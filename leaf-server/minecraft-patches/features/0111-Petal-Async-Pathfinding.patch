From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: peaches94 <peachescu94@gmail.com>
Date: Sun, 26 Jun 2022 16:51:37 -0500
Subject: [PATCH] Petal: Async Pathfinding

Fixed & Updated by KaiijuMC
Original license: GPLv3
Original project:  https://github.com/KaiijuMC/Kaiiju

Original license: GPLv3
Original project: https://github.com/Bloom-host/Petal

Co-authored-by: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Co-authored-by: Taiyou06 <kaandindar21@gmail.com>
Co-authored-by: Altiami <yoshimo.kristin@gmail.com>
Co-authored-by: hayanesuru <hayanesuru@outlook.jp>

This patch was ported downstream from the Petal fork.

Makes most pathfinding-related work happen asynchronously

diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index eef6b4b6ccc02e23c5a2707eaeb3566e32e47362..3bd2ba1c6d4359eb03c4df908bc4c76c3cbc386d 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -245,6 +245,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     @Nullable
     @Override
     public LivingEntity getTarget() {
+        //if (Thread.currentThread().getName().contains("petal-async-pathfinding-thread")) return this.target; // Kaiiju - Don't reset target when async pathfinding! // Leaf - Don't need this
         return this.target;
     }
 
diff --git a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
index b0ca555cc3b565a8be8d01fe10b139ed27a2a2c3..28f7ffc67babea619a8702b37324f45a94c9df7b 100644
--- a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
+++ b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
@@ -94,21 +94,20 @@ public class AcquirePoi {
                                 }
                             }
                             // Paper end - optimise POI access
-                            Path path = findPathToPois(mob, set);
-                            if (path != null && path.canReach()) {
-                                BlockPos target = path.getTarget();
-                                poiManager.getType(target).ifPresent(holder -> {
-                                    poiManager.take(acquirablePois, (holder1, blockPos) -> blockPos.equals(target), target, 1);
-                                    memoryAccessor.set(GlobalPos.of(level.dimension(), target));
-                                    entityEventId.ifPresent(id -> level.broadcastEntityEvent(mob, id));
-                                    map.clear();
-                                    DebugPackets.sendPoiTicketCountPacket(level, target);
+                            // Kaiiju start - petal - Async path processing
+                            if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+                                // await on path async
+                                Path possiblePath = findPathToPois(mob, set);
+
+                                // wait on the path to be processed
+                                org.dreeam.leaf.async.path.AsyncPath.awaitProcessing(possiblePath, path -> {
+                                    processPath(acquirablePois, entityEventId, map, memoryAccessor, level, mob, time, poiManager, set, path);
                                 });
                             } else {
-                                for (Pair<Holder<PoiType>, BlockPos> pair : set) {
-                                    map.computeIfAbsent(pair.getSecond().asLong(), l -> new AcquirePoi.JitteredLinearRetry(level.random, time));
-                                }
+                                Path path = findPathToPois(mob, set);
+                                processPath(acquirablePois, entityEventId, map, memoryAccessor, level, mob, time, poiManager, set, path);
                             }
+                            // Kaiiju end - Async path processing
 
                             return true;
                         }
@@ -120,6 +119,34 @@ public class AcquirePoi {
             : BehaviorBuilder.create(instance -> instance.group(instance.absent(existingAbsentMemory)).apply(instance, memoryAccessor -> oneShot));
     }
 
+    // Leaf start - Kaiiju - Async path processing
+    private static void processPath(Predicate<Holder<PoiType>> acquirablePois,
+                                    Optional<Byte> entityEventId,
+                                    Long2ObjectMap<JitteredLinearRetry> map,
+                                    net.minecraft.world.entity.ai.behavior.declarative.MemoryAccessor<com.mojang.datafixers.kinds.Const.Mu<com.mojang.datafixers.util.Unit>, GlobalPos> memoryAccessor,
+                                    ServerLevel level,
+                                    PathfinderMob mob,
+                                    long time,
+                                    PoiManager poiManager,
+                                    Set<Pair<Holder<PoiType>, BlockPos>> set,
+                                    @org.jetbrains.annotations.Nullable Path path) {
+        if (path != null && path.canReach()) {
+            BlockPos target = path.getTarget();
+            poiManager.getType(target).ifPresent(holder -> {
+                poiManager.take(acquirablePois, (holder1, blockPos) -> blockPos.equals(target), target, 1);
+                memoryAccessor.set(GlobalPos.of(level.dimension(), target));
+                entityEventId.ifPresent(id -> level.broadcastEntityEvent(mob, id));
+                map.clear();
+                DebugPackets.sendPoiTicketCountPacket(level, target);
+            });
+        } else {
+            for (Pair<Holder<PoiType>, BlockPos> pair : set) {
+                map.computeIfAbsent(pair.getSecond().asLong(), l -> new AcquirePoi.JitteredLinearRetry(level.random, time));
+            }
+        }
+    }
+    // Leaf end - Kaiiju - Async path processing
+
     @Nullable
     public static Path findPathToPois(Mob mob, Set<Pair<Holder<PoiType>, BlockPos>> poiPositions) {
         if (poiPositions.isEmpty()) {
diff --git a/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java b/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
index 621ba76784f2b92790eca62be4d0688834335ab6..bf4e7816bae92b26c6a5d17569db90b1db3dd076 100644
--- a/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
+++ b/net/minecraft/world/entity/ai/behavior/MoveToTargetSink.java
@@ -21,6 +21,7 @@ public class MoveToTargetSink extends Behavior<Mob> {
     private int remainingCooldown;
     @Nullable
     private Path path;
+    private boolean finishedProcessing; // Kaiiju - petal - track when path is processed
     @Nullable
     private BlockPos lastTargetPos;
     private float speedModifier;
@@ -53,9 +54,10 @@ public class MoveToTargetSink extends Behavior<Mob> {
             Brain<?> brain = owner.getBrain();
             WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
             boolean flag = this.reachedTarget(owner, walkTarget);
-            if (!flag && this.tryComputePath(owner, walkTarget, level.getGameTime())) {
+            if (!org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled && !flag && this.tryComputePath(owner, walkTarget, level.getGameTime())) { // Kaiiju - petal - async path processing means we can't know if the path is reachable here
                 this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
                 return true;
+            } else if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled && !flag) { return true; // Kaiiju - async pathfinding
             } else {
                 brain.eraseMemory(MemoryModuleType.WALK_TARGET);
                 if (flag) {
@@ -69,6 +71,7 @@ public class MoveToTargetSink extends Behavior<Mob> {
 
     @Override
     protected boolean canStillUse(ServerLevel level, Mob entity, long gameTime) {
+        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled && !this.finishedProcessing) return true; // Kaiiju - petal - wait for processing
         if (this.path != null && this.lastTargetPos != null) {
             Optional<WalkTarget> memory = entity.getBrain().getMemory(MemoryModuleType.WALK_TARGET);
             boolean flag = memory.map(MoveToTargetSink::isWalkTargetSpectator).orElse(false);
@@ -95,12 +98,68 @@ public class MoveToTargetSink extends Behavior<Mob> {
 
     @Override
     protected void start(ServerLevel level, Mob entity, long gameTime) {
+        // Kaiiju start - petal - start processing
+        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+            Brain<?> brain = entity.getBrain();
+            WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get();
+
+            this.finishedProcessing = false;
+            this.lastTargetPos = walkTarget.getTarget().currentBlockPosition();
+            this.path = this.computePath(entity, walkTarget);
+            return;
+        }
+        // Kaiiju end
         entity.getBrain().setMemory(MemoryModuleType.PATH, this.path);
         entity.getNavigation().moveTo(this.path, (double)this.speedModifier);
     }
 
     @Override
     protected void tick(ServerLevel level, Mob owner, long gameTime) {
+        // Kaiiju start - petal - Async path processing
+        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+            if (this.path != null && !this.path.complete()) return; // wait for processing
+
+            if (!this.finishedProcessing) {
+                this.finishedProcessing = true;
+
+                Brain<?> brain = owner.getBrain();
+                boolean canReach = this.path != null && this.path.canReach();
+                if (canReach) {
+                    brain.eraseMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
+                } else if (!brain.hasMemoryValue(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE)) {
+                    brain.setMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE, gameTime);
+                }
+
+                if (!canReach) {
+                    Optional<WalkTarget> walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET);
+
+                    if (!walkTarget.isPresent()) return;
+
+                    BlockPos blockPos = walkTarget.get().getTarget().currentBlockPosition();
+                    Vec3 vec3 = DefaultRandomPos.getPosTowards((PathfinderMob) owner, 10, 7, Vec3.atBottomCenterOf(blockPos), (float) Math.PI / 2F);
+                    if (vec3 != null) {
+                        // try recalculating the path using a random position
+                        this.path = owner.getNavigation().createPath(vec3.x, vec3.y, vec3.z, 0);
+                        this.finishedProcessing = false;
+                        return;
+                    }
+                }
+
+                owner.getBrain().setMemory(MemoryModuleType.PATH, this.path);
+                owner.getNavigation().moveTo(this.path, this.speedModifier);
+            }
+
+            Path path = owner.getNavigation().getPath();
+            Brain<?> brain = owner.getBrain();
+
+            if (path != null && this.lastTargetPos != null && brain.hasMemoryValue(MemoryModuleType.WALK_TARGET)) {
+                WalkTarget walkTarget = brain.getMemory(MemoryModuleType.WALK_TARGET).get(); // we know isPresent = true
+                if (walkTarget.getTarget().currentBlockPosition().distSqr(this.lastTargetPos) > 4.0D) {
+                    this.start(level, owner, gameTime);
+                }
+            }
+        } else {
+            // Kaiiju end
         Path path = owner.getNavigation().getPath();
         Brain<?> brain = owner.getBrain();
         if (this.path != path) {
@@ -115,7 +174,23 @@ public class MoveToTargetSink extends Behavior<Mob> {
                 this.start(level, owner, gameTime);
             }
         }
+        } // Kaiiju - async path processing
+    }
+
+    // Kaiiju start - petal - Async path processing
+    @Nullable
+    private Path computePath(Mob entity, WalkTarget walkTarget) {
+        BlockPos blockPos = walkTarget.getTarget().currentBlockPosition();
+        // don't pathfind outside region
+        //if (!io.papermc.paper.util.TickThread.isTickThreadFor((ServerLevel) entity.level(), blockPos)) return null; // Leaf - Don't need this
+        this.speedModifier = walkTarget.getSpeedModifier();
+        Brain<?> brain = entity.getBrain();
+        if (this.reachedTarget(entity, walkTarget)) {
+            brain.eraseMemory(MemoryModuleType.CANT_REACH_WALK_TARGET_SINCE);
+        }
+        return entity.getNavigation().createPath(blockPos, 0);
     }
+    // Kaiiju end
 
     private boolean tryComputePath(Mob mob, WalkTarget target, long time) {
         BlockPos blockPos = target.getTarget().currentBlockPosition();
diff --git a/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java b/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
index 4f9f3367b1ca3903df03a80fa2b01a3d24e6e77d..034d69d3cde535ed84f218f6deb07ebfb7389f43 100644
--- a/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
+++ b/net/minecraft/world/entity/ai/behavior/SetClosestHomeAsWalkTarget.java
@@ -60,17 +60,20 @@ public class SetClosestHomeAsWalkTarget {
                                         poi -> poi.is(PoiTypes.HOME), predicate, mob.blockPosition(), 48, PoiManager.Occupancy.ANY
                                     )
                                     .collect(Collectors.toSet());
+                                // Kaiiju start - petal - Async path processing
+                                if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+                                    // await on path async
+                                    Path possiblePath = AcquirePoi.findPathToPois(mob, set);
+
+                                    // wait on the path to be processed
+                                    org.dreeam.leaf.async.path.AsyncPath.awaitProcessing(possiblePath, path -> {
+                                        processPath(speedModifier, map, mutableLong, walkTarget, level, poiManager, mutableInt, path);
+                                    });
+                                } else {
+                                    // Kaiiju end
                                 Path path = AcquirePoi.findPathToPois(mob, set);
-                                if (path != null && path.canReach()) {
-                                    BlockPos target = path.getTarget();
-                                    Optional<Holder<PoiType>> type = poiManager.getType(target);
-                                    if (type.isPresent()) {
-                                        walkTarget.set(new WalkTarget(target, speedModifier, 1));
-                                        DebugPackets.sendPoiTicketCountPacket(level, target);
-                                    }
-                                } else if (mutableInt.getValue() < 5) {
-                                    map.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < mutableLong.getValue());
-                                }
+                                    processPath(speedModifier, map, mutableLong, walkTarget, level, poiManager, mutableInt, path);
+                                } // Kaiiju - async path processing
 
                                 return true;
                             } else {
@@ -81,4 +84,26 @@ public class SetClosestHomeAsWalkTarget {
                 )
         );
     }
+
+    // Leaf start - Kaiiju - petal - Async path processing
+    private static void processPath(float speedModifier,
+                                    Long2LongMap map,
+                                    MutableLong mutableLong,
+                                    net.minecraft.world.entity.ai.behavior.declarative.MemoryAccessor<com.mojang.datafixers.kinds.Const.Mu<com.mojang.datafixers.util.Unit>, WalkTarget> walkTarget,
+                                    net.minecraft.server.level.ServerLevel level,
+                                    PoiManager poiManager,
+                                    MutableInt mutableInt,
+                                    @org.jetbrains.annotations.Nullable Path path) {
+        if (path != null && path.canReach()) {
+            BlockPos target = path.getTarget();
+            Optional<Holder<PoiType>> type = poiManager.getType(target);
+            if (type.isPresent()) {
+                walkTarget.set(new WalkTarget(target, speedModifier, 1));
+                DebugPackets.sendPoiTicketCountPacket(level, target);
+            }
+        } else if (mutableInt.getValue() < 5) {
+            map.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < mutableLong.getValue());
+        }
+    }
+    // Leaf end - Kaiiju - petal - Async path processing
 }
diff --git a/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java b/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
index 73bba480f3f017a8aed14562bd82ba33db04391c..298eb9b0ff88927b5f714230e51460574d45d73e 100644
--- a/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
+++ b/net/minecraft/world/entity/ai/goal/DoorInteractGoal.java
@@ -54,7 +54,7 @@ public abstract class DoorInteractGoal extends Goal {
             return false;
         } else {
             Path path = this.mob.getNavigation().getPath();
-            if (path != null && !path.isDone()) {
+            if (path != null && path.complete() && !path.isDone()) { // Kaiiju - async pathfinding - ensure path is processed
                 for (int i = 0; i < Math.min(path.getNextNodeIndex() + 2, path.getNodeCount()); i++) {
                     Node node = path.getNode(i);
                     this.doorPos = new BlockPos(node.x, node.y + 1, node.z);
diff --git a/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java b/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
index 458ceec68ca138b0aa9b70d6c934473c01d468f4..dc42e63d1c166aed02081e687ada76a0e74da7a7 100644
--- a/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/AmphibiousPathNavigation.java
@@ -12,9 +12,25 @@ public class AmphibiousPathNavigation extends PathNavigation {
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        AmphibiousNodeEvaluator nodeEvaluator = new AmphibiousNodeEvaluator(false);
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.nodeEvaluator = new AmphibiousNodeEvaluator(false);
+        // Kaiiju start - petal - async path processing
+        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
diff --git a/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java b/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
index 077863b758fbc3e51f25bcf842d00a2cc07c6a2f..a848be7c3bb89f0492fcecc16807f84f7508e364 100644
--- a/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/FlyingPathNavigation.java
@@ -16,9 +16,25 @@ public class FlyingPathNavigation extends PathNavigation {
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        FlyNodeEvaluator nodeEvaluator = new FlyNodeEvaluator();
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.nodeEvaluator = new FlyNodeEvaluator();
+        // Kaiiju start - petal - async path processing
+        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
@@ -48,6 +64,7 @@ public class FlyingPathNavigation extends PathNavigation {
         if (this.hasDelayedRecomputation) {
             this.recomputePath();
         }
+        if (this.path != null && !this.path.complete()) return; // Kaiiju - petal - async path processing
 
         if (!this.isDone()) {
             if (this.canUpdatePath()) {
diff --git a/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java b/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
index 86fccf3617a32f3791b03d8067e2eaf6b8d8bebb..9cef6797e6d8eb43a51a1b94fea3947dd3d534da 100644
--- a/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/GroundPathNavigation.java
@@ -24,9 +24,25 @@ public class GroundPathNavigation extends PathNavigation {
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    protected static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        WalkNodeEvaluator nodeEvaluator = new WalkNodeEvaluator();
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.nodeEvaluator = new WalkNodeEvaluator();
+        // Kaiiju start - petal - async path processing
+        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
diff --git a/net/minecraft/world/entity/ai/navigation/PathNavigation.java b/net/minecraft/world/entity/ai/navigation/PathNavigation.java
index 24dd92449f70144c79f25bf24942ebd666655ed2..aaa818713517462355baded1a30001b938661229 100644
--- a/net/minecraft/world/entity/ai/navigation/PathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/PathNavigation.java
@@ -33,7 +33,7 @@ public abstract class PathNavigation {
     protected final Mob mob;
     protected final Level level;
     @Nullable
-    protected Path path;
+    public Path path; // Leaf - protected -> public
     protected double speedModifier;
     protected int tick;
     protected int lastStuckCheck;
@@ -47,8 +47,8 @@ public abstract class PathNavigation {
     protected long timeLastRecompute;
     protected NodeEvaluator nodeEvaluator;
     @Nullable
-    private BlockPos targetPos;
-    private int reachRange;
+    public BlockPos targetPos; // Leaf - private -> public
+    public int reachRange; // Leaf - private -> public
     private float maxVisitedNodesMultiplier = 1.0F;
     public final PathFinder pathFinder;
     private boolean isStuck;
@@ -98,6 +98,12 @@ public abstract class PathNavigation {
             if (this.targetPos != null) {
                 this.path = null;
                 this.path = this.createPath(this.targetPos, this.reachRange);
+                // Leaf start
+                org.dreeam.leaf.async.path.AsyncPath task = this.path == null ? null : this.path.task;
+                if (task != null) {
+                    org.dreeam.leaf.async.path.AsyncPath.moveTo(this, this.path, task);
+                }
+                // Leaf end
                 this.timeLastRecompute = this.level.getGameTime();
                 this.hasDelayedRecomputation = false;
             }
@@ -189,8 +195,12 @@ public abstract class PathNavigation {
             // Paper end - EntityPathfindEvent
             BlockPos blockPos = offsetUpward ? this.mob.blockPosition().above() : this.mob.blockPosition();
             int i = (int)(followRange + regionOffset);
-            PathNavigationRegion pathNavigationRegion = new PathNavigationRegion(this.level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i));
-            Path path = this.pathFinder.findPath(pathNavigationRegion, this.mob, targets, followRange, accuracy, this.maxVisitedNodesMultiplier);
+            // Leaf start
+            Path path = this.pathFinder.findPath(this.level, blockPos, i, this.mob, targets, followRange, accuracy, this.maxVisitedNodesMultiplier);
+            if (path != null && path.task != null) {
+                return path;
+            }
+            // Leaf end
             if (path != null && path.getTarget() != null) {
                 this.targetPos = path.getTarget();
                 this.reachRange = accuracy;
@@ -236,18 +246,34 @@ public abstract class PathNavigation {
 
     public boolean moveTo(@Nullable Path pathentity, double speed) {
         if (pathentity == null) {
+            // Leaf start
+            org.dreeam.leaf.async.path.AsyncPath task = this.path == null ? null : this.path.task;
+            if (task != null) {
+                task.stop();
+            }
+            // Leaf end
             this.path = null;
             return false;
         } else {
             if (!pathentity.sameAs(this.path)) {
-                this.path = pathentity;
+                // Leaf start
+                org.dreeam.leaf.async.path.AsyncPath task = pathentity.task;
+                if (task != null) {
+                    if (this.path == null) {
+                        this.path = pathentity;
+                    }
+                    org.dreeam.leaf.async.path.AsyncPath.moveTo(this, this.path, task);
+                } else {
+                    this.path = pathentity;
+                }
+                // Leaf end
             }
 
             if (this.isDone()) {
                 return false;
             } else {
-                this.trimPath();
-                if (this.path.getNodeCount() <= 0) {
+                if (this.path.complete()) { this.trimPath(); } // Kaiiju - petal - only trim if processed
+                if (path.complete() && this.path.getNodeCount() <= 0) { // Kaiiju - petal - only check node count if processed
                     return false;
                 } else {
                     this.speedModifier = speed;
@@ -266,12 +292,13 @@ public abstract class PathNavigation {
     }
 
     public void tick() {
+        if (this.path != null && !this.path.complete()) { return; } // Kaiiju - petal - skip pathfinding if we're still processing
         this.tick++;
         if (this.hasDelayedRecomputation) {
             this.recomputePath();
         }
 
-        if (!this.isDone()) {
+        if (!this.isDone2()) { // Leaf
             if (this.canUpdatePath()) {
                 this.followThePath();
             } else if (this.path != null && !this.path.isDone()) {
@@ -286,7 +313,7 @@ public abstract class PathNavigation {
             }
 
             DebugPackets.sendPathFindingPacket(this.level, this.mob, this.path, this.maxDistanceToWaypoint);
-            if (!this.isDone()) {
+            if (!this.isDone2()) { // Leaf
                 Vec3 tempMobPos = this.path.getNextEntityPos(this.mob);
                 this.mob.getMoveControl().setWantedPosition(tempMobPos.x, this.getGroundY(tempMobPos), tempMobPos.z, this.speedModifier);
             }
@@ -299,6 +326,7 @@ public abstract class PathNavigation {
     }
 
     protected void followThePath() {
+        if (!this.path.complete() && this.path.nodes.isEmpty()) { return; } // Kaiiju - petal - skip if not processed
         Vec3 tempMobPos = this.getTempMobPos();
         this.maxDistanceToWaypoint = this.mob.getBbWidth() > 0.75F ? this.mob.getBbWidth() / 2.0F : 0.75F - this.mob.getBbWidth() / 2.0F;
         Vec3i nextNodePos = this.path.getNextNodePos();
@@ -380,13 +408,19 @@ public abstract class PathNavigation {
         this.stop();
     }
 
-    private void resetStuckTimeout() {
+    public void resetStuckTimeout() { // Leaf - private -> public
         this.timeoutCachedNode = Vec3i.ZERO;
         this.timeoutTimer = 0L;
         this.timeoutLimit = 0.0;
         this.isStuck = false;
     }
 
+    // Leaf start
+    public boolean isDone2() {
+        return this.path == null || this.path.isDone2();
+    }
+    // Leaf end
+
     public boolean isDone() {
         return this.path == null || this.path.isDone();
     }
@@ -396,6 +430,12 @@ public abstract class PathNavigation {
     }
 
     public void stop() {
+        // Leaf start
+        org.dreeam.leaf.async.path.AsyncPath task = this.path == null ? null : this.path.task;
+        if (task != null) {
+            task.stop();
+        }
+        // Leaf end
         this.path = null;
     }
 
@@ -455,7 +495,7 @@ public abstract class PathNavigation {
     public boolean shouldRecomputePath(BlockPos pos) {
         if (this.hasDelayedRecomputation) {
             return false;
-        } else if (this.path != null && !this.path.isDone() && this.path.getNodeCount() != 0) {
+        } else if (this.path != null && this.path.complete() && !this.path.isDone() && this.path.getNodeCount() != 0) { // Kaiiju - petal - Skip if not processed
             Node endNode = this.path.getEndNode();
             Vec3 vec3 = new Vec3((endNode.x + this.mob.getX()) / 2.0, (endNode.y + this.mob.getY()) / 2.0, (endNode.z + this.mob.getZ()) / 2.0);
             return pos.closerToCenterThan(vec3, this.path.getNodeCount() - this.path.getNextNodeIndex());
diff --git a/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java b/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
index ea0f6a19e4a79538e68917ba86cbc98be4dbca8d..e2ed5b1d9eca79dc5a63d70d718fdf8298969e97 100644
--- a/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
+++ b/net/minecraft/world/entity/ai/navigation/WaterBoundPathNavigation.java
@@ -15,11 +15,27 @@ public class WaterBoundPathNavigation extends PathNavigation {
         super(mob, level);
     }
 
+    // Kaiiju start - petal - async path processing
+    private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+        SwimNodeEvaluator nodeEvaluator = new SwimNodeEvaluator(nodeEvaluatorFeatures.allowBreaching());
+        nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+        nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+        nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+        nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+        return nodeEvaluator;
+    };
+    // Kaiiju end
+
     @Override
     protected PathFinder createPathFinder(int maxVisitedNodes) {
         this.allowBreaching = this.mob.getType() == EntityType.DOLPHIN;
         this.nodeEvaluator = new SwimNodeEvaluator(this.allowBreaching);
         this.nodeEvaluator.setCanPassDoors(false);
+        // Kaiiju start - async path processing
+        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+            return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+        }
+        // Kaiiju end
         return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
     }
 
diff --git a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
index 1f96fd5085bacb4c584576c7cb9f51e7898e9b03..4a399b4e4cbc34c32560a93825c0854508687921 100644
--- a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
+++ b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
@@ -57,17 +57,32 @@ public class NearestBedSensor extends Sensor<Mob> {
             java.util.List<Pair<Holder<PoiType>, BlockPos>> poiposes = new java.util.ArrayList<>();
             // don't ask me why it's unbounded. ask mojang.
             io.papermc.paper.util.PoiAccess.findAnyPoiPositions(poiManager, type -> type.is(PoiTypes.HOME), predicate, entity.blockPosition(), level.purpurConfig.villagerNearestBedSensorSearchRadius, PoiManager.Occupancy.ANY, false, Integer.MAX_VALUE, poiposes); // Purpur - Configurable villager search radius
-            Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
             // Paper end - optimise POI access
-            if (path != null && path.canReach()) {
-                BlockPos target = path.getTarget();
-                Optional<Holder<PoiType>> type = poiManager.getType(target);
-                if (type.isPresent()) {
-                    entity.getBrain().setMemory(MemoryModuleType.NEAREST_BED, target);
-                }
-            } else if (this.triedCount < 5) {
-                this.batchCache.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < this.lastUpdate);
+            // Kaiiju start - await on async path processing
+            if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+                Path possiblePath = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
+                org.dreeam.leaf.async.path.AsyncPath.awaitProcessing(possiblePath, path -> {
+                    processPath(entity, poiManager, path);
+                });
+            } else {
+                // Kaiiju end
+                Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
+                processPath(entity, poiManager, path);
+            } // Kaiiju - async path processing
+        }
+    }
+
+    // Leaf start - Kaiiju - await on async path processing
+    private void processPath(Mob entity, PoiManager poiManager, @org.jetbrains.annotations.Nullable Path path) {
+        if (path != null && path.canReach()) {
+            BlockPos target = path.getTarget();
+            Optional<Holder<PoiType>> type = poiManager.getType(target);
+            if (type.isPresent()) {
+                entity.getBrain().setMemory(MemoryModuleType.NEAREST_BED, target);
             }
+        } else if (this.triedCount < 5) {
+            this.batchCache.long2LongEntrySet().removeIf(entry -> entry.getLongValue() < this.lastUpdate);
         }
     }
+    // Leaf end - Kaiiju - await on async path processing
 }
diff --git a/net/minecraft/world/entity/animal/Bee.java b/net/minecraft/world/entity/animal/Bee.java
index 7573f1be88ca23096e02efe2fa933429fa4421ba..4561e54a88abb2b314c88e996bfaedb36395d4dc 100644
--- a/net/minecraft/world/entity/animal/Bee.java
+++ b/net/minecraft/world/entity/animal/Bee.java
@@ -938,6 +938,14 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                             Bee.this.pathfindRandomlyTowards(Bee.this.hivePos);
                         }
                     } else {
+                        // Leaf start - async path processing fix
+                        // Wait for path processing before making navigation decisions
+                        Path currentPath = Bee.this.navigation.getPath();
+                        if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled && currentPath != null && !currentPath.complete()) {
+                            return;
+                        }
+                        // Leaf end - async path processing fix
+
                         boolean flag = this.pathfindDirectlyTowards(Bee.this.hivePos);
                         if (!flag) {
                             this.dropAndBlacklistHive();
@@ -991,7 +999,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                 return true;
             } else {
                 Path path = Bee.this.navigation.getPath();
-                return path != null && path.getTarget().equals(pos) && path.canReach() && path.isDone();
+                return path != null && path.complete() && path.getTarget().equals(pos) && path.canReach() && path.isDone(); // Kaiiju - petal - ensure path is processed
             }
         }
     }
diff --git a/net/minecraft/world/entity/animal/Rabbit.java b/net/minecraft/world/entity/animal/Rabbit.java
index 1af1b33702296f9aa74c33436ea2904c5e5ae43d..1ed1ab7d0d50276555db70e57966a654a22e59a2 100644
--- a/net/minecraft/world/entity/animal/Rabbit.java
+++ b/net/minecraft/world/entity/animal/Rabbit.java
@@ -612,6 +612,14 @@ public class Rabbit extends Animal {
 
         @Override
         public void vanillaTick() { // Purpur - Ridables
+            // Leaf start - async pathfinding - don't make movement decisions with unprocessed paths
+            if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+                Path path = this.rabbit.getNavigation().getPath();
+                if (path != null && !path.complete()) {
+                    return; // Wait for path processing before making movement decisions
+                }
+            }
+            // Leaf end - async pathfinding
             if (this.rabbit.onGround() && !this.rabbit.jumping && !((Rabbit.RabbitJumpControl)this.rabbit.jumpControl).wantJump()) {
                 this.rabbit.setSpeedModifier(0.0);
             } else if (this.hasWanted() || this.operation == MoveControl.Operation.JUMPING) {
diff --git a/net/minecraft/world/entity/animal/frog/Frog.java b/net/minecraft/world/entity/animal/frog/Frog.java
index bf8d1789e45722a1fa00fe48b08a9b0c11895423..e016a3d9fce58d6bb85e491e88088e112ac4f843 100644
--- a/net/minecraft/world/entity/animal/frog/Frog.java
+++ b/net/minecraft/world/entity/animal/frog/Frog.java
@@ -489,9 +489,25 @@ public class Frog extends Animal {
             return pathType != PathType.WATER_BORDER && super.canCutCorner(pathType);
         }
 
+        // Kaiiju start - petal - async path processing
+        private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+            Frog.FrogNodeEvaluator nodeEvaluator = new Frog.FrogNodeEvaluator(true);
+            nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+            nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+            nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+            nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+            return nodeEvaluator;
+        };
+        // Kaiiju end
+
         @Override
         protected PathFinder createPathFinder(int maxVisitedNodes) {
             this.nodeEvaluator = new Frog.FrogNodeEvaluator(true);
+            // Kaiiju start - petal - async path processing
+            if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+                return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+            }
+            // Kaiiju end
             return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
         }
     }
diff --git a/net/minecraft/world/entity/monster/Drowned.java b/net/minecraft/world/entity/monster/Drowned.java
index 2e6d0f035a01277aa28bbe912d5df8dc4cf04547..fc39b782b3e9e4531e4130b3f008fc3237af045a 100644
--- a/net/minecraft/world/entity/monster/Drowned.java
+++ b/net/minecraft/world/entity/monster/Drowned.java
@@ -308,7 +308,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
 
     protected boolean closeToNextPos() {
         Path path = this.getNavigation().getPath();
-        if (path != null) {
+        if (path != null && path.complete()) { // Kaiiju - petal - ensure path is processed
             BlockPos target = path.getTarget();
             if (target != null) {
                 double d = this.distanceToSqr(target.getX(), target.getY(), target.getZ());
diff --git a/net/minecraft/world/entity/monster/Strider.java b/net/minecraft/world/entity/monster/Strider.java
index fe31c4a45afd61be8b74efe9d0858ccd0aced075..e1717b5c854aa81fdd7b7e715d7c3498d9f86072 100644
--- a/net/minecraft/world/entity/monster/Strider.java
+++ b/net/minecraft/world/entity/monster/Strider.java
@@ -560,9 +560,25 @@ public class Strider extends Animal implements ItemSteerable {
             super(strider, level);
         }
 
+        // Kaiiju start - petal - async path processing
+        private static final org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator = (org.dreeam.leaf.async.path.NodeEvaluatorFeatures nodeEvaluatorFeatures) -> {
+            WalkNodeEvaluator nodeEvaluator = new WalkNodeEvaluator();
+            nodeEvaluator.setCanPassDoors(nodeEvaluatorFeatures.canPassDoors());
+            nodeEvaluator.setCanFloat(nodeEvaluatorFeatures.canFloat());
+            nodeEvaluator.setCanWalkOverFences(nodeEvaluatorFeatures.canWalkOverFences());
+            nodeEvaluator.setCanOpenDoors(nodeEvaluatorFeatures.canOpenDoors());
+            return nodeEvaluator;
+        };
+        // Kaiiju end
+
         @Override
         protected PathFinder createPathFinder(int maxVisitedNodes) {
             this.nodeEvaluator = new WalkNodeEvaluator();
+            // Kaiiju start - async path processing
+            if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+                return new PathFinder(this.nodeEvaluator, maxVisitedNodes, nodeEvaluatorGenerator);
+            }
+            // Kaiiju end
             return new PathFinder(this.nodeEvaluator, maxVisitedNodes);
         }
 
diff --git a/net/minecraft/world/entity/monster/warden/Warden.java b/net/minecraft/world/entity/monster/warden/Warden.java
index 322e6c68429f94151ff275496cd1726dc260aa0a..f626fa0c30873916f973f66e8d67c7e001c2630c 100644
--- a/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/net/minecraft/world/entity/monster/warden/Warden.java
@@ -576,6 +576,16 @@ public class Warden extends Monster implements VibrationSystem {
             @Override
             protected PathFinder createPathFinder(int maxVisitedNodes) {
                 this.nodeEvaluator = new WalkNodeEvaluator();
+                // Kaiiju start - petal - async path processing
+                if (org.dreeam.leaf.config.modules.async.AsyncPathfinding.enabled) {
+                    return new PathFinder(this.nodeEvaluator, maxVisitedNodes, GroundPathNavigation.nodeEvaluatorGenerator) {
+                        @Override
+                        protected float distance(Node first, Node second) {
+                            return first.distanceToXZ(second);
+                        }
+                    };
+                }
+                // Kaiiju end
                 return new PathFinder(this.nodeEvaluator, maxVisitedNodes) {
                     @Override
                     protected float distance(Node first, Node second) {
diff --git a/net/minecraft/world/level/block/ShulkerBoxBlock.java b/net/minecraft/world/level/block/ShulkerBoxBlock.java
index 49bac7af90b0a7c490141be6357563447783c6ca..8aedb5497ea52ae59e477162cb8089694a17f091 100644
--- a/net/minecraft/world/level/block/ShulkerBoxBlock.java
+++ b/net/minecraft/world/level/block/ShulkerBoxBlock.java
@@ -166,9 +166,16 @@ public class ShulkerBoxBlock extends BaseEntityBlock {
 
     @Override
     protected VoxelShape getShape(BlockState state, BlockGetter level, BlockPos pos, CollisionContext context) {
+        //if (Thread.currentThread().getName().contains("petal-async-pathfinding-thread")) return Shapes.block(); // Kaiiju - async pathfinding - we cannot get block entities // Leaf - Don't need this
         return level.getBlockEntity(pos) instanceof ShulkerBoxBlockEntity shulkerBoxBlockEntity
             ? Shapes.create(shulkerBoxBlockEntity.getBoundingBox(state))
             : Shapes.block();
+        // Kaiiju start - async pathfinding - workaround // Leaf - Don't need this
+        /*
+        } catch (NullPointerException e) {
+            return Shapes.block();
+        }
+        */
     }
 
     @Override
diff --git a/net/minecraft/world/level/pathfinder/NodeEvaluator.java b/net/minecraft/world/level/pathfinder/NodeEvaluator.java
index 0f307a399a1be63480b03cd35dc011a2faf8f7c7..81a07db3094580f67eceaaf982703ff4b99551e4 100644
--- a/net/minecraft/world/level/pathfinder/NodeEvaluator.java
+++ b/net/minecraft/world/level/pathfinder/NodeEvaluator.java
@@ -14,7 +14,7 @@ import net.minecraft.world.level.block.state.BlockState;
 public abstract class NodeEvaluator {
     protected PathfindingContext currentContext;
     protected Mob mob;
-    protected final Int2ObjectMap<Node> nodes = new Int2ObjectOpenHashMap<>();
+    public final Int2ObjectMap<Node> nodes = new Int2ObjectOpenHashMap<>(); // Leaf
     protected int entityWidth;
     protected int entityHeight;
     protected int entityDepth;
@@ -32,6 +32,14 @@ public abstract class NodeEvaluator {
         this.entityDepth = Mth.floor(mob.getBbWidth() + 1.0F);
     }
 
+    // Leaf start
+    public void disableCache() {
+        if (this.currentContext != null) {
+            this.currentContext.cache = null;
+        }
+    }
+    // Leaf end
+
     public void done() {
         this.currentContext = null;
         this.mob = null;
diff --git a/net/minecraft/world/level/pathfinder/Path.java b/net/minecraft/world/level/pathfinder/Path.java
index d6d3c8f5e5dd4a8cab0d3fcc131c3a59f06130c6..3ab33c719043ffd83ca29315b350ee34d0b4b886 100644
--- a/net/minecraft/world/level/pathfinder/Path.java
+++ b/net/minecraft/world/level/pathfinder/Path.java
@@ -18,13 +18,39 @@ public class Path {
     private final BlockPos target;
     private final float distToTarget;
     private final boolean reached;
-
-    public Path(List<Node> nodes, BlockPos target, boolean reached) {
+    // Leaf start
+    @Nullable
+    public org.dreeam.leaf.async.path.AsyncPath task;
+    public Path() {
+        this.nodes = List.of();
+        this.target = BlockPos.ZERO;
+        this.distToTarget = Float.MAX_VALUE;
+        this.reached = true;
+        this.task = null;
+    }
+    public Path(List<Node> nodes, BlockPos target, boolean reached, @Nullable org.dreeam.leaf.async.path.AsyncPath task) {
         this.nodes = nodes;
         this.target = target;
         this.distToTarget = nodes.isEmpty() ? Float.MAX_VALUE : this.nodes.get(this.nodes.size() - 1).distanceManhattan(this.target);
         this.reached = reached;
+        this.task = task;
+    }
+    // Leaf end
+
+    public Path(List<Node> nodes, BlockPos target, boolean reached) {
+        this(nodes, target, reached, null); // Leaf
+    }
+
+    // Kaiiju start - petal - async path processing
+    /**
+     * checks if the path is completely processed in the case of it being computed async
+     *
+     * @return true if the path is processed
+     */
+    public boolean complete() {
+        return task == null || task.complete();
     }
+    // Kaiiju end
 
     public void advance() {
         this.nextNodeIndex++;
@@ -35,8 +61,14 @@ public class Path {
     }
 
     public boolean isDone() {
+        return task == null ? this.nextNodeIndex >= this.nodes.size() : task.complete(); // Leaf
+    }
+
+    // Leaf start
+    public boolean isDone2() {
         return this.nextNodeIndex >= this.nodes.size();
     }
+    // Leaf end
 
     @Nullable
     public Node getEndNode() {
@@ -99,11 +131,13 @@ public class Path {
     }
 
     public boolean sameAs(@Nullable Path pathentity) {
+        if (pathentity == this) return true; // Kaiiju - petal - short circuit
         if (pathentity == null) {
             return false;
         } else if (pathentity.nodes.size() != this.nodes.size()) {
             return false;
         } else {
+            if (pathentity.task != null) { return false; } // Leaf
             for (int i = 0; i < this.nodes.size(); i++) {
                 Node node = this.nodes.get(i);
                 Node node1 = pathentity.nodes.get(i);
diff --git a/net/minecraft/world/level/pathfinder/PathFinder.java b/net/minecraft/world/level/pathfinder/PathFinder.java
index c2baadcdceb1df6a881d6f73aa4eb4dd264bcdfe..9fa756a50ae952f4a2df366ba51ffccb868f9ce6 100644
--- a/net/minecraft/world/level/pathfinder/PathFinder.java
+++ b/net/minecraft/world/level/pathfinder/PathFinder.java
@@ -22,17 +22,54 @@ public class PathFinder {
     public final NodeEvaluator nodeEvaluator;
     private static final boolean DEBUG = false;
     private final BinaryHeap openSet = new BinaryHeap();
+    private final @Nullable org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator; // Kaiiju - petal - we use this later to generate an evaluator
 
-    public PathFinder(NodeEvaluator nodeEvaluator, int maxVisitedNodes) {
+    public PathFinder(NodeEvaluator nodeEvaluator, int maxVisitedNodes, @Nullable org.dreeam.leaf.async.path.NodeEvaluatorGenerator nodeEvaluatorGenerator) { // Kaiiju - petal - add nodeEvaluatorGenerator
         this.nodeEvaluator = nodeEvaluator;
         this.maxVisitedNodes = maxVisitedNodes;
+        // Kaiiju start - petal - support nodeEvaluatorgenerators
+        this.nodeEvaluatorGenerator = nodeEvaluatorGenerator;
+    }
+
+    public PathFinder(NodeEvaluator nodeEvaluator, int maxVisitedNodes) {
+        this(nodeEvaluator, maxVisitedNodes, null);
+        // Kaiiju end
     }
 
     public void setMaxVisitedNodes(int maxVisitedNodes) {
         this.maxVisitedNodes = maxVisitedNodes;
     }
 
+    // Leaf start
     @Nullable
+    public Path findPath(net.minecraft.world.level.Level level, BlockPos blockPos, int i, Mob mob, Set<BlockPos> targetPositions, float maxRange, int accuracy, float searchDepthMultiplier) {
+        if (this.nodeEvaluatorGenerator == null) {
+            return this.findPath(new PathNavigationRegion(level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i)), mob, targetPositions, maxRange, accuracy, searchDepthMultiplier);
+        }
+        int maxVisitedNodes = this.maxVisitedNodes;
+        return new Path(List.of(), blockPos, false, new org.dreeam.leaf.async.path.AsyncPath(accuracy, () -> {
+            NodeEvaluator nodeEval = org.dreeam.leaf.async.path.NodeEvaluatorCache.takeNodeEvaluator(this.nodeEvaluatorGenerator, this.nodeEvaluator);
+            try {
+                nodeEval.prepare(new PathNavigationRegion(level, blockPos.offset(-i, -i, -i), blockPos.offset(i, i, i)), mob);
+                nodeEval.disableCache();
+                Node start = nodeEval.getStart();
+                if (start == null) {
+                    return null;
+                }
+                List<Map.Entry<Target, BlockPos>> map = Lists.newArrayList();
+                for (BlockPos pos : targetPositions) {
+                    map.add(new java.util.AbstractMap.SimpleEntry<>(nodeEval.getTarget(pos.getX(), pos.getY(), pos.getZ()), pos));
+                }
+                return this.findPath(nodeEval, org.dreeam.leaf.async.path.NodeEvaluatorCache.HEAP_LOCAL.get(), org.dreeam.leaf.async.path.NodeEvaluatorCache.NEIGHBORS_LOCAL.get(), maxVisitedNodes, start, map, maxRange, accuracy, searchDepthMultiplier);
+            } finally {
+                nodeEval.done();
+                nodeEval.nodes.clear();
+                org.dreeam.leaf.async.path.NodeEvaluatorCache.returnNodeEvaluator(nodeEval);
+            }
+        }));
+    }
+    // Leaf end
+
     public Path findPath(PathNavigationRegion region, Mob mob, Set<BlockPos> targetPositions, float maxRange, int accuracy, float searchDepthMultiplier) {
         this.openSet.clear();
         this.nodeEvaluator.prepare(region, mob);
@@ -52,25 +89,31 @@ public class PathFinder {
         }
     }
 
-    @Nullable
     private Path findPath(Node node, List<Map.Entry<Target, BlockPos>> positions, float maxRange, int accuracy, float searchDepthMultiplier) { // Paper - optimize collection
+    // Leaf start
+        return this.findPath(this.nodeEvaluator, this.openSet, this.neighbors, maxVisitedNodes, node, positions, maxRange, accuracy, searchDepthMultiplier);
+    }
+    private Path findPath(NodeEvaluator nodeEvaluator, BinaryHeap openSet, Node[] neighborsArr, int maxVisitedNodes, Node node, List<Map.Entry<Target, BlockPos>> positions, float maxRange, int accuracy, float searchDepthMultiplier) { // sync to only use the caching functions in this class on a single thread
+    // Leaf end
+        org.apache.commons.lang3.Validate.isTrue(!positions.isEmpty()); // ensure that we have at least one position, which means we'll always return a path
+        // Kaiiju end
         // Set<Target> set = targetPositions.keySet(); // Paper
         node.g = 0.0F;
         node.h = this.getBestH(node, positions); // Paper - optimize collection
         node.f = node.h;
-        this.openSet.clear();
-        this.openSet.insert(node);
+        openSet.clear(); // Leaf
+        openSet.insert(node); // Leaf
         // Set<Node> set1 = ImmutableSet.of(); // Paper - unused - diff on change
         int i = 0;
         List<Map.Entry<Target, BlockPos>> entryList = Lists.newArrayListWithExpectedSize(positions.size()); // Paper - optimize collection
-        int i1 = (int)(this.maxVisitedNodes * searchDepthMultiplier);
+        int i1 = (int)(maxVisitedNodes * searchDepthMultiplier); // Leaf
 
-        while (!this.openSet.isEmpty()) {
+        while (!openSet.isEmpty()) { // Leaf
             if (++i >= i1) {
                 break;
             }
 
-            Node node1 = this.openSet.pop();
+            Node node1 = openSet.pop(); // Leaf
             node1.closed = true;
 
             // Paper start - optimize collection
@@ -89,10 +132,10 @@ public class PathFinder {
             }
 
             if (!(node1.distanceTo(node) >= maxRange)) {
-                int neighbors = this.nodeEvaluator.getNeighbors(this.neighbors, node1);
+                int neighbors = nodeEvaluator.getNeighbors(neighborsArr, node1); // Kaiiju - petal - use provided nodeEvaluator
 
                 for (int i2 = 0; i2 < neighbors; i2++) {
-                    Node node2 = this.neighbors[i2];
+                    Node node2 = neighborsArr[i2]; // Leaf
                     float f = this.distance(node1, node2);
                     node2.walkedDistance = node1.walkedDistance + f;
                     float f1 = node1.g + f + node2.costMalus;
@@ -123,6 +166,7 @@ public class PathFinder {
                 best = path;
             }
         }
+        //noinspection ConstantConditions // Kaiiju - petal - ignore this warning, we know that the above loop always runs at least once since positions is not empty
         return best;
         // Paper end - Perf: remove streams and optimize collection
     }
diff --git a/net/minecraft/world/level/pathfinder/PathfindingContext.java b/net/minecraft/world/level/pathfinder/PathfindingContext.java
index 4eca1dd0819c7ee7a77e45fc5fa03f4ee5cdceaf..bc5fabd208f3673cbb54bd3df5287d037f5d2635 100644
--- a/net/minecraft/world/level/pathfinder/PathfindingContext.java
+++ b/net/minecraft/world/level/pathfinder/PathfindingContext.java
@@ -10,7 +10,7 @@ import net.minecraft.world.level.block.state.BlockState;
 public class PathfindingContext {
     private final CollisionGetter level;
     @Nullable
-    private final PathTypeCache cache;
+    public PathTypeCache cache; // Leaf
     private final BlockPos mobPosition;
     private final BlockPos.MutableBlockPos mutablePos = new BlockPos.MutableBlockPos();
 
