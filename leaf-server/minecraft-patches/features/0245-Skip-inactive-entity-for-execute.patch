From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Date: Tue, 9 Nov 2077 00:00:00 +0800
Subject: [PATCH] Skip inactive entity for execute


diff --git a/net/minecraft/commands/arguments/EntityArgument.java b/net/minecraft/commands/arguments/EntityArgument.java
index 6fd00b09c1be79e8aec40e87493321c4e24a53c3..1bd52f976392544dc0e0967f2b046783cf1ec0b1 100644
--- a/net/minecraft/commands/arguments/EntityArgument.java
+++ b/net/minecraft/commands/arguments/EntityArgument.java
@@ -67,7 +67,10 @@ public class EntityArgument implements ArgumentType<EntitySelector> {
     }
 
     public static Collection<? extends Entity> getOptionalEntities(CommandContext<CommandSourceStack> context, String name) throws CommandSyntaxException {
-        return context.getArgument(name, EntitySelector.class).findEntities(context.getSource());
+        // Leaf start - Skip inactive entity for execute
+        EntitySelector entitySelector = context.getArgument(name, EntitySelector.class);
+        return org.dreeam.leaf.config.modules.opt.SkipInactiveEntityForExecute.skipInactiveEntityForExecute && context.getSource().source instanceof net.minecraft.server.MinecraftServer ? entitySelector.findEntitiesSkipInactive(context.getSource()) : entitySelector.findEntities(context.getSource());
+        // Leaf end - Skip inactive entity for execute
     }
 
     public static Collection<ServerPlayer> getOptionalPlayers(CommandContext<CommandSourceStack> context, String name) throws CommandSyntaxException {
diff --git a/net/minecraft/commands/arguments/selector/EntitySelector.java b/net/minecraft/commands/arguments/selector/EntitySelector.java
index fbab3e2f4e3a9cdc1c148fc794036c5655368666..253b071fc910919babeb458f1f3aef475f67ebb1 100644
--- a/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -161,6 +161,54 @@ public class EntitySelector {
         }
     }
 
+    // Leaf start - Skip inactive entity for execute
+    // Copy from findEntities
+    public java.util.Collection<? extends Entity> findEntitiesSkipInactive(CommandSourceStack source) throws CommandSyntaxException {
+        this.checkPermissions(source);
+        if (!this.includesEntities) {
+            return this.findPlayers(source);
+        } else if (this.playerName != null) {
+            ServerPlayer playerByName = source.getServer().getPlayerList().getPlayerByName(this.playerName);
+            //playerByName = playerByName instanceof org.leavesmc.leaves.replay.ServerPhotographer ? null : playerByName; // Leaves - skip photographer // Leaf - TODO
+            return playerByName == null ? List.of() : List.of(playerByName);
+        } else if (this.entityUUID != null) {
+            for (ServerLevel serverLevel : source.getServer().getAllLevels()) {
+                Entity entity = serverLevel.getEntity(this.entityUUID);
+                //if (entity != null && !(entity instanceof org.leavesmc.leaves.replay.ServerPhotographer)) { // Leaves - skip photographer // Leaf - TODO
+                if (entity != null) {
+                    if (entity.getType().isEnabled(source.enabledFeatures())) {
+                        return List.of(entity);
+                    }
+                    break;
+                }
+            }
+
+            return List.of();
+        } else {
+            Vec3 vec3 = this.position.apply(source.getPosition());
+            AABB absoluteAabb = this.getAbsoluteAabb(vec3);
+            if (this.currentEntity) {
+                Predicate<Entity> predicate = this.getPredicateSkipInactive(vec3, absoluteAabb, null);
+                //return source.getEntity() != null && !(source.getEntity() instanceof org.leavesmc.leaves.replay.ServerPhotographer) && predicate.test(source.getEntity()) ? List.of(source.getEntity()) : List.of(); // Leaves - skip photographer // Leaf - TODO
+                return source.getEntity() != null && predicate.test(source.getEntity()) ? List.of(source.getEntity()) : List.of();
+            } else {
+                Predicate<Entity> predicate = this.getPredicateSkipInactive(vec3, absoluteAabb, source.enabledFeatures());
+                List<Entity> list = new ObjectArrayList<>();
+                if (this.isWorldLimited()) {
+                    this.addEntities(list, source.getLevel(), absoluteAabb, predicate);
+                } else {
+                    for (ServerLevel serverLevel1 : source.getServer().getAllLevels()) {
+                        this.addEntities(list, serverLevel1, absoluteAabb, predicate);
+                    }
+                }
+                //list.removeIf(entity -> entity instanceof org.leavesmc.leaves.replay.ServerPhotographer); // Leaves - skip photographer // Leaf - TODO
+
+                return this.sortAndLimit(vec3, list);
+            }
+        }
+    }
+    // Leaf end - Skip inactive entity for execute
+
     private void addEntities(List<Entity> entities, ServerLevel level, @Nullable AABB box, Predicate<Entity> predicate) {
         int resultLimit = this.getResultLimit();
         if (entities.size() < resultLimit) {
@@ -257,6 +305,39 @@ public class EntitySelector {
         return Util.allOf(list);
     }
 
+    // Leaf start - Skip inactive entity for execute
+    // Copy from getPredicate
+    private Predicate<Entity> getPredicateSkipInactive(Vec3 pos, @Nullable AABB box, @Nullable FeatureFlagSet enabledFeatures) {
+        boolean flag = enabledFeatures != null;
+        boolean flag1 = box != null;
+        boolean flag2 = this.range != null;
+        int i = (flag ? 1 : 0) + (flag1 ? 1 : 0) + (flag2 ? 1 : 0);
+        List<Predicate<Entity>> list;
+        if (i == 0) {
+            list = this.contextFreePredicates;
+        } else {
+            List<Predicate<Entity>> list1 = new ObjectArrayList<>(this.contextFreePredicates.size() + i);
+            list1.addAll(this.contextFreePredicates);
+            if (flag) {
+                list1.add(entity -> entity.getType().isEnabled(enabledFeatures));
+            }
+
+            if (flag1) {
+                list1.add(entity -> box.intersects(entity.getBoundingBox()));
+            }
+
+            if (flag2) {
+                list1.add(entity -> this.range.matchesSqr(entity.distanceToSqr(pos)));
+            }
+
+            list1.add(io.papermc.paper.entity.activation.ActivationRange::checkIfActive);
+            list = list1;
+        }
+
+        return Util.allOf(list);
+    }
+    // Leaf end - Skip inactive entity for execute
+
     private <T extends Entity> List<T> sortAndLimit(Vec3 pos, List<T> entities) {
         if (entities.size() > 1) {
             this.order.accept(pos, entities);
