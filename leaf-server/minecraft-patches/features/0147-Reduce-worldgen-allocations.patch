From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Date: Fri, 14 Jun 2024 23:19:55 +0800
Subject: [PATCH] Reduce worldgen allocations

This change optimizes the way SurfaceRules update their biome supplier,avoiding unnecessary object creations and thus reducing memory allocations
during world generation. The update method now reuses the existing PositionalBiomeGetter object if it's already present, otherwise it
initializes a new one.
Additionally, the tryApply method in SurfaceRules now avoids iterator
allocation by directly accessing the rules list, which further contributes
to reducing garbage collection pressure during world generation.

diff --git a/net/minecraft/world/level/levelgen/NoiseChunk.java b/net/minecraft/world/level/levelgen/NoiseChunk.java
index b7f4943b6c862f4b99aa7920af3fc91fc9fd0b76..347815500895ee68fd4707da026015bdbcb89fcd 100644
--- a/net/minecraft/world/level/levelgen/NoiseChunk.java
+++ b/net/minecraft/world/level/levelgen/NoiseChunk.java
@@ -371,7 +371,17 @@ public class NoiseChunk implements DensityFunction.ContextProvider, DensityFunct
     }
 
     protected DensityFunction wrap(DensityFunction densityFunction) {
-        return this.wrapped.computeIfAbsent(densityFunction, this::wrapNew);
+        // Leaf start - Reduce worldgen allocations
+        // Avoid lambda allocation
+        DensityFunction func = this.wrapped.get(densityFunction);
+
+        if (func == null) {
+            func = this.wrapNew(densityFunction);
+            this.wrapped.put(densityFunction, func);
+        }
+
+        return func;
+        // Leaf end - Reduce worldgen allocations
     }
 
     private DensityFunction wrapNew(DensityFunction densityFunction) {
diff --git a/net/minecraft/world/level/levelgen/SurfaceRules.java b/net/minecraft/world/level/levelgen/SurfaceRules.java
index c19a6843ba53d5c1850b45b82a967b9dd397e6b8..029926e1a8be234218f227c982237e957e23d5e7 100644
--- a/net/minecraft/world/level/levelgen/SurfaceRules.java
+++ b/net/minecraft/world/level/levelgen/SurfaceRules.java
@@ -313,8 +313,15 @@ public class SurfaceRules {
         }
 
         protected void updateY(int stoneDepthAbove, int stoneDepthBelow, int waterHeight, int blockX, int blockY, int blockZ) {
-            this.lastUpdateY++;
-            this.biome = Suppliers.memoize(() -> this.biomeGetter.apply(this.pos.set(blockX, blockY, blockZ)));
+            // Leaf start - Reduce worldgen allocations
+            // Reuse supplier object instead of creating new ones every time
+            ++this.lastUpdateY;
+            Supplier<Holder<Biome>> getter = this.biome;
+            if (getter == null) {
+                this.biome = getter = new org.dreeam.leaf.world.biome.PositionalBiomeGetter(this.biomeGetter, this.pos);
+            }
+            ((org.dreeam.leaf.world.biome.PositionalBiomeGetter) getter).update(blockX, blockY, blockZ);
+            // Leaf end - Reduce worldgen allocations
             this.blockY = blockY;
             this.waterHeight = waterHeight;
             this.stoneDepthBelow = stoneDepthBelow;
@@ -580,8 +587,13 @@ public class SurfaceRules {
     record SequenceRule(List<SurfaceRules.SurfaceRule> rules) implements SurfaceRules.SurfaceRule {
         @Override
         public @Nullable BlockState tryApply(int x, int y, int z) {
-            for (SurfaceRules.SurfaceRule surfaceRule : this.rules) {
-                BlockState blockState = surfaceRule.tryApply(x, y, z);
+            // Leaf start - Reduce worldgen allocations
+            // Avoid iterator allocation
+            int size = this.rules.size();
+            //noinspection ForLoopReplaceableByForEach
+            for (int i = 0; i < size; i++) {
+                BlockState blockState = this.rules.get(i).tryApply(x, y, z);
+                // Leaf end - Reduce worldgen allocations
                 if (blockState != null) {
                     return blockState;
                 }
diff --git a/net/minecraft/world/level/levelgen/material/MaterialRuleList.java b/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
index d2fd448300dcd7844c57ba8be04cd323fa47ee75..6c1fe411c8788960f406256bf854d43f958348a9 100644
--- a/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
+++ b/net/minecraft/world/level/levelgen/material/MaterialRuleList.java
@@ -8,13 +8,17 @@ import org.jspecify.annotations.Nullable;
 public record MaterialRuleList(NoiseChunk.BlockStateFiller[] materialRuleList) implements NoiseChunk.BlockStateFiller {
     @Override
     public @Nullable BlockState calculate(DensityFunction.FunctionContext context) {
-        for (NoiseChunk.BlockStateFiller blockStateFiller : this.materialRuleList) {
-            BlockState blockState = blockStateFiller.calculate(context);
-            if (blockState != null) {
-                return blockState;
-            }
+        // Leaf start - Reduce worldgen allocations
+        // Avoid iterator allocation
+        BlockState blockState = null;
+        int length = this.materialRuleList.length;
+
+        for (int i = 0; blockState == null && i < length; i++) {
+            NoiseChunk.BlockStateFiller blockStateFiller = this.materialRuleList[i];
+            blockState = blockStateFiller.calculate(context);
         }
 
-        return null;
+        return blockState;
+        // Leaf end - Reduce worldgen allocations
     }
 }
