From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hayanesuru <hayanesuru@outlook.jp>
Date: Mon, 11 Aug 2025 02:19:59 +0900
Subject: [PATCH] cache collision list


diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 7ffddaa634ca3e256aa81e697d147ad48b5f747c..0ed24644e07c409a3624614d3bab1797b44f7ae2 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1095,6 +1095,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public final org.dreeam.leaf.world.DespawnMap despawnMap = new org.dreeam.leaf.world.DespawnMap(paperConfig()); // Leaf - optimize despawn
     public final org.dreeam.leaf.world.NatureSpawnChunkMap natureSpawnChunkMap = new org.dreeam.leaf.world.NatureSpawnChunkMap(); // Leaf - optimize mob spawning
     public final org.dreeam.leaf.world.RandomTickSystem randomTickSystem = new org.dreeam.leaf.world.RandomTickSystem(); // Leaf - optimize random tick
+    public final org.dreeam.leaf.world.EntityCollisionCache entityCollisionCache = new org.dreeam.leaf.world.EntityCollisionCache(); // Leaf - cache collision list
+
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
         final net.minecraft.world.level.levelgen.BitRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Leaf - Faster random generator - upcasting
         ChunkPos pos = chunk.getPos();
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index df913bb859bbec721571daf45d0fef75c4adcec2..948e1825a585fe947d4f2c2e2a1e4cf997a182cb 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1647,8 +1647,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
         final AABB currentBox = this.getBoundingBox();
 
-        final List<VoxelShape> potentialCollisionsVoxel = new ArrayList<>();
-        final List<AABB> potentialCollisionsBB = new ArrayList<>();
+        // final List<VoxelShape> potentialCollisionsVoxel = new ArrayList<>(); // Leaf - cache collision list
+        // final List<AABB> potentialCollisionsBB = new ArrayList<>(); // Leaf - cache collision list
 
         final AABB initialCollisionBox;
         if (xZero & zZero) {
@@ -1660,17 +1660,17 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             initialCollisionBox = currentBox.expandTowards(movement);
         }
 
-        final List<AABB> entityAABBs = new ArrayList<>();
+        org.dreeam.leaf.world.EntityCollisionCache entityCollisionCache = ((ServerLevel) this.level).entityCollisionCache; // Leaf - cache collision list
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions(
-            this.level, (Entity)(Object)this, initialCollisionBox, entityAABBs, 0, null
+            this.level, (Entity)(Object)this, initialCollisionBox, entityCollisionCache.entityAABBs(), 0, null // Leaf - cache collision list
         );
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
-            this.level, (Entity)(Object)this, initialCollisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
+            this.level, (Entity)(Object)this, initialCollisionBox, entityCollisionCache.potentialCollisionsVoxel(), entityCollisionCache.potentialCollisionsBB(), // Leaf - cache collision list
             ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
         );
-        potentialCollisionsBB.addAll(entityAABBs);
-        final Vec3 collided = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currentBox, potentialCollisionsVoxel, potentialCollisionsBB);
+        entityCollisionCache.potentialCollisionsBB().addAll(entityCollisionCache.entityAABBs()); // Leaf - cache collision list
+        final Vec3 collided = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currentBox, entityCollisionCache.potentialCollisionsVoxel(), entityCollisionCache.potentialCollisionsBB()); // Leaf - cache collision list
 
         final boolean collidedX = collided.x != movement.x;
         final boolean collidedY = collided.y != movement.y;
@@ -1681,6 +1681,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         final double stepHeight;
 
         if ((!collidedDownwards && !this.onGround) || (!collidedX && !collidedZ) || (stepHeight = (double)this.maxUpStep()) <= 0.0) {
+            entityCollisionCache.clear(); // Leaf - cache collision list
             return collided;
         }
 
@@ -1691,7 +1692,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         }
 
         final List<VoxelShape> stepVoxels = new ArrayList<>();
-        final List<AABB> stepAABBs = entityAABBs;
+        final List<AABB> stepAABBs = entityCollisionCache.entityAABBs(); // Leaf // Leaf - cache collision list
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
             this.level, (Entity)(Object)this, stepRetrievalBox, stepVoxels, stepAABBs,
@@ -1701,10 +1702,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         for (final float step : calculateStepHeights(collidedYBox, stepVoxels, stepAABBs, (float)stepHeight, (float)collided.y)) {
             final Vec3 stepResult = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(new Vec3(movement.x, (double)step, movement.z), collidedYBox, stepVoxels, stepAABBs);
             if (stepResult.horizontalDistanceSqr() > collided.horizontalDistanceSqr()) {
+                entityCollisionCache.clear(); // Leaf - cache collision list
                 return stepResult.add(0.0, collidedYBox.minY - currentBox.minY, 0.0);
             }
         }
 
+        entityCollisionCache.clear(); // Leaf - cache collision list
         return collided;
         // Paper end - optimise collisions
     }
