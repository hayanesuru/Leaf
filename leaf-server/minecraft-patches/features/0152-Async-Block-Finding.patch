From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sun, 23 Mar 2025 11:51:44 +0100
Subject: [PATCH] Async Block Finding


diff --git a/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java b/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
index 3f080b15543bf8c5fa0774b62d7f12e13b82511a..135506968893cd164c4d416ce4d356e9f0ed3977 100644
--- a/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
+++ b/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
@@ -20,6 +20,18 @@ public abstract class MoveToBlockGoal extends Goal {
     private final int verticalSearchRange;
     protected int verticalSearchStart;
 
+    // Leaf start - Async Block Finding
+    private static final java.util.concurrent.ExecutorService BLOCK_FINDER_EXECUTOR =
+        java.util.concurrent.Executors.newSingleThreadExecutor(
+            new com.google.common.util.concurrent.ThreadFactoryBuilder()
+                .setNameFormat("Leaf Block Finding Thread - %d")
+                .setDaemon(true)
+                .build());
+
+    private final java.util.concurrent.ConcurrentLinkedQueue<BlockPos> candidateBlocks = new java.util.concurrent.ConcurrentLinkedQueue<>();
+    private boolean asyncSearchInProgress = false;
+    // Leaf end - Async Block Finding
+
     public MoveToBlockGoal(PathfinderMob mob, double speedModifier, int searchRange) {
         this(mob, speedModifier, searchRange, 1);
     }
@@ -29,6 +41,10 @@ public abstract class MoveToBlockGoal extends Goal {
         super.stop();
         this.blockPos = BlockPos.ZERO;
         this.mob.movingTarget = null;
+        // Leaf start - Reset async state on goal stop
+        this.candidateBlocks.clear();
+        this.asyncSearchInProgress = false;
+        // Leaf end
     }
     // Paper end
 
@@ -53,23 +69,28 @@ public abstract class MoveToBlockGoal extends Goal {
     }
 
     protected int nextStartTick(PathfinderMob creature) {
-        return reducedTickDelay(200 + creature.getRandom().nextInt(200));
+        // Use the static method from the Goal class directly
+        return Goal.reducedTickDelay(200 + creature.getRandom().nextInt(200));
     }
 
     @Override
     public boolean canContinueToUse() {
-        return this.tryTicks >= -this.maxStayTicks && this.tryTicks <= 1200 && this.isValidTarget(this.mob.level(), this.blockPos);
+        return this.tryTicks >= -this.maxStayTicks && this.tryTicks <= 1200 && this.blockPos != BlockPos.ZERO && this.isValidTarget(this.mob.level(), this.blockPos);
     }
 
     @Override
     public void start() {
-        this.moveMobToBlock();
+        if (this.blockPos != BlockPos.ZERO) {
+            this.moveMobToBlock();
+        }
         this.tryTicks = 0;
         this.maxStayTicks = this.mob.getRandom().nextInt(this.mob.getRandom().nextInt(1200) + 1200) + 1200;
     }
 
     protected void moveMobToBlock() {
-        this.mob.getNavigation().moveTo(this.blockPos.getX() + 0.5, this.blockPos.getY() + 1, this.blockPos.getZ() + 0.5, this.speedModifier);
+        if (this.blockPos != BlockPos.ZERO) {
+            this.mob.getNavigation().moveTo(this.blockPos.getX() + 0.5, this.blockPos.getY() + 1, this.blockPos.getZ() + 0.5, this.speedModifier);
+        }
     }
 
     public double acceptedDistance() {
@@ -77,7 +98,7 @@ public abstract class MoveToBlockGoal extends Goal {
     }
 
     protected BlockPos getMoveToTarget() {
-        return this.blockPos.above();
+        return this.blockPos != BlockPos.ZERO ? this.blockPos.above() : BlockPos.ZERO;
     }
 
     @Override
@@ -87,7 +108,13 @@ public abstract class MoveToBlockGoal extends Goal {
 
     @Override
     public void tick() {
+        if (this.blockPos == BlockPos.ZERO) {
+            return;
+        }
+
         BlockPos moveToTarget = this.getMoveToTarget();
+        if (moveToTarget == BlockPos.ZERO) return;
+
         if (!moveToTarget.closerToCenterThan(this.mob.position(), this.acceptedDistance())) {
             this.reachedTarget = false;
             this.tryTicks++;
@@ -109,20 +136,90 @@ public abstract class MoveToBlockGoal extends Goal {
     }
 
     protected boolean findNearestBlock() {
+        // Leaf start - Async Block Finding
+        if (!org.dreeam.leaf.config.modules.async.AsyncBlockFinding.enabled) {
+            return findNearestBlockSync();
+        }
+
+        while (!candidateBlocks.isEmpty()) {
+            BlockPos pos = candidateBlocks.poll();
+            if (pos != null && this.mob.level().hasChunkAt(pos) &&
+                this.mob.isWithinRestriction(pos) &&
+                this.isValidTarget(this.mob.level(), pos)) {
+
+                this.blockPos = pos;
+                this.mob.movingTarget = pos == BlockPos.ZERO ? null : pos;
+                return true;
+            }
+        }
+
+        if (asyncSearchInProgress) {
+            return false;
+        }
+
+        // Check again before starting, avoids tiny race condition if canUse is called rapidly
+        if (!asyncSearchInProgress) {
+            asyncSearchInProgress = true;
+            final BlockPos centerPos = this.mob.blockPosition().immutable();
+            final int searchRange = this.searchRange;
+            final int verticalRange = this.verticalSearchRange;
+            final int verticalStart = this.verticalSearchStart;
+
+            BLOCK_FINDER_EXECUTOR.execute(() -> {
+                try {
+                    generateCandidateBlocks(centerPos, searchRange, verticalRange, verticalStart);
+                } catch (Exception e) {
+                    e.printStackTrace(); // Keep basic error logging
+                } finally {
+                    asyncSearchInProgress = false;
+                }
+            });
+        }
+
+        return false;
+        // Leaf end - Async Block Finding
+    }
+
+    private void generateCandidateBlocks(BlockPos center, int searchRange, int verticalRange, int verticalStart) {
+        java.util.List<BlockPos> positions = new java.util.ArrayList<>();
+
+        for (int i2 = verticalStart; i2 <= verticalRange; i2 = i2 > 0 ? -i2 : 1 - i2) {
+            for (int i3 = 0; i3 < searchRange; i3++) {
+                for (int i4 = 0; i4 <= i3; i4 = i4 > 0 ? -i4 : 1 - i4) {
+                    for (int i5 = i4 < i3 && i4 > -i3 ? i3 : 0; i5 <= i3; i5 = i5 > 0 ? -i5 : 1 - i5) {
+                        BlockPos pos = center.offset(i4, i2 - 1, i5);
+                        positions.add(pos.immutable());
+                    }
+                }
+            }
+        }
+
+        positions.sort((p1, p2) -> {
+            double d1 = p1.distSqr(center);
+            double d2 = p2.distSqr(center);
+            return Double.compare(d1, d2);
+        });
+
+        for (BlockPos pos : positions) {
+            candidateBlocks.add(pos);
+        }
+    }
+
+    protected boolean findNearestBlockSync() {
         int i = this.searchRange;
         int i1 = this.verticalSearchRange;
-        BlockPos blockPos = this.mob.blockPosition();
+        BlockPos blockPosOrigin = this.mob.blockPosition();
         BlockPos.MutableBlockPos mutableBlockPos = new BlockPos.MutableBlockPos();
 
         for (int i2 = this.verticalSearchStart; i2 <= i1; i2 = i2 > 0 ? -i2 : 1 - i2) {
             for (int i3 = 0; i3 < i; i3++) {
                 for (int i4 = 0; i4 <= i3; i4 = i4 > 0 ? -i4 : 1 - i4) {
                     for (int i5 = i4 < i3 && i4 > -i3 ? i3 : 0; i5 <= i3; i5 = i5 > 0 ? -i5 : 1 - i5) {
-                        mutableBlockPos.setWithOffset(blockPos, i4, i2 - 1, i5);
+                        mutableBlockPos.setWithOffset(blockPosOrigin, i4, i2 - 1, i5);
                         if (!this.mob.level().hasChunkAt(mutableBlockPos)) continue; // Gale - Airplane - block goal does not load chunks - if this block isn't loaded, continue
                         if (this.mob.isWithinRestriction(mutableBlockPos) && this.isValidTarget(this.mob.level(), mutableBlockPos)) {
-                            this.blockPos = mutableBlockPos;
-                            this.mob.movingTarget = mutableBlockPos == BlockPos.ZERO ? null : mutableBlockPos.immutable(); // Paper
+                            this.blockPos = mutableBlockPos.immutable();
+                            this.mob.movingTarget = this.blockPos == BlockPos.ZERO ? null : this.blockPos; // Paper
                             return true;
                         }
                     }
@@ -134,4 +231,5 @@ public abstract class MoveToBlockGoal extends Goal {
     }
 
     protected abstract boolean isValidTarget(LevelReader level, BlockPos pos);
+
 }
