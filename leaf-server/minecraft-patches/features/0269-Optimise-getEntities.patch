From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sat, 12 Jul 2025 02:00:43 +0200
Subject: [PATCH] Optimise-getEntities

Co-authored by: Martijn Muijsers <martijnmuijsers@live.nl>

diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index 5ebc1b2cf186b512da5b62fedba16b612f2fa6ed..14dc37f0ed08b4eb4c7740ec68d23df0060c0955 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -579,6 +579,14 @@ public final class ChunkEntitySlices {
 
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
+            // Cache AABB fields to local variables to reduce field accesses inside the hot loop.
+            final double boxMinX = box.minX;
+            final double boxMinY = box.minY;
+            final double boxMinZ = box.minZ;
+            final double boxMaxX = box.maxX;
+            final double boxMaxY = box.maxY;
+            final double boxMaxZ = box.maxZ;
+
             for (int section = min; section <= max; ++section) {
                 final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
 
@@ -587,11 +595,18 @@ public final class ChunkEntitySlices {
                 }
 
                 final Entity[] storage = list.storage;
+                final int len = Math.min(storage.length, list.size());
 
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
+                for (int i = 0; i < len; ++i) {
                     final Entity entity = storage[i];
 
-                    if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
+                    if (entity == null || entity == except) {
+                        continue;
+                    }
+
+                    // Inline AABB#intersects to avoid a method call and use the cached AABB fields.
+                    final AABB entityBB = entity.getBoundingBox();
+                    if (entityBB.maxX <= boxMinX || entityBB.minX >= boxMaxX || entityBB.maxY <= boxMinY || entityBB.minY >= boxMaxY || entityBB.maxZ <= boxMinZ || entityBB.minZ >= boxMaxZ) {
                         continue;
                     }
 
@@ -618,19 +633,32 @@ public final class ChunkEntitySlices {
 
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
+            // Cache AABB fields to local variables to reduce field accesses inside the hot loop.
+            final double boxMinX = box.minX;
+            final double boxMinY = box.minY;
+            final double boxMinZ = box.minZ;
+            final double boxMaxX = box.maxX;
+            final double boxMaxY = box.maxY;
+            final double boxMaxZ = box.maxZ;
+
             for (int section = min; section <= max; ++section) {
                 final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
-
                 if (list == null) {
                     continue;
                 }
 
                 final Entity[] storage = list.storage;
+                final int len = Math.min(storage.length, list.size());
 
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
+                for (int i = 0; i < len; ++i) {
                     final Entity entity = storage[i];
+                    if (entity == null || entity == except) {
+                        continue;
+                    }
 
-                    if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
+                    // Inline AABB#intersects to avoid a method call and use the cached AABB fields.
+                    final AABB entityBB = entity.getBoundingBox();
+                    if (entityBB.maxX <= boxMinX || entityBB.minX >= boxMaxX || entityBB.maxY <= boxMinY || entityBB.minY >= boxMaxY || entityBB.maxZ <= boxMinZ || entityBB.minZ >= boxMaxZ) {
                         continue;
                     }
 
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index a55b1534dc3c0745ff569f5c1e07dbeaba0fe57d..1dbfbb0e56757c0ab6785755afc485055a87c327 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -2282,7 +2282,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
 
     @Override
     public boolean isAlive() {
-        return !this.isRemoved() && this.getHealth() > 0.0F && !this.dead; // Paper - Check this.dead
+        return !this.dead && !this.isRemoved() && this.getHealth() > 0.0F; // Paper - Check this.dead // Leaf - check the cheapest first
     }
 
     public boolean isLookingAtMe(LivingEntity entity, double tolerance, boolean scaleByDistance, boolean visual, double... yValues) {
