From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sat, 19 Jul 2025 13:31:49 +0200
Subject: [PATCH] optimize checkInsideBlocks calls

1. Chunk caching - Reduce chunk lookups via local caching
2. Array-based storage - Replace EnumMaps with ordinal-indexed arrays
3. Memory reuse - Cache positions/Vec3/level references
4. Iterator removal - Use indexed loops instead

License: LGPL-3.0 (https://www.gnu.org/licenses/lgpl-3.0.html)

diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index 3212d952bbceb1f4c53e9994a97cdc73eaaa12e7..f152126cfe27a73f8c4b75f5a00bb30647fc6c8a 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1756,8 +1756,13 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         }
     }
 
+    // Leaf start - optimize checkInsideBlocks calls
     private int checkInsideBlocks(Vec3 from, Vec3 to, InsideBlockEffectApplier.StepBasedCollector stepBasedCollector, LongSet visited, int maxSteps) {
-        AABB aabb = this.makeBoundingBox(to).deflate(1.0E-5F);
+        final Level level = this.level();
+        AABB aabb = this.getBoundingBox().move(to.subtract(this.position())).deflate(1.0E-5F);
+        final net.minecraft.world.level.chunk.ChunkAccess[] cachedChunk = {null};
+        final long[] cachedChunkPos = { Long.MIN_VALUE };
+
         boolean flag = from.distanceToSqr(to) > Mth.square(0.9999900000002526);
         boolean flag1 = this.level instanceof ServerLevel serverLevel
             && serverLevel.getServer().debugSubscribers().hasAnySubscriberFor(DebugSubscriptions.ENTITY_BLOCK_INTERSECTIONS);
@@ -1773,24 +1778,44 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                     return false;
                 } else {
                     atomicInteger.set(index);
-                    BlockState blockState = this.level().getBlockState(pos);
+                    final int chunkX = pos.getX() >> 4;
+                    final int chunkZ = pos.getZ() >> 4;
+                    final long currentChunkPos = ChunkPos.asLong(chunkX, chunkZ);
+                    BlockState blockState;
+
+                    if (cachedChunkPos[0] != currentChunkPos) {
+                        cachedChunk[0] = level.getChunkIfLoaded(chunkX, chunkZ);
+                        cachedChunkPos[0] = currentChunkPos;
+                    }
+
+                    if (cachedChunk[0] != null) {
+                        blockState = cachedChunk[0].getBlockState(pos);
+                    } else {
+                        blockState = level.getBlockStateIfLoaded(pos);
+                        if (blockState == null) {
+                            blockState = Blocks.AIR.defaultBlockState();
+                        }
+                    }
+
+                    final long posLong = pos.asLong();
                     if (blockState.isAir()) {
                         if (flag1) {
-                            this.debugBlockIntersection((ServerLevel)this.level(), pos.immutable(), false, false);
+                            this.debugBlockIntersection((ServerLevel)level, pos.immutable(), false, false);
                         }
 
                         return true;
                     } else {
-                        VoxelShape entityInsideCollisionShape = blockState.getEntityInsideCollisionShape(this.level(), pos, this);
+                        VoxelShape entityInsideCollisionShape = blockState.getEntityInsideCollisionShape(level, pos, this);
                         boolean flag2 = entityInsideCollisionShape == Shapes.block()
                             || this.collidedWithShapeMovingFrom(from, to, entityInsideCollisionShape.move(new Vec3(pos)).toAabbs());
-                        boolean flag3 = this.collidedWithFluid(blockState.getFluidState(), pos, from, to);
+                        final FluidState fluidState = blockState.getFluidState();
+                        boolean flag3 = !fluidState.isEmpty() && this.collidedWithFluid(fluidState, pos, from, to);
                         if ((flag2 || flag3) && visited.add(pos.asLong())) {
                             if (flag2) {
                                 try {
                                     boolean flag4 = flag || aabb.intersects(pos);
                                     stepBasedCollector.advanceStep(index, pos); // Paper - track position inside effect was triggered on
-                                    blockState.entityInside(this.level(), pos, this, stepBasedCollector, flag4);
+                                    blockState.entityInside(level, pos, this, stepBasedCollector, flag4);
                                     this.onInsideBlock(blockState);
                                 } catch (Throwable var20) {
                                     CrashReport crashReport = CrashReport.forThrowable(var20, "Colliding entity with block");
@@ -1804,11 +1829,11 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
 
                             if (flag3) {
                                 stepBasedCollector.advanceStep(index, pos); // Paper - track position inside effect was triggered on
-                                blockState.getFluidState().entityInside(this.level(), pos, this, stepBasedCollector);
+                                blockState.getFluidState().entityInside(level, pos, this, stepBasedCollector);
                             }
 
                             if (flag1) {
-                                this.debugBlockIntersection((ServerLevel)this.level(), pos.immutable(), flag2, flag3);
+                                this.debugBlockIntersection((ServerLevel)level, pos.immutable(), flag2, flag3);
                             }
 
                             return true;
@@ -1821,6 +1846,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         );
         return atomicInteger.get() + 1;
     }
+    // Leaf end - optimize checkInsideBlocks calls
 
     private void debugBlockIntersection(ServerLevel level, BlockPos pos, boolean inBlock, boolean inFluid) {
         DebugEntityBlockIntersection debugEntityBlockIntersection;
diff --git a/net/minecraft/world/entity/InsideBlockEffectApplier.java b/net/minecraft/world/entity/InsideBlockEffectApplier.java
index 934bebe2fc044d9c206d7e328e5c273b56ffbb2f..a0fa06529beb3690ff60371c2579df87ad649e5a 100644
--- a/net/minecraft/world/entity/InsideBlockEffectApplier.java
+++ b/net/minecraft/world/entity/InsideBlockEffectApplier.java
@@ -30,20 +30,28 @@ public interface InsideBlockEffectApplier {
     void runAfter(InsideBlockEffectType type, Consumer<Entity> effect);
 
     public static class StepBasedCollector implements InsideBlockEffectApplier {
+        // Leaf start - optimize checkInsideBlocks calls
         private static final InsideBlockEffectType[] APPLY_ORDER = InsideBlockEffectType.values();
         private static final int NO_STEP = -1;
-        private final Map<InsideBlockEffectType, Consumer<Entity>> effectsInStep = new java.util.EnumMap<>(InsideBlockEffectType.class); // Paper - track position inside effect was triggered on
-        private final Map<InsideBlockEffectType, List<Consumer<Entity>>> beforeEffectsInStep = Util.makeEnumMap(
-            InsideBlockEffectType.class, insideBlockEffectType -> new ArrayList<>()
-        );
-        private final Map<InsideBlockEffectType, List<Consumer<Entity>>> afterEffectsInStep = Util.makeEnumMap(
-            InsideBlockEffectType.class, insideBlockEffectType -> new ArrayList<>()
-        );
+
+        private final Consumer<Entity>[] effectsInStep = new Consumer[APPLY_ORDER.length];
+        private final List<Consumer<Entity>>[] beforeEffectsInStep = new List[APPLY_ORDER.length];
+        private final List<Consumer<Entity>>[] afterEffectsInStep = new List[APPLY_ORDER.length];
+
+        private static final List<Consumer<Entity>> EMPTY_LIST = List.of();
+
         private final List<Consumer<Entity>> finalEffects = new ArrayList<>();
         private int lastStep = -1;
 
-        public void advanceStep(int step, net.minecraft.core.BlockPos pos) { // Paper - track position inside effect was triggered on
-            this.currentBlockPos = pos; // Paper - track position inside effect was triggered on
+        public StepBasedCollector() {
+            for (int i = 0; i < APPLY_ORDER.length; i++) {
+                beforeEffectsInStep[i] = new ArrayList<>(2);
+                afterEffectsInStep[i] = new ArrayList<>(2);
+            }
+        }
+
+        public void advanceStep(int step, net.minecraft.core.BlockPos pos) {
+            this.currentBlockPos = pos;
             if (this.lastStep != step) {
                 this.lastStep = step;
                 this.flushStep();
@@ -53,46 +61,88 @@ public interface InsideBlockEffectApplier {
         public void applyAndClear(Entity entity) {
             this.flushStep();
 
-            for (Consumer<Entity> consumer : this.finalEffects) {
+            List<Consumer<Entity>> effects = this.finalEffects;
+            int size = effects.size();
+
+            if (size == 0) {
+                this.lastStep = -1;
+                return;
+            }
+
+            if (!entity.isAlive()) {
+                effects.clear();
+                this.lastStep = -1;
+                return;
+            }
+
+            int i = 0;
+            while (i < size - 3) {
+                effects.get(i++).accept(entity);
+                effects.get(i++).accept(entity);
+                effects.get(i++).accept(entity);
+                effects.get(i++).accept(entity);
                 if (!entity.isAlive()) {
                     break;
                 }
+            }
 
-                consumer.accept(entity);
+            if (entity.isAlive()) {
+                for (; i < size; i++) {
+                    effects.get(i).accept(entity);
+                    if (!entity.isAlive()) {
+                        break;
+                    }
+                }
             }
 
-            this.finalEffects.clear();
+            effects.clear();
             this.lastStep = -1;
         }
 
         private void flushStep() {
-            for (InsideBlockEffectType insideBlockEffectType : APPLY_ORDER) {
-                List<Consumer<Entity>> list = this.beforeEffectsInStep.get(insideBlockEffectType);
-                this.finalEffects.addAll(list);
-                list.clear();
-                if (this.effectsInStep.remove(insideBlockEffectType) instanceof final Consumer<Entity> recordedEffect) { // Paper - track position inside effect was triggered on - better than null check to avoid diff.
-                    this.finalEffects.add(recordedEffect); // Paper - track position inside effect was triggered on
+            final int len = APPLY_ORDER.length;
+            final List<Consumer<Entity>>[] beforeArr = this.beforeEffectsInStep;
+            final Consumer<Entity>[] effectArr = this.effectsInStep;
+            final List<Consumer<Entity>>[] afterArr = this.afterEffectsInStep;
+            final List<Consumer<Entity>> finalList = this.finalEffects;
+
+            for (int i = 0; i < len; i++) {
+                // Process before effects
+                List<Consumer<Entity>> beforeList = beforeArr[i];
+                if (!beforeList.isEmpty()) {
+                    finalList.addAll(beforeList);
+                    beforeList.clear();
+                }
+
+                // Process main effect
+                Consumer<Entity> effect = effectArr[i];
+                if (effect != null) {
+                    finalList.add(effect);
+                    effectArr[i] = null;
                 }
 
-                List<Consumer<Entity>> list1 = this.afterEffectsInStep.get(insideBlockEffectType);
-                this.finalEffects.addAll(list1);
-                list1.clear();
+                // Process after effects
+                List<Consumer<Entity>> afterList = afterArr[i];
+                if (!afterList.isEmpty()) {
+                    finalList.addAll(afterList);
+                    afterList.clear();
+                }
             }
         }
 
         @Override
         public void apply(InsideBlockEffectType type) {
-            this.effectsInStep.put(type, recorded(type));  // Paper - track position inside effect was triggered on
+            effectsInStep[type.ordinal()] = recorded(type);
         }
 
         @Override
         public void runBefore(InsideBlockEffectType type, Consumer<Entity> effect) {
-            this.beforeEffectsInStep.get(type).add(effect);
+            beforeEffectsInStep[type.ordinal()].add(effect);
         }
 
         @Override
         public void runAfter(InsideBlockEffectType type, Consumer<Entity> effect) {
-            this.afterEffectsInStep.get(type).add(effect);
+            afterEffectsInStep[type.ordinal()].add(effect);
         }
 
         // Paper start - track position inside effect was triggered on
@@ -113,5 +163,6 @@ public interface InsideBlockEffectApplier {
             }
         }
         // Paper end - track position inside effect was triggered on
+        // Leaf end - optimize checkInsideBlocks calls
     }
 }
