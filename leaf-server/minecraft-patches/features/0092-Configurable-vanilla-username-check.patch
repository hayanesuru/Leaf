From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dreeam <61569423+Dreeam-qwq@users.noreply.github.com>
Date: Wed, 12 Oct 2022 14:36:58 -0400
Subject: [PATCH] Configurable vanilla username check


diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index d874a58e9e815faad02fe1f2777f4375289b17ac..b82ef9485e24577a238b08249e09c87388768e9a 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -2620,7 +2620,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         if (this.level().purpurConfig.idleTimeoutUpdateTabList) {
             String scoreboardName = getScoreboardName();
             String playerListName = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().serialize(getBukkitEntity().playerListName());
-            String[] split = playerListName.split(scoreboardName);
+            String[] split = playerListName.split(java.util.regex.Pattern.quote(scoreboardName)); // Leaf - Configurable vanilla username check - Sanitize name input
             String prefix = (split.length > 0 ? split[0] : "").replace(org.purpurmc.purpur.PurpurConfig.afkTabListPrefix, "");
             String suffix = (split.length > 1 ? split[1] : "").replace(org.purpurmc.purpur.PurpurConfig.afkTabListSuffix, "");
             if (afk) {
diff --git a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index dacfe3ec4401304d3bd974df109fbb1826a3b503..ac3e011c158c24864e68fcc49b51619bb56b16e4 100644
--- a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -165,11 +165,20 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
     public void handleHello(ServerboundHelloPacket packet) {
         Validate.validState(this.state == ServerLoginPacketListenerImpl.State.HELLO, "Unexpected hello packet");
         // Paper start - Validate usernames
-        if (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode()
+        // Leaf start - Configurable vanilla username check
+        boolean allPrevChecksPassed;
+        if (!org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.removeAllCheck
+            && io.papermc.paper.configuration.GlobalConfiguration.get().proxies.isProxyOnlineMode()
             && io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.performUsernameValidation
             && !this.iKnowThisMayNotBeTheBestIdeaButPleaseDisableUsernameValidation) {
-            Validate.validState(StringUtil.isReasonablePlayerName(packet.name()), "Invalid characters in username");
+            allPrevChecksPassed = true;
+            if (!org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.allowOldPlayersJoin) {
+                Validate.validState(StringUtil.isReasonablePlayerName(packet.name()), "Invalid characters in username");
+            }
+        } else {
+            allPrevChecksPassed = false;
         }
+        // Leaf end - Configurable vanilla username check
         this.requestedUuid = packet.profileId();
         // Paper end - Validate usernames
         this.requestedUsername = packet.name();
@@ -196,6 +205,15 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                 authenticatorPool.execute(() -> {
                     try {
                         GameProfile gameprofile = ServerLoginPacketListenerImpl.this.createOfflineProfile(ServerLoginPacketListenerImpl.this.requestedUsername); // Spigot
+                        // Leaf start - Configurable vanilla username check
+                        if (org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.allowOldPlayersJoin) {
+                            if (server.playerDataStorage.load(new net.minecraft.server.players.NameAndId(gameprofile)).orElse(null) != null) {
+                                server.getPlayerList().playedPlayers.add(packet.name());
+                            } else if (allPrevChecksPassed) {
+                                Validate.validState(StringUtil.isReasonablePlayerName(packet.name()), "Invalid characters in username");
+                            }
+                        }
+                        // Leaf end - Configurable vanilla username check
 
                         gameprofile = ServerLoginPacketListenerImpl.this.callPlayerPreLoginEvents(gameprofile); // Paper - Add more fields to AsyncPlayerPreLoginEvent
                         ServerLoginPacketListenerImpl.LOGGER.info("UUID of player {} is {}", gameprofile.name(), gameprofile.id());
@@ -339,7 +357,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
         server.getPluginManager().callEvent(asyncEvent);
         profile = asyncEvent.getPlayerProfile();
         profile.complete(true); // Paper - setPlayerProfileAPI
-        gameprofile = com.destroystokyo.paper.profile.CraftPlayerProfile.asAuthlibCopy(profile);
+        gameprofile = com.destroystokyo.paper.profile.CraftPlayerProfile.asAuthlibCopyCustomValidation(profile); // Leaf - Configurable vanilla username check
         playerName = gameprofile.name();
         uniqueId = gameprofile.id();
         // Paper end - Add more fields to AsyncPlayerPreLoginEvent
diff --git a/net/minecraft/server/players/CachedUserNameToIdResolver.java b/net/minecraft/server/players/CachedUserNameToIdResolver.java
index 6d3f496881492ac67465746984d6ef8302750305..a06275b08bc2a343260245a348958ed57fdd37d4 100644
--- a/net/minecraft/server/players/CachedUserNameToIdResolver.java
+++ b/net/minecraft/server/players/CachedUserNameToIdResolver.java
@@ -67,7 +67,7 @@ public class CachedUserNameToIdResolver implements UserNameToIdResolver {
     }
 
     private Optional<NameAndId> lookupGameProfile(GameProfileRepository profileRepository, String name) {
-        if (!StringUtil.isValidPlayerName(name)) {
+        if (!StringUtil.isValidPlayerName(name, false)) { // Leaf - Configurable vanilla username check - Directly return, skip unnecessary following logic
             return this.createUnknownProfile(name);
         } else {
             final boolean shouldLookup = !org.apache.commons.lang3.StringUtils.isBlank(name)  // Paper - Don't lookup a profile with a blank name
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index 7f7406f6ca9d5d97fc5bab992f70c0702c718af8..2b10da9b31ca19bff46b3d758d8a3fed4b0f7ef4 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -136,6 +136,7 @@ public abstract class PlayerList {
     private org.bukkit.craftbukkit.CraftServer cserver;
     private final Map<String,ServerPlayer> playersByName = new java.util.HashMap<>();
     public @Nullable String collideRuleTeamName; // Paper - Configurable player collision
+    public final List<String> playedPlayers = new java.util.concurrent.CopyOnWriteArrayList<>(); // Leaf - Configurable vanilla username check
 
     public PlayerList(
         MinecraftServer server, LayeredRegistryAccess<RegistryLayer> registries, PlayerDataStorage playerIo, NotificationService notificationService
@@ -515,6 +516,7 @@ public abstract class PlayerList {
         player.getAdvancements().stopListening();
         this.players.remove(player);
         this.playersByName.remove(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
+        if (org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.allowOldPlayersJoin) this.playedPlayers.remove(player.getGameProfile().name()); // Leaf - Configurable vanilla username check
         this.removeFromSendAllPlayerInfoBuckets(player); // Gale - Purpur - spread out sending all player info
         this.server.getCustomBossEvents().onPlayerDisconnect(player);
         UUID uuid = player.getUUID();
diff --git a/net/minecraft/util/StringUtil.java b/net/minecraft/util/StringUtil.java
index da0018214439511288a43ca665abec6f01441f47..d21806680b1a4c1293ee1aed6c3cc9d259f76d9d 100644
--- a/net/minecraft/util/StringUtil.java
+++ b/net/minecraft/util/StringUtil.java
@@ -64,6 +64,15 @@ public class StringUtil {
     }
 
     public static boolean isValidPlayerName(String playerName) {
+        // Leaf start - Configurable vanilla username check
+        return isValidPlayerName(playerName, org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.shouldSkipNonPlayerNameCheck());
+    }
+    public static boolean isValidPlayerNameVanilla(String playerName) {
+        return playerName.length() <= 16 && playerName.chars().filter(i -> i <= 32 || i >= 127).findAny().isEmpty();
+    }
+    public static boolean isValidPlayerName(String playerName, boolean bypassCheck) {
+        if (bypassCheck) return playerName.length() <= 16;
+        // Leaf end - Configurable vanilla username check
         return playerName.length() <= 16 && playerName.chars().filter(i -> i <= 32 || i >= 127).findAny().isEmpty();
     }
 
@@ -87,7 +96,12 @@ public class StringUtil {
 
     // Paper start - Username validation
     public static boolean isReasonablePlayerName(final String name) {
-        if (true) return org.purpurmc.purpur.PurpurConfig.usernameValidCharactersPattern.matcher(name).matches(); // Purpur - Configurable valid characters for usernames
+        // Leaf start - Configurable vanilla username check
+        if (org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.allowOldPlayersJoin && net.minecraft.server.MinecraftServer.getServer().getPlayerList().playedPlayers.contains(name)) return true;
+        if (org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.useUsernameRegex) {
+            return org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.usernameRegex.matcher(name).matches() && name.length() <= 16; // Purpur - Configurable valid characters for usernames // Leaf - use our own config
+        }
+        // Leaf end - Configurable vanilla username check
         if (name.isEmpty() || name.length() > 16) {
             return false;
         }
diff --git a/net/minecraft/world/item/component/ResolvableProfile.java b/net/minecraft/world/item/component/ResolvableProfile.java
index 8dbdb40095321cfb2164026f5ca7e0d0c8f1914f..16ea3364aa60ed404752be40cfdf08cc676caa50 100644
--- a/net/minecraft/world/item/component/ResolvableProfile.java
+++ b/net/minecraft/world/item/component/ResolvableProfile.java
@@ -68,6 +68,30 @@ public abstract sealed class ResolvableProfile implements TooltipProvider permit
 
     public abstract Either<GameProfile, ResolvableProfile.Partial> unpack();
 
+    // Leaf start - Configurable vanilla username check - Enforce skull validation
+    private static Either<String, UUID> sanitizeDynamicPlayerName(Either<String, UUID> nameOrId) {
+        if (nameOrId.left().isEmpty()) {
+            return nameOrId;
+        }
+        return org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.enforceSkullValidation && !net.minecraft.util.StringUtil.isValidPlayerNameVanilla(nameOrId.left().get()) ? Either.left("INVALID_OWNER") : nameOrId;
+    }
+
+    private static Optional<String> sanitizePartialPlayerName(Optional<String> name) {
+        if (name.isEmpty()) {
+            return name;
+        }
+        return org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.enforceSkullValidation && !net.minecraft.util.StringUtil.isValidPlayerNameVanilla(name.get()) ? Optional.of("INVALID_OWNER") : name;
+    }
+
+    private static Either<GameProfile, ResolvableProfile.Partial> sanitizeStaticPlayerName(Either<GameProfile, ResolvableProfile.Partial> contents) {
+        if (contents.left().isEmpty()) {
+            return contents;
+        }
+        GameProfile gameProfile = contents.left().get();
+        return org.dreeam.leaf.config.modules.misc.VanillaUsernameCheck.enforceSkullValidation && !net.minecraft.util.StringUtil.isValidPlayerNameVanilla(gameProfile.name()) ? Either.left(new GameProfile(gameProfile.id(), "INVALID_OWNER", gameProfile.properties())) : contents;
+    }
+    // Leaf end - Configurable vanilla username check - Enforce skull validation
+
     protected ResolvableProfile(GameProfile partialProfile, PlayerSkin.Patch skinPatch) {
         this.partialProfile = partialProfile;
         this.skinPatch = skinPatch;
@@ -96,6 +120,11 @@ public abstract sealed class ResolvableProfile implements TooltipProvider permit
         private final Either<String, UUID> nameOrId;
 
         public Dynamic(Either<String, UUID> nameOrId, PlayerSkin.Patch skinPatch) {
+            // Leaf start - Configurable vanilla username check
+            this(sanitizeDynamicPlayerName(nameOrId), skinPatch, false);
+        }
+        public Dynamic(Either<String, UUID> nameOrId, PlayerSkin.Patch skinPatch, boolean dummy) {
+            // Leaf end - Configurable vanilla username check
             super(ResolvableProfile.createPartialProfile(nameOrId.left(), nameOrId.right(), PropertyMap.EMPTY), skinPatch);
             this.nameOrId = nameOrId;
         }
@@ -134,6 +163,11 @@ public abstract sealed class ResolvableProfile implements TooltipProvider permit
     }
 
     public record Partial(Optional<String> name, Optional<UUID> id, PropertyMap properties) {
+        // Leaf start - Configurable vanilla username check
+        public Partial {
+            name = ResolvableProfile.sanitizePartialPlayerName(name);
+        }
+        // Leaf end - Configurable vanilla username check
         public static final ResolvableProfile.Partial EMPTY = new ResolvableProfile.Partial(Optional.empty(), Optional.empty(), PropertyMap.EMPTY);
         public static final MapCodec<ResolvableProfile.Partial> MAP_CODEC = RecordCodecBuilder.mapCodec(
             instance -> instance.group(
@@ -164,6 +198,11 @@ public abstract sealed class ResolvableProfile implements TooltipProvider permit
         private final Either<GameProfile, ResolvableProfile.Partial> contents;
 
         public Static(Either<GameProfile, ResolvableProfile.Partial> contents, PlayerSkin.Patch skinPatch) {
+            // Leaf start - Configurable vanilla username check
+            this(sanitizeStaticPlayerName(contents), skinPatch, false);
+        }
+        public Static(Either<GameProfile, ResolvableProfile.Partial> contents, PlayerSkin.Patch skinPatch, boolean dummy) {
+            // Leaf end - Configurable vanilla username check
             super(contents.map(gameProfile -> (GameProfile)gameProfile, ResolvableProfile.Partial::createProfile), skinPatch);
             this.contents = contents;
         }
