From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Fri, 21 Feb 2025 15:06:55 +0100
Subject: [PATCH] Bulk writes to writeLongArray during chunk loading


diff --git a/net/minecraft/network/FriendlyByteBuf.java b/net/minecraft/network/FriendlyByteBuf.java
index abb0141426fd716e79a947b9498a8351daa342fc..6971f93c3f6008f2c2f99fc52e2a3058fd8b7659 100644
--- a/net/minecraft/network/FriendlyByteBuf.java
+++ b/net/minecraft/network/FriendlyByteBuf.java
@@ -341,10 +341,43 @@ public class FriendlyByteBuf extends ByteBuf {
 
     public FriendlyByteBuf writeLongArray(long[] array) {
         this.writeVarInt(array.length);
+        // Leaf start - Bulk writes to writeLongArray during chunk loading
+        if (array.length == 0) {
+            return this;
+        }
+        int neededBytes = array.length * Long.BYTES;
+        int maxWritableBytes = this.source.maxWritableBytes();
+
+        if (maxWritableBytes >= neededBytes) {
+            this.source.ensureWritable(neededBytes);
+            int writerIndex = this.source.writerIndex();
+
+            if (this.source.hasArray()) {
+                byte[] dest = this.source.array();
+                int offset = this.source.arrayOffset() + writerIndex;
+
+                ByteBuffer buf = ByteBuffer.wrap(dest, offset, neededBytes).order(this.source.order());
+                buf.asLongBuffer().put(array);
 
-        for (long l : array) {
-            this.writeLong(l);
+                this.source.writerIndex(writerIndex + neededBytes);
+            } else if (this.source.nioBufferCount() > 0) {
+                ByteBuffer nioBuf = this.source.nioBuffer(writerIndex, neededBytes);
+                nioBuf.asLongBuffer().put(array);
+                this.source.writerIndex(writerIndex + neededBytes);
+            } else {
+                ByteBuffer temp = ByteBuffer.allocate(neededBytes).order(this.source.order());
+                temp.asLongBuffer().put(array);
+                temp.rewind();
+                this.source.writeBytes(temp);
+            }
+        } else {
+            // Not enough space even at max capacity, use traditional approach
+            // which will write each element individually (and handle growing the buffer as needed)
+            for (long l : array) {
+                this.writeLong(l);
+            }
         }
+        // Leaf end - Bulk writes to writeLongArray during chunk loading
 
         return this;
     }
