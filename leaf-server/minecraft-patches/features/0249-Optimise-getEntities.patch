From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sat, 12 Jul 2025 02:00:43 +0200
Subject: [PATCH] Optimise getEntities

Co-authored by: Martijn Muijsers <martijnmuijsers@live.nl>

diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
index afcff04024c466efcf554c0642aac6f7679ac89f..09dd84d9866a3bbb7282b3277be99a5c16cb0a74 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/level/entity/ChunkEntitySlices.java
@@ -546,6 +546,15 @@ public final class ChunkEntitySlices {
 
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
+            // Leaf start - Optimise getEntities
+            // Cache AABB fields to local variables to reduce field accesses inside the hot loop.
+            final double boxMinX = box.minX;
+            final double boxMinY = box.minY;
+            final double boxMinZ = box.minZ;
+            final double boxMaxX = box.maxX;
+            final double boxMaxY = box.maxY;
+            final double boxMaxZ = box.maxZ;
+
             for (int section = min; section <= max; ++section) {
                 final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
 
@@ -554,11 +563,19 @@ public final class ChunkEntitySlices {
                 }
 
                 final Entity[] storage = list.storage;
+                final int len = Math.min(storage.length, list.size());
 
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
+                for (int i = 0; i < len; ++i) {
                     final Entity entity = storage[i];
 
-                    if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
+                    if (entity == null || entity == except) {
+                        continue;
+                    }
+
+                    // Inline AABB#intersects to avoid a method call and use the cached AABB fields.
+                    final AABB entityBB = entity.getBoundingBox();
+                    if (entityBB.maxX <= boxMinX || entityBB.minX >= boxMaxX || entityBB.maxY <= boxMinY || entityBB.minY >= boxMaxY || entityBB.maxZ <= boxMinZ || entityBB.minZ >= boxMaxZ) {
+                        // Leaf end - Optimise getEntities
                         continue;
                     }
 
@@ -585,19 +602,34 @@ public final class ChunkEntitySlices {
 
             final BasicEntityList<Entity>[] entitiesBySection = this.entitiesBySection;
 
+            // Leaf start - Optimise getEntities
+            // Cache AABB fields to local variables to reduce field accesses inside the hot loop.
+            final double boxMinX = box.minX;
+            final double boxMinY = box.minY;
+            final double boxMinZ = box.minZ;
+            final double boxMaxX = box.maxX;
+            final double boxMaxY = box.maxY;
+            final double boxMaxZ = box.maxZ;
+
             for (int section = min; section <= max; ++section) {
                 final BasicEntityList<Entity> list = entitiesBySection[section - minSection];
-
                 if (list == null) {
                     continue;
                 }
 
                 final Entity[] storage = list.storage;
+                final int len = Math.min(storage.length, list.size());
 
-                for (int i = 0, len = Math.min(storage.length, list.size()); i < len; ++i) {
+                for (int i = 0; i < len; ++i) {
                     final Entity entity = storage[i];
+                    if (entity == null || entity == except) {
+                        continue;
+                    }
 
-                    if (entity == null || entity == except || !entity.getBoundingBox().intersects(box)) {
+                    // Inline AABB#intersects to avoid a method call and use the cached AABB fields.
+                    final AABB entityBB = entity.getBoundingBox();
+                    if (entityBB.maxX <= boxMinX || entityBB.minX >= boxMaxX || entityBB.maxY <= boxMinY || entityBB.minY >= boxMaxY || entityBB.maxZ <= boxMinZ || entityBB.minZ >= boxMaxZ) {
+                        // Leaf end - Optimise getEntities
                         continue;
                     }
 
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index 456a287e4570f04b898e0ebdb3ccc91bb69f2fae..5d7d5d0b632782a6eae8cccb34e770e4b421d915 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -2350,7 +2350,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
 
     @Override
     public boolean isAlive() {
-        return !this.isRemoved() && this.getHealth() > 0.0F && !this.dead; // Paper - Check this.dead
+        return !this.dead && !this.isRemoved() && this.getHealth() > 0.0F; // Paper - Check this.dead // Leaf - Optimise getEntities - check the cheapest first
     }
 
     public boolean isLookingAtMe(LivingEntity entity, double tolerance, boolean scaleByDistance, boolean visual, double... yValues) {
