From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Wed, 23 Nov 2022 16:29:01 +0100
Subject: [PATCH] Predict Halloween

License: GPL-3.0 (https://www.gnu.org/licenses/gpl-3.0.html)
Gale - https://galemc.org

The Halloween date is 10/31
Cache the date result to prevent calculate in every call

The JMH benchmark of this patch can be found in SunBox's `PredictHalloween`

diff --git a/net/minecraft/util/SpecialDates.java b/net/minecraft/util/SpecialDates.java
index a6018d9fba0957fc721cebc9f366767fa04d4950..5d663a3b26de7eac1bfd25245b0cadb60d721264 100644
--- a/net/minecraft/util/SpecialDates.java
+++ b/net/minecraft/util/SpecialDates.java
@@ -13,12 +13,58 @@ public class SpecialDates {
     public static final MonthDay CHRISTMAS = MonthDay.of(Month.DECEMBER, 24);
     public static final MonthDay NEW_YEAR = MonthDay.of(Month.JANUARY, 1);
 
+    // Gale start - predict Halloween
+    /**
+     * The 1-indexed month of the year that Halloween starts (inclusive).
+     */
+    private static final int halloweenMonthOfYear = 10;
+
+    /**
+     * The 1-indexed day of the month that Halloween starts (inclusive).
+     */
+    private static final int halloweenDayOfMonth = 31;
+
+    /**
+     * The next start of Halloween, given as milliseconds since the Unix epoch.
+     * Will be 0 while not computed yet.
+     */
+    private static long nextHalloweenStart = 0;
+
+    /**
+     * The next end of Halloween, given as milliseconds since the Unix epoch.
+     * Will be 0 while not computed yet.
+     */
+    private static long nextHalloweenEnd = 0;
+    // Gale end - predict Halloween
+
     public static MonthDay dayNow() {
         return MonthDay.from(ZonedDateTime.now());
     }
 
     public static boolean isHalloween() {
-        return HALLOWEEN.equals(dayNow());
+        // Gale start - predict Halloween
+        long currentEpochMillis = System.currentTimeMillis();
+
+        // Update predicate
+        if (nextHalloweenEnd == 0 || currentEpochMillis >= nextHalloweenEnd) {
+            java.time.OffsetDateTime currentDate = java.time.OffsetDateTime.ofInstant(java.time.Instant.ofEpochMilli(currentEpochMillis), java.time.ZoneId.systemDefault())
+                .withHour(0).withMinute(0).withSecond(0).withNano(0); // Adjust to directly start or end at zero o'clock
+
+            java.time.OffsetDateTime thisHalloweenStart = currentDate.withMonth(halloweenMonthOfYear).withDayOfMonth(halloweenDayOfMonth);
+            java.time.OffsetDateTime thisHalloweenEnd = thisHalloweenStart.plusDays(1);
+
+            // Move to next year date if current passed
+            if (!currentDate.isBefore(thisHalloweenEnd)) {
+                thisHalloweenStart = thisHalloweenStart.plusYears(1);
+                thisHalloweenEnd = thisHalloweenEnd.plusYears(1);
+            }
+
+            nextHalloweenStart = thisHalloweenStart.toInstant().toEpochMilli();
+            nextHalloweenEnd = thisHalloweenEnd.toInstant().toEpochMilli();
+        }
+
+        return currentEpochMillis >= nextHalloweenStart && currentEpochMillis < nextHalloweenEnd;
+        // Gale end - predict Halloween
     }
 
     public static boolean isExtendedChristmas() {
