From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: hayanesuru <hayanesuru@outlook.jp>
Date: Mon, 11 Aug 2025 02:19:59 +0900
Subject: [PATCH] cache collision list


diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index ba9efafd8e58e1dee7d871892906f85b4cbdf89a..4599332ae1fd488c29e1f9332f557d3ee417ce47 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -1095,6 +1095,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public final org.dreeam.leaf.world.DespawnMap despawnMap = new org.dreeam.leaf.world.DespawnMap(paperConfig()); // Leaf - optimize despawn
     public final org.dreeam.leaf.world.NatureSpawnChunkMap natureSpawnChunkMap = new org.dreeam.leaf.world.NatureSpawnChunkMap(); // Leaf - optimize mob spawning
     public final org.dreeam.leaf.world.RandomTickSystem randomTickSystem = new org.dreeam.leaf.world.RandomTickSystem(); // Leaf - optimize random tick
+    public final org.dreeam.leaf.world.EntityCollisionCache entityCollisionCache = new org.dreeam.leaf.world.EntityCollisionCache(); // Leaf
+
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
         final net.minecraft.world.level.levelgen.BitRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Leaf - Faster random generator - upcasting
         ChunkPos pos = chunk.getPos();
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index 7dda8c5db2bbbfe04db07b1a053489b4d19f3f09..2b0c5d5920a3df8c4d6076c45d3191976f7abfec 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -1641,8 +1641,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
         final AABB currentBox = this.getBoundingBox();
 
-        final List<VoxelShape> potentialCollisionsVoxel = new ArrayList<>();
-        final List<AABB> potentialCollisionsBB = new ArrayList<>();
+        // final List<VoxelShape> potentialCollisionsVoxel = new ArrayList<>(); // Leaf
+        // final List<AABB> potentialCollisionsBB = new ArrayList<>(); // Leaf
 
         final AABB initialCollisionBox;
         if (xZero & zZero) {
@@ -1654,17 +1654,17 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             initialCollisionBox = currentBox.expandTowards(movement);
         }
 
-        final List<AABB> entityAABBs = new ArrayList<>();
+        org.dreeam.leaf.world.EntityCollisionCache entityCollisionCache = ((ServerLevel) this.level).entityCollisionCache; // Leaf
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getEntityHardCollisions(
-            this.level, (Entity)(Object)this, initialCollisionBox, entityAABBs, 0, null
+            this.level, (Entity)(Object)this, initialCollisionBox, entityCollisionCache.entityAABBs(), 0, null // Leaf
         );
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
-            this.level, (Entity)(Object)this, initialCollisionBox, potentialCollisionsVoxel, potentialCollisionsBB,
+            this.level, (Entity)(Object)this, initialCollisionBox, entityCollisionCache.potentialCollisionsVoxel(), entityCollisionCache.potentialCollisionsBB(),
             ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.COLLISION_FLAG_CHECK_BORDER, null
         );
-        potentialCollisionsBB.addAll(entityAABBs);
-        final Vec3 collided = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currentBox, potentialCollisionsVoxel, potentialCollisionsBB);
+        entityCollisionCache.potentialCollisionsBB().addAll(entityCollisionCache.entityAABBs()); // Leaf
+        final Vec3 collided = ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.performCollisions(movement, currentBox, entityCollisionCache.potentialCollisionsVoxel(), entityCollisionCache.potentialCollisionsBB()); // Leaf
 
         final boolean collidedX = collided.x != movement.x;
         final boolean collidedY = collided.y != movement.y;
@@ -1675,6 +1675,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         final double stepHeight;
 
         if ((!collidedDownwards && !this.onGround) || (!collidedX && !collidedZ) || (stepHeight = (double)this.maxUpStep()) <= 0.0) {
+            entityCollisionCache.clear(); // Leaf
             return collided;
         }
 
@@ -1685,7 +1686,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         }
 
         final List<VoxelShape> stepVoxels = new ArrayList<>();
-        final List<AABB> stepAABBs = entityAABBs;
+        final List<AABB> stepAABBs = entityCollisionCache.entityAABBs(); // Leaf
 
         ca.spottedleaf.moonrise.patches.collisions.CollisionUtil.getCollisionsForBlocksOrWorldBorder(
             this.level, (Entity)(Object)this, stepRetrievalBox, stepVoxels, stepAABBs,
@@ -1699,6 +1700,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             }
         }
 
+        entityCollisionCache.clear(); // Leaf
         return collided;
         // Paper end - optimise collisions
     }
