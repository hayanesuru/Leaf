From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Fri, 21 Feb 2025 15:06:55 +0100
Subject: [PATCH] Bulk writes to writeLongArray during chunk loading


diff --git a/net/minecraft/network/FriendlyByteBuf.java b/net/minecraft/network/FriendlyByteBuf.java
index f4bc9d05cd2349804eec832490fbb47862e5f073..5f8d007b14fa37b08fafe9a6f16edb8231b7c976 100644
--- a/net/minecraft/network/FriendlyByteBuf.java
+++ b/net/minecraft/network/FriendlyByteBuf.java
@@ -343,7 +343,7 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeLongArray(long[] array) {
-        writeLongArray(this, array);
+        writeLongArrayBulk(this, array); // Leaf - Bulk writes to writeLongArray during chunk loading
         return this;
     }
 
@@ -353,7 +353,7 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeFixedSizeLongArray(long[] array) {
-        writeFixedSizeLongArray(this, array);
+        writeFixedSizeLongArrayBulk(this, array); // Leaf - Bulk writes to writeLongArray during chunk loading
         return this;
     }
 
@@ -363,6 +363,50 @@ public class FriendlyByteBuf extends ByteBuf {
         }
     }
 
+    // Leaf start - Bulk writes to writeLongArray during chunk loading
+    public static void writeLongArrayBulk(FriendlyByteBuf buffer, long[] array) {
+        VarInt.write(buffer, array.length);
+        writeFixedSizeLongArrayBulk(buffer, array);
+    }
+
+    public static void writeFixedSizeLongArrayBulk(FriendlyByteBuf buffer, long[] array) {
+        if (array.length == 0) {
+            return;
+        }
+        int neededBytes = array.length * Long.BYTES;
+        int maxWritableBytes = buffer.source.maxWritableBytes();
+
+        if (maxWritableBytes >= neededBytes) {
+            buffer.source.ensureWritable(neededBytes);
+            int writerIndex = buffer.source.writerIndex();
+
+            if (buffer.source.hasArray()) {
+                byte[] dest = buffer.source.array();
+                int offset = buffer.source.arrayOffset() + writerIndex;
+
+                ByteBuffer buf = ByteBuffer.wrap(dest, offset, neededBytes).order(buffer.source.order());
+                buf.asLongBuffer().put(array);
+                buffer.source.writerIndex(writerIndex + neededBytes);
+            } else if (buffer.source.nioBufferCount() > 0) {
+                ByteBuffer nioBuf = buffer.source.nioBuffer(writerIndex, neededBytes);
+                nioBuf.asLongBuffer().put(array);
+                buffer.source.writerIndex(writerIndex + neededBytes);
+            } else {
+                ByteBuffer temp = ByteBuffer.allocate(neededBytes).order(buffer.source.order());
+                temp.asLongBuffer().put(array);
+                temp.rewind();
+                buffer.source.writeBytes(temp);
+            }
+        } else {
+            // Not enough space even at max capacity, use traditional approach
+            // which will write each element individually (and handle growing the buffer as needed)
+            for (long l : array) {
+                buffer.writeLong(l);
+            }
+        }
+    }
+    // Leaf end - Bulk writes to writeLongArray during chunk loading
+
     public long[] readLongArray() {
         return readLongArray(this);
     }
