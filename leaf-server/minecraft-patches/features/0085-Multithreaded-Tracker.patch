From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: peaches94 <peachescu94@gmail.com>
Date: Sat, 2 Jul 2022 00:35:56 -0500
Subject: [PATCH] Multithreaded Tracker

Original license: GPL v3
Original project: https://github.com/Bloom-host/Petal

Original license: GPL v3
Original project: https://github.com/TECHNOVE/Airplane-Experimental

Co-authored-by: Paul Sauve <paul@technove.co>
Co-authored-by: Kevin Raneri <kevin.raneri@gmail.com>
Co-authored-by: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>

This patch refactored from original multithreaded tracker (Petal version),
and is derived from the Airplane fork by Paul Sauve, the tree is like:
Airplane -> Pufferfish? -> Petal -> Leaf

We made much of tracking logic asynchronously, and fixed visible issue
for the case of some NPC plugins which using real entity type, e.g. Citizens.

But it is still recommending to use those packet based, virtual entity
based NPC plugins, e.g. ZNPC Plus, Adyeshach, Fancy NPC, etc.

diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
index dd2509996bfd08e8c3f9f2be042229eac6d7692d..a35e9fae8f8da0c42f0616c4f78dc396492673aa 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -342,7 +342,7 @@ public final class RegionizedPlayerChunkLoader {
         private boolean canGenerateChunks = true;
 
         private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
-        private final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        private final LongOpenHashSet sentChunks = org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled && !org.dreeam.leaf.config.modules.async.MultithreadedTracker.compatModeEnabled ? new org.dreeam.leaf.util.map.ConcurrentLongHashSet() : new LongOpenHashSet(); // Leaf - Multithreaded tracker
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
         private static final byte CHUNK_TICKET_STAGE_LOADING        = 1;
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index 5d9d233e3a568aa6297ed9c703fa450f98158602..24765ca23899b2eec049bf539c1f9eafc8b48d1b 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -248,6 +248,15 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         final ServerPlayer[] backingSet = inRange.getRawDataUnchecked();
+        // Leaf start - Multithreaded tracker
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled)
+            for (int i = 0, len = inRange.size(); i < len; i++) {
+                final ServerPlayer player = backingSet[i];
+                if (player == null) continue;
+                ++(player.mobCounts[index]);
+            }
+        else
+            // Leaf end - Multithreaded tracker
         for (int i = 0, len = inRange.size(); i < len; i++) {
             ++(backingSet[i].mobCounts[index]);
         }
@@ -951,6 +960,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
     // Paper end - optimise entity tracker
 
     protected void tick() {
+        // Leaf start - Multithreaded tracker
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+            final ServerLevel level = this.level;
+            org.dreeam.leaf.async.tracker.MultithreadedTracker.tick(level);
+            return;
+        }
+        // Leaf end - Multithreaded tracker
         // Paper start - optimise entity tracker
         if (true) {
             this.newTrackerTick();
@@ -1073,7 +1089,18 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         final Entity entity;
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        // Leaf start - Multithreaded tracker
+        public static final ServerPlayerConnection[] EMPTY_OBJECT_ARRAY = new ServerPlayerConnection[0];
+        public final Object sync = new Object();
+        public final Set<ServerPlayerConnection> seenBy = org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled ? it.unimi.dsi.fastutil.objects.ReferenceSets.synchronize(new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>()) : new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        private volatile ServerPlayerConnection[] seenByArray = EMPTY_OBJECT_ARRAY;
+        public ServerPlayerConnection[] seenBy() {
+            return seenByArray;
+        }
+        public void seenByUpdated() {
+            this.seenByArray = this.seenBy.toArray(EMPTY_OBJECT_ARRAY);
+        }
+        // Leaf end - Multithreaded tracker
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
@@ -1100,27 +1127,95 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             this.lastTrackedChunk = chunk;
 
             final ServerPlayer[] playersRaw = players.getRawDataUnchecked();
-
-            for (int i = 0, len = players.size(); i < len; ++i) {
+            final int playersLength = Math.min(playersRaw.length, players.size()); // Leaf - Multithreaded tracker
+            for (int i = 0; i < playersLength; ++i) { // Leaf - Multithreaded tracker
                 final ServerPlayer player = playersRaw[i];
                 this.updatePlayer(player);
             }
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                // Leaf start - Multithreaded tracker
+                boolean removed = false;
+                for (final ServerPlayerConnection conn : this.seenBy()) {
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
-                        this.removePlayer(player);
+                        removed |= this.removePlayerMulti(player);
                     }
                 }
+                if (removed) {
+                    this.seenByUpdated();
+                }
             }
         }
+        // Leaf end - Multithreaded tracker
+
+        // Leaf start - Multithreaded tracker
+        public final @Nullable Runnable leafTickCompact(final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk chunk) {
+            if (chunk == null) {
+                this.moonrise$clearPlayers();
+                return null;
+            }
+
+            final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = chunk.getPlayers(ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.VIEW_DISTANCE);
+
+            if (players == null) {
+                this.moonrise$clearPlayers();
+                return null;
+            }
+
+            final long lastChunkUpdate = this.lastChunkUpdate;
+            final long currChunkUpdate = chunk.getUpdateCount();
+            final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk lastTrackedChunk = this.lastTrackedChunk;
+            this.lastChunkUpdate = currChunkUpdate;
+            this.lastTrackedChunk = chunk;
+
+            final ServerPlayer[] playersRaw = players.getRawDataUnchecked();
+            final int playersLen = players.size(); // Ensure length won't change in the future tasks
+
+            if (!org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled || !org.dreeam.leaf.config.modules.async.MultithreadedTracker.compatModeEnabled) {
+                throw new IllegalStateException();
+            }
+            final boolean isServerPlayer = this.entity instanceof ServerPlayer;
+            final boolean isRealPlayer = isServerPlayer && ((ca.spottedleaf.moonrise.patches.chunk_system.player.ChunkSystemServerPlayer) this.entity).moonrise$isRealPlayer();
+            Runnable updatePlayerTasks = () -> {
+                for (int i = 0; i < playersLen; ++i) {
+                    final ServerPlayer player = playersRaw[i];
+                    this.updatePlayer(player);
+                }
+
+                if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
+                    // need to purge any players possible not in the chunk list
+                    boolean removed = false;
+                    for (final ServerPlayerConnection conn : this.seenBy()) {
+                        final ServerPlayer player = conn.getPlayer();
+                        if (!players.contains(player)) {
+                            removed |= this.removePlayerMulti(player);
+                        }
+                    }
+                    if (removed) {
+                        this.seenByUpdated();
+                    }
+                }
+            };
+
+            // Only update asynchronously for real player, and sync update for fake players
+            // This can fix compatibility issue with NPC plugins using real entity type, like Citizens
+            // To prevent visible issue with player type NPCs
+            // btw, still recommend to use packet based NPC plugins, like ZNPC Plus, Adyeshach, Fancy NPC, etc.
+            if (isRealPlayer || !isServerPlayer) {
+                return updatePlayerTasks;
+            } else {
+                updatePlayerTasks.run();
+                return null;
+            }
+        }
+        // Leaf end - Multithreaded tracker
 
         @Override
         public final void moonrise$removeNonTickThreadPlayers() {
             boolean foundToRemove = false;
-            for (final ServerPlayerConnection conn : this.seenBy) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Leaf - Multithreaded tracker
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(conn.getPlayer())) {
                     foundToRemove = true;
                     break;
@@ -1131,12 +1226,13 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 return;
             }
 
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Leaf - Multithreaded tracker
                 ServerPlayer player = conn.getPlayer();
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
-                    this.removePlayer(player);
+                    this.removePlayerMulti(player); // Leaf - Multithreaded tracker
                 }
             }
+            this.seenByUpdated(); // Leaf - Multithreaded tracker
         }
 
         @Override
@@ -1146,10 +1242,11 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
             if (this.seenBy.isEmpty()) {
                 return;
             }
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Leaf - Multithreaded tracker
                 ServerPlayer player = conn.getPlayer();
-                this.removePlayer(player);
+                this.removePlayerMulti(player); // Leaf - Multithreaded tracker
             }
+            this.seenByUpdated(); // Leaf - Multithreaded tracker
         }
 
         @Override
@@ -1176,7 +1273,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcast(Packet<?> packet) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy()) { // Leaf - petal - Multithreaded tracker
                 serverPlayerConnection.send(packet);
             }
         }
@@ -1189,21 +1286,34 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         public void broadcastRemoved() {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy()) { // Leaf - petal - Multithreaded tracker
                 this.serverEntity.removePairing(serverPlayerConnection.getPlayer());
             }
         }
 
+        // Leaf start - Multithreaded tracker
+        public boolean removePlayerMulti(ServerPlayer player) {
+            if (this.seenBy.remove(player.connection)) {
+                this.serverEntity.removePairing(player);
+                return true;
+            } else {
+                return false;
+            }
+        }
+        // Leaf end - Multithreaded tracker
+
         public void removePlayer(ServerPlayer player) {
-            org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
+            //org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot // Leaf - petal - Multithreaded tracker - We can remove async too
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
             }
+            this.seenByUpdated(); // Leaf - Multithreaded tracker
         }
 
         public void updatePlayer(ServerPlayer player) {
-            org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
+            //org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot // Leaf - petal - Multithreaded tracker - We can update async
             if (player != this.entity) {
+                if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled && player == null) return; // Leaf - Multithreaded tracker
                 // Paper start - remove allocation of Vec3D here
                 // Vec3 vec3 = player.position().subtract(this.entity.position());
                 double vec3_dx = player.getX() - this.entity.getX();
@@ -1231,6 +1341,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                 // CraftBukkit end
                 if (flag) {
                     if (this.seenBy.add(player.connection)) {
+                        this.seenByUpdated(); // Leaf - Multithreaded tracker
                         // Paper start - entity tracking events
                         if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 || new io.papermc.paper.event.player.PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity()).callEvent()) {
                         this.serverEntity.addPairing(player);
@@ -1239,6 +1350,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
                         this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
                     }
                 } else if (this.seenBy.remove(player.connection)) {
+                    this.seenByUpdated(); // Leaf - Multithreaded tracker
                     this.serverEntity.removePairing(player);
                 }
             }
diff --git a/net/minecraft/server/level/ServerBossEvent.java b/net/minecraft/server/level/ServerBossEvent.java
index f106373ef3ac4a8685c2939c9e8361688a285913..51ae390c68e7a3aa193329cc3bc47ca675930ff2 100644
--- a/net/minecraft/server/level/ServerBossEvent.java
+++ b/net/minecraft/server/level/ServerBossEvent.java
@@ -13,7 +13,7 @@ import net.minecraft.util.Mth;
 import net.minecraft.world.BossEvent;
 
 public class ServerBossEvent extends BossEvent {
-    private final Set<ServerPlayer> players = Sets.newHashSet();
+    private final Set<ServerPlayer> players = org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled ? Sets.newConcurrentHashSet() : Sets.newHashSet(); // Leaf - petal - Multithreaded tracker - players can be removed in async tracking
     private final Set<ServerPlayer> unmodifiablePlayers = Collections.unmodifiableSet(this.players);
     public boolean visible = true;
 
diff --git a/net/minecraft/server/level/ServerEntity.java b/net/minecraft/server/level/ServerEntity.java
index 1dee20436fc29537319ee456756a8e8f7b6fe66a..1f3e030cea42a0c9e27425cb18c232f482ef8608 100644
--- a/net/minecraft/server/level/ServerEntity.java
+++ b/net/minecraft/server/level/ServerEntity.java
@@ -70,6 +70,7 @@ public class ServerEntity {
     private boolean wasOnGround;
     @Nullable
     private List<SynchedEntityData.DataValue<?>> trackedDataValues;
+    public boolean wantSendDirtyEntityData = false; // Leaf - Multithreaded tracker
 
     // CraftBukkit start
     private final Set<net.minecraft.server.network.ServerPlayerConnection> trackedPlayers;
@@ -110,8 +111,16 @@ public class ServerEntity {
                 .forEach(
                     removedPassenger -> {
                         if (removedPassenger instanceof ServerPlayer serverPlayer1) {
-                            serverPlayer1.connection
-                                .teleport(serverPlayer1.getX(), serverPlayer1.getY(), serverPlayer1.getZ(), serverPlayer1.getYRot(), serverPlayer1.getXRot());
+                            // Leaf start - Multithreaded tracker - Ensure teleport is executed on server thread
+                            if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled && Thread.currentThread() instanceof org.dreeam.leaf.async.tracker.MultithreadedTracker.MultithreadedTrackerThread) {
+                                net.minecraft.server.MinecraftServer.getServer().scheduleOnMain(() -> serverPlayer1.connection
+                                    .teleport(serverPlayer1.getX(), serverPlayer1.getY(), serverPlayer1.getZ(), serverPlayer1.getYRot(), serverPlayer1.getXRot())
+                                );
+                            } else {
+                                serverPlayer1.connection
+                                    .teleport(serverPlayer1.getX(), serverPlayer1.getY(), serverPlayer1.getZ(), serverPlayer1.getYRot(), serverPlayer1.getXRot());
+                            }
+                            // Leaf end - Multithreaded tracker - Ensure teleport is executed on server thread
                         }
                     }
                 );
@@ -124,7 +133,7 @@ public class ServerEntity {
                 MapId mapId = itemFrame.cachedMapId; // Paper - Perf: Cache map ids on item frames
                 MapItemSavedData savedData = MapItem.getSavedData(mapId, this.level);
                 if (savedData != null) {
-                    for (final net.minecraft.server.network.ServerPlayerConnection connection : this.trackedPlayers) { // Paper
+                    for (final net.minecraft.server.network.ServerPlayerConnection connection : this.trackedPlayers.toArray(ChunkMap.TrackedEntity.EMPTY_OBJECT_ARRAY)) { // Paper // Leaf - Multithreaded tracker
                         final ServerPlayer serverPlayer = connection.getPlayer(); // Paper
                         savedData.tickCarriedBy(serverPlayer, item);
                         Packet<?> updatePacket = savedData.getUpdatePacket(mapId, serverPlayer);
@@ -425,6 +434,12 @@ public class ServerEntity {
     }
 
     public void sendDirtyEntityData() {
+        // Leaf start - Multithreaded tracker
+        if (Thread.currentThread() instanceof org.dreeam.leaf.async.tracker.MultithreadedTracker.MultithreadedTrackerThread) {
+            wantSendDirtyEntityData = true;
+            return;
+        }
+        // Leaf end - Multithreaded tracker
         SynchedEntityData entityData = this.entity.getEntityData();
         List<SynchedEntityData.DataValue<?>> list = entityData.packDirty();
         if (list != null) {
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 275b640f4536366152f59acf071dd4eba15696c8..a669a59a42f814480879a52d2da5e04c636720de 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -2522,7 +2522,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public LevelEntityGetter<Entity> getEntities() {
-        org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp("Chunk getEntities call"); // Spigot // Leaf - Multithreaded tracker
         return this.moonrise$getEntityLookup(); // Paper - rewrite chunk system
     }
 
@@ -2754,7 +2754,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                         }
 
                         map.carriedByPlayers.remove(player);
-                        if (map.carriedBy.removeIf(holdingPlayer -> holdingPlayer.player == player)) {
+                        if (map.carriedBy.removeIf(holdingPlayer -> holdingPlayer != null && holdingPlayer.player == player)) { // Leaf - Multithreaded tracker
                             map.decorations.remove(player.getName().getString());
                         }
                     }
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 04bf8bba0d8c0d5459605253dcc3f135bf43fd95..abe79d07196de0a10a382d4c37161c7eb4a604ae 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1819,7 +1819,7 @@ public class ServerGamePacketListenerImpl
     }
 
     public void internalTeleport(PositionMoveRotation posMoveRotation, Set<Relative> relatives) {
-        org.spigotmc.AsyncCatcher.catchOp("teleport"); // Paper
+        //org.spigotmc.AsyncCatcher.catchOp("teleport"); // Paper // Leaf - Multithreaded tracker
         // Paper start - Prevent teleporting dead entities
         if (this.player.isRemoved()) {
             LOGGER.info("Attempt to teleport removed player {} restricted", player.getScoreboardName());
diff --git a/net/minecraft/world/entity/item/PrimedTnt.java b/net/minecraft/world/entity/item/PrimedTnt.java
index c96f458994818392857642282ec3d492124885da..d345afd14ef6fe2f0a584df5dfa080fd7ab3f47e 100644
--- a/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/net/minecraft/world/entity/item/PrimedTnt.java
@@ -142,12 +142,14 @@ public class PrimedTnt extends Entity implements TraceableEntity {
                 net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket velocityPacket = new net.minecraft.network.protocol.game.ClientboundSetEntityMotionPacket(this);
                 net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket positionPacket = net.minecraft.network.protocol.game.ClientboundTeleportEntityPacket.teleport(this.getId(), net.minecraft.world.entity.PositionMoveRotation.of(this), java.util.Set.of(), this.onGround);
 
-                ete.seenBy.stream()
-                    .filter(viewer -> (viewer.getPlayer().getX() - this.getX()) * (viewer.getPlayer().getY() - this.getY()) * (viewer.getPlayer().getZ() - this.getZ()) < 16 * 16)
-                    .forEach(viewer -> {
+                // Leaf start - Multithreaded tracker
+                for (var viewer : ete.seenBy()) {
+                    if ((viewer.getPlayer().getX() - this.getX()) * (viewer.getPlayer().getY() - this.getY()) * (viewer.getPlayer().getZ() - this.getZ()) < 16 * 16) {
                         viewer.send(velocityPacket);
                         viewer.send(positionPacket);
-                    });
+                    }
+                }
+                // Leaf end - Multithreaded tracker
             }
         }
         // Paper end - Option to prevent TNT from moving in water
diff --git a/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java b/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
index 724466d14c925704671e510cea1919ee95a2ae02..4426b344677ab9f2753dd2d219921bcb7cf39980 100644
--- a/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
@@ -35,13 +35,20 @@ public class NewMinecartBehavior extends MinecartBehavior {
     private int cachedLerpDelay;
     private float cachedPartialTick;
     private int lerpDelay = 0;
-    public final List<NewMinecartBehavior.MinecartStep> lerpSteps = new LinkedList<>();
+    public final List<NewMinecartBehavior.MinecartStep> lerpSteps; // Leaf - Multithreaded tracker
     public final List<NewMinecartBehavior.MinecartStep> currentLerpSteps = new LinkedList<>();
     public double currentLerpStepsTotalWeight = 0.0;
     public NewMinecartBehavior.MinecartStep oldLerp = NewMinecartBehavior.MinecartStep.ZERO;
 
     public NewMinecartBehavior(AbstractMinecart minecart) {
         super(minecart);
+        // Leaf start - Multithreaded tracker
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+            lerpSteps = it.unimi.dsi.fastutil.objects.ObjectLists.synchronize(new it.unimi.dsi.fastutil.objects.ObjectArrayList<>());
+        } else {
+            lerpSteps = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+        }
+        // Leaf end - Multithreaded tracker
     }
 
     @Override
diff --git a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
index 681dec447486138088fe5f705ef4fadab531139f..27f8a22d798a17dbd5949d1b6ff0526837fe91d5 100644
--- a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -279,6 +279,7 @@ public class MapItemSavedData extends SavedData {
 
         for (int i = 0; i < this.carriedBy.size(); i++) {
             MapItemSavedData.HoldingPlayer holdingPlayer1 = this.carriedBy.get(i);
+            if (holdingPlayer1 == null) continue; // Leaf - Multithreaded tracker
             Player player1 = holdingPlayer1.player;
             String string = player1.getName().getString();
             if (!player1.isRemoved() && (player1.getInventory().contains(predicate) || mapStack.isFramed())) {
