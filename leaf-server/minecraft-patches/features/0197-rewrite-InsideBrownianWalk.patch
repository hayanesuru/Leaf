From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Wed, 19 Mar 2025 15:18:58 +0100
Subject: [PATCH] rewrite InsideBrownianWalk

License: LGPL-3.0 (https://www.gnu.org/licenses/lgpl-3.0.html)

This method is mainly visible when ton of villagers suddenly wants to sleep.

diff --git a/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java b/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java
index 55e2396d8c2f74df4a38c4b556b5dad64dd33b1d..13724f5463aa6a1a1ec91cc361ab3862d038b9e8 100644
--- a/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java
+++ b/net/minecraft/world/entity/ai/behavior/InsideBrownianWalk.java
@@ -20,16 +20,29 @@ public class InsideBrownianWalk {
                             return false;
                         } else {
                             BlockPos blockPos = mob.blockPosition();
-                            List<BlockPos> list = BlockPos.betweenClosedStream(blockPos.offset(-1, -1, -1), blockPos.offset(1, 1, 1))
-                                .map(BlockPos::immutable)
-                                .collect(Util.toMutableList());
-                            Collections.shuffle(list);
-                            list.stream()
-                                .filter(pos -> !level.canSeeSky(pos))
-                                .filter(pos -> level.loadedAndEntityCanStandOn(pos, mob))
-                                .filter(pos -> level.noCollision(mob))
-                                .findFirst()
-                                .ifPresent(pos -> walkTarget.set(new WalkTarget(pos, speedModifier, 0)));
+                            // Leaf start - rewrite InsideBrownianWalk
+                            BlockPos[] list = org.dreeam.leaf.util.BlockAreaUtils.getBlocksBetween(
+                                blockPos.offset(-1, -1, -1),
+                                blockPos.offset(1, 1, 1)
+                            );
+
+                            // Fisher-Yates shuffle is faster for this case
+                            for (int i = list.length - 1; i > 0; i--) {
+                                int j = mob.random.nextInt(i + 1);
+                                BlockPos temp = list[i];
+                                list[i] = list[j];
+                                list[j] = temp;
+                            }
+
+                            for (BlockPos pos : list) {
+                                if (!level.canSeeSky(pos) &&
+                                    level.loadedAndEntityCanStandOn(pos, mob) &&
+                                    level.noCollision(mob)) {
+                                    walkTarget.set(new WalkTarget(pos, speedModifier, 0));
+                                    break;
+                                }
+                            }
+                            // Leaf end - rewrite InsideBrownianWalk
                             return true;
                         }
                     }
