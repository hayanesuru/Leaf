From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Sat, 7 Jun 2025 23:22:56 +0200
Subject: [PATCH] Use ActivationList on runningBehaviors


diff --git a/net/minecraft/world/entity/ai/Brain.java b/net/minecraft/world/entity/ai/Brain.java
index 34b66ee67927bc0796d6c5f069393618abca9d74..f7dd07feea8884c686e78becb1f9cbd0d2769915 100644
--- a/net/minecraft/world/entity/ai/Brain.java
+++ b/net/minecraft/world/entity/ai/Brain.java
@@ -61,6 +61,7 @@ public class Brain<E extends LivingEntity> {
     private long lastScheduleUpdate = -9999L;
 
     private ObjectArrayList<BehaviorControl<? super E>> cachedPotentialBehaviors;
+    private org.dreeam.leaf.util.list.ActivationList<BehaviorControl<? super E>> runningBehaviors;
     public static <E extends LivingEntity> Brain.Provider<E> provider(
         Collection<? extends MemoryModuleType<?>> memoryTypes, Collection<? extends SensorType<? extends Sensor<? super E>>> sensorTypes
     ) {
@@ -273,19 +274,7 @@ public class Brain<E extends LivingEntity> {
     @Deprecated
     @VisibleForDebug
     public List<BehaviorControl<? super E>> getRunningBehaviors() {
-        List<BehaviorControl<? super E>> list = new ObjectArrayList<>();
-
-        for (Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
-            for (Set<BehaviorControl<? super E>> set : map.values()) {
-                for (BehaviorControl<? super E> behaviorControl : set) {
-                    if (behaviorControl.getStatus() == Behavior.Status.RUNNING) {
-                        list.add(behaviorControl);
-                    }
-                }
-            }
-        }
-
-        return list;
+        return this.getRunningBehaviorsList();
     }
 
     public void useDefaultActivity() {
@@ -453,12 +442,14 @@ public class Brain<E extends LivingEntity> {
         long gameTime = owner.level().getGameTime();
 
         for (BehaviorControl<? super E> behaviorControl : this.getRunningBehaviors()) {
+            this.getRunningBehaviorsList().setVisibility(behaviorControl, false);
             behaviorControl.doStop(level, owner, gameTime);
         }
     }
 
     private void invalidateBehaviorCache() {
         this.cachedPotentialBehaviors = null;
+        this.runningBehaviors = null;
     }
 
     private void rebuildBehaviorCache() {
@@ -476,6 +467,25 @@ public class Brain<E extends LivingEntity> {
         }
     }
 
+    private void initializeRunningBehaviors() {
+        this.runningBehaviors = new org.dreeam.leaf.util.list.ActivationList<>(false);
+
+        for (Map<Activity, Set<BehaviorControl<? super E>>> map : this.availableBehaviorsByPriority.values()) {
+            for (Set<BehaviorControl<? super E>> set : map.values()) {
+                for (BehaviorControl<? super E> task : set) {
+                    this.runningBehaviors.addOrUpdate(task, task.getStatus() == Behavior.Status.RUNNING);
+                }
+            }
+        }
+    }
+
+    private org.dreeam.leaf.util.list.ActivationList<BehaviorControl<? super E>> getRunningBehaviorsList() {
+        if (this.runningBehaviors == null) {
+            this.initializeRunningBehaviors();
+        }
+        return this.runningBehaviors;
+    }
+
     private ObjectArrayList<BehaviorControl<? super E>> getPotentialBehaviors() {
         if (this.cachedPotentialBehaviors == null) {
             this.rebuildBehaviorCache();
@@ -489,6 +499,9 @@ public class Brain<E extends LivingEntity> {
         for (BehaviorControl<? super E> task : this.getPotentialBehaviors()) {
             if (task.getStatus() == Behavior.Status.STOPPED) {
                 task.tryStart(level, entity, startTime);
+                if (task.getStatus() == Behavior.Status.RUNNING) {
+                    this.getRunningBehaviorsList().setVisibility(task, true);
+                }
             }
         }
     }
@@ -498,6 +511,9 @@ public class Brain<E extends LivingEntity> {
 
         for (BehaviorControl<? super E> behaviorControl : this.getRunningBehaviors()) {
             behaviorControl.tickOrStop(level, entity, gameTime);
+            if (behaviorControl.getStatus() != Behavior.Status.RUNNING) {
+                this.getRunningBehaviorsList().setVisibility(behaviorControl, false);
+            }
         }
     }
 
