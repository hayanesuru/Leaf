From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Fri, 21 Feb 2025 15:06:55 +0100
Subject: [PATCH] Bulk writes to writeLongArray during chunk loading


diff --git a/net/minecraft/network/FriendlyByteBuf.java b/net/minecraft/network/FriendlyByteBuf.java
index b53179a3a7afa4099f48d6e9bbe064a88d6c59f4..1df8091b85ad50f9c95e4fd427ed8885f3f5a52e 100644
--- a/net/minecraft/network/FriendlyByteBuf.java
+++ b/net/minecraft/network/FriendlyByteBuf.java
@@ -354,7 +354,7 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeLongArray(long[] array) {
-        writeLongArray(this, array);
+        writeLongArrayBulk(this, array); // Leaf - Bulk writes to writeLongArray during chunk loading
         return this;
     }
 
@@ -364,7 +364,7 @@ public class FriendlyByteBuf extends ByteBuf {
     }
 
     public FriendlyByteBuf writeFixedSizeLongArray(long[] array) {
-        writeFixedSizeLongArray(this, array);
+        writeFixedSizeLongArrayBulk(this, array); // Leaf - Bulk writes to writeLongArray during chunk loading
         return this;
     }
 
@@ -374,6 +374,50 @@ public class FriendlyByteBuf extends ByteBuf {
         }
     }
 
+    // Leaf start - Bulk writes to writeLongArray during chunk loading
+    public static void writeLongArrayBulk(FriendlyByteBuf buffer, long[] array) {
+        VarInt.write(buffer, array.length);
+        writeFixedSizeLongArrayBulk(buffer, array);
+    }
+
+    public static void writeFixedSizeLongArrayBulk(FriendlyByteBuf buffer, long[] array) {
+        if (array.length == 0) {
+            return;
+        }
+        int neededBytes = array.length * Long.BYTES;
+        int maxWritableBytes = buffer.source.maxWritableBytes();
+
+        if (maxWritableBytes >= neededBytes) {
+            buffer.source.ensureWritable(neededBytes);
+            int writerIndex = buffer.source.writerIndex();
+
+            if (buffer.source.hasArray()) {
+                byte[] dest = buffer.source.array();
+                int offset = buffer.source.arrayOffset() + writerIndex;
+
+                ByteBuffer buf = ByteBuffer.wrap(dest, offset, neededBytes).order(buffer.source.order());
+                buf.asLongBuffer().put(array);
+                buffer.source.writerIndex(writerIndex + neededBytes);
+            } else if (buffer.source.nioBufferCount() > 0) {
+                ByteBuffer nioBuf = buffer.source.nioBuffer(writerIndex, neededBytes);
+                nioBuf.asLongBuffer().put(array);
+                buffer.source.writerIndex(writerIndex + neededBytes);
+            } else {
+                ByteBuffer temp = ByteBuffer.allocate(neededBytes).order(buffer.source.order());
+                temp.asLongBuffer().put(array);
+                temp.rewind();
+                buffer.source.writeBytes(temp);
+            }
+        } else {
+            // Not enough space even at max capacity, use traditional approach
+            // which will write each element individually (and handle growing the buffer as needed)
+            for (long l : array) {
+                buffer.writeLong(l);
+            }
+        }
+    }
+    // Leaf end - Bulk writes to writeLongArray during chunk loading
+
     public long[] readLongArray() {
         return readLongArray(this);
     }
