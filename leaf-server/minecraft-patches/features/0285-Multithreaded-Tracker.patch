From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: peaches94 <peachescu94@gmail.com>
Date: Sat, 2 Jul 2022 00:35:56 -0500
Subject: [PATCH] Multithreaded Tracker

Original license: GPL v3
Original project: https://github.com/Bloom-host/Petal

Original license: GPL v3
Original project: https://github.com/TECHNOVE/Airplane-Experimental

Co-authored-by: Paul Sauve <paul@technove.co>
Co-authored-by: Kevin Raneri <kevin.raneri@gmail.com>
Co-authored-by: HaHaWTH <102713261+HaHaWTH@users.noreply.github.com>
Co-authored-by: hayanesuru <hayanesuru@outlook.jp>

This patch refactored from original multithreaded tracker (Petal version),
and is derived from the Airplane fork by Paul Sauve, the tree is like:
Airplane -> Pufferfish(?) -> Petal -> Leaf

The core logic has beed reworked compared to the old one, can handle larger
scale situation better now.
Current impl includes many improvements and fixes we made, such as
plugin compat issues with some NPC plugins using real entity type,
e.g. Citizens.

However we still recommend to use those packet based NPC plugins,
e.g. ZNPC Plus, Adyeshach, Fancy NPC, etc.

diff --git a/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java b/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
index 288a3eb57f3431dd624ad8a4b08684563abbc5ad..499cad369242f9ad724b3251538d62d8dc8d2ec8 100644
--- a/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
+++ b/ca/spottedleaf/moonrise/common/misc/NearbyPlayers.java
@@ -164,6 +164,8 @@ public final class NearbyPlayers {
         private int nonEmptyLists;
         private long updateCount;
 
+        public final it.unimi.dsi.fastutil.objects.ReferenceSet<ServerPlayer> playersTracking = org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled ? it.unimi.dsi.fastutil.objects.ReferenceSets.synchronize(new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(1)) : null; // Leaf - Multithreaded tracker
+        public final java.util.concurrent.atomic.AtomicLong trackingUpdateCountAtomic = org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled ? new java.util.concurrent.atomic.AtomicLong(0) : null; // Leaf - Multithreaded tracker
         public TrackedChunk(final long chunkKey, final NearbyPlayers nearbyPlayers) {
             this.chunkKey = chunkKey;
             this.nearbyPlayers = nearbyPlayers;
@@ -177,6 +179,12 @@ public final class NearbyPlayers {
             return this.updateCount;
         }
 
+        // Leaf start - Multithreaded tracker
+        public long getAtomicUpdateCount() {
+            return this.trackingUpdateCountAtomic.get() | 0x1000000000000000L;
+        }
+        // Leaf end - Multithreaded tracker
+
         public ReferenceList<ServerPlayer> getPlayers(final NearbyMapType type) {
             return this.players[type.ordinal()];
         }
@@ -185,6 +193,12 @@ public final class NearbyPlayers {
             ++this.updateCount;
 
             final int idx = type.ordinal();
+            // Leaf start - Multithreaded tracker
+            if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled && idx == NearbyMapType.VIEW_DISTANCE.ordinal()) {
+                this.trackingUpdateCountAtomic.getAndIncrement();
+                this.playersTracking.add(player);
+            }
+            // Leaf end - Multithreaded tracker
             final ReferenceList<ServerPlayer> list = this.players[idx];
             if (list == null) {
                 ++this.nonEmptyLists;
@@ -203,6 +217,12 @@ public final class NearbyPlayers {
             ++this.updateCount;
 
             final int idx = type.ordinal();
+            // Leaf start - Multithreaded tracker
+            if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled && type == NearbyMapType.VIEW_DISTANCE) {
+                this.trackingUpdateCountAtomic.getAndIncrement();
+                this.playersTracking.remove(player);
+            }
+            // Leaf end - Multithreaded tracker
             final ReferenceList<ServerPlayer> list = this.players[idx];
             if (list == null) {
                 throw new IllegalStateException("Does not contain player " + player);
diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
index 7a40cef6c0edf4bb728f74f0c2e93c7e9f34a1b3..3ca08ab3b57c278748ad58ab03751f25ab6202e5 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -345,7 +345,7 @@ public final class RegionizedPlayerChunkLoader {
         private boolean canGenerateChunks = true;
 
         private final ArrayDeque<ChunkHolderManager.TicketOperation<?, ?>> delayedTicketOps = new ArrayDeque<>();
-        private final LongOpenHashSet sentChunks = new LongOpenHashSet();
+        private final LongOpenHashSet sentChunks = org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled ? new org.dreeam.leaf.util.map.SyncLongOpenHashSet() : new LongOpenHashSet(); // Leaf - Multithreaded tracker
 
         private static final byte CHUNK_TICKET_STAGE_NONE           = 0;
         private static final byte CHUNK_TICKET_STAGE_LOADING        = 1;
@@ -423,6 +423,14 @@ public final class RegionizedPlayerChunkLoader {
 
                 PlatformHooks.get().onChunkWatch(this.world, chunk, this.player);
                 PlayerChunkSender.sendChunk(this.player.connection, this.world, chunk);
+                // Leaf start - Multithreaded tracker
+                if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+                    ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk trackedChunk = chunk.moonrise$getChunkHolder().holderData.nearbyPlayers;
+                    if (trackedChunk != null) {
+                        trackedChunk.trackingUpdateCountAtomic.getAndIncrement();
+                    }
+                }
+                // Leaf end - Multithreaded tracker
                 return;
             }
             throw new IllegalStateException();
diff --git a/io/papermc/paper/FeatureHooks.java b/io/papermc/paper/FeatureHooks.java
index 22f37a0779996c9e3a9416a2a1ba2bee74e3f568..e0f5ed5109402dcef0a71c44d0877c15c22f6f7c 100644
--- a/io/papermc/paper/FeatureHooks.java
+++ b/io/papermc/paper/FeatureHooks.java
@@ -81,10 +81,22 @@ public final class FeatureHooks {
         final LongOpenHashSet rawChunkKeys = player.moonrise$getChunkLoader().getSentChunksRaw();
         final ObjectSet<org.bukkit.Chunk> chunks = new ObjectOpenHashSet<>(rawChunkKeys.size());
         final World world = player.level().getWorld();
-        final LongIterator iter = player.moonrise$getChunkLoader().getSentChunksRaw().longIterator();
-        while (iter.hasNext()) {
-            chunks.add(world.getChunkAt(iter.nextLong(), false));
+        // Leaf start - Multithreaded tracker
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+            final LongOpenHashSet set = player.moonrise$getChunkLoader().getSentChunksRaw();
+            synchronized (set) {
+                final LongIterator iter = set.longIterator();
+                while (iter.hasNext()) {
+                    chunks.add(world.getChunkAt(iter.nextLong(), false));
+                }
+            }
+        } else {
+            final LongIterator iter = player.moonrise$getChunkLoader().getSentChunksRaw().longIterator();
+            while (iter.hasNext()) {
+                chunks.add(world.getChunkAt(iter.nextLong(), false));
+            }
         }
+        // Leaf end - Multithreaded tracker
         // Paper end - rewrite chunk system
         return ObjectSets.unmodifiable(chunks);
     }
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index 7c7934b7379ad7c9b0adb497b3c38ab510f7595b..d896a33a39f8385cffa526e3ea838979c1956bf9 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -1984,6 +1984,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         // Leaf end - SparklyPaper - parallel world ticking
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
 
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) { for (ServerLevel world : getAllLevels()) { world.leaf$asyncTracker.onTickEnd(); } } // Leaf - Multithreaded tracker
+
         profilerFiller.popPush("connection");
         this.tickConnection();
         profilerFiller.popPush("players");
@@ -2082,6 +2084,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) level.tickExecutor.shutdown(); // Leaf - SparklyPaper - parallel world ticking (We remove it in here instead of ServerLevel.close() because ServerLevel.close() is never called!)
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) { level.leaf$asyncTracker.onTickEnd(); } // Leaf - Multithreaded tracker
         this.levels = Collections.unmodifiableMap(newLevels);
     }
     // CraftBukkit end
diff --git a/net/minecraft/server/level/ChunkMap.java b/net/minecraft/server/level/ChunkMap.java
index 21340bd7fd7a90dfef705c3819a391763a835e3e..d5e1ef4b6b3a882c6f05f3be35d1681bf30b485c 100644
--- a/net/minecraft/server/level/ChunkMap.java
+++ b/net/minecraft/server/level/ChunkMap.java
@@ -1076,6 +1076,13 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
     // Paper end - optimise entity tracker
 
     protected void tick() {
+        // Leaf start - Multithreaded tracker
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+            final ServerLevel level = this.level;
+            level.leaf$asyncTracker.tick(level);
+            return;
+        }
+        // Leaf end - Multithreaded tracker
         // Paper start - optimise entity tracker
         if (true) {
             this.newTrackerTick();
@@ -1225,12 +1232,60 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
         final Entity entity;
         private final int range;
         SectionPos lastSectionPos;
-        public final Set<ServerPlayerConnection> seenBy = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(); // Paper - Perf: optimise map impl
+        // Leaf start - Multithreaded tracker
+        public static final ServerPlayerConnection[] EMPTY_OBJECT_ARRAY = new ServerPlayerConnection[0];
+
+        private class SeenBySet extends it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<ServerPlayerConnection> {
+            @Override
+            public boolean add(ServerPlayerConnection serverPlayerConnection) {
+                if (super.add(serverPlayerConnection)) {
+                    // for plugin compatibility
+                    TrackedEntity.this.seenByUpdated = true;
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+
+            @Override
+            public boolean remove(Object k) {
+                if (super.remove(k)) {
+                    // for plugin compatibility
+                    TrackedEntity.this.seenByUpdated = true;
+                    return true;
+                } else {
+                    return false;
+                }
+            }
+
+            @Override
+            public void clear() {
+                TrackedEntity.this.seenByUpdated = true;
+                super.clear();
+            }
+        }
+
+        public final Set<ServerPlayerConnection> seenBy = org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled ? it.unimi.dsi.fastutil.objects.ReferenceSets.synchronize(new SeenBySet()) : new SeenBySet(); // Paper - Perf: optimise map impl
+        private volatile boolean seenByUpdated = false;
+        private volatile ServerPlayerConnection[] seenByArray = EMPTY_OBJECT_ARRAY;
+        public ServerPlayerConnection[] seenBy() {
+            if (!seenByUpdated) {
+                return seenByArray;
+            } else {
+                return seenBy.toArray(EMPTY_OBJECT_ARRAY);
+            }
+        }
+        public void seenByUpdated() {
+            this.seenByArray = this.seenBy.toArray(EMPTY_OBJECT_ARRAY);
+            seenByUpdated = false;
+        }
+        // Leaf end - Multithreaded tracker
 
         // Paper start - optimise entity tracker
         private long lastChunkUpdate = -1L;
         private ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk lastTrackedChunk;
 
+        // Leaf - Multithreaded tracker - diff on change
         @Override
         public final void moonrise$tick(final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk chunk) {
             if (chunk == null) {
@@ -1240,6 +1295,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
 
             final ca.spottedleaf.moonrise.common.list.ReferenceList<ServerPlayer> players = chunk.getPlayers(ca.spottedleaf.moonrise.common.misc.NearbyPlayers.NearbyMapType.VIEW_DISTANCE);
 
+            // Leaf - Multithreaded tracker - diff on change
             if (players == null) {
                 this.moonrise$clearPlayers();
                 return;
@@ -1252,27 +1308,35 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
             this.lastTrackedChunk = chunk;
 
             final ServerPlayer[] playersRaw = players.getRawDataUnchecked();
-
-            for (int i = 0, len = players.size(); i < len; ++i) {
+            // Leaf start - Multithreaded tracker
+            final int playersLength = Math.min(playersRaw.length, players.size());
+            boolean updated = false;
+            for (int i = 0; i < playersLength; ++i) {
                 final ServerPlayer player = playersRaw[i];
-                this.updatePlayer(player);
+                updated |= this.updatePlayerMulti(player);
             }
+            if (updated) seenByUpdated();
+            // Leaf end - Multithreaded tracker
 
             if (lastChunkUpdate != currChunkUpdate || lastTrackedChunk != chunk) {
                 // need to purge any players possible not in the chunk list
-                for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+                // Leaf start - Multithreaded tracker
+                boolean removed = false;
+                for (final ServerPlayerConnection conn : this.seenBy()) {
                     final ServerPlayer player = conn.getPlayer();
                     if (!players.contains(player)) {
-                        this.removePlayer(player);
+                        removed |= this.removePlayerMulti(player);
                     }
                 }
+                if (removed) this.seenByUpdated();
+                // Leaf end - Multithreaded tracker
             }
         }
 
         @Override
         public final void moonrise$removeNonTickThreadPlayers() {
             boolean foundToRemove = false;
-            for (final ServerPlayerConnection conn : this.seenBy) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Leaf - Multithreaded tracker
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(conn.getPlayer())) {
                     foundToRemove = true;
                     break;
@@ -1283,12 +1347,13 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
                 return;
             }
 
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Leaf - Multithreaded tracker
                 ServerPlayer player = conn.getPlayer();
                 if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
-                    this.removePlayer(player);
+                    this.removePlayerMulti(player); // Leaf - Multithreaded tracker
                 }
             }
+            this.seenByUpdated(); // Leaf - Multithreaded tracker
         }
 
         @Override
@@ -1298,10 +1363,11 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
             if (this.seenBy.isEmpty()) {
                 return;
             }
-            for (final ServerPlayerConnection conn : new java.util.ArrayList<>(this.seenBy)) {
+            for (final ServerPlayerConnection conn : this.seenBy()) { // Leaf - Multithreaded tracker
                 ServerPlayer player = conn.getPlayer();
-                this.removePlayer(player);
+                this.removePlayerMulti(player); // Leaf - Multithreaded tracker
             }
+            this.seenByUpdated(); // Leaf - Multithreaded tracker
         }
 
         @Override
@@ -1329,7 +1395,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
 
         @Override
         public void sendToTrackingPlayers(Packet<? super ClientGamePacketListener> packet) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy()) { // Leaf - petal - Multithreaded tracker
                 serverPlayerConnection.send(packet);
             }
         }
@@ -1344,7 +1410,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
 
         @Override
         public void sendToTrackingPlayersFiltered(Packet<? super ClientGamePacketListener> packet, Predicate<ServerPlayer> filter) {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy()) { // Leaf - petal - Multithreaded tracker
                 if (filter.test(serverPlayerConnection.getPlayer())) {
                     serverPlayerConnection.send(packet);
                 }
@@ -1352,7 +1418,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
         }
 
         public void broadcastRemoved() {
-            for (ServerPlayerConnection serverPlayerConnection : this.seenBy) {
+            for (ServerPlayerConnection serverPlayerConnection : this.seenBy()) { // Leaf - petal - Multithreaded tracker
                 this.serverEntity.removePairing(serverPlayerConnection.getPlayer());
             }
         }
@@ -1361,6 +1427,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
             org.spigotmc.AsyncCatcher.catchOp("player tracker clear"); // Spigot
             if (this.seenBy.remove(player.connection)) {
                 this.serverEntity.removePairing(player);
+                this.seenByUpdated(); // Leaf - Multithreaded tracker
                 if (this.seenBy.isEmpty()) {
                     ChunkMap.this.level.debugSynchronizers().dropEntity(this.entity);
                 }
@@ -1397,6 +1464,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
                 // CraftBukkit end
                 if (flag) {
                     if (this.seenBy.add(player.connection)) {
+                        this.seenByUpdated(); // Leaf - Multithreaded tracker
                         // Paper start - entity tracking events
                         if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 || new io.papermc.paper.event.player.PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity()).callEvent()) {
                         this.serverEntity.addPairing(player);
@@ -1410,7 +1478,7 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
                         this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
                     }
                 } else {
-                    this.removePlayer(player);
+                    this.removePlayer(player); // Leaf - Multithreaded tracker - diff on change
                 }
             }
         }
@@ -1440,10 +1508,156 @@ public class ChunkMap extends SimpleRegionStorage implements ChunkHolder.PlayerP
             // Paper end - optimise entity tracker
         }
 
+        // Leaf start - Multithreaded tracker
+        public final boolean leaf$tick(final org.dreeam.leaf.async.tracker.TrackerCtx ctx, final ca.spottedleaf.moonrise.common.misc.NearbyPlayers.TrackedChunk chunk) {
+            if (chunk == null || chunk.playersTracking.isEmpty()) {
+                this.lastChunkUpdate = -1L;
+                this.lastTrackedChunk = null;
+                for (final ServerPlayerConnection conn : this.seenBy()) {
+                    if (this.seenBy.remove(conn)) {
+                        ctx.stopSeenByPlayer(conn, this.entity);
+                    }
+                }
+                this.seenByUpdated();
+                return false;
+            }
+
+            final it.unimi.dsi.fastutil.objects.ReferenceSet<ServerPlayer> players = chunk.playersTracking;
+            final long currChunkUpdate = chunk.getAtomicUpdateCount();
+            final boolean chunkStateChanged = this.lastChunkUpdate != currChunkUpdate || this.lastTrackedChunk != chunk;
+            this.lastChunkUpdate = currChunkUpdate;
+            this.lastTrackedChunk = chunk;
+
+            if (!(chunkStateChanged || ((entity.tickCount + entity.getId()) & 15) == 15)) {
+                return this.seenBy().length != 0;
+            }
+
+            boolean updated = false;
+            final double ex = this.entity.getX();
+            final double ey = this.entity.getY();
+            final double ez = this.entity.getZ();
+            final int eChunkX = this.entity.chunkPosition().x;
+            final int eChunkZ = this.entity.chunkPosition().z;
+            final double effectiveRange = this.getEffectiveRange();
+            final double rangeSqr = effectiveRange * effectiveRange;
+            final double rangeY = level.paperConfig().entities.trackingRangeY.enabled ? level.paperConfig().entities.trackingRangeY.get(this.entity, -1) : -1;
+            final double rangeYSqr = (rangeY > 0.0) ? (rangeY * rangeY) : 0.0;
+            synchronized (players) {
+                for (ServerPlayer player : players) {
+                    if (player == this.entity) {
+                        continue;
+                    }
+                    Vec3 playerPos = player.position();
+                    final double dx = playerPos.x - ex;
+                    final double dz = playerPos.z - ez;
+                    final double dy = playerPos.y - ey;
+                    final double playerViewDistance = ChunkMap.this.getPlayerViewDistance(player);
+                    final boolean flag = ((dx * dx + dz * dz) <= Math.min(rangeSqr, playerViewDistance * playerViewDistance * 256.0))
+                        && ((rangeYSqr == 0.0) || ((dy * dy) <= rangeYSqr))
+                        && this.entity.broadcastToPlayer(player)
+                        && ChunkMap.this.isChunkTracked(player, eChunkX, eChunkZ)
+                        && player.getBukkitEntity().canSeeChunkMapUpdatePlayer(this.entity.getBukkitEntity());
+                    if (flag) {
+                        if (this.seenBy.add(player.connection)) {
+                            ctx.startSeenByPlayer(player.connection, this.serverEntity.entity);
+                            this.serverEntity.onPlayerAdd();
+                            updated = true;
+                        }
+                    } else if (this.seenBy.remove(player.connection)) {
+                        ctx.stopSeenByPlayer(player.connection, this.entity);
+                        updated = true;
+                    }
+                }
+            }
+            if (updated) {
+                this.seenByUpdated();
+            }
+            if (!chunkStateChanged) {
+                return this.seenBy().length != 0;
+            }
+            updated = false;
+            for (final ServerPlayerConnection conn : this.seenBy()) {
+                final ServerPlayer player = conn.getPlayer();
+                if (!players.contains(player) && this.seenBy.remove(conn)) {
+                    ctx.stopSeenByPlayer(conn, this.entity);
+                    updated = true;
+                }
+            }
+            if (updated) {
+                this.seenByUpdated();
+            }
+            return this.seenBy().length != 0;
+        }
+
+        public boolean removePlayerMulti(ServerPlayer player) {
+            if (this.seenBy.remove(player.connection)) {
+                this.serverEntity.removePairing(player);
+                if (this.seenBy.isEmpty()) {
+                    ChunkMap.this.level.debugSynchronizers().dropEntity(this.entity);
+                }
+                return true;
+            } else {
+                return false;
+            }
+        }
+
+        private boolean updatePlayerMulti(ServerPlayer player) {
+            org.spigotmc.AsyncCatcher.catchOp("player tracker update"); // Spigot
+            if (player != this.entity) {
+                // Paper start - remove allocation of Vec3D here
+                // Vec3 vec3 = player.position().subtract(this.entity.position());
+                double vec3_dx = player.getX() - this.entity.getX();
+                double vec3_dz = player.getZ() - this.entity.getZ();
+                // Paper end - remove allocation of Vec3D here
+                int playerViewDistance = ChunkMap.this.getPlayerViewDistance(player);
+                double d = Math.min(this.getEffectiveRange(), playerViewDistance * 16);
+                double d1 = vec3_dx * vec3_dx + vec3_dz * vec3_dz; // Paper
+                double d2 = d * d;
+                // Paper start - Configurable entity tracking range by Y
+                boolean flag = d1 <= d2;
+                if (flag && level.paperConfig().entities.trackingRangeY.enabled) {
+                    double rangeY = level.paperConfig().entities.trackingRangeY.get(this.entity, -1);
+                    if (rangeY != -1) {
+                        double vec3_dy = player.getY() - this.entity.getY();
+                        flag = vec3_dy * vec3_dy <= rangeY * rangeY;
+                    }
+                }
+                flag = flag && this.entity.broadcastToPlayer(player) && ChunkMap.this.isChunkTracked(player, this.entity.chunkPosition().x, this.entity.chunkPosition().z);
+                // Paper end - Configurable entity tracking range by Y
+                // CraftBukkit start - respect vanish API
+                if (flag && !player.getBukkitEntity().canSeeChunkMapUpdatePlayer(this.entity.getBukkitEntity())) { // Paper - only consider hits // SparklyPaper - optimize canSee checks
+                    flag = false;
+                }
+                // CraftBukkit end
+                if (flag) {
+                    if (this.seenBy.add(player.connection)) {
+                        // Paper start - entity tracking events
+                        if (io.papermc.paper.event.player.PlayerTrackEntityEvent.getHandlerList().getRegisteredListeners().length == 0 || new io.papermc.paper.event.player.PlayerTrackEntityEvent(player.getBukkitEntity(), this.entity.getBukkitEntity()).callEvent()) {
+                            this.serverEntity.addPairing(player);
+                            if (this.seenBy.size() == 1) {
+                                ChunkMap.this.level.debugSynchronizers().registerEntity(this.entity);
+                            }
+
+                            ChunkMap.this.level.debugSynchronizers().startTrackingEntity(player, this.entity);
+                        }
+                        // Paper end - entity tracking events
+                        this.serverEntity.onPlayerAdd(); // Paper - fix desync when a player is added to the tracker
+                        return true;
+                    }
+                } else {
+                    this.removePlayerMulti(player);
+                }
+            }
+            return false;
+        }
+
         public void updatePlayers(List<ServerPlayer> playersList) {
+            boolean updated = false;
             for (ServerPlayer serverPlayer : playersList) {
-                this.updatePlayer(serverPlayer);
+                updated |= this.updatePlayerMulti(serverPlayer);
             }
+            if (updated) seenByUpdated();
         }
+        // Leaf end - Multithreaded tracker
     }
 }
diff --git a/net/minecraft/server/level/ServerBossEvent.java b/net/minecraft/server/level/ServerBossEvent.java
index f106373ef3ac4a8685c2939c9e8361688a285913..cb516acac856f30ad0e2d24648bbfd86686339d2 100644
--- a/net/minecraft/server/level/ServerBossEvent.java
+++ b/net/minecraft/server/level/ServerBossEvent.java
@@ -105,6 +105,20 @@ public class ServerBossEvent extends BossEvent {
         }
     }
 
+    // Leaf start - Multithreaded tracker
+    public void leaf$addPlayer(org.dreeam.leaf.async.tracker.TrackerCtx ctx, ServerPlayer player) {
+        if (this.players.add(player) && this.visible) {
+            ctx.send(player.connection, ClientboundBossEventPacket.createAddPacket(this));
+        }
+    }
+
+    public void leaf$removePlayer(org.dreeam.leaf.async.tracker.TrackerCtx ctx, ServerPlayer player) {
+        if (this.players.remove(player) && this.visible) {
+            ctx.send(player.connection, ClientboundBossEventPacket.createRemovePacket(this.getId()));
+        }
+    }
+    // Leaf end - Multithreaded tracker
+
     public void removeAllPlayers() {
         if (!this.players.isEmpty()) {
             for (ServerPlayer serverPlayer : Lists.newArrayList(this.players)) {
diff --git a/net/minecraft/server/level/ServerEntity.java b/net/minecraft/server/level/ServerEntity.java
index 5e7f0429f8e6441b21994e92c4ecc67a4b71abd7..315792310b7e982aa495cdf98390a74cd66b0023 100644
--- a/net/minecraft/server/level/ServerEntity.java
+++ b/net/minecraft/server/level/ServerEntity.java
@@ -53,11 +53,11 @@ public class ServerEntity {
     private static final double TOLERANCE_LEVEL_POSITION = 7.6293945E-6F;
     public static final int FORCED_POS_UPDATE_PERIOD = 60;
     private static final int FORCED_TELEPORT_PERIOD = 400;
-    private final ServerLevel level;
-    private final Entity entity;
+    private final ServerLevel level; // Leaf - Multithreaded tracker - diff on change
+    public final Entity entity; // Leaf - Multithreaded tracker - private -> public
     private final int updateInterval;
     private final boolean trackDelta;
-    private final ServerEntity.Synchronizer synchronizer;
+    private final ServerEntity.Synchronizer synchronizer; // Leaf - Multithreaded tracker - diff on change
     private final VecDeltaCodec positionCodec = new VecDeltaCodec();
     private byte lastSentYRot;
     private byte lastSentXRot;
@@ -68,13 +68,13 @@ public class ServerEntity {
     private List<Entity> lastPassengers = com.google.common.collect.ImmutableList.of(); // Paper - optimize passenger checks
     private boolean wasRiding;
     private boolean wasOnGround;
-    private @Nullable List<SynchedEntityData.DataValue<?>> trackedDataValues;
+    public @Nullable List<SynchedEntityData.DataValue<?>> trackedDataValues; // Leaf - Multithreaded tracker - private -> public
     private final Set<net.minecraft.server.network.ServerPlayerConnection> trackedPlayers; // Paper
 
     public ServerEntity(ServerLevel level, Entity entity, int updateInterval, boolean trackDelta, ServerEntity.Synchronizer synchronizer, final Set<net.minecraft.server.network.ServerPlayerConnection> trackedPlayers) { // Paper
         this.trackedPlayers = trackedPlayers; // Paper
         this.level = level;
-        this.synchronizer = synchronizer;
+        this.synchronizer = synchronizer; // Leaf - Multithreaded tracker - diff on change
         this.entity = entity;
         this.updateInterval = updateInterval;
         this.trackDelta = trackDelta;
@@ -88,118 +88,119 @@ public class ServerEntity {
     }
 
     // Paper start - fix desync when a player is added to the tracker
-    private boolean forceStateResync;
+    private boolean forceStateResync; // Leaf - Multithreaded tracker - diff on change
     public void onPlayerAdd() {
         this.forceStateResync = true;
     }
     // Paper end - fix desync when a player is added to the tracker
 
-    public void sendChanges() {
+    public void sendChanges() { // Leaf - Multithreaded tracker - diff on change
         // Paper start - optimise collisions
         if (((ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity)this.entity).moonrise$isHardColliding()) {
             this.teleportDelay = 9999;
         }
+        // Leaf - Multithreaded tracker - diff on change
         // Paper end - optimise collisions
-        this.entity.updateDataBeforeSync();
-        List<Entity> passengers = this.entity.getPassengers();
+        this.entity.updateDataBeforeSync(); // Leaf - Multithreaded tracker - diff on change
+        List<Entity> passengers = this.entity.getPassengers(); // Leaf - Multithreaded tracker - diff on change
         if (!passengers.equals(this.lastPassengers)) {
             this.synchronizer
-                .sendToTrackingPlayersFiltered(
+                .sendToTrackingPlayersFiltered( // Leaf - Multithreaded tracker - diff on change
                     new ClientboundSetPassengersPacket(this.entity),
                     serverPlayer1 -> passengers.contains(serverPlayer1) == this.lastPassengers.contains(serverPlayer1)
                 );
-            // Paper start - Allow riding players
+            // Paper start - Allow riding players // Leaf - Multithreaded tracker - diff on change
             if (this.entity instanceof ServerPlayer player) {
                 player.connection.send(new ClientboundSetPassengersPacket(this.entity));
             }
             // Paper end - Allow riding players
-            this.lastPassengers = passengers;
+            this.lastPassengers = passengers; // Leaf - Multithreaded tracker - diff on change
         }
 
-        if (!this.trackedPlayers.isEmpty() && this.entity instanceof ItemFrame itemFrame /*&& this.tickCount % 10 == 0*/) { // CraftBukkit - moved tickCount below // Paper - Perf: Only tick item frames if players can see it
+        if (!this.trackedPlayers.isEmpty() && this.entity instanceof ItemFrame itemFrame /*&& this.tickCount % 10 == 0*/) { // CraftBukkit - moved tickCount below // Paper - Perf: Only tick item frames if players can see it // Leaf - Multithreaded tracker - diff on change
             ItemStack item = itemFrame.getItem();
             if (this.level.paperConfig().maps.itemFrameCursorUpdateInterval > 0 && this.tickCount % this.level.paperConfig().maps.itemFrameCursorUpdateInterval == 0 && item.getItem() instanceof MapItem) { // CraftBukkit - Moved this.tickCounter % 10 logic here so item frames do not enter the other blocks // Paper - Make item frame map cursor update interval configurable
                 MapId mapId = itemFrame.cachedMapId; // Paper - Perf: Cache map ids on item frames
-                MapItemSavedData savedData = MapItem.getSavedData(mapId, this.level);
+                MapItemSavedData savedData = MapItem.getSavedData(mapId, this.level); // Leaf - Multithreaded tracker - diff on change
                 if (savedData != null) {
                     for (final net.minecraft.server.network.ServerPlayerConnection connection : this.trackedPlayers) { // Paper
                         final ServerPlayer serverPlayer = connection.getPlayer(); // Paper
                         savedData.tickCarriedBy(serverPlayer, item);
-                        Packet<?> updatePacket = savedData.getUpdatePacket(mapId, serverPlayer);
+                        Packet<?> updatePacket = savedData.getUpdatePacket(mapId, serverPlayer); // Leaf - Multithreaded tracker - diff on change
                         if (updatePacket != null) {
-                            serverPlayer.connection.send(updatePacket);
+                            serverPlayer.connection.send(updatePacket); // Leaf - Multithreaded tracker - diff on change
                         }
                     }
                 }
             }
 
-            this.sendDirtyEntityData();
+            this.sendDirtyEntityData(); // Leaf - Multithreaded tracker - diff on change
         }
 
-        if (this.forceStateResync || this.tickCount % this.updateInterval == 0 || this.entity.needsSync || this.entity.getEntityData().isDirty()) { // Paper - fix desync when a player is added to the tracker
+        if (this.forceStateResync || this.tickCount % this.updateInterval == 0 || this.entity.needsSync || this.entity.getEntityData().isDirty()) { // Paper - fix desync when a player is added to the tracker // Leaf - Multithreaded tracker - diff on change
             byte b = Mth.packDegrees(this.entity.getYRot());
             byte b1 = Mth.packDegrees(this.entity.getXRot());
-            boolean flag = Math.abs(b - this.lastSentYRot) >= 1 || Math.abs(b1 - this.lastSentXRot) >= 1;
+            boolean flag = Math.abs(b - this.lastSentYRot) >= 1 || Math.abs(b1 - this.lastSentXRot) >= 1; // Leaf - Multithreaded tracker - diff on change
             if (this.entity.isPassenger()) {
-                if (flag) {
+                if (flag) { // Leaf - Multithreaded tracker - diff on change
                     this.synchronizer.sendToTrackingPlayers(new ClientboundMoveEntityPacket.Rot(this.entity.getId(), b, b1, this.entity.onGround()));
                     this.lastSentYRot = b;
                     this.lastSentXRot = b1;
-                }
+                } // Leaf - Multithreaded tracker - diff on change
 
-                this.positionCodec.setBase(this.entity.trackingPosition());
+                this.positionCodec.setBase(this.entity.trackingPosition()); // Leaf - Multithreaded tracker - diff on change
                 this.sendDirtyEntityData();
                 this.wasRiding = true;
             } else if (this.entity instanceof AbstractMinecart abstractMinecart
                 && abstractMinecart.getBehavior() instanceof NewMinecartBehavior newMinecartBehavior) {
-                this.handleMinecartPosRot(newMinecartBehavior, b, b1, flag);
+                this.handleMinecartPosRot(newMinecartBehavior, b, b1, flag); // Leaf - Multithreaded tracker - diff on change
             } else {
                 this.teleportDelay++;
-                Vec3 vec3 = this.entity.trackingPosition();
+                Vec3 vec3 = this.entity.trackingPosition(); // Leaf - Multithreaded tracker - diff on change
                 // Paper start - reduce allocation of Vec3D here
                 Vec3 base = this.positionCodec.base;
                 double vec3_dx = vec3.x - base.x;
                 double vec3_dy = vec3.y - base.y;
-                double vec3_dz = vec3.z - base.z;
+                double vec3_dz = vec3.z - base.z; // Leaf - Multithreaded tracker - diff on change
                 boolean flag1 = (vec3_dx * vec3_dx + vec3_dy * vec3_dy + vec3_dz * vec3_dz) >= 7.62939453125E-6D;
                 // Paper end - reduce allocation of Vec3D here
-                Packet<ClientGamePacketListener> packet = null;
+                Packet<ClientGamePacketListener> packet = null; // Leaf - Multithreaded tracker - diff on change
                 boolean flag2 = flag1 || this.tickCount % 60 == 0;
                 boolean flag3 = false;
                 boolean flag4 = false;
                 long l = this.positionCodec.encodeX(vec3);
                 long l1 = this.positionCodec.encodeY(vec3);
-                long l2 = this.positionCodec.encodeZ(vec3);
+                long l2 = this.positionCodec.encodeZ(vec3); // Leaf - Multithreaded tracker - diff on change
                 boolean flag5 = l < -32768L || l > 32767L || l1 < -32768L || l1 > 32767L || l2 < -32768L || l2 > 32767L;
                 boolean onGroundChanged = this.wasOnGround != this.entity.onGround(); // Purpur - Dont send useless entity packets
                 if (this.forceStateResync || this.entity.getRequiresPrecisePosition() // Paper - fix desync when a player is added to the tracker
                     || flag5
                     || this.teleportDelay > 400
                     || this.wasRiding
-                    || onGroundChanged) { // Purpur - Dont send useless entity packets
+                    || onGroundChanged) { // Purpur - Dont send useless entity packets // Leaf - Multithreaded tracker - diff on change
                     this.wasOnGround = this.entity.onGround();
                     this.teleportDelay = 0;
                     packet = ClientboundEntityPositionSyncPacket.of(this.entity);
                     flag3 = true;
-                    flag4 = true;
+                    flag4 = true; // Leaf - Multithreaded tracker - diff on change
                     // Gale start - Airplane - better checking for useless move packets
-                } else {
+                } else { // Leaf - Multithreaded tracker - diff on change
                     if (flag2 || flag || this.entity instanceof AbstractArrow) {
-                        if ((!flag2 || !flag) && !(this.entity instanceof AbstractArrow)) {
+                        if ((!flag2 || !flag) && !(this.entity instanceof AbstractArrow)) { // Leaf - Multithreaded tracker - diff on change
                             if (flag2) {
                                 packet = new ClientboundMoveEntityPacket.Pos(this.entity.getId(), (short) l, (short) l1, (short) l2, this.entity.onGround());
                                 flag3 = true;
-                            } else if (flag) {
+                            } else if (flag) { // Leaf - Multithreaded tracker - diff on change
                                 packet = new ClientboundMoveEntityPacket.Rot(this.entity.getId(), b, b1, this.entity.onGround());
                                 flag4 = true;
                             }
-                        } else {
+                        } else { // Leaf - Multithreaded tracker - diff on change
                             packet = new ClientboundMoveEntityPacket.PosRot(this.entity.getId(), (short) l, (short) l1, (short) l2, b, b1, this.entity.onGround());
                             flag3 = true;
                             flag4 = true;
                         }
                     }
-                }
+                } // Leaf - Multithreaded tracker - diff on change
                 // Gale end - Airplane - better checking for useless move packets
 
                 if (org.dreeam.leaf.config.modules.opt.ReduceUselessPackets.reduceUselessEntityMovePackets && !onGroundChanged && isUselessMoveEntityPacket(packet)) packet = null; // Purpur - Dont send useless entity packets
@@ -209,74 +210,74 @@ public class ServerEntity {
                     if (deltaMovement != this.lastSentMovement) { // SparklyPaper start - skip distanceToSqr call in ServerEntity#sendChanges if the delta movement hasn't changed
                     double d = deltaMovement.distanceToSqr(this.lastSentMovement);
                     if (d > 1.0E-7 || d > 0.0 && deltaMovement.lengthSqr() == 0.0) {
-                        this.lastSentMovement = deltaMovement;
+                        this.lastSentMovement = deltaMovement;// Leaf - Multithreaded tracker - diff on change
                         if (this.entity instanceof AbstractHurtingProjectile abstractHurtingProjectile) {
                             this.synchronizer
                                 .sendToTrackingPlayers(
                                     new ClientboundBundlePacket(
-                                        List.of(
+                                        List.of( // Leaf - Multithreaded tracker - diff on change
                                             new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement),
                                             new ClientboundProjectilePowerPacket(abstractHurtingProjectile.getId(), abstractHurtingProjectile.accelerationPower)
                                         )
                                     )
                                 );
-                        } else {
+                        } else { // Leaf - Multithreaded tracker - diff on change
                             this.synchronizer.sendToTrackingPlayers(new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement));
                         }
                     }
                     } // SparklyPaper end
                 }
 
-                if (packet != null) {
+                if (packet != null) { // Leaf - Multithreaded tracker - diff on change
                     this.synchronizer.sendToTrackingPlayers(packet);
                 }
 
-                this.sendDirtyEntityData();
+                this.sendDirtyEntityData(); // Leaf - Multithreaded tracker - diff on change
                 if (flag3) {
                     this.positionCodec.setBase(vec3);
                 }
 
-                if (flag4) {
+                if (flag4) { // Leaf - Multithreaded tracker - diff on change
                     this.lastSentYRot = b;
                     this.lastSentXRot = b1;
                 }
 
-                this.wasRiding = false;
+                this.wasRiding = false; // Leaf - Multithreaded tracker - diff on change
             }
 
-            byte b2 = Mth.packDegrees(this.entity.getYHeadRot());
+            byte b2 = Mth.packDegrees(this.entity.getYHeadRot()); // Leaf - Multithreaded tracker - diff on change
             if (Math.abs(b2 - this.lastSentYHeadRot) >= 1) {
                 this.synchronizer.sendToTrackingPlayers(new ClientboundRotateHeadPacket(this.entity, b2));
                 this.lastSentYHeadRot = b2;
             }
 
-            this.entity.needsSync = false;
+            this.entity.needsSync = false; // Leaf - Multithreaded tracker - diff on change
             this.forceStateResync = false; // Paper - fix desync when a player is added to the tracker
         }
 
-        this.tickCount++;
+        this.tickCount++; // Leaf - Multithreaded tracker - diff on change
         if (this.entity.hurtMarked) {
             // CraftBukkit start - Create PlayerVelocity event
             boolean cancelled = false;
 
-            if (this.entity instanceof ServerPlayer) {
+            if (this.entity instanceof ServerPlayer) { // Leaf - Multithreaded tracker - diff on change
                 org.bukkit.entity.Player player = (org.bukkit.entity.Player) this.entity.getBukkitEntity();
                 org.bukkit.util.Vector velocity = player.getVelocity();
 
-                org.bukkit.event.player.PlayerVelocityEvent event = new org.bukkit.event.player.PlayerVelocityEvent(player, velocity.clone());
+                org.bukkit.event.player.PlayerVelocityEvent event = new org.bukkit.event.player.PlayerVelocityEvent(player, velocity.clone()); // Leaf - Multithreaded tracker - diff on change
                 if (!event.callEvent()) {
-                    cancelled = true;
+                    cancelled = true; // Leaf - Multithreaded tracker - diff on change
                 } else if (!velocity.equals(event.getVelocity())) {
                     player.setVelocity(event.getVelocity());
                 }
-            }
+            } // Leaf - Multithreaded tracker - diff on change
 
             if (cancelled) {
                 return;
-            }
+            } // Leaf - Multithreaded tracker - diff on change
             // CraftBukkit end
             this.entity.hurtMarked = false;
-            this.synchronizer.sendToTrackingPlayersAndSelf(new ClientboundSetEntityMotionPacket(this.entity));
+            this.synchronizer.sendToTrackingPlayersAndSelf(new ClientboundSetEntityMotionPacket(this.entity)); // Leaf - Multithreaded tracker - diff on change
         }
     }
 
@@ -298,14 +299,14 @@ public class ServerEntity {
     private void handleMinecartPosRot(NewMinecartBehavior behavior, byte yRot, byte xRot, boolean dirty) {
         this.sendDirtyEntityData();
         if (behavior.lerpSteps.isEmpty()) {
-            Vec3 deltaMovement = this.entity.getDeltaMovement();
+            Vec3 deltaMovement = this.entity.getDeltaMovement(); // Leaf - Multithreaded tracker - diff on change
             double d = deltaMovement.distanceToSqr(this.lastSentMovement);
             Vec3 vec3 = this.entity.trackingPosition();
             boolean flag = this.positionCodec.delta(vec3).lengthSqr() >= 7.6293945E-6F;
             boolean flag1 = flag || this.tickCount % 60 == 0;
             if (flag1 || dirty || d > 1.0E-7) {
                 this.synchronizer
-                    .sendToTrackingPlayers(
+                    .sendToTrackingPlayers( // Leaf - Multithreaded tracker - diff on change
                         new ClientboundMoveMinecartPacket(
                             this.entity.getId(),
                             List.of(
@@ -327,6 +328,7 @@ public class ServerEntity {
     }
 
     public void removePairing(ServerPlayer player) {
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) { ((ServerLevel) this.entity.level()).leaf$asyncTracker.ctx().stopSeenByPlayer(player.connection, this.entity); return; } // Leaf - Multithreaded tracker
         this.entity.stopSeenByPlayer(player);
         player.connection.send(new ClientboundRemoveEntitiesPacket(this.entity.getId()));
     }
@@ -414,6 +416,7 @@ public class ServerEntity {
         return Mth.unpackDegrees(this.lastSentYHeadRot);
     }
 
+    // Leaf - Multithreaded tracker - diff on change
     private void sendDirtyEntityData() {
         SynchedEntityData entityData = this.entity.getEntityData();
         List<SynchedEntityData.DataValue<?>> list = entityData.packDirty();
@@ -421,10 +424,12 @@ public class ServerEntity {
             this.trackedDataValues = entityData.getNonDefaultValues();
             this.synchronizer.sendToTrackingPlayersAndSelf(new ClientboundSetEntityDataPacket(this.entity.getId(), list));
         }
+        // Leaf - Multithreaded tracker - diff on change
 
         if (this.entity instanceof LivingEntity) {
             Set<AttributeInstance> attributesToSync = ((LivingEntity)this.entity).getAttributes().getAttributesToSync();
             if (!attributesToSync.isEmpty()) {
+                // Leaf - Multithreaded tracker - diff on change
                 // CraftBukkit start - Send scaled max health
                 if (this.entity instanceof ServerPlayer serverPlayer) {
                     serverPlayer.getBukkitEntity().injectScaledMaxHealth(attributesToSync, false);
@@ -437,6 +442,234 @@ public class ServerEntity {
         }
     }
 
+    // Leaf start - Multithreaded tracker
+    public void leaf$sendChanges(org.dreeam.leaf.async.tracker.TrackerCtx ctx, ChunkMap.TrackedEntity tracker, boolean force) {
+        if (this.forceStateResync && !force) {
+            this.forceStateResync = false;
+            ctx.forceResync(tracker);
+            return;
+        }
+        // Paper start - optimise collisions
+        if (this.entity.moonrise$isHardColliding()) {
+            this.teleportDelay = 9999;
+        }
+        // Paper end - optimise collisions
+        this.entity.updateDataBeforeSync();
+        List<Entity> passengers = this.entity.getPassengers();
+        if (!passengers.equals(this.lastPassengers)) {
+            ctx.sendToTrackingPlayersFiltered(
+                tracker,
+                new ClientboundSetPassengersPacket(this.entity),
+                serverPlayer1 -> passengers.contains(serverPlayer1) == this.lastPassengers.contains(serverPlayer1)
+                );
+            // Paper start - Allow riding players
+            if (this.entity instanceof ServerPlayer player) {
+                ctx.send(player.connection, new ClientboundSetPassengersPacket(this.entity));
+            }
+            // Paper end - Allow riding players
+            this.lastPassengers = passengers;
+        }
+        if (!tracker.seenBy.isEmpty() && this.entity instanceof ItemFrame itemFrame /*&& this.tickCount % 10 == 0*/) { // CraftBukkit - moved tickCount below // Paper - Perf: Only tick item frames if players can see it
+            if (this.level.paperConfig().maps.itemFrameCursorUpdateInterval > 0 && this.tickCount % this.level.paperConfig().maps.itemFrameCursorUpdateInterval == 0 && itemFrame.getItem().getItem() instanceof MapItem) { // CraftBukkit - Moved this.tickCounter % 10 logic here so item frames do not enter the other blocks // Paper - Make item frame map cursor update interval configurable
+                ctx.updateItemFrame(itemFrame);
+            }
+            ctx.sendDirtyEntityData(tracker);
+        }
+
+        if (force || this.tickCount % this.updateInterval == 0 || this.entity.needsSync || this.entity.getEntityData().isDirty()) { // Paper - fix desync when a player is added to the tracker
+            byte b = Mth.packDegrees(this.entity.getYRot());
+            byte b1 = Mth.packDegrees(this.entity.getXRot());
+            boolean flag = Math.abs(b - this.lastSentYRot) >= 1 || Math.abs(b1 - this.lastSentXRot) >= 1;
+            if (this.entity.isPassenger()) {
+                if (flag) {
+                    ctx.sendToTrackingPlayers(tracker, new ClientboundMoveEntityPacket.Rot(this.entity.getId(), b, b1, this.entity.onGround()));
+                    this.lastSentYRot = b;
+                    this.lastSentXRot = b1;
+                }
+
+                this.positionCodec.setBase(this.entity.trackingPosition());
+                ctx.sendDirtyEntityData(tracker);
+                this.wasRiding = true;
+            } else if (this.entity instanceof AbstractMinecart abstractMinecart
+                && abstractMinecart.getBehavior() instanceof NewMinecartBehavior newMinecartBehavior) {
+                this.leaf$HandleMinecartPosRot(ctx, tracker, newMinecartBehavior, b, b1, flag);
+            } else {
+                this.teleportDelay++;
+                Vec3 vec3 = this.entity.trackingPosition();
+                // Paper start - reduce allocation of Vec3D here
+                Vec3 base = this.positionCodec.base;
+                double vec3_dx = vec3.x - base.x;
+                double vec3_dy = vec3.y - base.y;
+                double vec3_dz = vec3.z - base.z;
+                boolean flag1 = (vec3_dx * vec3_dx + vec3_dy * vec3_dy + vec3_dz * vec3_dz) >= 7.62939453125E-6D;
+                // Paper end - reduce allocation of Vec3D here
+                Packet<ClientGamePacketListener> packet = null;
+                boolean flag2 = flag1 || this.tickCount % 60 == 0;
+                boolean flag3 = false;
+                boolean flag4 = false;
+                long l = this.positionCodec.encodeX(vec3);
+                long l1 = this.positionCodec.encodeY(vec3);
+                long l2 = this.positionCodec.encodeZ(vec3);
+                boolean flag5 = l < -32768L || l > 32767L || l1 < -32768L || l1 > 32767L || l2 < -32768L || l2 > 32767L;
+                boolean onGroundChanged = this.wasOnGround != this.entity.onGround();
+                if (force || this.entity.getRequiresPrecisePosition() // Paper - fix desync when a player is added to the tracker
+                    || flag5
+                    || this.teleportDelay > 400
+                    || this.wasRiding
+                    || onGroundChanged) {
+                    this.wasOnGround = this.entity.onGround();
+                    this.teleportDelay = 0;
+                    packet = ClientboundEntityPositionSyncPacket.of(this.entity);
+                    flag3 = true;
+                    flag4 = true;
+                    // Gale start - Airplane - better checking for useless move packets
+                } else {
+                    if (flag2 || flag || this.entity instanceof AbstractArrow) {
+                        if ((!flag2 || !flag) && !(this.entity instanceof AbstractArrow)) {
+                            if (flag2) {
+                                packet = new ClientboundMoveEntityPacket.Pos(this.entity.getId(), (short) l, (short) l1, (short) l2, this.entity.onGround());
+                                flag3 = true;
+                            } else if (flag) {
+                                packet = new ClientboundMoveEntityPacket.Rot(this.entity.getId(), b, b1, this.entity.onGround());
+                                flag4 = true;
+                            }
+                        } else {
+                            packet = new ClientboundMoveEntityPacket.PosRot(this.entity.getId(), (short) l, (short) l1, (short) l2, b, b1, this.entity.onGround());
+                            flag3 = true;
+                            flag4 = true;
+                        }
+                    }
+                }
+                // Gale end - Airplane - better checking for useless move packets
+
+                if (org.dreeam.leaf.config.modules.opt.ReduceUselessPackets.reduceUselessEntityMovePackets && !onGroundChanged && isUselessMoveEntityPacket(packet)) packet = null; // Purpur - Dont send useless entity packets
+
+                if (this.entity.needsSync || this.trackDelta || this.entity instanceof LivingEntity && ((LivingEntity)this.entity).isFallFlying()) {
+                    Vec3 deltaMovement = this.entity.getDeltaMovement();
+                    if (deltaMovement != this.lastSentMovement) { // SparklyPaper start - skip distanceToSqr call in ServerEntity#sendChanges if the delta movement hasn't changed
+                        double d = deltaMovement.distanceToSqr(this.lastSentMovement);
+                        if (d > 1.0E-7 || d > 0.0 && deltaMovement.lengthSqr() == 0.0) {
+                            this.lastSentMovement = deltaMovement;
+                            if (this.entity instanceof AbstractHurtingProjectile abstractHurtingProjectile) {
+                                ctx.sendToTrackingPlayers(tracker, new ClientboundBundlePacket(List.of(
+                                    new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement),
+                                    new ClientboundProjectilePowerPacket(abstractHurtingProjectile.getId(), abstractHurtingProjectile.accelerationPower)
+                                )));
+                            } else {
+                                ctx.sendToTrackingPlayers(tracker, new ClientboundSetEntityMotionPacket(this.entity.getId(), this.lastSentMovement));
+                            }
+                        }
+                    } // SparklyPaper end
+                }
+
+                if (packet != null) {
+                    ctx.sendToTrackingPlayers(tracker, packet);
+                }
+
+                ctx.sendDirtyEntityData(tracker);
+                if (flag3) {
+                    this.positionCodec.setBase(vec3);
+                }
+
+                if (flag4) {
+                    this.lastSentYRot = b;
+                    this.lastSentXRot = b1;
+                }
+
+                this.wasRiding = false;
+            }
+
+            byte b2 = Mth.packDegrees(this.entity.getYHeadRot());
+            if (Math.abs(b2 - this.lastSentYHeadRot) >= 1) {
+                ctx.sendToTrackingPlayers(tracker, new ClientboundRotateHeadPacket(this.entity, b2));
+                this.lastSentYHeadRot = b2;
+            }
+
+            this.entity.needsSync = false;
+        }
+
+        this.tickCount++;
+        if (this.entity.hurtMarked && !(this.entity instanceof ServerPlayer)) {
+            this.entity.hurtMarked = false;
+            ctx.sendToTrackingPlayersAndSelf(tracker, new ClientboundSetEntityMotionPacket(this.entity));
+        }
+    }
+
+    private void leaf$HandleMinecartPosRot(org.dreeam.leaf.async.tracker.TrackerCtx ctx, ChunkMap.TrackedEntity tracker, NewMinecartBehavior behavior, byte yRot, byte xRot, boolean dirty) {
+        ctx.sendDirtyEntityData(tracker);
+        if (behavior.lerpSteps.isEmpty()) {
+            Vec3 deltaMovement = this.entity.getDeltaMovement();
+            double d = deltaMovement.distanceToSqr(this.lastSentMovement);
+            Vec3 vec3 = this.entity.trackingPosition();
+            boolean flag = this.positionCodec.delta(vec3).lengthSqr() >= 7.6293945E-6F;
+            boolean flag1 = flag || this.tickCount % 60 == 0;
+            if (flag1 || dirty || d > 1.0E-7) {
+                ctx.sendToTrackingPlayers(tracker, new ClientboundMoveMinecartPacket(
+                    this.entity.getId(),
+                    List.of(
+                        new NewMinecartBehavior.MinecartStep(
+                            this.entity.position(), this.entity.getDeltaMovement(), this.entity.getYRot(), this.entity.getXRot(), 1.0F
+                        ))));
+            }
+        } else {
+            ctx.sendToTrackingPlayers(tracker, new ClientboundMoveMinecartPacket(this.entity.getId(), List.copyOf(behavior.lerpSteps)));
+            behavior.lerpSteps.clear();
+        }
+
+        this.lastSentYRot = yRot;
+        this.lastSentXRot = xRot;
+        this.positionCodec.setBase(this.entity.position());
+    }
+
+    public boolean leaf$sendPairingData(List<Packet<? super ClientGamePacketListener>> consumer) {
+        if (this.entity.isRemoved()) {
+            // CraftBukkit start - Remove useless error spam, just return
+            // LOGGER.warn("Fetching packet for removed entity {}", this.entity);
+            return false;
+            // CraftBukkit end
+        }
+
+        if (this.trackedDataValues != null) {
+            consumer.add(new ClientboundSetEntityDataPacket(this.entity.getId(), this.trackedDataValues));
+        }
+
+        boolean flag = false;
+        if (this.entity instanceof LivingEntity livingEntity) {
+            List<ClientboundUpdateAttributesPacket.AttributeSnapshot> syncableAttributes = livingEntity.getAttributes().getSyncableAttributesPacket();
+            if (!syncableAttributes.isEmpty()) {
+                flag = livingEntity instanceof ServerPlayer && livingEntity.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH) != null;
+                consumer.add(new ClientboundUpdateAttributesPacket(this.entity.getId(), syncableAttributes));
+            }
+            if (livingEntity.hasItemInSlots()) {
+                List<Pair<EquipmentSlot, ItemStack>> list = Lists.newArrayList();
+                for (EquipmentSlot equipmentSlot : EquipmentSlot.VALUES_ARRAY) { // Gale - JettPack - reduce array allocations
+                    ItemStack itemBySlot = livingEntity.getItemBySlot(equipmentSlot);
+                    if (!itemBySlot.isEmpty()) {
+                        list.add(Pair.of(equipmentSlot, itemBySlot.copy()));
+                    }
+                }
+                if (!list.isEmpty()) {
+                    consumer.add(new ClientboundSetEquipmentPacket(this.entity.getId(), list, true)); // Paper - data sanitization
+                }
+            }
+        }
+
+        if (!this.entity.getPassengers().isEmpty()) {
+            consumer.add(new ClientboundSetPassengersPacket(this.entity));
+        }
+
+        if (this.entity.isPassenger()) {
+            consumer.add(new ClientboundSetPassengersPacket(this.entity.getVehicle()));
+        }
+
+        if (this.entity instanceof Leashable leashable && leashable.isLeashed()) {
+            consumer.add(new ClientboundSetEntityLinkPacket(this.entity, leashable.getLeashHolder()));
+        }
+
+        return flag;
+    }
+    // Leaf end - Multithreaded tracker
+
     public interface Synchronizer {
         void sendToTrackingPlayers(Packet<? super ClientGamePacketListener> packet);
 
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 1f0d17b0588654d1066a49bc934ff92bfc870afc..93071a7616afbcf28186420dc3bf8d01d94d7f4f 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -236,6 +236,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public boolean hasEntityMoveEvent; // Paper - Add EntityMoveEvent
     private final alternate.current.wire.WireHandler wireHandler = new alternate.current.wire.WireHandler(this); // Paper - optimize redstone (Alternate Current)
     public boolean hasRidableMoveEvent = false; // Purpur - Ridables
+    public final org.dreeam.leaf.async.tracker.AsyncTracker leaf$asyncTracker = new org.dreeam.leaf.async.tracker.AsyncTracker(this); // Leaf - Multithreaded tracker
 
     @Override
     public @Nullable LevelChunk getChunkIfLoaded(int x, int z) {
@@ -1059,6 +1060,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.debugSynchronizers.tick(this.server.debugSubscribers());
         profilerFiller.pop();
         this.environmentAttributes().invalidateTickCache();
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) { this.leaf$asyncTracker.onEntitiesTickEnd(); } // Leaf - Multithreaded tracker
     }
 
     @Override
diff --git a/net/minecraft/world/entity/EntityEquipment.java b/net/minecraft/world/entity/EntityEquipment.java
index 940a1ca7374592dd75ba5fd7b5eecdb9ff20f8ee..ce7e7a9539a6bd639f7ced5c3db70cc4b933454a 100644
--- a/net/minecraft/world/entity/EntityEquipment.java
+++ b/net/minecraft/world/entity/EntityEquipment.java
@@ -45,11 +45,14 @@ public class EntityEquipment implements net.caffeinemc.mods.lithium.common.entit
     }
 
     public boolean isEmpty() {
-        for (ItemStack itemStack : this.items.values()) {
-            if (!itemStack.isEmpty()) {
+        // Leaf start - Multithreaded tracker
+        for (int i = 0; i < EquipmentSlot.VALUES_ARRAY.length; i++) {
+            ItemStack itemStack = this.items.get(EquipmentSlot.VALUES_ARRAY[i]);
+            if (itemStack != null && !itemStack.isEmpty()) {
                 return false;
             }
         }
+        // Leaf end - Multithreaded tracker
 
         return true;
     }
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index 1d63d41b0dd8be376b9fe257db795f7a24118de1..73029fced7a033c6bcb8051662c5f86d5b1f13c1 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -3026,6 +3026,12 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         return this.equipment.get(slot);
     }
 
+    // Leaf start - Multithreaded tracker
+    public boolean hasItemInSlots() {
+        return !this.equipment.isEmpty();
+    }
+    // Leaf end - Multithreaded tracker
+
     public void setItemSlot(EquipmentSlot slot, ItemStack stack) {
     // Paper start
         this.setItemSlot(slot, stack, false);
diff --git a/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java b/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java
index 84b11654411eaa561a9b58ffa1210ca3d3b5a7cd..4b336bb2690244b5c99bb7dd566e4fd84e031e79 100644
--- a/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/minecart/NewMinecartBehavior.java
@@ -34,13 +34,20 @@ public class NewMinecartBehavior extends MinecartBehavior {
     private int cachedLerpDelay;
     private float cachedPartialTick;
     private int lerpDelay = 0;
-    public final List<NewMinecartBehavior.MinecartStep> lerpSteps = new LinkedList<>();
+    public final List<NewMinecartBehavior.MinecartStep> lerpSteps; // Leaf - Multithreaded tracker
     public final List<NewMinecartBehavior.MinecartStep> currentLerpSteps = new LinkedList<>();
     public double currentLerpStepsTotalWeight = 0.0;
     public NewMinecartBehavior.MinecartStep oldLerp = NewMinecartBehavior.MinecartStep.ZERO;
 
     public NewMinecartBehavior(AbstractMinecart minecart) {
         super(minecart);
+        // Leaf start - Multithreaded tracker
+        if (org.dreeam.leaf.config.modules.async.MultithreadedTracker.enabled) {
+            lerpSteps = it.unimi.dsi.fastutil.objects.ObjectLists.synchronize(new it.unimi.dsi.fastutil.objects.ObjectArrayList<>());
+        } else {
+            lerpSteps = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+        }
+        // Leaf end - Multithreaded tracker
     }
 
     @Override
