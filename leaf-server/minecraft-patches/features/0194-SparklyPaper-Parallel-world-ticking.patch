From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: MrPowerGamerBR <git@mrpowergamerbr.com>
Date: Sun, 25 May 2025 21:39:32 -0300
Subject: [PATCH] SparklyPaper: Parallel world ticking

Original project: https://github.com/SparklyPower/SparklyPaper

Co-authored-by: Altiami <yoshimo.kristin@gmail.com>
Co-authored-by: Taiyou06 <kaandindar21@gmail.com>
Co-authored-by: MrlingXD <90316914+wling-art@users.noreply.github.com>

Commit: 491a14f432bd2ab42ba1586d4a6786b740713662

diff --git a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
index 09fe3dc6d661b7f21d899dcb04e249d39cd4b6ba..0d51d2ac814d000724e056be6f480766fd892993 100644
--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkHolderManager.java
@@ -1129,7 +1129,7 @@ public final class ChunkHolderManager {
         if (changedFullStatus.isEmpty()) {
             return;
         }
-        if (!TickThread.isTickThread()) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && !TickThread.isTickThreadFor(world) || !TickThread.isTickThread()) { // Leaf - SparklyPaper - parallel world ticking
             // These will be handled on the next ServerChunkCache$MainThreadExecutor#pollTask, as it runs the distance manager update
             // which will invoke processTicketUpdates
             this.offThreadPendingFullLoadUpdate.addAll(changedFullStatus);
@@ -1150,7 +1150,13 @@ public final class ChunkHolderManager {
 
     // note: never call while inside the chunk system, this will absolutely break everything
     public void processUnloads() {
-        TickThread.ensureTickThread("Cannot unload chunks off-main");
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            TickThread.ensureTickThread(world, "Cannot unload chunks off-main");
+        } else {
+            TickThread.ensureTickThread("Cannot unload chunks off-main");
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
 
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot unload chunks recursively");
@@ -1419,7 +1425,7 @@ public final class ChunkHolderManager {
         if (BLOCK_TICKET_UPDATES.get() == Boolean.TRUE) {
             throw new IllegalStateException("Cannot update ticket level while unloading chunks or updating entity manager");
         }
-        final boolean isTickThread = TickThread.isTickThread();
+        final boolean isTickThread = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? TickThread.isTickThreadFor(world) : TickThread.isTickThread(); // Leaf - SparklyPaper - parallel world ticking
 
         if (!PlatformHooks.get().allowAsyncTicketUpdates() && isTickThread) {
             TickThread.ensureTickThread("Cannot asynchronously process ticket updates");
diff --git a/io/papermc/paper/entity/activation/ActivationRange.java b/io/papermc/paper/entity/activation/ActivationRange.java
index ff46777225fc102e25d4e6ff3a9a3ab748173ca2..45b17a4fbb7f4941f23f5bf4983f9eccf425b73f 100644
--- a/io/papermc/paper/entity/activation/ActivationRange.java
+++ b/io/papermc/paper/entity/activation/ActivationRange.java
@@ -134,7 +134,7 @@ public final class ActivationRange {
      *
      * @param world
      */
-    public static void activateEntities(final Level world) {
+    public synchronized static void activateEntities(final Level world) { // Leaf - SparklyPaper - parallel world ticking
         final int miscActivationRange = world.spigotConfig.miscActivationRange;
         final int raiderActivationRange = world.spigotConfig.raiderActivationRange;
         final int animalActivationRange = world.spigotConfig.animalActivationRange;
diff --git a/io/papermc/paper/redstone/RedstoneWireTurbo.java b/io/papermc/paper/redstone/RedstoneWireTurbo.java
index ff747a1ecdf3c888bca0d69de4f85dcd810b6139..0838b3d60e94a280a6fdd1aef413078a0ec71a1c 100644
--- a/io/papermc/paper/redstone/RedstoneWireTurbo.java
+++ b/io/papermc/paper/redstone/RedstoneWireTurbo.java
@@ -829,14 +829,22 @@ public final class RedstoneWireTurbo {
         j = getMaxCurrentStrength(upd, j);
         int l = 0;
 
-        wire.shouldSignal = false;
-        // Unfortunately, World.isBlockIndirectlyGettingPowered is complicated,
-        // and I'm not ready to try to replicate even more functionality from
-        // elsewhere in Minecraft into this accelerator.  So sadly, we must
-        // suffer the performance hit of this very expensive call.  If there
-        // is consistency to what this call returns, we may be able to cache it.
-        final int k = worldIn.getBestNeighborSignal(upd.self);
-        wire.shouldSignal = true;
+        // Leaf start - SparklyPaper - parallel world ticking
+        final int k;
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            // This now correctly calls the (conditionally) thread-safe method in RedStoneWireBlock
+            k = wire.getBlockSignal(worldIn, upd.self);
+        } else {
+            wire.shouldSignal = false;
+            // Unfortunately, World.isBlockIndirectlyGettingPowered is complicated,
+            // and I'm not ready to try to replicate even more functionality from
+            // elsewhere in Minecraft into this accelerator.  So sadly, we must
+            // suffer the performance hit of this very expensive call.  If there
+            // is consistency to what this call returns, we may be able to cache it.
+            k = worldIn.getBestNeighborSignal(upd.self);
+            wire.shouldSignal = true;
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
 
         // The variable 'k' holds the maximum redstone power value of any adjacent blocks.
         // If 'k' has the highest level of all neighbors, then the power level of this
diff --git a/net/minecraft/core/dispenser/DispenseItemBehavior.java b/net/minecraft/core/dispenser/DispenseItemBehavior.java
index ff32a89a720676c5a9f34ea7c859f03d47545b72..76ec194d213a1f3f8b7afd6565d8c63a07b524ba 100644
--- a/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -416,8 +416,8 @@ public interface DispenseItemBehavior {
                 // CraftBukkit start
                 level.captureTreeGeneration = false;
                 if (!level.capturedBlockStates.isEmpty()) {
-                    org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeType;
-                    net.minecraft.world.level.block.SaplingBlock.treeType = null;
+                    org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.getTreeTypeRT(); // Leaf - SparklyPaper - parallel world ticking
+                    net.minecraft.world.level.block.SaplingBlock.setTreeTypeRT(null); // Leaf - SparklyPaper - parallel world ticking
                     org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(blockPos, level);
                     List<org.bukkit.block.BlockState> states = new java.util.ArrayList<>(level.capturedBlockStates.values());
                     level.capturedBlockStates.clear();
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index 2a0d08a3f19022c34b51029d1aaa400dc620743c..96e16d7dbccc40a0ccf65cb8f46796fc126a0046 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -311,6 +311,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public boolean lagging = false; // Purpur - Lagging threshold
     protected boolean upnp = false; // Purpur - UPnP Port Forwarding
     public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("Leaf Async Mob Spawn Thread"); // Pufferfish - optimize mob spawning // Leaf - Fix Pufferfish and Purpur patches - Unify thread name
+    public java.util.concurrent.Semaphore serverLevelTickingSemaphore = null; // Leaf - SparklyPaper - parallel world ticking
     // Paper start - improve tick loop
     public final ca.spottedleaf.moonrise.common.time.TickData tickTimes1s  = new ca.spottedleaf.moonrise.common.time.TickData(java.util.concurrent.TimeUnit.SECONDS.toNanos(1L));
     public final ca.spottedleaf.moonrise.common.time.TickData tickTimes5s  = new ca.spottedleaf.moonrise.common.time.TickData(java.util.concurrent.TimeUnit.SECONDS.toNanos(5L));
@@ -454,24 +455,35 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private long lastMidTickExecute;
     private long lastMidTickExecuteFailure;
 
+    // Leaf start - SparklyPaper - parallel world ticking
+    private boolean pwt$tickLevelMidTickTasks(ServerLevel world) {
+        long currTime = System.nanoTime();
+        if (currTime - world.moonrise$getLastMidTickFailure() <= TASK_EXECUTION_FAILURE_BACKOFF) {
+            return false;
+        }
+        if (!world.getChunkSource().pollTask()) {
+            // we need to back off if this fails
+            world.moonrise$setLastMidTickFailure(currTime);
+            return false;
+        }
+        return true;
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
+
     private boolean tickMidTickTasks() {
         // give all worlds a fair chance at by targeting them all.
         // if we execute too many tasks, that's fine - we have logic to correctly handle overuse of allocated time.
-        boolean executed = false;
-        for (final ServerLevel world : this.getAllLevels()) {
-            long currTime = System.nanoTime();
-            if (currTime - ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$getLastMidTickFailure() <= TASK_EXECUTION_FAILURE_BACKOFF) {
-                continue;
-            }
-            if (!world.getChunkSource().pollTask()) {
-                // we need to back off if this fails
-                ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)world).moonrise$setLastMidTickFailure(currTime);
-            } else {
-                executed = true;
+        // Leaf start - SparklyPaper - parallel world ticking - only mid-tick the level for the current thread
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && Thread.currentThread() instanceof ca.spottedleaf.moonrise.common.util.TickThread.ServerLevelTickThread levelThread) {
+            return this.pwt$tickLevelMidTickTasks(levelThread.currentTickingServerLevel);
+        } else {
+            boolean executed = false;
+            for (final ServerLevel world : this.getAllLevels()) {
+                    executed = executed || this.pwt$tickLevelMidTickTasks(world);
             }
+            return executed;
         }
-
-        return executed;
+        // Leaf end - SparklyPaper - parallel world ticking - only mid-tick the level for the current thread
     }
 
     @Override
@@ -992,6 +1004,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
 
             serverLevel.save(null, flush, SharedConstants.DEBUG_DONT_SAVE_WORLD || serverLevel.noSave && !force, close); // Paper - add close param
+            // Leaf start - SparklyPaper - parallel world ticking - Shutdown handling for async reads
+            // Only prepare shutdown if 'close' is true, indicating this save is part of server shutdown
+            if (close && org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+                serverLevel.prepareShutdown();
+            }
+            // Leaf end - SparklyPaper - parallel world ticking - Shutdown handling for async reads
             flag = true;
         }
 
@@ -1836,6 +1854,18 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList(); // Paper - optimise Folia entity scheduler
 
+    // Leaf start - SparklyPaper - parallel world ticking - move level ticking logic out for branch convergence
+    private void tickLevel(ServerLevel serverLevel, BooleanSupplier hasTimeLeft) {
+        try {
+            serverLevel.tick(hasTimeLeft);
+        } catch (Throwable levelTickingException) {
+            CrashReport crashReport = CrashReport.forThrowable(levelTickingException, "Exception ticking world");
+            serverLevel.fillReportDetails(crashReport);
+            throw new ReportedException(crashReport);
+        }
+    }
+    // Leaf end - SparklyPaper - parallel world ticking - move level ticking logic out for branch convergence
+
     protected void tickChildren(BooleanSupplier hasTimeLeft) {
         ProfilerFiller profilerFiller = Profiler.get();
         this.getPlayerList().getPlayers().forEach(serverPlayer1 -> serverPlayer1.connection.suspendFlushing());
@@ -1885,35 +1915,56 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         }
 
         this.isIteratingOverLevels = true; // Paper - Throw exception on world create while being ticked
-        for (ServerLevel serverLevel : this.getAllLevels()) {
-            serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
-            serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
-            serverLevel.updateLagCompensationTick(); // Paper - lag compensation
-            net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = serverLevel.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
-            serverLevel.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur - Ridables
-            profilerFiller.push(() -> serverLevel + " " + serverLevel.dimension().identifier());
-            /* Drop global time updates
-            if (this.tickCount % 20 == 0) {
-                profilerFiller.push("timeSync");
-                this.synchronizeTime(serverLevel);
-                profilerFiller.pop();
-            }
-            // CraftBukkit end */
+        // Leaf start - SparklyPaper - parallel world ticking
+        java.util.ArrayDeque<java.util.concurrent.Future<ServerLevel>> tasks = new java.util.ArrayDeque<>();
+        try {
+            for (ServerLevel serverLevel : this.getAllLevels()) {
+                serverLevel.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
+                serverLevel.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
+                serverLevel.updateLagCompensationTick(); // Paper - lag compensation
+                net.minecraft.world.level.block.entity.HopperBlockEntity.skipHopperEvents = serverLevel.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+                serverLevel.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur - Ridables
+                profilerFiller.push(() -> serverLevel + " " + serverLevel.dimension().identifier());
+                /* Drop global time updates
+                if (this.tickCount % 20 == 0) {
+                    profilerFiller.push("timeSync");
+                    this.synchronizeTime(serverLevel);
+                    profilerFiller.pop();
+                }
+                // CraftBukkit end */
 
-            profilerFiller.push("tick");
+                profilerFiller.push("tick");
 
-            try {
-                serverLevel.tick(hasTimeLeft);
-            } catch (Throwable var7) {
-                CrashReport crashReport = CrashReport.forThrowable(var7, "Exception ticking world");
-                serverLevel.fillReportDetails(crashReport);
-                throw new ReportedException(crashReport);
+                if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+                    serverLevelTickingSemaphore.acquire();
+                    tasks.add(
+                        serverLevel.tickExecutor.submit(() -> {
+                            ca.spottedleaf.moonrise.common.util.TickThread.ServerLevelTickThread currentThread = (ca.spottedleaf.moonrise.common.util.TickThread.ServerLevelTickThread) Thread.currentThread();
+                            currentThread.currentTickingServerLevel = serverLevel;
+
+                            try {
+                                tickLevel(serverLevel, hasTimeLeft); // Leaf - SparklyPaper - parallel world ticking - move level ticking logic out for branch convergence
+                            } finally {
+                                serverLevelTickingSemaphore.release();
+                            }
+                        }, serverLevel)
+                    );
+                } else {
+                    tickLevel(serverLevel, hasTimeLeft);
+                }
+
+                profilerFiller.pop();
+                profilerFiller.pop();
+                serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
             }
 
-            profilerFiller.pop();
-            profilerFiller.pop();
-            serverLevel.explosionDensityCache.clear(); // Paper - Optimize explosions
+            while (!tasks.isEmpty()) {
+                tasks.pop().get();
+            }
+        } catch (java.lang.InterruptedException | java.util.concurrent.ExecutionException e) {
+            throw new RuntimeException(e); // Propagate exception
         }
+        // Leaf end - SparklyPaper - parallel world ticking
         this.isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
 
         profilerFiller.popPush("connection");
@@ -2011,6 +2062,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) level.tickExecutor.shutdown(); // Leaf - SparklyPaper - parallel world ticking (We remove it in here instead of ServerLevel.close() because ServerLevel.close() is never called!)
         this.levels = Collections.unmodifiableMap(newLevels);
     }
     // CraftBukkit end
diff --git a/net/minecraft/server/PlayerAdvancements.java b/net/minecraft/server/PlayerAdvancements.java
index 78135cf45c8900eb142933d216744f4a73127965..96525c3107801cdb2904e5379cd59b98024141cd 100644
--- a/net/minecraft/server/PlayerAdvancements.java
+++ b/net/minecraft/server/PlayerAdvancements.java
@@ -53,8 +53,10 @@ public class PlayerAdvancements {
     private AdvancementTree tree;
     private final Map<AdvancementHolder, AdvancementProgress> progress = new LinkedHashMap<>();
     private final Set<AdvancementHolder> visible = new HashSet<>();
-    private final Set<AdvancementHolder> progressChanged = new HashSet<>();
-    private final Set<AdvancementNode> rootsToUpdate = new HashSet<>();
+    // Leaf start - SparklyPaper - parallel world ticking
+    private final Set<AdvancementHolder> progressChanged = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? java.util.concurrent.ConcurrentHashMap.newKeySet() : new HashSet<>();
+    private final Set<AdvancementNode> rootsToUpdate = new HashSet<>(); // Always managed on player tick thread
+    // Leaf end - SparklyPaper - parallel world ticking
     private ServerPlayer player;
     private @Nullable AdvancementHolder lastSelectedTab;
     private boolean isFirstPacket = true;
@@ -149,7 +151,7 @@ public class PlayerAdvancements {
                 if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.ignoredAdvancements) LOGGER.warn("Ignored advancement '{}' in progress file {} - it doesn't exist anymore?", path, this.playerSavePath); // Gale - Purpur - do not log ignored advancements
             } else {
                 this.startProgress(advancementHolder, progress);
-                this.progressChanged.add(advancementHolder);
+                this.progressChanged.add(advancementHolder); // Leaf - SparklyPaper - parallel world ticking fix - Always add to non-concurrent set during load, flushDirty will handle sync
                 this.markForVisibilityUpdate(advancementHolder);
             }
         });
@@ -218,7 +220,7 @@ public class PlayerAdvancements {
             flag = true;
         }
 
-        if (isDone && !orStartProgress.isDone()) {
+        if (isDone && !orStartProgress.isDone()) { // Leaf - SparklyPaper - parallel world ticking - If the advancement was just un-completed
             this.markForVisibilityUpdate(advancement);
         }
 
@@ -264,6 +266,7 @@ public class PlayerAdvancements {
     }
 
     public void flushDirty(ServerPlayer player, boolean showAdvancements) {
+        final boolean isConcurrent = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled; // Leaf - SparklyPaper - parallel world ticking
         if (this.isFirstPacket || !this.rootsToUpdate.isEmpty() || !this.progressChanged.isEmpty()) {
             Map<Identifier, AdvancementProgress> map = new HashMap<>();
             Set<AdvancementHolder> set = new java.util.TreeSet<>(java.util.Comparator.comparing(adv -> adv.id().toString())); // Paper - Changed from HashSet to TreeSet ordered alphabetically.
@@ -275,13 +278,23 @@ public class PlayerAdvancements {
 
             this.rootsToUpdate.clear();
 
-            for (AdvancementHolder advancementHolder : this.progressChanged) {
+            // Leaf start - SparklyPaper - parallel world ticking
+            if (!this.progressChanged.isEmpty()) {
+                Set<AdvancementHolder> toProcess = isConcurrent ? new HashSet<>(this.progressChanged) : this.progressChanged;
+
+            for (AdvancementHolder advancementHolder : toProcess) {
                 if (this.visible.contains(advancementHolder)) {
                     map.put(advancementHolder.id(), this.progress.get(advancementHolder));
                 }
             }
 
-            this.progressChanged.clear();
+                if (isConcurrent) {
+                    this.progressChanged.removeAll(toProcess); // Remove processed items from concurrent set
+                } else {
+                    this.progressChanged.clear();
+                }
+            }
+            // Leaf end - SparklyPaper - parallel world ticking
             if (!map.isEmpty() || !set.isEmpty() || !set1.isEmpty()) {
                 player.connection.send(new ClientboundUpdateAdvancementsPacket(this.isFirstPacket, set, set1, map, showAdvancements));
             }
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index f24ce01762e865a4302af6eb4aa87ff7e0da564f..a8890cbe24479fd65c0de1688187fd250c5ef2c8 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -297,6 +297,12 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.purpurmc.purpur.PurpurConfig.registerCommands();
         */// Purpur end - Purpur config files // Purpur end - Migrate Setting to reintroduce end void rings
         org.dreeam.leaf.command.LeafCommands.registerCommands(this); // Leaf - Leaf commands
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            serverLevelTickingSemaphore = new java.util.concurrent.Semaphore(org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.threads);
+            DedicatedServer.LOGGER.info("Using {} permits for parallel world ticking", serverLevelTickingSemaphore.availablePermits());
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
 
         // Gale start - Pufferfish - SIMD support
diff --git a/net/minecraft/server/level/ServerChunkCache.java b/net/minecraft/server/level/ServerChunkCache.java
index 8ebc3aaa79526cc489885bc817d0c9880ab6ca55..3849314a97b484af454aa8b9a3fe96389cf20e86 100644
--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -176,6 +176,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
             // call mid-tick tasks for chunk system
             if ((i & 7) == 0) {
+                if (!org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) // Leaf - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
                 ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.level.getServer()).moonrise$executeMidTickTasks();
                 continue;
             }
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 8f6cbc40c59800f2e1ee08c3ea0f12c9daa375c3..79745c9e576ff0c861ce920fb80dc1512af02d4c 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -194,7 +194,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     public final ServerChunkCache chunkSource;
     private final MinecraftServer server;
     public final net.minecraft.world.level.storage.PrimaryLevelData serverLevelData; // CraftBukkit - type
-    final EntityTickList entityTickList = new EntityTickList();
+    final EntityTickList entityTickList = new EntityTickList(this); // Leaf - SparklyPaper - parallel world ticking
     private final ServerWaypointManager waypointManager;
     private final EnvironmentAttributeSystem environmentAttributes;
     // Paper - rewrite chunk system
@@ -222,6 +222,11 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
     final LevelDebugSynchronizers debugSynchronizers = new LevelDebugSynchronizers(this);
+    // Leaf start - SparklyPaper - parallel world ticking
+    public final java.util.concurrent.ExecutorService tickExecutor;
+    public final java.util.concurrent.ConcurrentLinkedQueue<org.dreeam.leaf.async.world.WorldReadRequest> asyncReadRequestQueue;
+    private volatile boolean isShuttingDown = false; // Shutdown handling for async reads
+    // Leaf end - SparklyPaper - parallel world ticking
 
     // CraftBukkit start
     public final LevelStorageSource.LevelStorageAccess levelStorageAccess;
@@ -712,7 +717,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         this.sleepStatus = new SleepStatus();
         this.gameEventDispatcher = new GameEventDispatcher(this);
         this.randomSequences = Objects.requireNonNullElseGet(randomSequences, () -> this.getDataStorage().computeIfAbsent(RandomSequences.TYPE));
-        this.waypointManager = new ServerWaypointManager();
+        this.waypointManager = new ServerWaypointManager(this); // Leaf - SparklyPaper - parallel world ticking
         this.environmentAttributes = EnvironmentAttributeSystem.builder().addDefaultLayers(this).build();
         this.updateSkyBrightness();
         // Paper start - rewrite chunk system
@@ -731,6 +736,15 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.preciseTime = this.serverLevelData.getDayTime(); // Purpur - Configurable daylight cycle
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            this.tickExecutor = java.util.concurrent.Executors.newSingleThreadExecutor(new org.dreeam.leaf.async.world.SparklyPaperServerLevelTickExecutorThreadFactory(getWorld().getName()));
+            this.asyncReadRequestQueue = new java.util.concurrent.ConcurrentLinkedQueue<>();
+        } else {
+            this.tickExecutor = null;
+            this.asyncReadRequestQueue = null;
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
     }
 
     // Paper start
@@ -768,9 +782,128 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         return this.environmentAttributes;
     }
 
+    // Leaf start - SparklyPaper - parallel world ticking - Shutdown handling for async reads
+    public boolean isShuttingDown() {
+        return this.isShuttingDown;
+    }
+
+    public void prepareShutdown() {
+        this.isShuttingDown = true;
+        org.dreeam.leaf.async.world.WorldReadRequest req;
+        int clearedRequests = 0;
+        while ((req = this.asyncReadRequestQueue.poll()) != null) {
+            req.future().completeExceptionally(new IllegalStateException("World " + this.getWorld().getName() + " is shutting down. Cannot process buffered read: " + req.type()));
+            clearedRequests++;
+        }
+        if (clearedRequests > 0) {
+            MinecraftServer.LOGGER.info("PWT: Cleared {} pending async read requests for world {} during shutdown.", clearedRequests, this.getWorld().getName());
+        }
+    }
+    // Leaf end - SparklyPaper - parallel world ticking - Shutdown handling for async reads
+
+    // Leaf start - SparklyPaper - parallel world ticking
+    private void processAsyncReadRequests() {
+        // Clear queue if buffering gets disabled to prevent memory leaks
+        if (org.dreeam.leaf.async.world.UnsafeReadPolicy.BUFFERED != org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.asyncUnsafeReadHandling && !this.asyncReadRequestQueue.isEmpty()) {
+            org.dreeam.leaf.async.world.WorldReadRequest req;
+            while ((req = this.asyncReadRequestQueue.poll()) != null) {
+                req.future().completeExceptionally(new IllegalStateException("Async read buffering disabled while request was pending."));
+            }
+            return;
+        }
+
+        org.dreeam.leaf.async.world.WorldReadRequest request;
+        int processed = 0;
+        // Limit processing per tick to avoid stalling the tick loop
+        int maxToProcess = 16384; // Consider making this configurable
+
+        while (processed < maxToProcess && (request = this.asyncReadRequestQueue.poll()) != null) {
+            processed++;
+            // Ensure we are on the correct thread before executing
+            // This check might be redundant if called correctly from tick(), but good for safety
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Processing async read request off-thread");
+
+            try {
+                Object result = executeReadRequest(request);
+                request.future().complete(result);
+            } catch (Throwable t) {
+                // Log the error from the tick thread side
+                org.bukkit.Bukkit.getLogger().log(java.util.logging.Level.SEVERE, "Exception processing buffered async world read for type " + request.type(), t);
+                request.future().completeExceptionally(t);
+            }
+        }
+    }
+
+    // Executes the actual read operation based on the request type
+    public Object executeReadRequest(org.dreeam.leaf.async.world.WorldReadRequest request) {
+        Object[] params = request.params();
+        BlockPos pos; // Declare pos outside the switch
+
+        switch (request.type()) {
+            case BLOCK_GET_NMS_STATE: { //
+                pos = (BlockPos) params[0];
+                return this.getBlockState(pos);
+            }
+            case BLOCK_GET_BIOME: {
+                pos = (BlockPos) params[0];
+                return this.getNoiseBiome(pos.getX() >> 2, pos.getY() >> 2, pos.getZ() >> 2);
+            }
+            case BLOCK_GET_COMPUTED_BIOME: {
+                pos = (BlockPos) params[0];
+                return this.getBiome(pos);
+            }
+            case BLOCK_IS_INDIRECTLY_POWERED: {
+                pos = (BlockPos) params[0];
+                return this.hasNeighborSignal(pos);
+            }
+            case BLOCK_GET_BLOCK_POWER: {
+                pos = (BlockPos) params[0];
+                org.bukkit.block.BlockFace face = (org.bukkit.block.BlockFace) params[1];
+                int power = 0;
+                Direction notchDir = org.bukkit.craftbukkit.block.CraftBlock.blockFaceToNotch(face);
+
+                if ((face == org.bukkit.block.BlockFace.DOWN || face == org.bukkit.block.BlockFace.SELF) && this.hasSignal(pos.below(), Direction.DOWN)) power = org.bukkit.craftbukkit.block.CraftBlock.getPower(power, this.getBlockState(pos.below()));
+                if ((face == org.bukkit.block.BlockFace.UP || face == org.bukkit.block.BlockFace.SELF) && this.hasSignal(pos.above(), Direction.UP)) power = org.bukkit.craftbukkit.block.CraftBlock.getPower(power, this.getBlockState(pos.above()));
+                if ((face == org.bukkit.block.BlockFace.EAST || face == org.bukkit.block.BlockFace.SELF) && this.hasSignal(pos.east(), Direction.EAST)) power = org.bukkit.craftbukkit.block.CraftBlock.getPower(power, this.getBlockState(pos.east()));
+                if ((face == org.bukkit.block.BlockFace.WEST || face == org.bukkit.block.BlockFace.SELF) && this.hasSignal(pos.west(), Direction.WEST)) power = org.bukkit.craftbukkit.block.CraftBlock.getPower(power, this.getBlockState(pos.west()));
+                if ((face == org.bukkit.block.BlockFace.NORTH || face == org.bukkit.block.BlockFace.SELF) && this.hasSignal(pos.north(), Direction.NORTH)) power = org.bukkit.craftbukkit.block.CraftBlock.getPower(power, this.getBlockState(pos.north()));
+                if ((face == org.bukkit.block.BlockFace.SOUTH || face == org.bukkit.block.BlockFace.SELF) && this.hasSignal(pos.south(), Direction.SOUTH)) power = org.bukkit.craftbukkit.block.CraftBlock.getPower(power, this.getBlockState(pos.south()));
+
+                boolean indirectlyPowered = (face == org.bukkit.block.BlockFace.SELF) ? this.hasNeighborSignal(pos) : (this.getSignal(pos, notchDir) > 0); // Simplified indirect check for faces
+                return power > 0 ? power : (indirectlyPowered ? 15 : 0);
+            }
+            case BLOCK_RAY_TRACE: {
+                pos = (BlockPos) params[0];
+                org.bukkit.Location start = (org.bukkit.Location) params[1];
+                org.bukkit.util.Vector direction = (org.bukkit.util.Vector) params[2];
+                double maxDistance = (double) params[3];
+                org.bukkit.FluidCollisionMode fluidCollisionMode = (org.bukkit.FluidCollisionMode) params[4];
+
+                org.bukkit.util.Vector dir = direction.clone().normalize().multiply(maxDistance);
+                Vec3 startPos = org.bukkit.craftbukkit.util.CraftLocation.toVec3(start);
+                Vec3 endPos = startPos.add(dir.getX(), dir.getY(), dir.getZ());
+
+                return this.clip(new net.minecraft.world.level.ClipContext(startPos, endPos, net.minecraft.world.level.ClipContext.Block.OUTLINE, org.bukkit.craftbukkit.CraftFluidCollisionMode.toFluid(fluidCollisionMode), net.minecraft.world.phys.shapes.CollisionContext.empty()), pos); // Pass block pos
+            }
+            case BLOCK_CAN_PLACE: {
+                pos = (BlockPos) params[0];
+                org.bukkit.block.data.BlockData data = (org.bukkit.block.data.BlockData) params[1];
+                net.minecraft.world.level.block.state.BlockState nmsData = ((org.bukkit.craftbukkit.block.data.CraftBlockData) data).getState();
+                return nmsData.canSurvive(this, pos);
+            }
+            // Add cases for other ReadOperationType values here...
+            // case GET_ENTITIES_IN_BOX: ... (complex, needs careful list handling)
+
+            default:
+                throw new UnsupportedOperationException("Unsupported buffered read type: " + request.type());
+        }
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
+
     public void tick(BooleanSupplier hasTimeLeft) {
         ProfilerFiller profilerFiller = Profiler.get();
         this.handlingTick = true;
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) this.processAsyncReadRequests(); // Leaf - SparklyPaper - parallel world ticking
         TickRateManager tickRateManager = this.tickRateManager();
         boolean runsNormally = tickRateManager.runsNormally();
         if (runsNormally) {
@@ -781,6 +914,12 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             profilerFiller.pop();
         }
 
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && (++this.tickedBlocksOrFluids & 7L) != 0L) { // Execute mid-tick tasks if PWT is enabled
+            this.moonrise$midTickTasks();
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
+
         int i = this.getGameRules().get(GameRules.PLAYERS_SLEEPING_PERCENTAGE);
         if (this.purpurConfig.playersSkipNight && this.sleepStatus.areEnoughSleeping(i) && this.sleepStatus.areEnoughDeepSleeping(i, this.players)) { // Purpur - Config for skipping night
             // Paper start - create time skip event - move up calculations
@@ -886,6 +1025,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                                         entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
                                         // Paper end - Prevent block entity and entity crashes
                                     }
+                                    if (!org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) // Leaf - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
                                     this.moonrise$midTickTasks(); // Paper - rewrite chunk system
                                     // Gale end - Airplane - remove lambda from ticking guard - copied from guardEntityTick
                                     profilerFiller.pop();
@@ -1415,7 +1555,10 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             fluidState.tick(this, pos, blockState);
         }
         // Paper start - rewrite chunk system
-        if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
+        // Leaf start - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
+        ++this.tickedBlocksOrFluids;
+        if (!org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && (this.tickedBlocksOrFluids & 7L) != 0L) {
+            // Leaf end - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
             ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
         }
         // Paper end - rewrite chunk system
@@ -1428,7 +1571,10 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             blockState.tick(this, pos, this.random);
         }
         // Paper start - rewrite chunk system
-        if ((++this.tickedBlocksOrFluids & 7L) != 0L) {
+        // Leaf start - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
+        ++this.tickedBlocksOrFluids;
+        if (!org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && (this.tickedBlocksOrFluids & 7L) != 0L) {
+            // Leaf end - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
             ((ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer)this.server).moonrise$executeMidTickTasks();
         }
         // Paper end - rewrite chunk system
@@ -1699,6 +1845,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     }
 
     private void addPlayer(ServerPlayer player) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot add player off-main"); // Leaf - SparklyPaper - parallel world ticking (async is no longer safe; schedule on main; additional concurrency issues logs)
         Entity entity = this.getEntity(player.getUUID());
         if (entity != null) {
             LOGGER.warn("Force-added player with duplicate UUID {}", player.getUUID());
@@ -1711,7 +1858,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     // CraftBukkit start
     private boolean addEntity(Entity entity, org.bukkit.event.entity.CreatureSpawnEvent.@Nullable SpawnReason spawnReason) {
-        org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot add entity off-main"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
+        } else {
+            org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
         entity.generation = false; // Paper - Don't fire sync event during generation; Reset flag if it was added during a ServerLevel generation process
         // Paper start - extra debug info
         if (entity.valid) {
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index 84ea591ecd4f42383f69525f32b748d15497cfed..bd97fe2058d236ba5c8e25e60d4b3216917fb5df 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -470,6 +470,8 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
     }
     // Paper end - rewrite chunk system
 
+    public boolean hasTickedAtLeastOnceInNewWorld = false; // Leaf - SparklyPaper - parallel world ticking (fixes bug in DreamResourceReset where the inventory is opened AFTER the player has changed worlds, if you click with the quick tp torch in a chest, because the inventory is opened AFTER the player has teleported)
+
     public ServerPlayer(MinecraftServer server, ServerLevel level, GameProfile gameProfile, ClientInformation clientInformation) {
         super(level, gameProfile);
         this.server = server;
@@ -726,6 +728,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
     @Override
     public void tick() {
+        hasTickedAtLeastOnceInNewWorld = true; // Leaf - SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
         // CraftBukkit start
         if (this.joining) {
             this.joining = false;
@@ -1565,6 +1568,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                 teleportTransition.postTeleportTransition().onTransition(this);
                 return this;
             } else {
+                if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot change dimension of a player off-main, from world[" + serverLevel.getWorld().getName() + "] to world[" + level.getWorld().getName() + "]"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
                 this.isChangingDimension = true;
                 LevelData levelData = level.getLevelData();
                 this.connection.send(new ClientboundRespawnPacket(this.createCommonSpawnInfo(level), ClientboundRespawnPacket.KEEP_ALL_DATA));
@@ -1895,6 +1899,12 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                 return OptionalInt.empty();
             } else {
                 // CraftBukkit start
+                // Leaf start - SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
+                if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && !hasTickedAtLeastOnceInNewWorld) {
+                    MinecraftServer.LOGGER.warn("Ignoring request to open container {} because we haven't ticked in the current world yet!", abstractContainerMenu, new Throwable());
+                    return OptionalInt.empty();
+                }
+                // Leaf end - SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
                 this.containerMenu = abstractContainerMenu; // Moved up
                 if (!this.isImmobile())
                 this.connection
@@ -1983,6 +1993,11 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
     }
     @Override
     public void closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason reason) {
+        // Leaf start - SparklyPaper - parallel world ticking (debugging)
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.logContainerCreationStacktraces) {
+            MinecraftServer.LOGGER.warn("Closing {} inventory that was created at", this.getBukkitEntity().getName(), this.containerMenu.containerCreationStacktrace);
+        }
+        // Leaf end - SparklyPaper - parallel world ticking (debugging)
         org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(this, reason); // CraftBukkit
         // Paper end - Inventory close reason
         this.connection.send(new ClientboundContainerClosePacket(this.containerMenu.containerId));
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index 75be3647b91b34b32d79fb185f53289141923a91..9f7d2b0766b0c3a181e3db33140758f77a2a0431 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -156,6 +156,7 @@ public abstract class PlayerList {
     abstract public void loadAndSaveFiles(); // Paper - fix converting txt to json file; moved from DedicatedPlayerList constructor
 
     public void placeNewPlayer(Connection connection, ServerPlayer player, CommonListenerCookie cookie) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureOnlyTickThread("Cannot place new player off-main"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         player.isRealPlayer = true; // Paper
         player.loginTime = System.currentTimeMillis(); // Paper - Replace OfflinePlayer#getLastPlayed
         NameAndId nameAndId = player.nameAndId();
@@ -615,6 +616,14 @@ public abstract class PlayerList {
 
     // Paper start - respawn event
     public ServerPlayer respawn(ServerPlayer player, boolean keepInventory, Entity.RemovalReason reason, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason respawnReason) {
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && !this.server.isSameThread()) {
+            // Respawning is a complex operation that modifies global player lists and can interact with multiple
+            // worlds. It must be executed on the main server thread to ensure thread safety. We block the
+            // calling (world) thread to wait for the result, preserving the synchronous API contract of this method.
+            return this.server.submit(() -> this.respawn(player, keepInventory, reason, respawnReason)).join();
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
         ServerPlayer.RespawnResult result = player.findRespawnPositionAndUseSpawnBlock0(!keepInventory, TeleportTransition.DO_NOTHING, respawnReason);
         if (result == null) { // disconnected player during the respawn event
             return player;
@@ -628,6 +637,7 @@ public abstract class PlayerList {
         player.level().removePlayerImmediately(player, reason);
         ServerLevel level = teleportTransition.newLevel();
         ServerPlayer serverPlayer = player; // Paper - TODO - recreate instance
+        serverPlayer.hasTickedAtLeastOnceInNewWorld = false; // Leaf - SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
         serverPlayer.connection = player.connection;
         serverPlayer.restoreFrom(player, keepInventory);
         serverPlayer.setId(player.getId());
diff --git a/net/minecraft/server/waypoints/ServerWaypointManager.java b/net/minecraft/server/waypoints/ServerWaypointManager.java
index 471e558a609c9e457720660b90fe57322b860461..3bf75ecdee76c53e178509619be8011bce4226d9 100644
--- a/net/minecraft/server/waypoints/ServerWaypointManager.java
+++ b/net/minecraft/server/waypoints/ServerWaypointManager.java
@@ -20,8 +20,16 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     private final Set<ServerPlayer> players = new HashSet<>();
     private final Table<ServerPlayer, WaypointTransmitter, WaypointTransmitter.Connection> connections = HashBasedTable.create();
 
+    // Leaf start - SparklyPaper - parallel world ticking
+    private final net.minecraft.server.level.ServerLevel level;
+    public ServerWaypointManager(net.minecraft.server.level.ServerLevel level) {
+        this.level = level;
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
+
     @Override
     public void trackWaypoint(WaypointTransmitter waypoint) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot track waypoints off-main"); // Leaf - SparklyPaper - parallel world ticking
         this.waypoints.add(waypoint);
 
         for (ServerPlayer serverPlayer : this.players) {
@@ -31,6 +39,7 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
 
     @Override
     public void updateWaypoint(WaypointTransmitter waypoint) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot update waypoints off-main"); // Leaf - SparklyPaper - parallel world ticking
         if (this.waypoints.contains(waypoint)) {
             Map<ServerPlayer, WaypointTransmitter.Connection> map = Tables.transpose(this.connections).row(waypoint);
             SetView<ServerPlayer> set = Sets.difference(this.players, map.keySet());
@@ -47,12 +56,14 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
 
     @Override
     public void untrackWaypoint(WaypointTransmitter waypoint) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot untrack waypoints off-main"); // Leaf - SparklyPaper - parallel world ticking
         this.connections.column(waypoint).forEach((serverPlayer, connection) -> connection.disconnect());
         Tables.transpose(this.connections).row(waypoint).clear();
         this.waypoints.remove(waypoint);
     }
 
     public void addPlayer(ServerPlayer player) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot add player to waypoints off-main"); // Leaf - SparklyPaper - parallel world ticking
         this.players.add(player);
 
         for (WaypointTransmitter waypointTransmitter : this.waypoints) {
@@ -65,6 +76,7 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     }
 
     public void updatePlayer(ServerPlayer player) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot update player for waypoints off-main"); // Leaf - SparklyPaper - parallel world ticking
         Map<WaypointTransmitter, WaypointTransmitter.Connection> map = this.connections.row(player);
         SetView<WaypointTransmitter> set = Sets.difference(this.waypoints, map.keySet());
 
@@ -78,6 +90,7 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     }
 
     public void removePlayer(ServerPlayer player) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot remove player from waypoints off-main"); // Leaf - SparklyPaper - parallel world ticking
         this.connections.row(player).values().removeIf(connection -> {
             connection.disconnect();
             return true;
@@ -87,6 +100,7 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     }
 
     public void breakAllConnections() {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot break all waypoint connections off-main"); // Leaf - SparklyPaper - parallel world ticking
         this.connections.values().forEach(WaypointTransmitter.Connection::disconnect);
         this.connections.clear();
     }
@@ -106,6 +120,7 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     }
 
     private void createConnection(ServerPlayer player, WaypointTransmitter waypoint) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot create waypoint connections off-main"); // Leaf - SparklyPaper - parallel world ticking
         if (player != waypoint) {
             if (isLocatorBarEnabledFor(player)) {
                 waypoint.makeWaypointConnectionWith(player).ifPresentOrElse(connection -> {
@@ -122,6 +137,7 @@ public class ServerWaypointManager implements WaypointManager<WaypointTransmitte
     }
 
     private void updateConnection(ServerPlayer player, WaypointTransmitter waypoint, WaypointTransmitter.Connection connection) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, "Cannot update waypoint connection off-main"); // Leaf - SparklyPaper - parallel world ticking
         if (player != waypoint) {
             if (isLocatorBarEnabledFor(player)) {
                 if (!connection.isBroken()) {
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index dc41aa4da487929e955de17a91c8bc4471d9519b..f2ba25c6cb6414c5e26b07c279a4ee63f740455a 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -3574,15 +3574,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
                     ProfilerFiller profilerFiller = Profiler.get();
                     profilerFiller.push("portal");
                     this.setPortalCooldown();
-                    TeleportTransition portalDestination = this.portalProcess.getPortalDestination(serverLevel, this);
-                    if (portalDestination != null) {
-                        ServerLevel level = portalDestination.newLevel();
-                        if (serverLevel.isAllowedToEnterPortal(level) && (level.dimension() == serverLevel.dimension() || this.canTeleport(serverLevel, level))
-                            )
-                         {
-                            this.teleport(portalDestination);
-                        }
-                    }
+                    handleTeleport(serverLevel); // Leaf - SparklyPaper - parallel world ticking
 
                     profilerFiller.pop();
                 } else if (this.portalProcess.hasExpired()) {
@@ -3592,6 +3584,56 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
         }
     }
 
+    // Leaf start - SparklyPaper - parallel world ticking - mark pending teleport to prevent clearing portal process
+    private void handleTeleport(ServerLevel serverLevel) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            pwt$handleTeleport(serverLevel);
+        } else {
+            TeleportTransition portalDestination = this.portalProcess.getPortalDestination(serverLevel, this);
+            if (portalDestination != null) {
+                ServerLevel level = portalDestination.newLevel();
+                if (serverLevel.isAllowedToEnterPortal(level) && (level.dimension() == serverLevel.dimension() || this.canTeleport(serverLevel, level))
+                ) {
+                    this.teleport(portalDestination);
+                }
+            }
+        }
+    }
+
+    private void pwt$handleTeleport(ServerLevel serverLevel) {
+        java.util.function.Consumer<Entity> portalEntityTask = entity -> {
+            assert entity.portalProcess != null;
+            // Fix NPE when portalProcess becomes null before task execution
+            // Portal process was likely nulled out (e.g., expired) between scheduling and execution.
+            if (entity.portalProcess == null) {
+                return;
+            }
+
+            if (entity.portalProcess.isParallelCancelledByPlugin()) {
+                entity.portalProcess = null;
+                return;
+            }
+
+            TeleportTransition portalDestination = entity.portalProcess.getPortalDestination(serverLevel, entity);
+            if (portalDestination != null) {
+                ServerLevel level = portalDestination.newLevel();
+                if (serverLevel.isAllowedToEnterPortal(level) && (level.dimension() == serverLevel.dimension() || this.canTeleport(serverLevel, level))
+                ) {
+                    entity.teleport(portalDestination);
+                }
+            }
+            // Add another null check here just in case teleport() somehow nulled it (defensive)
+            if (entity.portalProcess != null) {
+                entity.portalProcess.confirmParallelAsHandled();
+            }
+        };
+
+        this.portalProcess.setParallelAsScheduled();
+        this.getBukkitEntity().taskScheduler.schedule(portalEntityTask, entity -> {
+        }, 0);
+    }
+    // Leaf start - SparklyPaper - parallel world ticking - mark pending teleport to prevent clearing portal process
+
     public int getDimensionChangingDelay() {
         Entity firstPassenger = this.getFirstPassenger();
         return firstPassenger instanceof ServerPlayer ? firstPassenger.getDimensionChangingDelay() : 300;
@@ -4162,6 +4204,7 @@ public abstract class Entity implements SyncedDataHolder, DebugValueSource, Name
     }
 
     private @Nullable Entity teleportCrossDimension(ServerLevel oldLevel, ServerLevel newLevel, TeleportTransition teleportTransition) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(newLevel, "Cannot teleport entity to another world off-main, from world[" + oldLevel.getWorld().getName() + "] to world[" + newLevel.getWorld().getName() + "]"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         List<Entity> passengers = this.getPassengers();
         List<Entity> list = new ArrayList<>(passengers.size());
         this.ejectPassengers();
diff --git a/net/minecraft/world/entity/PortalProcessor.java b/net/minecraft/world/entity/PortalProcessor.java
index 4e69e32ad000b8c02e44c3ffce24ff5e3c090a2f..2f12b6804627e451b9575fa9525d0723ef6fa67d 100644
--- a/net/minecraft/world/entity/PortalProcessor.java
+++ b/net/minecraft/world/entity/PortalProcessor.java
@@ -11,6 +11,7 @@ public class PortalProcessor {
     private BlockPos entryPosition;
     private int portalTime;
     private boolean insidePortalThisTick;
+    private ParallelPendingTeleportState pendingTeleport = ParallelPendingTeleportState.INACTIVE; // Leaf - SparklyPaper - parallel world ticking - prevent clearing portal process
 
     public PortalProcessor(Portal portal, BlockPos entryPosition) {
         this.portal = portal;
@@ -19,6 +20,8 @@ public class PortalProcessor {
     }
 
     public boolean processPortalTeleportation(ServerLevel level, Entity entity, boolean canChangeDimensions) {
+        if (this.isParallelTeleportScheduled()) return false; // Leaf - SparklyPaper - parallel world ticking - prevent clearing portal process
+
         if (!this.insidePortalThisTick) {
             this.decayTick();
             return false;
@@ -41,7 +44,7 @@ public class PortalProcessor {
     }
 
     public boolean hasExpired() {
-        return this.portalTime <= 0;
+        return !this.isParallelTeleportScheduled() && this.portalTime <= 0; // Leaf - SparklyPaper - parallel world ticking - prevent clearing portal process
     }
 
     public BlockPos getEntryPosition() {
@@ -67,4 +70,36 @@ public class PortalProcessor {
     public boolean isSamePortal(Portal portal) {
         return this.portal == portal;
     }
+
+    // Leaf start - SparklyPaper - parallel world ticking - prevent clearing portal process
+    public boolean isParallelTeleportPending() {
+        return this.pendingTeleport == ParallelPendingTeleportState.PENDING;
+    }
+
+    public boolean isParallelTeleportScheduled() {
+        return this.pendingTeleport != ParallelPendingTeleportState.INACTIVE;
+    }
+
+    public boolean isParallelCancelledByPlugin() {
+        return this.pendingTeleport == ParallelPendingTeleportState.CANCELLED;
+    }
+
+    public void setParallelAsScheduled() {
+        this.pendingTeleport = ParallelPendingTeleportState.PENDING;
+    }
+
+    public void confirmParallelAsHandled() {
+        this.pendingTeleport = ParallelPendingTeleportState.INACTIVE;
+    }
+
+    public void setParallelAsCancelled() {
+        this.pendingTeleport = ParallelPendingTeleportState.CANCELLED;
+    }
+
+    private enum ParallelPendingTeleportState {
+        INACTIVE,
+        PENDING,
+        CANCELLED
+    }
+    // Leaf end - SparklyPaper - parallel world ticking - prevent clearing portal process
 }
diff --git a/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java b/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java
index eefc8f835f8818407612eadf3f2df5730a0bbe97..0e573bb6b216ca0bc874a4053509ec61f393d912 100644
--- a/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java
+++ b/net/minecraft/world/entity/ai/behavior/GoToPotentialJobSite.java
@@ -43,15 +43,39 @@ public class GoToPotentialJobSite extends Behavior<Villager> {
         Optional<GlobalPos> memory = entity.getBrain().getMemory(MemoryModuleType.POTENTIAL_JOB_SITE);
         memory.ifPresent(globalPos -> {
             BlockPos blockPos = globalPos.pos();
-            ServerLevel level1 = level.getServer().getLevel(globalPos.dimension());
-            if (level1 != null) {
-                PoiManager poiManager = level1.getPoiManager();
-                if (poiManager.exists(blockPos, holder -> true)) {
-                    poiManager.release(blockPos);
+            // Leaf start - SparklyPaper - parallel world ticking
+            if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+                ServerLevel entityLevel = level; // Villager's current level
+                ServerLevel poiLevel = entityLevel.getServer().getLevel(globalPos.dimension()); // POI's actual level
+
+                if (poiLevel != null) {
+                    Runnable poiOperationsTask = () -> {
+                        PoiManager poiManager = poiLevel.getPoiManager();
+                        if (poiManager.exists(blockPos, holder -> true)) {
+                            poiManager.release(blockPos);
+                        }
+                    };
+
+                    // DebugPackets.sendPoiTicketCountPacket uses the entity's level for its PoiManager context.
+                    Runnable debugPacketTask = () -> level.debugSynchronizers().updatePoi(blockPos);;
+
+                    // Schedule POI operations on the POI's level thread, using POI's chunk coordinates for locality
+                    poiLevel.moonrise$getChunkTaskScheduler().scheduleChunkTask(blockPos.getX() >> 4, blockPos.getZ() >> 4, poiOperationsTask, ca.spottedleaf.concurrentutil.util.Priority.BLOCKING);
+                    // Schedule debug packet on the entity's level thread, using entity's chunk coordinates for locality
+                    entityLevel.moonrise$getChunkTaskScheduler().scheduleChunkTask(entity.chunkPosition().x, entity.chunkPosition().z, debugPacketTask, ca.spottedleaf.concurrentutil.util.Priority.BLOCKING);
                 }
+            } else {
+                ServerLevel level1 = level.getServer().getLevel(globalPos.dimension());
+                if (level1 != null) {
+                    PoiManager poiManager = level1.getPoiManager();
+                    if (poiManager.exists(blockPos, holder -> true)) {
+                        poiManager.release(blockPos);
+                    }
 
-                level.debugSynchronizers().updatePoi(blockPos);
+                    level.debugSynchronizers().updatePoi(blockPos);
+                }
             }
+            // Leaf end - SparklyPaper - parallel world ticking
         });
         entity.getBrain().eraseMemory(MemoryModuleType.POTENTIAL_JOB_SITE);
     }
diff --git a/net/minecraft/world/entity/npc/villager/Villager.java b/net/minecraft/world/entity/npc/villager/Villager.java
index 9a2c86a1470755c53e06289addd22fbebc91b9da..fe122a1026c198abec959b7980db46262af5685d 100644
--- a/net/minecraft/world/entity/npc/villager/Villager.java
+++ b/net/minecraft/world/entity/npc/villager/Villager.java
@@ -800,13 +800,29 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
             this.brain.getMemory(moduleType).ifPresent(pos -> {
                 ServerLevel level = server.getLevel(pos.dimension());
                 if (level != null) {
-                    PoiManager poiManager = level.getPoiManager();
-                    Optional<Holder<PoiType>> type = poiManager.getType(pos.pos());
-                    BiPredicate<Villager, Holder<PoiType>> biPredicate = POI_MEMORIES.get(moduleType);
-                    if (type.isPresent() && biPredicate.test(this, type.get())) {
-                        poiManager.release(pos.pos());
-                        level.debugSynchronizers().updatePoi(pos.pos());
+                    // Leaf start - SparklyPaper - parallel world ticking - handling for releasing poi cross-dimension
+                    if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+                        Runnable releasePoiTask = () -> {
+                            PoiManager poiManager = level.getPoiManager();
+                            Optional<Holder<PoiType>> type = poiManager.getType(pos.pos());
+                            BiPredicate<Villager, Holder<PoiType>> biPredicate = POI_MEMORIES.get(moduleType);
+                            if (type.isPresent() && biPredicate.test(this, type.get())) {
+                                poiManager.release(pos.pos());
+                                level.debugSynchronizers().updatePoi(pos.pos());
+                            }
+                        };
+
+                        level.moonrise$getChunkTaskScheduler().scheduleChunkTask(0, 0, releasePoiTask, ca.spottedleaf.concurrentutil.util.Priority.BLOCKING);
+                    } else {
+                        PoiManager poiManager = level.getPoiManager();
+                        Optional<Holder<PoiType>> type = poiManager.getType(pos.pos());
+                        BiPredicate<Villager, Holder<PoiType>> biPredicate = POI_MEMORIES.get(moduleType);
+                        if (type.isPresent() && biPredicate.test(this, type.get())) {
+                            poiManager.release(pos.pos());
+                            level.debugSynchronizers().updatePoi(pos.pos());
+                        }
                     }
+                    // Leaf end - SparklyPaper - parallel world ticking - handling for releasing poi cross-dimension
                 }
             });
         }
diff --git a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
index 6ad07d8f82c0f745d3c3c742f25d05b9b38193c2..4d416d3a8402a78b8ad6383d842f589a821ddbe9 100644
--- a/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
+++ b/net/minecraft/world/entity/projectile/throwableitemprojectile/ThrownEnderpearl.java
@@ -102,11 +102,13 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                 Vec3 vec3 = this.oldPosition();
                 if (owner instanceof ServerPlayer serverPlayer) {
                     if (serverPlayer.connection.isAcceptingMessages()) {
+                        // Leaf start - SparklyPaper - parallel world ticking - handling for pearl teleportation cross-dimension
+                        java.util.function.Consumer<ServerPlayer> teleportPlayerCrossDimensionTask = taskServerPlayer -> {
                         // CraftBukkit start
                         // Store pre teleportation position as the teleport has been moved up.
                         final double preTeleportX = serverPlayer.getX(), preTeleportY = serverPlayer.getY(), preTeleportZ = serverPlayer.getZ();
                         final float preTeleportYRot = serverPlayer.getYRot(), preTeleportXRot = serverPlayer.getXRot();
-                        ServerPlayer serverPlayer1 = serverPlayer.teleport(new TeleportTransition(serverLevel, vec3, Vec3.ZERO, 0.0F, 0.0F, Relative.union(Relative.ROTATION, Relative.DELTA), TeleportTransition.DO_NOTHING, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.ENDER_PEARL));
+                        ServerPlayer serverPlayer1 = taskServerPlayer.teleport(new TeleportTransition(serverLevel, vec3, Vec3.ZERO, 0.0F, 0.0F, Relative.union(Relative.ROTATION, Relative.DELTA), TeleportTransition.DO_NOTHING, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.ENDER_PEARL));
                         if (serverPlayer1 == null) {
                             this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.HIT);
                             return;
@@ -135,10 +137,18 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                         if (serverPlayer1 != null) {
                             serverPlayer1.resetFallDistance();
                             serverPlayer1.resetCurrentImpulseContext();
-                            serverPlayer1.hurtServer(serverPlayer.level(), this.damageSources().enderPearl().eventEntityDamager(this), this.level().purpurConfig.enderPearlDamage); // CraftBukkit // Paper - fix DamageSource API // Purpur - Configurable Ender Pearl damage
+                            serverPlayer1.hurtServer(taskServerPlayer.level(), this.damageSources().enderPearl().eventEntityDamager(this), this.level().purpurConfig.enderPearlDamage); // CraftBukkit // Paper - fix DamageSource API // Purpur - Configurable Ender Pearl damage
                         }
 
                         this.playSound(serverLevel, vec3);
+                        };
+                        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+                            serverPlayer.getBukkitEntity().taskScheduler.schedule(teleportPlayerCrossDimensionTask, entity -> {
+                            }, 0);
+                        } else {
+                            teleportPlayerCrossDimensionTask.accept(serverPlayer);
+                        }
+                        // Leaf end - SparklyPaper - parallel world ticking - handling for pearl teleportation cross-dimension
                     }
                 } else {
                     Entity entity = owner.teleport(
diff --git a/net/minecraft/world/inventory/AbstractContainerMenu.java b/net/minecraft/world/inventory/AbstractContainerMenu.java
index 19bdb38a69dcdb3d30f08a85b3e9c3d6d723191f..3a0c8dca827f567a00e611461aeb74699155bffb 100644
--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -93,8 +93,14 @@ public abstract class AbstractContainerMenu {
 
     public void startOpen() {}
     // CraftBukkit end
+    public Throwable containerCreationStacktrace; // Leaf - SparklyPaper - parallel world ticking (debugging)
 
     protected AbstractContainerMenu(@Nullable MenuType<?> menuType, int containerId) {
+        // Leaf start - SparklyPaper - parallel world ticking (debugging)
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.logContainerCreationStacktraces) {
+            this.containerCreationStacktrace = new Throwable();
+        }
+        // Leaf end - SparklyPaper - parallel world ticking (debugging)
         this.menuType = menuType;
         this.containerId = containerId;
     }
diff --git a/net/minecraft/world/item/ItemStack.java b/net/minecraft/world/item/ItemStack.java
index ee113e10ae244f21744c6b3a64d157fe85ec9f74..bba028a852aa1552269a1942994cc8ad1cb3e695 100644
--- a/net/minecraft/world/item/ItemStack.java
+++ b/net/minecraft/world/item/ItemStack.java
@@ -404,8 +404,8 @@ public final class ItemStack implements DataComponentHolder {
             if (interactionResult.consumesAction() && serverLevel.captureTreeGeneration && !serverLevel.capturedBlockStates.isEmpty()) {
                 serverLevel.captureTreeGeneration = false;
                 org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(clickedPos, serverLevel);
-                org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.treeType;
-                net.minecraft.world.level.block.SaplingBlock.treeType = null;
+                org.bukkit.TreeType treeType = net.minecraft.world.level.block.SaplingBlock.getTreeTypeRT(); // Leaf - SparklyPaper - parallel world ticking
+                net.minecraft.world.level.block.SaplingBlock.setTreeTypeRT(null); // Leaf - SparklyPaper - parallel world ticking
                 List<org.bukkit.craftbukkit.block.CraftBlockState> blocks = new java.util.ArrayList<>(serverLevel.capturedBlockStates.values());
                 serverLevel.capturedBlockStates.clear();
                 org.bukkit.event.world.StructureGrowEvent structureEvent = null;
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index e7360551860f611debb7e163d6f2a40fb08274a6..9fd8210849bdc55ddbde00158c354beadea5549f 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -173,6 +173,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     // Gale end - Gale configuration
 
     public final org.purpurmc.purpur.PurpurWorldConfig purpurConfig; // Purpur - Purpur config files
+    public final io.papermc.paper.redstone.RedstoneWireTurbo turbo; // Leaf - SparklyPaper - parallel world ticking - moved to world
     public static @Nullable BlockPos lastPhysicsProblem; // Spigot
     private int tileTickPosition;
     public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new java.util.HashMap<>(); // Paper - Optimize explosions
@@ -924,6 +925,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         this.damageSources = new DamageSources(registryAccess);
         this.entityLookup = new ca.spottedleaf.moonrise.patches.chunk_system.level.entity.dfl.DefaultEntityLookup(this); // Paper - rewrite chunk system
         this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new io.papermc.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : io.papermc.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
+        this.turbo = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? new io.papermc.paper.redstone.RedstoneWireTurbo((net.minecraft.world.level.block.RedStoneWireBlock) net.minecraft.world.level.block.Blocks.REDSTONE_WIRE) : null;
     }
 
     // Paper start - Cancel hit for vanished players
@@ -1102,6 +1104,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public boolean setBlock(BlockPos pos, BlockState state, @Block.UpdateFlags int flags, int recursionLeft) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, pos, "Updating block asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // CraftBukkit start - tree generation
         if (this.captureTreeGeneration) {
             // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
@@ -1468,7 +1471,10 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             } else if (runsNormally && this.shouldTickBlocksAt(tickingBlockEntity.getPos())) {
                 tickingBlockEntity.tick();
                 // Paper start - rewrite chunk system
-                if ((++tickedEntities & 7) == 0) {
+                // Leaf start - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
+                ++tickedEntities;
+                if (!org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && (tickedEntities & 7) == 0) {
+                    // Leaf end - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
                     ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemLevel)(Level)(Object)this).moonrise$midTickTasks();
                 }
                 // Paper end - rewrite chunk system
@@ -1491,6 +1497,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
             entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD); // Gale - Airplane - remove lambda from ticking guard - diff on change ServerLevel#tick
             // Paper end - Prevent block entity and entity crashes
         }
+        if (!org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) // Leaf - SparklyPaper - parallel world ticking (only run mid-tick at the end of each tick / fixes concurrency bugs related to executeMidTickTasks)
         this.moonrise$midTickTasks(); // Paper - rewrite chunk system // Gale - Airplane - remove lambda from ticking guard - diff on change ServerLevel#tick
     }
 
@@ -1632,6 +1639,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public @Nullable BlockEntity getBlockEntity(BlockPos pos) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThreadOrAsyncThread((ServerLevel) this, "Cannot read world asynchronously"); // Leaf - SparklyPaper - parallel world ticking
         // Paper start - Perf: Optimize capturedTileEntities lookup
         net.minecraft.world.level.block.entity.BlockEntity blockEntity;
         if (!this.capturedTileEntities.isEmpty() && (blockEntity = this.capturedTileEntities.get(pos)) != null) {
@@ -1648,6 +1656,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     public void setBlockEntity(BlockEntity blockEntity) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel) this, "Cannot modify world asynchronously"); // Leaf - SparklyPaper - parallel world ticking
         BlockPos blockPos = blockEntity.getBlockPos();
         if (this.isInValidBounds(blockPos)) {
             // CraftBukkit start
@@ -1729,6 +1738,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
 
     @Override
     public List<Entity> getEntities(@Nullable Entity entity, AABB boundingBox, Predicate<? super Entity> predicate) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread((ServerLevel)this, boundingBox, "Cannot getEntities asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         Profiler.get().incrementCounter("getEntities");
         List<Entity> list = Lists.newArrayList();
 
diff --git a/net/minecraft/world/level/block/FungusBlock.java b/net/minecraft/world/level/block/FungusBlock.java
index 9711efb088bd0da9168e9bcd0496bd7caddd2974..38a9d3c23b9ccdfd38e0454181bde762e00e4b3f 100644
--- a/net/minecraft/world/level/block/FungusBlock.java
+++ b/net/minecraft/world/level/block/FungusBlock.java
@@ -76,9 +76,9 @@ public class FungusBlock extends VegetationBlock implements BonemealableBlock {
             // CraftBukkit start
             .map((value) -> {
                 if (this == Blocks.WARPED_FUNGUS) {
-                    SaplingBlock.treeType = org.bukkit.TreeType.WARPED_FUNGUS;
+                    SaplingBlock.setTreeTypeRT(org.bukkit.TreeType.WARPED_FUNGUS); // Leaf - SparklyPaper - parallel world ticking
                 } else if (this == Blocks.CRIMSON_FUNGUS) {
-                    SaplingBlock.treeType = org.bukkit.TreeType.CRIMSON_FUNGUS;
+                    SaplingBlock.setTreeTypeRT(org.bukkit.TreeType.CRIMSON_FUNGUS); // Leaf - SparklyPaper - parallel world ticking
                 }
                 return value;
             })
diff --git a/net/minecraft/world/level/block/MushroomBlock.java b/net/minecraft/world/level/block/MushroomBlock.java
index b11ff87df7b75f2a3065bbed7b13cc52f7df83fc..b1adac6d0303ad2936024461b28e390385dd337c 100644
--- a/net/minecraft/world/level/block/MushroomBlock.java
+++ b/net/minecraft/world/level/block/MushroomBlock.java
@@ -93,7 +93,7 @@ public class MushroomBlock extends VegetationBlock implements BonemealableBlock
             return false;
         } else {
             level.removeBlock(pos, false);
-            SaplingBlock.treeType = (this == Blocks.BROWN_MUSHROOM) ? org.bukkit.TreeType.BROWN_MUSHROOM : org.bukkit.TreeType.RED_MUSHROOM; // CraftBukkit
+            SaplingBlock.setTreeTypeRT((this == Blocks.BROWN_MUSHROOM) ? org.bukkit.TreeType.BROWN_MUSHROOM : org.bukkit.TreeType.RED_MUSHROOM); // CraftBukkit // Leaf - SparklyPaper - parallel world ticking
             if (optional.get().value().place(level, level.getChunkSource().getGenerator(), random, pos)) {
                 return true;
             } else {
diff --git a/net/minecraft/world/level/block/RedStoneWireBlock.java b/net/minecraft/world/level/block/RedStoneWireBlock.java
index 6d98bc37d88459d1e0a171b52bbff5810d775c38..ebc43f02c356e94d889e20ed26f66dc216b305a6 100644
--- a/net/minecraft/world/level/block/RedStoneWireBlock.java
+++ b/net/minecraft/world/level/block/RedStoneWireBlock.java
@@ -65,6 +65,7 @@ public class RedStoneWireBlock extends Block {
     private final BlockState crossState;
     private final RedstoneWireEvaluator evaluator = new DefaultRedstoneWireEvaluator(this);
     public boolean shouldSignal = true;
+    private final ThreadLocal<Boolean> shouldSignalTL = ThreadLocal.withInitial(() -> true); // Leaf - SparklyPaper - parallel world ticking
 
     @Override
     public MapCodec<RedStoneWireBlock> codec() {
@@ -282,7 +283,13 @@ public class RedStoneWireBlock extends Block {
             if (orientation != null) {
                 source = pos.relative(orientation.getFront().getOpposite());
             }
-            turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            // Leaf start - SparklyPaper - parallel world ticking
+            if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+                worldIn.turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            } else {
+                turbo.updateSurroundingRedstone(worldIn, pos, state, source);
+            }
+            // Leaf end - parallel world ticking
             return;
         }
         updatePowerStrength(worldIn, pos, state, orientation, blockAdded);
@@ -310,7 +317,13 @@ public class RedStoneWireBlock extends Block {
                 // [Space Walker] suppress shape updates and emit those manually to
                 // bypass the new neighbor update stack.
                 if (level.setBlock(pos, state, Block.UPDATE_KNOWN_SHAPE | Block.UPDATE_CLIENTS)) {
-                    turbo.updateNeighborShapes(level, pos, state);
+                    // Leaf start - SparklyPaper - parallel world ticking
+                    if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+                        level.turbo.updateNeighborShapes(level, pos, state);
+                    } else {
+                        turbo.updateNeighborShapes(level, pos, state);
+                    }
+                    // Leaf end - SparklyPaper - parallel world ticking
                 }
             }
         }
@@ -327,10 +340,19 @@ public class RedStoneWireBlock extends Block {
     }
 
     public int getBlockSignal(Level level, BlockPos pos) {
-        this.shouldSignal = false;
-        int bestNeighborSignal = level.getBestNeighborSignal(pos);
-        this.shouldSignal = true;
-        return bestNeighborSignal;
+        // Leaf start - SparklyPaper - parallel world ticking
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            this.shouldSignalTL.set(false);
+            int bestNeighborSignal = level.getBestNeighborSignal(pos);
+            this.shouldSignalTL.set(true);
+            return bestNeighborSignal;
+        } else {
+            this.shouldSignal = false;
+            int bestNeighborSignal = level.getBestNeighborSignal(pos);
+            this.shouldSignal = true;
+            return bestNeighborSignal;
+        }
+        // Leaf end - SparklyPaper - parallel world ticking
     }
 
     private void checkCornerChangeAt(Level level, BlockPos pos) {
@@ -421,12 +443,18 @@ public class RedStoneWireBlock extends Block {
 
     @Override
     protected int getDirectSignal(BlockState state, BlockGetter level, BlockPos pos, Direction side) {
-        return !this.shouldSignal ? 0 : state.getSignal(level, pos, side);
+        // Leaf start - SparklyPaper - parallel world ticking
+        boolean signal = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? this.shouldSignalTL.get() : this.shouldSignal;
+        return !signal ? 0 : state.getSignal(level, pos, side);
+        // Leaf end - SparklyPaper - parallel world ticking
     }
 
     @Override
     protected int getSignal(BlockState state, BlockGetter level, BlockPos pos, Direction side) {
-        if (this.shouldSignal && side != Direction.DOWN) {
+        // Leaf start - SparklyPaper - parallel world ticking
+        final boolean signal = org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? this.shouldSignalTL.get() : this.shouldSignal;
+        if (signal && side != Direction.DOWN) {
+            // Leaf end - SparklyPaper - parallel world ticking
             int powerValue = state.getValue(POWER);
             if (powerValue == 0) {
                 return 0;
@@ -458,7 +486,7 @@ public class RedStoneWireBlock extends Block {
 
     @Override
     protected boolean isSignalSource(BlockState state) {
-        return this.shouldSignal;
+        return org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled ? this.shouldSignalTL.get() : this.shouldSignal; // Leaf - SparklyPaper - parallel world ticking
     }
 
     public static int getColorForPower(int power) {
diff --git a/net/minecraft/world/level/block/SaplingBlock.java b/net/minecraft/world/level/block/SaplingBlock.java
index 23e9e5e7ef76fe3d6e1bbc41faf69ee65ca77d80..f2aea15f223c270f1abee30175693f7e53f2cc47 100644
--- a/net/minecraft/world/level/block/SaplingBlock.java
+++ b/net/minecraft/world/level/block/SaplingBlock.java
@@ -26,6 +26,35 @@ public class SaplingBlock extends VegetationBlock implements BonemealableBlock {
     private static final VoxelShape SHAPE = Block.column(12.0, 0.0, 12.0);
     protected final TreeGrower treeGrower;
     public static @javax.annotation.Nullable org.bukkit.TreeType treeType; // CraftBukkit
+    public static final ThreadLocal<org.bukkit.TreeType> treeTypeRT = new ThreadLocal<>(); // Leaf - SparklyPaper - parallel world ticking (from Folia)
+
+    // Leaf start - SparklyPaper - parallel world ticking
+    // refer to original field in case plugins attempt to modify it
+    public static org.bukkit.TreeType getTreeTypeRT() {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            org.bukkit.TreeType treeTypeRTCopy;
+            if ((treeTypeRTCopy = treeTypeRT.get()) != null)
+                return treeTypeRTCopy;
+            synchronized (SaplingBlock.class) {
+                return treeType;
+            }
+        } else {
+            return treeType;
+        }
+    }
+
+    // update original field in case plugins attempt to access it
+    public static void setTreeTypeRT(org.bukkit.TreeType value) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) {
+            treeTypeRT.set(value);
+            synchronized (SaplingBlock.class) {
+                treeType = value;
+            }
+        } else {
+            treeType = value;
+        }
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
 
     @Override
     public MapCodec<? extends SaplingBlock> codec() {
@@ -62,14 +91,14 @@ public class SaplingBlock extends VegetationBlock implements BonemealableBlock {
                 this.treeGrower.growTree(level, level.getChunkSource().getGenerator(), pos, state, random);
                 level.captureTreeGeneration = false;
                 if (!level.capturedBlockStates.isEmpty()) {
-                    org.bukkit.TreeType treeType = SaplingBlock.treeType;
-                    SaplingBlock.treeType = null;
+                    org.bukkit.TreeType treeTypeLocal = SaplingBlock.getTreeTypeRT(); // Leaf - SparklyPaper - parallel world ticking
+                    SaplingBlock.setTreeTypeRT(null); // Leaf - SparklyPaper - parallel world ticking
                     org.bukkit.Location location = org.bukkit.craftbukkit.util.CraftLocation.toBukkit(pos, level);
                     java.util.List<org.bukkit.block.BlockState> blocks = new java.util.ArrayList<>(level.capturedBlockStates.values());
                     level.capturedBlockStates.clear();
                     org.bukkit.event.world.StructureGrowEvent event = null;
-                    if (treeType != null) {
-                        event = new org.bukkit.event.world.StructureGrowEvent(location, treeType, false, null, blocks);
+                    if (treeTypeLocal != null) { // Leaf - SparklyPaper - parallel world ticking - fix missing stuff from original sparkly paper
+                        event = new org.bukkit.event.world.StructureGrowEvent(location, treeTypeLocal, false, null, blocks); // Leaf - SparklyPaper - parallel world ticking - fix missing stuff from original sparkly paper
                         org.bukkit.Bukkit.getPluginManager().callEvent(event);
                     }
                     if (event == null || !event.isCancelled()) {
diff --git a/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java b/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
index edf3bc4adc9b1700b73f06ea940f17cd55b16860..8b03d50a8f3edcba4a336c97913c95a9a820a3fe 100644
--- a/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BaseContainerBlockEntity.java
@@ -66,6 +66,12 @@ public abstract class BaseContainerBlockEntity extends BlockEntity implements Co
     protected abstract Component getDefaultName();
 
     public boolean canOpen(Player player) {
+        // Leaf start - SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled && player instanceof net.minecraft.server.level.ServerPlayer serverPlayer && this.getLevel() != serverPlayer.level()) {
+            net.minecraft.server.MinecraftServer.LOGGER.warn("Player {} ({}) attempted to open a BlockEntity @ {} {}, {}, {} while they were in a different world {} than the block themselves!", serverPlayer.getScoreboardName(), serverPlayer.getStringUUID(), this.getLevel().getWorld().getName(), this.getBlockPos().getX(), this.getBlockPos().getY(), this.getBlockPos().getZ(), serverPlayer.level().getWorld().getName());
+            return false;
+        }
+        // Leaf end - SparklyPaper - parallel world ticking (see: PARALLEL_NOTES.md - Opening an inventory after a world switch)
         return org.bukkit.craftbukkit.event.CraftEventFactory.callBlockLockCheckEvent(this, this.lockKey, this.getDisplayName(), player); // Paper - Call BlockLockCheckEvent
     }
 
diff --git a/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java b/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
index a757bfd993f1ff1f9ba8c3eecc706f65e36a67db..79e5a0ed25ec40391a0b78f309eabfc9fa9f0de9 100644
--- a/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/SculkCatalystBlockEntity.java
@@ -44,9 +44,9 @@ public class SculkCatalystBlockEntity extends BlockEntity implements GameEventLi
     // Paper end - Fix NPE in SculkBloomEvent world access
 
     public static void serverTick(Level level, BlockPos pos, BlockState state, SculkCatalystBlockEntity sculkCatalyst) {
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = sculkCatalyst.getBlockPos(); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep.
+        org.bukkit.craftbukkit.event.CraftEventFactory.setSourceBlockOverrideRT(pos); // CraftBukkit - SPIGOT-7068: Add source block override, not the most elegant way but better than passing down a BlockPosition up to five methods deep. // Leaf - SparklyPaper - parallel world ticking
         sculkCatalyst.catalystListener.getSculkSpreader().updateCursors(level, pos, level.getRandom(), true);
-        org.bukkit.craftbukkit.event.CraftEventFactory.sourceBlockOverride = null; // CraftBukkit
+        org.bukkit.craftbukkit.event.CraftEventFactory.setSourceBlockOverrideRT(null); // CraftBukkit //  Leaf - SparklyPaper - parallel world ticking
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/grower/TreeGrower.java b/net/minecraft/world/level/block/grower/TreeGrower.java
index 5471619a0484ece08640e2b3fd26746c351dc3e0..5a71e70e840a48716b05c97005526402c73a1813 100644
--- a/net/minecraft/world/level/block/grower/TreeGrower.java
+++ b/net/minecraft/world/level/block/grower/TreeGrower.java
@@ -201,55 +201,57 @@ public final class TreeGrower {
 
     // CraftBukkit start
     private void setTreeType(Holder<ConfiguredFeature<?, ?>> feature) {
+        org.bukkit.TreeType treeType; // Leaf - SparklyPaper - parallel world ticking
         if (feature.is(TreeFeatures.OAK) || feature.is(TreeFeatures.OAK_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TREE;
+            treeType = org.bukkit.TreeType.TREE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.HUGE_RED_MUSHROOM)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.RED_MUSHROOM;
+            treeType = org.bukkit.TreeType.RED_MUSHROOM; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.HUGE_BROWN_MUSHROOM)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BROWN_MUSHROOM;
+            treeType = org.bukkit.TreeType.BROWN_MUSHROOM; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.JUNGLE_TREE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.COCOA_TREE;
+            treeType = org.bukkit.TreeType.COCOA_TREE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.JUNGLE_TREE_NO_VINE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.SMALL_JUNGLE;
+            treeType = org.bukkit.TreeType.SMALL_JUNGLE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.PINE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_REDWOOD;
+            treeType = org.bukkit.TreeType.TALL_REDWOOD; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.SPRUCE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.REDWOOD;
+            treeType = org.bukkit.TreeType.REDWOOD; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.ACACIA)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.ACACIA;
+            treeType = org.bukkit.TreeType.ACACIA; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.BIRCH) || feature.is(TreeFeatures.BIRCH_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BIRCH;
+            treeType = org.bukkit.TreeType.BIRCH; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.SUPER_BIRCH_BEES_0002)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_BIRCH;
+            treeType = org.bukkit.TreeType.TALL_BIRCH; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.SWAMP_OAK)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.SWAMP;
+            treeType = org.bukkit.TreeType.SWAMP; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.FANCY_OAK) || feature.is(TreeFeatures.FANCY_OAK_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.BIG_TREE;
+            treeType = org.bukkit.TreeType.BIG_TREE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.JUNGLE_BUSH)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.JUNGLE_BUSH;
+            treeType = org.bukkit.TreeType.JUNGLE_BUSH; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.DARK_OAK)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.DARK_OAK;
+            treeType = org.bukkit.TreeType.DARK_OAK; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.MEGA_SPRUCE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MEGA_REDWOOD;
+            treeType = org.bukkit.TreeType.MEGA_REDWOOD; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.MEGA_PINE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MEGA_PINE;
+            treeType = org.bukkit.TreeType.MEGA_PINE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.MEGA_JUNGLE_TREE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.JUNGLE;
+            treeType = org.bukkit.TreeType.JUNGLE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.AZALEA_TREE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.AZALEA;
+            treeType = org.bukkit.TreeType.AZALEA; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.MANGROVE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.MANGROVE;
+            treeType = org.bukkit.TreeType.MANGROVE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.TALL_MANGROVE)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.TALL_MANGROVE;
+            treeType = org.bukkit.TreeType.TALL_MANGROVE; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.CHERRY) || feature.is(TreeFeatures.CHERRY_BEES_005)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.CHERRY;
+            treeType = org.bukkit.TreeType.CHERRY; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.PALE_OAK) || feature.is(TreeFeatures.PALE_OAK_BONEMEAL)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.PALE_OAK;
+            treeType = org.bukkit.TreeType.PALE_OAK; // Leaf - SparklyPaper - parallel world ticking
         } else if (feature.is(TreeFeatures.PALE_OAK_CREAKING)) {
-            net.minecraft.world.level.block.SaplingBlock.treeType = org.bukkit.TreeType.PALE_OAK_CREAKING;
+            treeType = org.bukkit.TreeType.PALE_OAK_CREAKING; // Leaf - SparklyPaper - parallel world ticking
         } else {
             throw new IllegalArgumentException("Unknown tree generator " + feature);
         }
+        net.minecraft.world.level.block.SaplingBlock.setTreeTypeRT(treeType); // Leaf - SparklyPaper - parallel world ticking
     }
     // CraftBukkit end
 }
diff --git a/net/minecraft/world/level/chunk/LevelChunk.java b/net/minecraft/world/level/chunk/LevelChunk.java
index 6052cb3b348def15429dad5aac83c096b6fff4d3..81904bcbb982d770320304ef237b85203cc016df 100644
--- a/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/net/minecraft/world/level/chunk/LevelChunk.java
@@ -408,6 +408,7 @@ public class LevelChunk extends ChunkAccess implements DebugValueSource, ca.spot
 
     @Override
     public @Nullable BlockState setBlockState(BlockPos pos, BlockState state, @Block.UpdateFlags int flags) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this.level, pos, "Updating block asynchronously"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         int y = pos.getY();
         LevelChunkSection section = this.getSection(this.getSectionIndex(y));
         boolean hasOnlyAir = section.hasOnlyAir();
diff --git a/net/minecraft/world/level/entity/EntityTickList.java b/net/minecraft/world/level/entity/EntityTickList.java
index ce70bd4f6aeed185a67f6c7537eda41d40e80cb1..c1473d82cabc854a40d062f912b6a17e2d98b70f 100644
--- a/net/minecraft/world/level/entity/EntityTickList.java
+++ b/net/minecraft/world/level/entity/EntityTickList.java
@@ -11,16 +11,31 @@ import org.jspecify.annotations.Nullable;
 public class EntityTickList {
     public final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system // Pufferfish - private->public
 
+    // Leaf start - SparklyPaper - parallel world ticking
+    // Used to track async entity additions/removals/loops
+    private final net.minecraft.server.level.@Nullable ServerLevel serverLevel;
+
+    public EntityTickList() {
+        this(null);
+    }
+
+    public EntityTickList(net.minecraft.server.level.@Nullable ServerLevel serverLevel) {
+        this.serverLevel = serverLevel;
+    }
+    // Leaf end - SparklyPaper - parallel world ticking
+
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
     }
 
     public void add(Entity entity) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(entity, "Asynchronous entity ticklist addition"); // Paper // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.ensureActiveIsNotIterated();
         this.entities.add(entity); // Paper - rewrite chunk system
     }
 
     public void remove(Entity entity) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(entity, "Asynchronous entity ticklist removal"); // Paper // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         this.ensureActiveIsNotIterated();
         this.entities.remove(entity); // Paper - rewrite chunk system
     }
@@ -30,6 +45,7 @@ public class EntityTickList {
     }
 
     public void forEach(Consumer<Entity> entity) {
+        if (org.dreeam.leaf.config.modules.async.SparklyPaperParallelWorldTicking.enabled) ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(serverLevel, "Asynchronous entity ticklist iteration"); // Leaf - SparklyPaper - parallel world ticking (additional concurrency issues logs)
         // Paper start - rewrite chunk system
         // To ensure nothing weird happens with dimension travelling, do not iterate over new entries...
         // (by dfl iterator() is configured to not iterate over new entries)
diff --git a/net/minecraft/world/level/saveddata/maps/MapIndex.java b/net/minecraft/world/level/saveddata/maps/MapIndex.java
index 06025d79cc2297119b22224d777aca79f9d3d9c1..9c1fa292637f867db1ca2d964f912579e434f750 100644
--- a/net/minecraft/world/level/saveddata/maps/MapIndex.java
+++ b/net/minecraft/world/level/saveddata/maps/MapIndex.java
@@ -23,8 +23,10 @@ public class MapIndex extends SavedData {
     }
 
     public MapId getNextMapId() {
+        synchronized (TYPE) { // Leaf start - SparklyPaper - parallel world ticking
         MapId mapId = new MapId(++this.lastMapId);
         this.setDirty();
         return mapId;
+        } // Leaf end - SparklyPaper - parallel world ticking
     }
 }
