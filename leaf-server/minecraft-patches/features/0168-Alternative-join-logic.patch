From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Taiyou06 <kaandindar21@gmail.com>
Date: Thu, 8 May 2025 11:14:06 +0200
Subject: [PATCH] Alternative join logic


diff --git a/net/minecraft/network/Connection.java b/net/minecraft/network/Connection.java
index f998cf8d70302a21289de4d84b46d322d0b8a8fe..1eba5608af0bf70d6c7a9e34c5726ac6eaa6e096 100644
--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -66,6 +66,8 @@ import org.slf4j.Logger;
 import org.slf4j.Marker;
 import org.slf4j.MarkerFactory;
 
+import static org.dreeam.leaf.config.modules.network.AlternativeJoin.AlternativeJoin;
+
 public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static final float AVERAGE_PACKETS_SMOOTHING = 0.75F;
     private static final Logger LOGGER = LogUtils.getLogger();
@@ -341,35 +343,54 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         this.validateListener(protocolInfo, packetInfo);
         if (protocolInfo.flow() != this.getReceiving()) {
             throw new IllegalStateException("Invalid inbound protocol: " + protocolInfo.id());
+        }
+        this.packetListener = packetInfo;
+        this.disconnectListener = null;
+        UnconfiguredPipelineHandler.InboundConfigurationTask inboundConfigurationTask = UnconfiguredPipelineHandler.setupInboundProtocol(protocolInfo);
+        BundlerInfo bundlerInfo = protocolInfo.bundlerInfo();
+        if (bundlerInfo != null) {
+            PacketBundlePacker packetBundlePacker = new PacketBundlePacker(bundlerInfo);
+            inboundConfigurationTask = inboundConfigurationTask.andThen(context -> context.pipeline().addAfter("decoder", "bundler", (ChannelHandler)packetBundlePacker));
+        }
+        ChannelFuture future = this.channel.writeAndFlush(inboundConfigurationTask);
+        if (!AlternativeJoin) {
+            Connection.syncAfterConfigurationChange(future);
         } else {
-            this.packetListener = packetInfo;
-            this.disconnectListener = null;
-            UnconfiguredPipelineHandler.InboundConfigurationTask inboundConfigurationTask = UnconfiguredPipelineHandler.setupInboundProtocol(protocolInfo);
-            BundlerInfo bundlerInfo = protocolInfo.bundlerInfo();
-            if (bundlerInfo != null) {
-                PacketBundlePacker packetBundlePacker = new PacketBundlePacker(bundlerInfo);
-                inboundConfigurationTask = inboundConfigurationTask.andThen(context -> context.pipeline().addAfter("decoder", "bundler", packetBundlePacker));
-            }
-
-            syncAfterConfigurationChange(this.channel.writeAndFlush(inboundConfigurationTask));
+            java.util.concurrent.CompletableFuture.runAsync(() -> {
+                try {
+                    future.await();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            });
         }
     }
 
     public void setupOutboundProtocol(ProtocolInfo<?> protocolInfo) {
+        boolean flag;
         if (protocolInfo.flow() != this.getSending()) {
-            throw new IllegalStateException("Invalid outbound protocol: " + protocolInfo.id());
+            throw new IllegalStateException("Invalid inbound protocol: " + protocolInfo.id());
+        }
+        UnconfiguredPipelineHandler.OutboundConfigurationTask outboundConfigurationTask = UnconfiguredPipelineHandler.setupOutboundProtocol(protocolInfo);
+        BundlerInfo bundlerInfo = protocolInfo.bundlerInfo();
+        if (bundlerInfo != null) {
+            PacketBundleUnpacker packetBundleUnpacker = new PacketBundleUnpacker(bundlerInfo);
+            outboundConfigurationTask = outboundConfigurationTask.andThen(context -> context.pipeline().addAfter("encoder", "unbundler", (ChannelHandler)packetBundleUnpacker));
+        }
+        boolean bl = flag = protocolInfo.id() == ConnectionProtocol.LOGIN;
+        ChannelFuture future = this.channel.writeAndFlush(outboundConfigurationTask.andThen(context -> {
+            this.sendLoginDisconnect = flag;
+        }));
+        if (!AlternativeJoin) {
+            Connection.syncAfterConfigurationChange(future);
         } else {
-            UnconfiguredPipelineHandler.OutboundConfigurationTask outboundConfigurationTask = UnconfiguredPipelineHandler.setupOutboundProtocol(protocolInfo);
-            BundlerInfo bundlerInfo = protocolInfo.bundlerInfo();
-            if (bundlerInfo != null) {
-                PacketBundleUnpacker packetBundleUnpacker = new PacketBundleUnpacker(bundlerInfo);
-                outboundConfigurationTask = outboundConfigurationTask.andThen(
-                    context -> context.pipeline().addAfter("encoder", "unbundler", packetBundleUnpacker)
-                );
-            }
-
-            boolean flag = protocolInfo.id() == ConnectionProtocol.LOGIN;
-            syncAfterConfigurationChange(this.channel.writeAndFlush(outboundConfigurationTask.andThen(context -> this.sendLoginDisconnect = flag)));
+            java.util.concurrent.CompletableFuture.runAsync(() -> {
+                try {
+                    future.await();
+                } catch (InterruptedException e) {
+                    Thread.currentThread().interrupt();
+                }
+            });
         }
     }
 
