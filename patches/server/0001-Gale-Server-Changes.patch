From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Martijn Muijsers <martijnmuijsers@live.nl>
Date: Thu, 24 Nov 2022 21:26:57 +0100
Subject: [PATCH] Gale Server Changes

Original License: GPL-3.0 (https://github.com/GaleMC/Gale/blob/HEAD/license/GPL-3.0.txt) LGPL-3.0 (https://github.com/GaleMC/Gale/blob/HEAD/license/LGPL-3.0.txt)
Original Project: https://github.com/GaleMC/Gale

diff --git a/LGPL.txt b/LGPL.txt
deleted file mode 100644
index 65c5ca88a67c30becee01c5a8816d964b03862f9..0000000000000000000000000000000000000000
--- a/LGPL.txt
+++ /dev/null
@@ -1,165 +0,0 @@
-                   GNU LESSER GENERAL PUBLIC LICENSE
-                       Version 3, 29 June 2007
-
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-
-  This version of the GNU Lesser General Public License incorporates
-the terms and conditions of version 3 of the GNU General Public
-License, supplemented by the additional permissions listed below.
-
-  0. Additional Definitions.
-
-  As used herein, "this License" refers to version 3 of the GNU Lesser
-General Public License, and the "GNU GPL" refers to version 3 of the GNU
-General Public License.
-
-  "The Library" refers to a covered work governed by this License,
-other than an Application or a Combined Work as defined below.
-
-  An "Application" is any work that makes use of an interface provided
-by the Library, but which is not otherwise based on the Library.
-Defining a subclass of a class defined by the Library is deemed a mode
-of using an interface provided by the Library.
-
-  A "Combined Work" is a work produced by combining or linking an
-Application with the Library.  The particular version of the Library
-with which the Combined Work was made is also called the "Linked
-Version".
-
-  The "Minimal Corresponding Source" for a Combined Work means the
-Corresponding Source for the Combined Work, excluding any source code
-for portions of the Combined Work that, considered in isolation, are
-based on the Application, and not on the Linked Version.
-
-  The "Corresponding Application Code" for a Combined Work means the
-object code and/or source code for the Application, including any data
-and utility programs needed for reproducing the Combined Work from the
-Application, but excluding the System Libraries of the Combined Work.
-
-  1. Exception to Section 3 of the GNU GPL.
-
-  You may convey a covered work under sections 3 and 4 of this License
-without being bound by section 3 of the GNU GPL.
-
-  2. Conveying Modified Versions.
-
-  If you modify a copy of the Library, and, in your modifications, a
-facility refers to a function or data to be supplied by an Application
-that uses the facility (other than as an argument passed when the
-facility is invoked), then you may convey a copy of the modified
-version:
-
-   a) under this License, provided that you make a good faith effort to
-   ensure that, in the event an Application does not supply the
-   function or data, the facility still operates, and performs
-   whatever part of its purpose remains meaningful, or
-
-   b) under the GNU GPL, with none of the additional permissions of
-   this License applicable to that copy.
-
-  3. Object Code Incorporating Material from Library Header Files.
-
-  The object code form of an Application may incorporate material from
-a header file that is part of the Library.  You may convey such object
-code under terms of your choice, provided that, if the incorporated
-material is not limited to numerical parameters, data structure
-layouts and accessors, or small macros, inline functions and templates
-(ten or fewer lines in length), you do both of the following:
-
-   a) Give prominent notice with each copy of the object code that the
-   Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the object code with a copy of the GNU GPL and this license
-   document.
-
-  4. Combined Works.
-
-  You may convey a Combined Work under terms of your choice that,
-taken together, effectively do not restrict modification of the
-portions of the Library contained in the Combined Work and reverse
-engineering for debugging such modifications, if you also do each of
-the following:
-
-   a) Give prominent notice with each copy of the Combined Work that
-   the Library is used in it and that the Library and its use are
-   covered by this License.
-
-   b) Accompany the Combined Work with a copy of the GNU GPL and this license
-   document.
-
-   c) For a Combined Work that displays copyright notices during
-   execution, include the copyright notice for the Library among
-   these notices, as well as a reference directing the user to the
-   copies of the GNU GPL and this license document.
-
-   d) Do one of the following:
-
-       0) Convey the Minimal Corresponding Source under the terms of this
-       License, and the Corresponding Application Code in a form
-       suitable for, and under terms that permit, the user to
-       recombine or relink the Application with a modified version of
-       the Linked Version to produce a modified Combined Work, in the
-       manner specified by section 6 of the GNU GPL for conveying
-       Corresponding Source.
-
-       1) Use a suitable shared library mechanism for linking with the
-       Library.  A suitable mechanism is one that (a) uses at run time
-       a copy of the Library already present on the user's computer
-       system, and (b) will operate properly with a modified version
-       of the Library that is interface-compatible with the Linked
-       Version.
-
-   e) Provide Installation Information, but only if you would otherwise
-   be required to provide such information under section 6 of the
-   GNU GPL, and only to the extent that such information is
-   necessary to install and execute a modified version of the
-   Combined Work produced by recombining or relinking the
-   Application with a modified version of the Linked Version. (If
-   you use option 4d0, the Installation Information must accompany
-   the Minimal Corresponding Source and Corresponding Application
-   Code. If you use option 4d1, you must provide the Installation
-   Information in the manner specified by section 6 of the GNU GPL
-   for conveying Corresponding Source.)
-
-  5. Combined Libraries.
-
-  You may place library facilities that are a work based on the
-Library side by side in a single library together with other library
-facilities that are not Applications and are not covered by this
-License, and convey such a combined library under terms of your
-choice, if you do both of the following:
-
-   a) Accompany the combined library with a copy of the same work based
-   on the Library, uncombined with any other library facilities,
-   conveyed under the terms of this License.
-
-   b) Give prominent notice with the combined library that part of it
-   is a work based on the Library, and explaining where to find the
-   accompanying uncombined form of the same work.
-
-  6. Revised Versions of the GNU Lesser General Public License.
-
-  The Free Software Foundation may publish revised and/or new versions
-of the GNU Lesser General Public License from time to time. Such new
-versions will be similar in spirit to the present version, but may
-differ in detail to address new problems or concerns.
-
-  Each version is given a distinguishing version number. If the
-Library as you received it specifies that a certain numbered version
-of the GNU Lesser General Public License "or any later version"
-applies to it, you have the option of following the terms and
-conditions either of that published version or of any later version
-published by the Free Software Foundation. If the Library as you
-received it does not specify a version number of the GNU Lesser
-General Public License, you may choose any version of the GNU Lesser
-General Public License ever published by the Free Software Foundation.
-
-  If the Library as you received it specifies that a proxy can decide
-whether future versions of the GNU Lesser General Public License shall
-apply, that proxy's public statement of acceptance of any version is
-permanent authorization for you to choose that version for the
-Library.
diff --git a/LICENCE.txt b/LICENSE.txt
similarity index 99%
rename from LICENCE.txt
rename to LICENSE.txt
index 94a9ed024d3859793618152ea559a168bbcbb5e2..e60008693e017bec1b4eb49c84be3898e26fcf2a 100644
--- a/LICENCE.txt
+++ b/LICENSE.txt
@@ -1,7 +1,7 @@
                     GNU GENERAL PUBLIC LICENSE
                        Version 3, 29 June 2007
 
- Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
@@ -645,7 +645,7 @@ the "copyright" line and a pointer to where the full notice is found.
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 
 Also add information on how to contact you by electronic and paper mail.
 
@@ -664,11 +664,11 @@ might be different; for a GUI interface, you would use an "about box".
   You should also get your employer (if you work as a programmer) or school,
 if any, to sign a "copyright disclaimer" for the program, if necessary.
 For more information on this, and how to apply and follow the GNU GPL, see
-<http://www.gnu.org/licenses/>.
+<https://www.gnu.org/licenses/>.
 
   The GNU General Public License does not permit incorporating your program
 into proprietary programs.  If your program is a subroutine library, you
 may consider it more useful to permit linking proprietary applications with
 the library.  If this is what you want to do, use the GNU Lesser General
 Public License instead of this License.  But first, please read
-<http://www.gnu.org/philosophy/why-not-lgpl.html>.
+<https://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/build.gradle.kts b/build.gradle.kts
index 2da91ed6363c0851e4c459188f5e8ef5475e0c97..83b7f1ea9bfd2894272848e73874a0de5c3147a0 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -25,7 +25,7 @@ abstract class MockitoAgentProvider : CommandLineArgumentProvider {
 // Paper end - configure mockito agent that is needed in newer java versions
 
 dependencies {
-    implementation(project(":paper-api"))
+    implementation(project(":gale-api")) // Gale start - project setup - Depend on own API
     implementation("ca.spottedleaf:concurrentutil:0.0.2") // Paper - Add ConcurrentUtil dependency
     // Paper start
     implementation("org.jline:jline-terminal-ffm:3.27.1") // use ffm on java 22+
@@ -87,6 +87,16 @@ paperweight {
     craftBukkitPackageVersion.set("v1_21_R3") // also needs to be updated in MappingEnvironment
 }
 
+// Gale start - hide irrelevant compilation warnings
+tasks.withType<JavaCompile> {
+    val compilerArgs = options.compilerArgs
+    compilerArgs.add("-Xlint:-module")
+    compilerArgs.add("-Xlint:-removal")
+    compilerArgs.add("-Xlint:-dep-ann")
+    compilerArgs.add("--add-modules=jdk.incubator.vector") // Gale - Pufferfish - SIMD support
+}
+// Gale end - hide irrelevant compilation warnings
+
 tasks.jar {
     archiveClassifier.set("dev")
 
@@ -100,14 +110,14 @@ tasks.jar {
         val gitBranch = git("rev-parse", "--abbrev-ref", "HEAD").getText().trim() // Paper
         attributes(
             "Main-Class" to "org.bukkit.craftbukkit.Main",
-            "Implementation-Title" to "Paper",
+            "Implementation-Title" to "Gale", // Gale - branding changes
             "Implementation-Version" to implementationVersion,
             "Implementation-Vendor" to date, // Paper
-            "Specification-Title" to "Paper",
+            "Specification-Title" to "Gale", // Gale - branding changes
             "Specification-Version" to project.version,
-            "Specification-Vendor" to "Paper Team",
-            "Brand-Id" to "papermc:paper",
-            "Brand-Name" to "Paper",
+            "Specification-Vendor" to "GaleMC Team", // Gale - branding changes
+            "Brand-Id" to "galemc:gale", // Gale - branding changes
+            "Brand-Name" to "Gale", // Gale - branding changes
             "Build-Number" to (build ?: ""),
             "Build-Time" to Instant.now().toString(),
             "Git-Branch" to gitBranch, // Paper
@@ -201,6 +211,8 @@ fun TaskContainer.registerRunTask(
     val memoryGb = providers.gradleProperty("paper.runMemoryGb").getOrElse("2")
     minHeapSize = "${memoryGb}G"
     maxHeapSize = "${memoryGb}G"
+    jvmArgs("--enable-preview") // Gale - enable preview features for development runs
+    jvmArgs("--add-modules=jdk.incubator.vector") // Gale - Pufferfish - SIMD support
 
     doFirst {
         workingDir.mkdirs()
@@ -252,3 +264,22 @@ tasks.registerRunTask("runReobfPaperclip") {
     classpath(rootProject.tasks.named<io.papermc.paperweight.tasks.CreatePaperclipJar>("createReobfPaperclipJar").flatMap { it.outputZip })
     mainClass.set(null as String?)
 }
+
+// Gale start - package license into jar
+tasks.register<Copy>("copyLicense") {
+    from(layout.projectDirectory.file("LICENSE.txt"))
+    into(layout.buildDirectory.dir("tmp/copiedlicense"))
+}
+
+tasks.processResources {
+    dependsOn("copyLicense")
+}
+
+sourceSets {
+    main {
+        resources {
+            srcDir(layout.buildDirectory.dir("tmp/copiedlicense"))
+        }
+    }
+}
+// Gale end - package license into jar
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java b/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java
index 31b92bd48828cbea25b44a9f0f96886347aa1ae6..036c1a287db04c0191e5f84b027ea68d31447cbc 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java
@@ -16,7 +16,7 @@ public final class CoordinateUtils {
     }
 
     public static long getChunkKey(final Entity entity) {
-        return ((Mth.lfloor(entity.getZ()) >> 4) << 32) | ((Mth.lfloor(entity.getX()) >> 4) & 0xFFFFFFFFL);
+        return ((long) (entity.blockPosition.getZ() >> 4) << 32) | ((entity.blockPosition.getX() >> 4) & 0xFFFFFFFFL); // Gale - Pufferfish - optimize entity coordinate key - eliminate double->long cast in hotpath
     }
 
     public static long getChunkKey(final ChunkPos pos) {
diff --git a/src/main/java/com/destroystokyo/paper/Metrics.java b/src/main/java/com/destroystokyo/paper/Metrics.java
index 8f62879582195d8ae4f64bd23f752fa133b1c973..96549e7f8eb5921bb99159f0265130a810727a18 100644
--- a/src/main/java/com/destroystokyo/paper/Metrics.java
+++ b/src/main/java/com/destroystokyo/paper/Metrics.java
@@ -592,7 +592,7 @@ public class Metrics {
             boolean logFailedRequests = config.getBoolean("logFailedRequests", false);
             // Only start Metrics, if it's enabled in the config
             if (config.getBoolean("enabled", true)) {
-                Metrics metrics = new Metrics("Paper", serverUUID, logFailedRequests, Bukkit.getLogger());
+                Metrics metrics = new Metrics("Gale", serverUUID, logFailedRequests, Bukkit.getLogger()); // Gale - branding changes - metrics
 
                 metrics.addCustomChart(new Metrics.SimplePie("minecraft_version", () -> {
                     String minecraftVersion = Bukkit.getVersion();
@@ -602,20 +602,20 @@ public class Metrics {
 
                 metrics.addCustomChart(new Metrics.SingleLineChart("players", () -> Bukkit.getOnlinePlayers().size()));
                 metrics.addCustomChart(new Metrics.SimplePie("online_mode", () -> Bukkit.getOnlineMode() ? "online" : "offline"));
-                final String paperVersion;
+                final String galeVersion; // Gale - branding changes - metrics
                 final String implVersion = org.bukkit.craftbukkit.Main.class.getPackage().getImplementationVersion();
                 if (implVersion != null) {
                     final String buildOrHash = implVersion.substring(implVersion.lastIndexOf('-') + 1);
-                    paperVersion = "git-Paper-%s-%s".formatted(Bukkit.getServer().getMinecraftVersion(), buildOrHash);
+                    galeVersion = "git-Gale-%s-%s".formatted(Bukkit.getServer().getMinecraftVersion(), buildOrHash); // Gale - branding changes - metrics
                 } else {
-                    paperVersion = "unknown";
+                    galeVersion = "unknown"; // Gale - branding changes - metrics
                 }
-                metrics.addCustomChart(new Metrics.SimplePie("paper_version", () -> paperVersion));
+                metrics.addCustomChart(new Metrics.SimplePie("gale_version", () -> galeVersion)); // Gale - branding changes - metrics
 
                 metrics.addCustomChart(new Metrics.DrilldownPie("java_version", () -> {
-                    Map<String, Map<String, Integer>> map = new HashMap<>();
+                    Map<String, Map<String, Integer>> map = new HashMap<>(2); // Gale - metrics - reduce HashMap capacity
                     String javaVersion = System.getProperty("java.version");
-                    Map<String, Integer> entry = new HashMap<>();
+                    Map<String, Integer> entry = new HashMap<>(2); // Gale - metrics - reduce HashMap capacity
                     entry.put(javaVersion, 1);
 
                     // http://openjdk.java.net/jeps/223
@@ -644,7 +644,7 @@ public class Metrics {
                 }));
 
                 metrics.addCustomChart(new Metrics.DrilldownPie("legacy_plugins", () -> {
-                    Map<String, Map<String, Integer>> map = new HashMap<>();
+                    Map<String, Map<String, Integer>> map = new HashMap<>(2); // Gale - metrics - reduce HashMap capacity
 
                     // count legacy plugins
                     int legacy = 0;
@@ -655,7 +655,7 @@ public class Metrics {
                     }
 
                     // insert real value as lower dimension
-                    Map<String, Integer> entry = new HashMap<>();
+                    Map<String, Integer> entry = new HashMap<>(2); // Gale - metrics - reduce HashMap capacity
                     entry.put(String.valueOf(legacy), 1);
 
                     // create buckets as higher dimension
@@ -675,6 +675,277 @@ public class Metrics {
 
                     return map;
                 }));
+
+                // Gale start - metrics - proxy
+                metrics.addCustomChart(new Metrics.DrilldownPie("proxy", () -> {
+                    String type;
+                    boolean onlineMode;
+                    var proxiesConfig = io.papermc.paper.configuration.GlobalConfiguration.get().proxies;
+                    if (proxiesConfig.velocity.enabled) {
+                        type = "Velocity";
+                        onlineMode = proxiesConfig.velocity.onlineMode;
+                    } else if (org.spigotmc.SpigotConfig.bungee) {
+                        type = "BungeeCord";
+                        onlineMode = proxiesConfig.bungeeCord.onlineMode;
+                    } else {
+                        type = "none";
+                        onlineMode = Bukkit.getOnlineMode();
+                    }
+
+                    Map<String, Map<String, Integer>> map = new HashMap<>(2);
+
+                    // insert type and online mode as lower dimension
+                    Map<String, Integer> entry = new HashMap<>(2);
+                    entry.put(type + " (" + (onlineMode ? "online" : "offline") + ")", 1);
+
+                    // create type as higher dimension
+                    map.put(type, entry);
+
+                    return map;
+                }));
+                // Gale end - metrics - proxy
+
+                // Gale start - metrics - Java VM
+                Map<String, Map<String, Integer>> javaVirtualMachineMap = new HashMap<>(2);
+                {
+                    Map<String, Integer> entry = new HashMap<>(2);
+                    String vmVendor = null;
+                    try {
+                        vmVendor = System.getProperty("java.vm.vendor");
+                    } catch (Exception ignored) {}
+                    entry.put(vmVendor == null ? "Unknown" : vmVendor, 1);
+                    String vmName = null;
+                    try {
+                        vmName = System.getProperty("java.vm.name");
+                    } catch (Exception ignored) {}
+                    javaVirtualMachineMap.put(vmName == null ? "Unknown" : vmName, entry);
+                }
+                metrics.addCustomChart(new Metrics.DrilldownPie("java_virtual_machine", () -> javaVirtualMachineMap));
+                // Gale end - metrics - Java VM
+
+                // Gale start - metrics - per-server player count
+                metrics.addCustomChart(new Metrics.DrilldownPie("per_server_player_count", () -> {
+                    Map<String, Map<String, Integer>> map = new HashMap<>(2);
+
+                    // count players
+                    int playerCount = Bukkit.getOnlinePlayers().size();
+
+                    // insert real value as lower dimension
+                    Map<String, Integer> entry = new HashMap<>(2);
+                    entry.put(String.valueOf(playerCount), 1);
+
+                    // create buckets as higher dimension
+                    if (playerCount <= 5) {
+                        map.put(String.valueOf(playerCount), entry);
+                    } else if (playerCount > 1000) {
+                        map.put("> 1000", entry);
+                    } else {
+                        int divisor;
+                        if (playerCount <= 50) {
+                            divisor = 5;
+                        } else if (playerCount <= 100) {
+                            divisor = 10;
+                        } else if (playerCount <= 250) {
+                            divisor = 25;
+                        } else if (playerCount <= 500) {
+                            divisor = 50;
+                        } else {
+                            divisor = 100;
+                        }
+                        int start = (playerCount - 1) / divisor * divisor + 1;
+                        int end = start + divisor - 1;
+                        map.put(start + "-" + end, entry);
+                    }
+
+                    return map;
+                }));
+                // Gale end - metrics - per-server player count
+
+                // Gale start - metrics - plugin count
+                metrics.addCustomChart(new Metrics.DrilldownPie("plugin_count", () -> {
+                    Map<String, Map<String, Integer>> map = new HashMap<>(2);
+
+                    // count plugins
+                    int pluginCount = Bukkit.getPluginManager().getPlugins().length;
+
+                    // insert real value as lower dimension
+                    Map<String, Integer> entry = new HashMap<>(2);
+                    entry.put(String.valueOf(pluginCount), 1);
+
+                    // create buckets as higher dimension
+                    if (pluginCount <= 5) {
+                        map.put(String.valueOf(pluginCount), entry);
+                    } else if (pluginCount > 1000) {
+                        map.put("> 1000", entry);
+                    } else {
+                        int divisor;
+                        if (pluginCount <= 50) {
+                            divisor = 5;
+                        } else if (pluginCount <= 100) {
+                            divisor = 10;
+                        } else if (pluginCount <= 250) {
+                            divisor = 25;
+                        } else if (pluginCount <= 500) {
+                            divisor = 50;
+                        } else {
+                            divisor = 100;
+                        }
+                        int start = (pluginCount - 1) / divisor * divisor + 1;
+                        int end = start + divisor - 1;
+                        map.put(start + "-" + end, entry);
+                    }
+
+                    return map;
+                }));
+                // Gale end - metrics - plugin count
+
+                // Gale start - metrics - netty threads
+                metrics.addCustomChart(new Metrics.SimplePie("netty_thread_count", () -> {
+                    // Try to get the number of Netty threads from the system property
+                    try {
+                        return System.getProperty("io.netty.eventLoopThreads");
+                    } catch (Exception ignored) {}
+                    // Otherwise, we fall back to nothing currently (reading from the Spigot configuration causes a re-read which is undesirable)
+                    return null;
+                }));
+                // Gale end - metrics - netty threads
+
+                // Gale start - metrics - physical cores
+                metrics.addCustomChart(new Metrics.SimplePie("physical_core_count", () -> {
+                    try {
+                        int physicalProcessorCount = new oshi.SystemInfo().getHardware().getProcessor().getPhysicalProcessorCount();
+                        if (physicalProcessorCount > 0) {
+                            return String.valueOf(physicalProcessorCount);
+                        }
+                    } catch (Exception ignored) {}
+                    return null;
+                }));
+                // Gale end - metrics - physical cores
+
+                // Gale start - metrics - processor frequency
+                metrics.addCustomChart(new Metrics.DrilldownPie("processor_frequency", () -> {
+                    try {
+                        long processorFrequency = new oshi.SystemInfo().getHardware().getProcessor().getProcessorIdentifier().getVendorFreq();
+                        if (processorFrequency > 0) {
+
+                            Map<String, Map<String, Integer>> map = new HashMap<>(2);
+
+                            // use MHz as lower dimension
+                            var flooredMHz = processorFrequency / 1_000_000L;
+                            Map<String, Integer> entry = new HashMap<>(2);
+                            if (flooredMHz < 1) {
+                                entry.put("< 1 MHz", 1);
+                            } else if (flooredMHz < 1000) {
+                                entry.put(flooredMHz + " MHz", 1);
+                            } else {
+                                // Add a comma
+                                StringBuilder flooredMHzAfterComma = new StringBuilder(String.valueOf(flooredMHz % 1000));
+                                while (flooredMHzAfterComma.length() < 3) {
+                                    flooredMHzAfterComma.insert(0, "0");
+                                }
+                                entry.put((flooredMHz / 1000) + "," + flooredMHzAfterComma + " MHz", 1);
+                            }
+
+                            // use tenth of GHz as higher dimension
+                            long flooredTenthGHz = processorFrequency / 100_000_000L;
+                            if (flooredTenthGHz < 1) {
+                                map.put("< 0.1 GHz", entry);
+                            } else {
+                                // Add a dot
+                                map.put((flooredTenthGHz / 10) + "." + (flooredTenthGHz % 10) + " GHz", entry);
+                            }
+
+                            return map;
+
+                        }
+                    } catch (Exception ignored) {}
+                    return null;
+                }));
+                // Gale end - metrics - processor frequency
+
+                // Gale start - metrics - physical memory
+                metrics.addCustomChart(new Metrics.DrilldownPie("physical_memory_total", () -> {
+                    try {
+                        long physicalMemory = new oshi.SystemInfo().getHardware().getMemory().getTotal();
+                        if (physicalMemory > 0) {
+
+                            Map<String, Map<String, Integer>> map = new HashMap<>(2);
+
+                            // use floored MB as lower dimension
+                            var flooredMB = physicalMemory / (1L << 20);
+                            Map<String, Integer> entry = new HashMap<>(2);
+                            entry.put(flooredMB < 1 ? "< 1 MB" : flooredMB + " MB", 1);
+
+                            // use floored GB as higher dimension
+                            var flooredGB = physicalMemory / (1L << 30);
+                            map.put(flooredGB < 1 ? "< 1 GB" : flooredGB + " GB", entry);
+
+                            return map;
+
+                        }
+                    } catch (Exception ignored) {}
+                    return null;
+                }));
+                // Gale end - metrics - physical memory
+
+                // Gale start - metrics - runtime max memory
+                metrics.addCustomChart(new Metrics.DrilldownPie("runtime_max_memory", () -> {
+
+                    // get memory limit
+                    long maxMemory = Runtime.getRuntime().maxMemory();
+                    if (maxMemory <= 0) {
+                        return null;
+                    }
+
+                    Map<String, Map<String, Integer>> map = new HashMap<>(2);
+
+                    // in the case of no limit
+                    if (maxMemory == Long.MAX_VALUE) {
+                        Map<String, Integer> entry = new HashMap<>(2);
+                        entry.put("no limit", 1);
+                        map.put("no limit", entry);
+                        return map;
+                    }
+
+                    // use floored MB as lower dimension
+                    var flooredMB = maxMemory / (1L << 20);
+                    Map<String, Integer> entry = new HashMap<>(2);
+                    entry.put(flooredMB < 1 ? "< 1 MB" : flooredMB + " MB", 1);
+
+                    // use floored GB as higher dimension
+                    var flooredGB = maxMemory / (1L << 30);
+                    map.put(flooredGB < 1 ? "< 1 GB" : flooredGB + " GB", entry);
+
+                    return map;
+                }));
+                // Gale end - metrics - runtime max memory
+
+                // Gale start - semantic version - include in metrics
+                Map<String, Map<String, Integer>> semanticVersionMap = new HashMap<>(2);
+                {
+                    Map<String, Integer> entry = new HashMap<>(2);
+                    entry.put(org.galemc.gale.version.GaleSemanticVersion.version, 1);
+                    semanticVersionMap.put(org.galemc.gale.version.GaleSemanticVersion.majorMinorVersion, entry);
+                }
+                metrics.addCustomChart(new Metrics.DrilldownPie("gale_semantic_version", () -> semanticVersionMap));
+                // Gale end - semantic version - include in metrics
+
+                // Gale start - virtual thread support - include in metrics
+                Map<String, Map<String, Integer>> virtualThreadSupportMap = new HashMap<>(2);
+                {
+                    Map<String, Integer> entry = new HashMap<>(2);
+                    boolean isSupported = org.galemc.gale.virtualthread.VirtualThreadService.isSupported();
+                    try {
+                        int javaMajorVersion = org.galemc.gale.virtualthread.VirtualThreadService.getJavaMajorVersion();
+                        entry.put(isSupported + " (Java " + javaMajorVersion + ")", 1);
+                    } catch (Exception ignored) {
+                        entry.put(String.valueOf(isSupported), 1);
+                    }
+                    virtualThreadSupportMap.put(String.valueOf(isSupported), entry);
+                }
+                metrics.addCustomChart(new Metrics.DrilldownPie("virtual_thread_support", () -> virtualThreadSupportMap));
+                // Gale end - virtual thread support - include in metrics
+
             }
 
         }
diff --git a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java b/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
index 532306cacd52579cdf37e4aca25887b1ed3ba6a1..07317899d4e28b55592c8035686c81ea198c1675 100644
--- a/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
+++ b/src/main/java/com/destroystokyo/paper/PaperVersionFetcher.java
@@ -30,58 +30,28 @@ import org.slf4j.Logger;
 import static net.kyori.adventure.text.Component.text;
 import static net.kyori.adventure.text.format.TextColor.color;
 
+// Gale start - branding changes - version fetcher
+/**
+ * The original version fetcher for Paper. Most of the original content of this class has been moved to
+ * {@link org.galemc.gale.version.AbstractPaperVersionFetcher}.
+ */
 @DefaultQualifier(NonNull.class)
-public class PaperVersionFetcher implements VersionFetcher {
-    private static final Logger LOGGER = LogUtils.getClassLogger();
-    private static final int DISTANCE_ERROR = -1;
-    private static final int DISTANCE_UNKNOWN = -2;
-    private static final String DOWNLOAD_PAGE = "https://papermc.io/downloads/paper";
+public class PaperVersionFetcher extends org.galemc.gale.version.AbstractPaperVersionFetcher {
 
-    @Override
-    public long getCacheTime() {
-        return 720000;
+    public PaperVersionFetcher() {
+        super("master", "https://papermc.io/downloads/paper", "Paper", "PaperMC", "PaperMC", "Paper");
     }
 
     @Override
-    public Component getVersionMessage(final String serverVersion) {
-        final Component updateMessage;
-        final ServerBuildInfo build = ServerBuildInfo.buildInfo();
-        if (build.buildNumber().isEmpty() && build.gitCommit().isEmpty()) {
-            updateMessage = text("You are running a development version without access to version information", color(0xFF5300));
-        } else {
-            updateMessage = getUpdateStatusMessage("PaperMC/Paper", build);
-        }
-        final @Nullable Component history = this.getHistory();
-
-        return history != null ? Component.textOfChildren(updateMessage, Component.newline(), history) : updateMessage;
+    protected boolean canFetchDistanceFromSiteApi() {
+        return true;
     }
 
-    private static Component getUpdateStatusMessage(final String repo, final ServerBuildInfo build) {
-        int distance = DISTANCE_ERROR;
-
-        final OptionalInt buildNumber = build.buildNumber();
-        if (buildNumber.isPresent()) {
-            distance = fetchDistanceFromSiteApi(build, buildNumber.getAsInt());
-        } else {
-            final Optional<String> gitBranch = build.gitBranch();
-            final Optional<String> gitCommit = build.gitCommit();
-            if (gitBranch.isPresent() && gitCommit.isPresent()) {
-                distance = fetchDistanceFromGitHub(repo, gitBranch.get(), gitCommit.get());
-            }
-        }
-
-        return switch (distance) {
-            case DISTANCE_ERROR -> text("Error obtaining version information", NamedTextColor.YELLOW);
-            case 0 -> text("You are running the latest version", NamedTextColor.GREEN);
-            case DISTANCE_UNKNOWN -> text("Unknown version", NamedTextColor.YELLOW);
-            default -> text("You are " + distance + " version(s) behind", NamedTextColor.YELLOW)
-                .append(Component.newline())
-                .append(text("Download the new version at: ")
-                    .append(text(DOWNLOAD_PAGE, NamedTextColor.GOLD)
-                        .hoverEvent(text("Click to open", NamedTextColor.WHITE))
-                        .clickEvent(ClickEvent.openUrl(DOWNLOAD_PAGE))));
-        };
+    @Override
+    protected int fetchDistanceFromSiteApi(int jenkinsBuild) {
+        return fetchDistanceFromSiteApi(ServerBuildInfo.buildInfo(), jenkinsBuild);
     }
+    // Gale end - branding changes - version fetcher
 
     private static int fetchDistanceFromSiteApi(final ServerBuildInfo build, final int jenkinsBuild) {
         try {
@@ -105,42 +75,4 @@ public class PaperVersionFetcher implements VersionFetcher {
             return DISTANCE_ERROR;
         }
     }
-
-    // Contributed by Techcable <Techcable@outlook.com> in GH-65
-    private static int fetchDistanceFromGitHub(final String repo, final String branch, final String hash) {
-        try {
-            final HttpURLConnection connection = (HttpURLConnection) URI.create("https://api.github.com/repos/%s/compare/%s...%s".formatted(repo, branch, hash)).toURL().openConnection();
-            connection.connect();
-            if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) return DISTANCE_UNKNOWN; // Unknown commit
-            try (final BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))) {
-                final JsonObject obj = new Gson().fromJson(reader, JsonObject.class);
-                final String status = obj.get("status").getAsString();
-                return switch (status) {
-                    case "identical" -> 0;
-                    case "behind" -> obj.get("behind_by").getAsInt();
-                    default -> DISTANCE_ERROR;
-                };
-            } catch (final JsonSyntaxException | NumberFormatException e) {
-                LOGGER.error("Error parsing json from GitHub's API", e);
-                return DISTANCE_ERROR;
-            }
-        } catch (final IOException e) {
-            LOGGER.error("Error while parsing version", e);
-            return DISTANCE_ERROR;
-        }
-    }
-
-    private @Nullable Component getHistory() {
-        final VersionHistoryManager.@Nullable VersionData data = VersionHistoryManager.INSTANCE.getVersionData();
-        if (data == null) {
-            return null;
-        }
-
-        final @Nullable String oldVersion = data.getOldVersion();
-        if (oldVersion == null) {
-            return null;
-        }
-
-        return text("Previous version: " + oldVersion, NamedTextColor.GRAY, TextDecoration.ITALIC);
-    }
 }
diff --git a/src/main/java/com/destroystokyo/paper/console/PaperConsole.java b/src/main/java/com/destroystokyo/paper/console/PaperConsole.java
index 6ee39b534b8d992655bc0cef3c299d12cbae0034..b78828e83d8128eace986aeb73213da3b3f905e4 100644
--- a/src/main/java/com/destroystokyo/paper/console/PaperConsole.java
+++ b/src/main/java/com/destroystokyo/paper/console/PaperConsole.java
@@ -20,7 +20,7 @@ public final class PaperConsole extends SimpleTerminalConsole {
     @Override
     protected LineReader buildReader(LineReaderBuilder builder) {
         builder
-                .appName("Paper")
+                .appName("Gale") // Gale - branding changes
                 .variable(LineReader.HISTORY_FILE, java.nio.file.Paths.get(".console_history"))
                 .completer(new ConsoleCommandCompleter(this.server))
                 .option(LineReader.Option.COMPLETE_IN_WORD, true);
diff --git a/src/main/java/com/destroystokyo/paper/gui/RAMDetails.java b/src/main/java/com/destroystokyo/paper/gui/RAMDetails.java
index 12b327eea95e0de9e9c39b7d039badee8ec46508..6178f0212214a2a075cea60c758dca793a61951b 100644
--- a/src/main/java/com/destroystokyo/paper/gui/RAMDetails.java
+++ b/src/main/java/com/destroystokyo/paper/gui/RAMDetails.java
@@ -61,6 +61,7 @@ public class RAMDetails extends JList<String> {
 
         // Follows CraftServer#getTPS
         double[] tps = new double[] {
+            server.tps5s.getAverage(), // Gale - Purpur - 5 second TPS average
             server.tps1.getAverage(),
             server.tps5.getAverage(),
             server.tps15.getAverage()
@@ -73,7 +74,7 @@ public class RAMDetails extends JList<String> {
         vector.add("Memory use: " + (data.getUsedMem() / 1024L / 1024L) + " mb (" + (data.getFree() * 100L / data.getMax()) + "% free)");
         vector.add("Heap: " + (data.getTotal() / 1024L / 1024L) + " / " + (data.getMax() / 1024L / 1024L) + " mb");
         vector.add("Avg tick: " + DECIMAL_FORMAT.format((double)this.server.getAverageTickTimeNanos() / (double) TimeUtil.NANOSECONDS_PER_MILLISECOND) + " ms");
-        vector.add("TPS from last 1m, 5m, 15m: " + String.join(", ", tpsAvg));
+        vector.add("TPS from last 5s, 1m, 5m, 15m: " + String.join(", ", tpsAvg)); // Gale - Purpur - 5 second TPS average
         setListData(vector);
     }
 
diff --git a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
index 861bff267cb397e13e8e1c79bd0776b130c6e5da..30972bf7889973cf63b5f32ad166afdc9800bee1 100644
--- a/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
+++ b/src/main/java/com/destroystokyo/paper/loottable/PaperLootableInventoryData.java
@@ -21,7 +21,7 @@ import org.checkerframework.framework.qual.DefaultQualifier;
 @DefaultQualifier(NonNull.class)
 public class PaperLootableInventoryData {
 
-    private static final Random RANDOM = new Random();
+    public static Random RANDOM; // Gale - xor-shift random - set in GaleGlobalConfiguration
 
     private long lastFill = -1;
     private long nextRefill = -1;
diff --git a/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java b/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java
index 790bad0494454ca12ee152e3de6da3da634d9b20..2596e0ee4df5b96f181e28a742ef345981fc97e3 100644
--- a/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java
+++ b/src/main/java/io/papermc/paper/ServerBuildInfoImpl.java
@@ -31,6 +31,7 @@ public record ServerBuildInfoImpl(
     private static final String ATTRIBUTE_GIT_COMMIT = "Git-Commit";
 
     private static final String BRAND_PAPER_NAME = "Paper";
+    private static final String BRAND_GALE_NAME = "Gale"; // Gale - branding changes
 
     private static final String BUILD_DEV = "DEV";
 
@@ -42,9 +43,9 @@ public record ServerBuildInfoImpl(
         this(
             getManifestAttribute(manifest, ATTRIBUTE_BRAND_ID)
                 .map(Key::key)
-                .orElse(BRAND_PAPER_ID),
+                .orElse(BRAND_GALE_ID), // Gale - branding changes
             getManifestAttribute(manifest, ATTRIBUTE_BRAND_NAME)
-                .orElse(BRAND_PAPER_NAME),
+                .orElse(BRAND_GALE_NAME), // Gale - branding changes
             SharedConstants.getCurrentVersion().getId(),
             SharedConstants.getCurrentVersion().getName(),
             getManifestAttribute(manifest, ATTRIBUTE_BUILD_NUMBER)
@@ -61,7 +62,7 @@ public record ServerBuildInfoImpl(
 
     @Override
     public boolean isBrandCompatible(final @NotNull Key brandId) {
-        return brandId.equals(this.brandId);
+        return brandId.equals(this.brandId) || brandId.equals(BRAND_PAPER_ID); // Gale - branding changes
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
index 14e412ebf75b0e06ab53a1c8f9dd1be6ad1e2680..506c746980cfca170efd249d035a572361b667c4 100644
--- a/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
+++ b/src/main/java/io/papermc/paper/adventure/ChatProcessor.java
@@ -317,7 +317,7 @@ public final class ChatProcessor {
 
         private void sendToServer(final ChatType.Bound chatType, final @Nullable Function<Audience, net.minecraft.network.chat.Component> msgFunction) {
             final PlayerChatMessage toConsoleMessage = msgFunction == null ? ChatProcessor.this.message : ChatProcessor.this.message.withUnsignedContent(msgFunction.apply(ChatProcessor.this.server.console));
-            ChatProcessor.this.server.logChatMessage(toConsoleMessage.decoratedContent(), chatType, ChatProcessor.this.server.getPlayerList().verifyChatTrusted(toConsoleMessage) ? null : "Not Secure");
+            ChatProcessor.this.server.logChatMessage(toConsoleMessage.decoratedContent(), chatType, !org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.chat.notSecureMarker || ChatProcessor.this.server.getPlayerList().verifyChatTrusted(toConsoleMessage) ? null : "Not Secure"); // Gale - do not log Not Secure marker
         }
     }
 
diff --git a/src/main/java/io/papermc/paper/configuration/Configurations.java b/src/main/java/io/papermc/paper/configuration/Configurations.java
index 8cf720f08514e8e4f62f4ad196f1277bd761c6b2..63afa5284028f3c423d19c2d5cb35b83c89050fd 100644
--- a/src/main/java/io/papermc/paper/configuration/Configurations.java
+++ b/src/main/java/io/papermc/paper/configuration/Configurations.java
@@ -94,7 +94,7 @@ public abstract class Configurations<G, W> {
         };
     }
 
-    static <T> CheckedFunction<ConfigurationNode, T, SerializationException> reloader(Class<T> type, T instance) {
+    public static <T> CheckedFunction<ConfigurationNode, T, SerializationException> reloader(Class<T> type, T instance) { // Gale - Gale configuration
         return node -> {
             ObjectMapper.Factory factory = (ObjectMapper.Factory) Objects.requireNonNull(node.options().serializers().get(type));
             ObjectMapper.Mutable<T> mutable = (ObjectMapper.Mutable<T>) factory.get(type);
@@ -168,7 +168,7 @@ public abstract class Configurations<G, W> {
         final YamlConfigurationLoader loader = result.loader();
         final ConfigurationNode node = loader.load();
         if (result.isNewFile()) { // add version to new files
-            node.node(Configuration.VERSION_FIELD).raw(this.worldConfigVersion());
+            node.node(Configuration.VERSION_FIELD).raw(getWorldConfigurationCurrentVersion()); // Gale - Gale configuration
         } else {
             this.verifyWorldConfigVersion(contextMap, node);
         }
@@ -230,7 +230,7 @@ public abstract class Configurations<G, W> {
             .build();
         final ConfigurationNode worldNode = worldLoader.load();
         if (newFile) { // set the version field if new file
-            worldNode.node(Configuration.VERSION_FIELD).set(this.worldConfigVersion());
+            worldNode.node(Configuration.VERSION_FIELD).set(getWorldConfigurationCurrentVersion()); // Gale - Gale configuration
         } else {
             this.verifyWorldConfigVersion(contextMap, worldNode);
         }
@@ -356,4 +356,25 @@ public abstract class Configurations<G, W> {
             return "ContextKey{" + this.name + "}";
         }
     }
+
+    // Gale start - Gale configuration
+
+    public static final String legacyWorldsSectionKey = "__________WORLDS__________";
+    public static final String legacyWorldDefaultsSectionKey = "__defaults__";
+
+    @Deprecated
+    public org.bukkit.configuration.file.YamlConfiguration createLegacyObject(final net.minecraft.server.MinecraftServer server) {
+        org.bukkit.configuration.file.YamlConfiguration global = org.bukkit.configuration.file.YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.globalConfigFileName).toFile());
+        org.bukkit.configuration.ConfigurationSection worlds = global.createSection(legacyWorldsSectionKey);
+        worlds.set(legacyWorldDefaultsSectionKey, org.bukkit.configuration.file.YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.defaultWorldConfigFileName).toFile()));
+        for (ServerLevel level : server.getAllLevels()) {
+            worlds.set(level.getWorld().getName(), org.bukkit.configuration.file.YamlConfiguration.loadConfiguration(getWorldConfigFile(level).toFile()));
+        }
+        return global;
+    }
+
+    public abstract int getWorldConfigurationCurrentVersion();
+
+    // Gale end - Gale configuration
+
 }
diff --git a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
index c5644d8d64f12073e39bc6ed79c8714f4560ff89..b993d3e2e9d987115129067e3a51060880453ee2 100644
--- a/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
+++ b/src/main/java/io/papermc/paper/configuration/PaperConfigurations.java
@@ -326,7 +326,7 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         }
     }
 
-    private static ContextMap createWorldContextMap(ServerLevel level) {
+    public static ContextMap createWorldContextMap(ServerLevel level) { // Gale - Gale configuration
         return createWorldContextMap(level.convertable.levelDirectory.path(), level.serverLevelData.getLevelName(), level.dimension().location(), level.spigotConfig, level.registryAccess(), level.getGameRules());
     }
 
@@ -429,17 +429,6 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
         return Files.exists(legacyConfig) && Files.isRegularFile(legacyConfig);
     }
 
-    @Deprecated
-    public YamlConfiguration createLegacyObject(final MinecraftServer server) {
-        YamlConfiguration global = YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.globalConfigFileName).toFile());
-        ConfigurationSection worlds = global.createSection("__________WORLDS__________");
-        worlds.set("__defaults__", YamlConfiguration.loadConfiguration(this.globalFolder.resolve(this.defaultWorldConfigFileName).toFile()));
-        for (ServerLevel level : server.getAllLevels()) {
-            worlds.set(level.getWorld().getName(), YamlConfiguration.loadConfiguration(getWorldConfigFile(level).toFile()));
-        }
-        return global;
-    }
-
     @Deprecated
     public static YamlConfiguration loadLegacyConfigFile(File configFile) throws Exception {
         YamlConfiguration config = new YamlConfiguration();
@@ -462,9 +451,16 @@ public class PaperConfigurations extends Configurations<GlobalConfiguration, Wor
     }
 
     // Symlinks are not correctly checked in createDirectories
-    static void createDirectoriesSymlinkAware(Path path) throws IOException {
+    public static void createDirectoriesSymlinkAware(Path path) throws IOException { // Gale - Gale configuration
         if (!Files.isDirectory(path)) {
             Files.createDirectories(path);
         }
     }
+
+    // Gale start - Gale configuration
+    @Override
+    public int getWorldConfigurationCurrentVersion() {
+        return WorldConfiguration.CURRENT_VERSION;
+    }
+    // Gale end - Gale configuration
 }
diff --git a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassFieldDiscoverer.java b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassFieldDiscoverer.java
index 05339a176083af667c16f77d76dc1878dafce3f0..9ca55cba185b9de566f911b08d671bee50bca075 100644
--- a/src/main/java/io/papermc/paper/configuration/mapping/InnerClassFieldDiscoverer.java
+++ b/src/main/java/io/papermc/paper/configuration/mapping/InnerClassFieldDiscoverer.java
@@ -46,7 +46,19 @@ public final class InnerClassFieldDiscoverer implements FieldDiscoverer<Map<Fiel
         return new InnerClassFieldDiscoverer(overrides);
     }
 
-    public static FieldDiscoverer<?> globalConfig() {
+    // Gale start - Gale configuration
+    public static FieldDiscoverer<?> galeWorldConfig(io.papermc.paper.configuration.Configurations.ContextMap contextMap) {
+        final Map<Class<?>, Object> overrides = Map.of(
+            org.galemc.gale.configuration.GaleWorldConfiguration.class, new org.galemc.gale.configuration.GaleWorldConfiguration(
+                contextMap.require(io.papermc.paper.configuration.PaperConfigurations.SPIGOT_WORLD_CONFIG_CONTEXT_KEY).get(),
+                contextMap.require(io.papermc.paper.configuration.Configurations.WORLD_KEY)
+            )
+        );
+        return new InnerClassFieldDiscoverer(overrides);
+    }
+    // Gale end - Gale configuration
+
+    public static FieldDiscoverer<?> globalConfig() { // Gale - Gale configuration
         return new InnerClassFieldDiscoverer(Collections.emptyMap());
     }
 }
diff --git a/src/main/java/net/caffeinemc/mods/lithium/common/world/chunk/LithiumHashPalette.java b/src/main/java/net/caffeinemc/mods/lithium/common/world/chunk/LithiumHashPalette.java
new file mode 100644
index 0000000000000000000000000000000000000000..92429036253d8cdbaa6b10732d52081e5cd7a035
--- /dev/null
+++ b/src/main/java/net/caffeinemc/mods/lithium/common/world/chunk/LithiumHashPalette.java
@@ -0,0 +1,198 @@
+// Gale - Lithium - faster chunk serialization
+
+package net.caffeinemc.mods.lithium.common.world.chunk;
+
+import com.google.common.collect.ImmutableList;
+import it.unimi.dsi.fastutil.HashCommon;
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.Predicate;
+import net.minecraft.core.IdMap;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.VarInt;
+import net.minecraft.world.level.chunk.MissingPaletteEntryException;
+import net.minecraft.world.level.chunk.Palette;
+import net.minecraft.world.level.chunk.PaletteResize;
+
+import static it.unimi.dsi.fastutil.Hash.FAST_LOAD_FACTOR;
+
+/**
+ * Generally provides better performance over the vanilla {@link net.minecraft.world.level.chunk.HashMapPalette} when calling
+ * {@link LithiumHashPalette#idFor(Object)} through using a faster backing map and reducing pointer chasing.
+ */
+public class LithiumHashPalette<T> implements Palette<T> {
+    private static final int ABSENT_VALUE = -1;
+
+    private final IdMap<T> idList;
+    private final PaletteResize<T> resizeHandler;
+    private final int indexBits;
+
+    private final Reference2IntMap<T> table;
+    private T[] entries;
+    private int size = 0;
+
+    public LithiumHashPalette(IdMap<T> idList, PaletteResize<T> resizeHandler, int indexBits, T[] entries, Reference2IntMap<T> table, int size) {
+        this.idList = idList;
+        this.resizeHandler = resizeHandler;
+        this.indexBits = indexBits;
+        this.entries = entries;
+        this.table = table;
+        this.size = size;
+    }
+
+    public LithiumHashPalette(IdMap<T> idList, int bits, PaletteResize<T> resizeHandler, List<T> list) {
+        this(idList, bits, resizeHandler);
+
+        for (T t : list) {
+            this.addEntry(t);
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    public LithiumHashPalette(IdMap<T> idList, int bits, PaletteResize<T> resizeHandler) {
+        this.idList = idList;
+        this.indexBits = bits;
+        this.resizeHandler = resizeHandler;
+
+        int capacity = 1 << bits;
+
+        this.entries = (T[]) new Object[capacity];
+        this.table = new Reference2IntOpenHashMap<>(capacity, FAST_LOAD_FACTOR);
+        this.table.defaultReturnValue(ABSENT_VALUE);
+    }
+
+    @Override
+    public int idFor(T obj) {
+        int id = this.table.getInt(obj);
+
+        if (id == ABSENT_VALUE) {
+            id = this.computeEntry(obj);
+        }
+
+        return id;
+    }
+
+    @Override
+    public boolean maybeHas(Predicate<T> predicate) {
+        for (int i = 0; i < this.size; ++i) {
+            if (predicate.test(this.entries[i])) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    private int computeEntry(T obj) {
+        int id = this.addEntry(obj);
+
+        if (id >= 1 << this.indexBits) {
+            if (this.resizeHandler == null) {
+                throw new IllegalStateException("Cannot grow");
+            } else {
+                id = this.resizeHandler.onResize(this.indexBits + 1, obj);
+            }
+        }
+
+        return id;
+    }
+
+    private int addEntry(T obj) {
+        int nextId = this.size;
+
+        if (nextId >= this.entries.length) {
+            this.resize(this.size);
+        }
+
+        this.table.put(obj, nextId);
+        this.entries[nextId] = obj;
+
+        this.size++;
+
+        return nextId;
+    }
+
+    private void resize(int neededCapacity) {
+        this.entries = Arrays.copyOf(this.entries, HashCommon.nextPowerOfTwo(neededCapacity + 1));
+    }
+
+    @Override
+    public T valueFor(int id) {
+        T[] entries = this.entries;
+
+        T entry = null;
+        if (id >= 0 && id < entries.length) {
+            entry = entries[id];
+        }
+
+        if (entry != null) {
+            return entry;
+        } else {
+            throw new MissingPaletteEntryException(id);
+        }
+    }
+
+    @Override
+    public void read(FriendlyByteBuf buf) {
+        this.clear();
+
+        int entryCount = buf.readVarInt();
+
+        for (int i = 0; i < entryCount; ++i) {
+            this.addEntry(this.idList.byId(buf.readVarInt()));
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf buf) {
+        int size = this.size;
+        buf.writeVarInt(size);
+
+        for (int i = 0; i < size; ++i) {
+            buf.writeVarInt(this.idList.getId(this.valueFor(i)));
+        }
+    }
+
+    @Override
+    public int getSerializedSize() {
+        int size = VarInt.getByteSize(this.size);
+
+        for (int i = 0; i < this.size; ++i) {
+            size += VarInt.getByteSize(this.idList.getId(this.valueFor(i)));
+        }
+
+        return size;
+    }
+
+    @Override
+    public int getSize() {
+        return this.size;
+    }
+
+    @Override
+    public Palette<T> copy(PaletteResize<T> ctx) {
+        return new LithiumHashPalette<>(this.idList, ctx, this.indexBits, this.entries.clone(), new Reference2IntOpenHashMap<>(this.table), this.size);
+    }
+
+    private void clear() {
+        Arrays.fill(this.entries, null);
+        this.table.clear();
+        this.size = 0;
+    }
+
+    public List<T> getElements() {
+        ImmutableList.Builder<T> builder = new ImmutableList.Builder<>();
+        for (T entry : this.entries) {
+            if (entry != null) {
+                builder.add(entry);
+            }
+        }
+        return builder.build();
+    }
+
+    public static <A> Palette<A> create(int bits, IdMap<A> idList, PaletteResize<A> listener, List<A> list) {
+        return new LithiumHashPalette<>(idList, bits, listener, list);
+    }
+}
diff --git a/src/main/java/net/minecraft/advancements/Advancement.java b/src/main/java/net/minecraft/advancements/Advancement.java
index fb4b7652c386fa10783d71899615723a958ffd56..8045b17eed344e4bcdd02adba1d63904b6562cde 100644
--- a/src/main/java/net/minecraft/advancements/Advancement.java
+++ b/src/main/java/net/minecraft/advancements/Advancement.java
@@ -60,7 +60,7 @@ public record Advancement(
         AdvancementRequirements requirements,
         boolean sendsTelemetryEvent
     ) {
-        this(parent, display, rewards, Map.copyOf(criteria), requirements, sendsTelemetryEvent, display.map(Advancement::decorateName));
+        this(parent, display, rewards, criteria, requirements, sendsTelemetryEvent, display.map(Advancement::decorateName)); // Gale - Mirai - skip cloning advancement criteria
     }
 
     private static DataResult<Advancement> validate(Advancement advancement) {
diff --git a/src/main/java/net/minecraft/commands/Commands.java b/src/main/java/net/minecraft/commands/Commands.java
index 64bf4444ffba25cb40743a32267aa790ad1738f9..6382cb34d77ce66dbe5301998124cbe51a3e6c63 100644
--- a/src/main/java/net/minecraft/commands/Commands.java
+++ b/src/main/java/net/minecraft/commands/Commands.java
@@ -515,6 +515,7 @@ public class Commands {
     private void runSync(ServerPlayer player, Collection<String> bukkit, RootCommandNode<SharedSuggestionProvider> rootcommandnode) {
         // Paper end - Perf: Async command map building
         new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) rootcommandnode, true).callEvent(); // Paper - Brigadier API
+        if (PlayerCommandSendEvent.getHandlerList().getRegisteredListeners().length > 0) { // Gale - Purpur - skip PlayerCommandSendEvent if there are no listeners
         PlayerCommandSendEvent event = new PlayerCommandSendEvent(player.getBukkitEntity(), new LinkedHashSet<>(bukkit));
         event.getPlayer().getServer().getPluginManager().callEvent(event);
 
@@ -525,6 +526,7 @@ public class Commands {
             }
         }
         // CraftBukkit end
+        } // Gale - Purpur - skip PlayerCommandSendEvent if there are no listeners
         player.connection.send(new ClientboundCommandsPacket(rootcommandnode));
     }
 
diff --git a/src/main/java/net/minecraft/commands/execution/tasks/BuildContexts.java b/src/main/java/net/minecraft/commands/execution/tasks/BuildContexts.java
index b0d26b0eadb2a43924629424a6c13198aace8f69..e8b8c453a7ff7af0a60ae915cfd85aba313139c9 100644
--- a/src/main/java/net/minecraft/commands/execution/tasks/BuildContexts.java
+++ b/src/main/java/net/minecraft/commands/execution/tasks/BuildContexts.java
@@ -52,7 +52,7 @@ public class BuildContexts<T extends ExecutionCommandSource<T>> {
                     }
 
                     RedirectModifier<T> redirectModifier = commandContext.getRedirectModifier();
-                    if (redirectModifier instanceof CustomModifierExecutor<T> customModifierExecutor) {
+                    if (redirectModifier instanceof CustomModifierExecutor.ModifierAdapter<T> customModifierExecutor) { // Gale - dev import deobfuscation fixes
                         customModifierExecutor.apply(baseSource, list, contextChain, chainModifiers, ExecutionControl.create(context, frame));
                         return;
                     }
@@ -92,11 +92,11 @@ public class BuildContexts<T extends ExecutionCommandSource<T>> {
 
         if (list.isEmpty()) {
             if (chainModifiers.isReturn()) {
-                context.queueNext(new CommandQueueEntry<>(frame, FallthroughTask.instance()));
+                context.queueNext(new CommandQueueEntry<T>(frame, FallthroughTask.instance())); // Gale - dev import deobfuscation fixes
             }
         } else {
             CommandContext<T> commandContext2 = contextChain.getTopContext();
-            if (commandContext2.getCommand() instanceof CustomCommandExecutor<T> customCommandExecutor) {
+            if (commandContext2.getCommand() instanceof CustomCommandExecutor.CommandAdapter<T> customCommandExecutor) { // Gale - dev import deobfuscation fixes
                 ExecutionControl<T> executionControl = ExecutionControl.create(context, frame);
 
                 for (T executionCommandSource2 : list) {
diff --git a/src/main/java/net/minecraft/network/VarInt.java b/src/main/java/net/minecraft/network/VarInt.java
index 74ed47659d3e615c2dae7da98d5a8cf1559625bf..82a8354b5ce503508716af3966b9809a6b4d956c 100644
--- a/src/main/java/net/minecraft/network/VarInt.java
+++ b/src/main/java/net/minecraft/network/VarInt.java
@@ -51,6 +51,41 @@ public class VarInt {
     }
 
     public static ByteBuf write(ByteBuf buf, int i) {
+        // Gale start - Velocity - optimized VarInt#write
+        if ((i & 0xFFFFFF80) == 0) {
+            buf.writeByte(i);
+        } else if ((i & 0xFFFFC000) == 0) {
+            int w = (i & 0x7F) << 8
+                | (i >>> 7)
+                | 0x00008000;
+            buf.writeShort(w);
+        } else if ((i & 0xFFE00000) == 0) {
+            int w = (i & 0x7F) << 16
+                | (i & 0x3F80) << 1
+                | (i >>> 14)
+                | 0x00808000;
+            buf.writeMedium(w);
+        } else if ((i & 0xF0000000) == 0) {
+            int w = (i & 0x7F) << 24
+                | ((i & 0x3F80) << 9)
+                | (i & 0x1FC000) >> 6
+                | (i >>> 21)
+                | 0x80808000;
+            buf.writeInt(w);
+        } else {
+            int w = (i & 0x7F) << 24
+                | (i & 0x3F80) << 9
+                | (i & 0x1FC000) >> 6
+                | ((i >>> 21) & 0x7F)
+                | 0x80808080;
+            buf.writeInt(w);
+            buf.writeByte(i >>> 28);
+        }
+        return buf;
+    }
+
+    static ByteBuf writeOld(ByteBuf buf, int i) { // public -> package-private
+        // Gale end - Velocity - optimized VarInt#write
      // Paper start - Optimize VarInts
         // Peel the one and two byte count cases explicitly as they are the most common VarInt sizes
         // that the proxy will write, to improve inlining.
@@ -60,11 +95,11 @@ public class VarInt {
             int w = (i & 0x7F | 0x80) << 8 | (i >>> 7);
             buf.writeShort(w);
         } else {
-            writeOld(buf, i);
+            writeOld2(buf, i); // rename
         }
         return buf;
     }
-    public static ByteBuf writeOld(ByteBuf buf, int i) {
+    public static ByteBuf writeOld2(ByteBuf buf, int i) { // rename
     // Paper end - Optimize VarInts
         while ((i & -128) != 0) {
             buf.writeByte(i & 127 | 128);
diff --git a/src/main/java/net/minecraft/network/VarLong.java b/src/main/java/net/minecraft/network/VarLong.java
index c4fd722f4203e3f4de7b41de9d6ef47b5cfaed10..c127dd051572177e4fc379bb7e2d40571d0abeed 100644
--- a/src/main/java/net/minecraft/network/VarLong.java
+++ b/src/main/java/net/minecraft/network/VarLong.java
@@ -9,6 +9,18 @@ public class VarLong {
     private static final int DATA_BITS_PER_BYTE = 7;
 
     public static int getByteSize(long l) {
+        // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+        return VARLONG_EXACT_BYTE_LENGTHS[Long.numberOfLeadingZeros(l)];
+    }
+    private static final int[] VARLONG_EXACT_BYTE_LENGTHS = new int[65];
+    static {
+        for (int i = 0; i < 64; ++i) {
+            VARLONG_EXACT_BYTE_LENGTHS[i] = (int) Math.ceil((63d - (i - 1)) / 7d);
+        }
+        VARLONG_EXACT_BYTE_LENGTHS[64] = 1; // Special case for the number 0
+    }
+    static int getByteSizeOld(long l) { // public -> package-private
+        // Gale end - Velocity - pre-compute VarInt and VarLong sizes
         for (int i = 1; i < 10; i++) {
             if ((l & -1L << i * 7) == 0L) {
                 return i;
@@ -39,6 +51,127 @@ public class VarLong {
     }
 
     public static ByteBuf write(ByteBuf buf, long l) {
+        // Gale start - Velocity - optimized VarLong#write
+        if ((l & 0xFFFFFFFFFFFFFF80L) == 0) {
+            buf.writeByte((int) l);
+        } else if (l < 0) {
+            // The case of writing arbitrary longs is common
+            // Here, the number is negative, which has probability 1/2 for arbitrary numbers
+            int least7bits = (int) (l & 0xFFFFFFFL);
+            int w = (least7bits & 0x7F) << 24
+                | (least7bits & 0x3F80) << 9
+                | (least7bits & 0x1FC000) >> 6
+                | ((least7bits >>> 21) & 0x7F)
+                | 0x80808080;
+            long nonLeast7Bits = l >>> 28;
+            int secondLeast7bits = (int) (nonLeast7Bits & 0xFFFFFFFL);
+            int w2 = (secondLeast7bits & 0x7F) << 24
+                | ((secondLeast7bits & 0x3F80) << 9)
+                | (secondLeast7bits & 0x1FC000) >> 6
+                | (secondLeast7bits >>> 21)
+                | 0x80808080;
+            int thirdLeast7Bits = (int) (nonLeast7Bits >>> 28);
+            int w3 = (thirdLeast7Bits & 0x7F) << 8
+                | (thirdLeast7Bits >>> 7)
+                | 0x00008000;
+            buf.writeInt(w);
+            buf.writeInt(w2);
+            buf.writeShort(w3);
+        } else if ((l & 0xFFFFFFFFFFFFC000L) == 0) {
+            int least7bits = (int) l;
+            int w = (least7bits & 0x7F) << 8
+                | (least7bits >>> 7)
+                | 0x00008000;
+            buf.writeShort(w);
+        } else if ((l & 0xFFFFFFFFFFE00000L) == 0) {
+            int least7bits = (int) l;
+            int w = (least7bits & 0x7F) << 16
+                | (least7bits & 0x3F80) << 1
+                | (least7bits >>> 14)
+                | 0x00808000;
+            buf.writeMedium(w);
+        } else if ((l & 0xFFFFFFFFF0000000L) == 0) {
+            int least7bits = (int) l;
+            int w = (least7bits & 0x7F) << 24
+                | ((least7bits & 0x3F80) << 9)
+                | (least7bits & 0x1FC000) >> 6
+                | (least7bits >>> 21)
+                | 0x80808000;
+            buf.writeInt(w);
+        } else if ((l & 0xFFFFFFF800000000L) == 0) {
+            int least7bits = (int) (l & 0xFFFFFFFL);
+            int w = (least7bits & 0x7F) << 24
+                | (least7bits & 0x3F80) << 9
+                | (least7bits & 0x1FC000) >> 6
+                | ((least7bits >>> 21) & 0x7F)
+                | 0x80808080;
+            buf.writeInt(w);
+            buf.writeByte((int) (l >>> 28));
+        } else if ((l & 0xFFFFFC0000000000L) == 0) {
+            int least7bits = (int) (l & 0xFFFFFFFL);
+            int w = (least7bits & 0x7F) << 24
+                | (least7bits & 0x3F80) << 9
+                | (least7bits & 0x1FC000) >> 6
+                | ((least7bits >>> 21) & 0x7F)
+                | 0x80808080;
+            int secondLeast7bits = (int) (l >>> 28);
+            int w2 = (secondLeast7bits & 0x7F) << 8
+                | (secondLeast7bits >>> 7)
+                | 0x00008000;
+            buf.writeInt(w);
+            buf.writeShort(w2);
+        } else if ((l & 0xFFFE000000000000L) == 0) {
+            int least7bits = (int) (l & 0xFFFFFFFL);
+            int w = (least7bits & 0x7F) << 24
+                | (least7bits & 0x3F80) << 9
+                | (least7bits & 0x1FC000) >> 6
+                | ((least7bits >>> 21) & 0x7F)
+                | 0x80808080;
+            int secondLeast7bits = (int) (l >>> 28);
+            int w2 = (secondLeast7bits & 0x7F) << 16
+                | (secondLeast7bits & 0x3F80) << 1
+                | (secondLeast7bits >>> 14)
+                | 0x00808000;
+            buf.writeInt(w);
+            buf.writeMedium(w2);
+        } else if ((l & 0xFF00000000000000L) == 0) {
+            int least7bits = (int) (l & 0xFFFFFFFL);
+            int w = (least7bits & 0x7F) << 24
+                | (least7bits & 0x3F80) << 9
+                | (least7bits & 0x1FC000) >> 6
+                | ((least7bits >>> 21) & 0x7F)
+                | 0x80808080;
+            int secondLeast7bits = (int) (l >>> 28);
+            int w2 = (secondLeast7bits & 0x7F) << 24
+                | ((secondLeast7bits & 0x3F80) << 9)
+                | (secondLeast7bits & 0x1FC000) >> 6
+                | (secondLeast7bits >>> 21)
+                | 0x80808000;
+            buf.writeInt(w);
+            buf.writeInt(w2);
+        } else {
+            int least7bits = (int) (l & 0xFFFFFFFL);
+            int w = (least7bits & 0x7F) << 24
+                | (least7bits & 0x3F80) << 9
+                | (least7bits & 0x1FC000) >> 6
+                | ((least7bits >>> 21) & 0x7F)
+                | 0x80808080;
+            long nonLeast7Bits = l >>> 28;
+            int secondLeast7bits = (int) (nonLeast7Bits & 0xFFFFFFFL);
+            int w2 = (secondLeast7bits & 0x7F) << 24
+                | ((secondLeast7bits & 0x3F80) << 9)
+                | (secondLeast7bits & 0x1FC000) >> 6
+                | (secondLeast7bits >>> 21)
+                | 0x80808080;
+            buf.writeInt(w);
+            buf.writeInt(w2);
+            buf.writeByte((int) (nonLeast7Bits >>> 28));
+        }
+        return buf;
+    }
+
+    static ByteBuf writeOld(ByteBuf buf, long l) { // public -> package-private
+        // Gale end - Velocity - optimized VarLong#write
         while ((l & -128L) != 0L) {
             buf.writeByte((int)(l & 127L) | 128);
             l >>>= 7;
diff --git a/src/main/java/net/minecraft/network/chat/SignedMessageChain.java b/src/main/java/net/minecraft/network/chat/SignedMessageChain.java
index 300929a406905f5ff1ede664d5b99fb0938d4d2e..68efb80b1580dde0097eae72365f0260190c53cb 100644
--- a/src/main/java/net/minecraft/network/chat/SignedMessageChain.java
+++ b/src/main/java/net/minecraft/network/chat/SignedMessageChain.java
@@ -45,7 +45,7 @@ public class SignedMessageChain {
                     SignedMessageLink signedMessageLink = SignedMessageChain.this.nextLink;
                     if (signedMessageLink == null) {
                         throw new SignedMessageChain.DecodeException(SignedMessageChain.DecodeException.CHAIN_BROKEN);
-                    } else if (body.timeStamp().isBefore(SignedMessageChain.this.lastTimeStamp)) {
+                    } else if (body.timeStamp().isBefore(SignedMessageChain.this.lastTimeStamp) && org.galemc.gale.configuration.GaleGlobalConfiguration.get().misc.verifyChatOrder) { // Gale - Pufferfish - make chat order verification configurable
                         this.setChainBroken();
                         throw new SignedMessageChain.DecodeException(SignedMessageChain.DecodeException.OUT_OF_ORDER_CHAT, org.bukkit.event.player.PlayerKickEvent.Cause.OUT_OF_ORDER_CHAT); // Paper - kick event causes
                     } else {
@@ -56,7 +56,7 @@ public class SignedMessageChain {
                             throw new SignedMessageChain.DecodeException(SignedMessageChain.DecodeException.INVALID_SIGNATURE);
                         } else {
                             if (playerChatMessage.hasExpiredServer(Instant.now())) {
-                                SignedMessageChain.LOGGER.warn("Received expired chat: '{}'. Is the client/server system time unsynchronized?", body.content());
+                                if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.chat.expiredMessageWarning) SignedMessageChain.LOGGER.warn("Received expired chat: '{}'. Is the client/server system time unsynchronized?", body.content()); // Gale - do not log expired message warnings
                             }
 
                             SignedMessageChain.this.nextLink = signedMessageLink.advance();
diff --git a/src/main/java/net/minecraft/server/Eula.java b/src/main/java/net/minecraft/server/Eula.java
index 4f12ee62a381f87419c72f12a7c155a7b403d207..f8d6f9b165929961d23bc18a6044973405c1d633 100644
--- a/src/main/java/net/minecraft/server/Eula.java
+++ b/src/main/java/net/minecraft/server/Eula.java
@@ -17,13 +17,30 @@ public class Eula {
 
     public Eula(Path eulaFile) {
         this.file = eulaFile;
-        this.agreed = SharedConstants.IS_RUNNING_IN_IDE || this.readFile();
+        this.agreed = SharedConstants.IS_RUNNING_IN_IDE || this.readGlobalFile() || this.readFile(); // Gale - YAPFA - global EULA file
     }
 
     private boolean readFile() {
+        // Gale start - YAPFA - global EULA file
+        return readFile(this.file);
+    }
+
+    private boolean readGlobalFile() {
+        try {
+            Path globalFile = Path.of(System.getProperty("user.home"), "eula.txt");
+            if (globalFile.toFile().exists()) {
+                return readFile(globalFile);
+            }
+        } catch (Throwable ignored) {
+        }
+        return false;
+    }
+
+    private boolean readFile(Path file) {
+        // Gale end - YAPFA - global EULA file
         try {
             boolean var3;
-            try (InputStream inputStream = Files.newInputStream(this.file)) {
+            try (InputStream inputStream = Files.newInputStream(file)) { // Gale - YAPFA - global EULA file
                 Properties properties = new Properties();
                 properties.load(inputStream);
                 var3 = Boolean.parseBoolean(properties.getProperty("eula", "false"));
@@ -31,8 +48,10 @@ public class Eula {
 
             return var3;
         } catch (Exception var6) {
+            if (file == this.file) { // Gale - YAPFA - global EULA file
             LOGGER.warn("Failed to load {}", this.file);
             this.saveDefaults();
+            } // Gale - YAPFA - global EULA file
             return false;
         }
     }
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index ae4ebf509837e8d44255781c61d02873f8b74be8..f6e1d4acac7f967f71ec33203e86e9c3be7e3f1d 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -206,6 +206,8 @@ import org.bukkit.event.server.ServerLoadEvent;
 
 public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTask> implements ServerInfo, ChunkIOErrorReporter, CommandSource, ca.spottedleaf.moonrise.patches.chunk_system.server.ChunkSystemMinecraftServer { // Paper - rewrite chunk system
 
+    public static final int SERVER_THREAD_PRIORITY = Integer.getInteger("gale.thread.priority.server", -1); // Gale - server thread priority environment variable
+
     private static MinecraftServer SERVER; // Paper
     public static final Logger LOGGER = LogUtils.getLogger();
     public static final net.kyori.adventure.text.logger.slf4j.ComponentLogger COMPONENT_LOGGER = net.kyori.adventure.text.logger.slf4j.ComponentLogger.logger(LOGGER.getName()); // Paper
@@ -327,6 +329,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public final double[] recentTps = new double[ 3 ];
     // Spigot end
     public final io.papermc.paper.configuration.PaperConfigurations paperConfigurations; // Paper - add paper configuration files
+    public final org.galemc.gale.configuration.GaleConfigurations galeConfigurations; // Gale - Gale configuration
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
     private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
 
@@ -352,6 +355,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         S s0 = serverFactory.apply(thread); // CraftBukkit - decompile error
 
         atomicreference.set(s0);
+        // Gale start - server thread priority environment variable
+        if (SERVER_THREAD_PRIORITY > 0) {
+            thread.setPriority(SERVER_THREAD_PRIORITY);
+        }
+        // Gale end - server thread priority environment variable
         thread.start();
         return s0;
     }
@@ -512,6 +520,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
         // CraftBukkit end
         this.paperConfigurations = services.paperConfigurations(); // Paper - add paper configuration files
+        this.galeConfigurations = services.galeConfigurations(); // Gale - Gale configuration
     }
 
     private void readScoreboard(DimensionDataStorage persistentStateManager) {
@@ -1183,6 +1192,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
     private long lastTick = 0;
     private long catchupTime = 0;
+    public final RollingAverage tps5s = new RollingAverage(5); // Gale - Purpur - 5 second TPS average
     public final RollingAverage tps1 = new RollingAverage(60);
     public final RollingAverage tps5 = new RollingAverage(60 * 5);
     public final RollingAverage tps15 = new RollingAverage(60 * 15);
@@ -1230,6 +1240,11 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     // Paper end
     // Spigot End
 
+    // Gale start - YAPFA - last tick time
+    public static long lastTickProperTime;
+    public static long lastTickOversleepTime;
+    // Gale end - YAPFA - last tick time
+
     protected void runServer() {
         try {
             long serverStartTime = Util.getNanos(); // Paper
@@ -1296,6 +1311,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 if (++MinecraftServer.currentTick % MinecraftServer.SAMPLE_INTERVAL == 0) {
                     final long diff = currentTime - tickSection;
                     final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                    tps5s.add(currentTps, diff); // Gale - Purpur - 5 second TPS average
                     tps1.add(currentTps, diff);
                     tps5.add(currentTps, diff);
                     tps15.add(currentTps, diff);
@@ -1319,6 +1335,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 //MinecraftServer.currentTick = (int) (System.currentTimeMillis() / 50); // CraftBukkit // Paper - don't overwrite current tick time
                 lastTick = currentTime;
                 this.nextTickTimeNanos += i;
+                long tickProperStart = System.nanoTime(); // Gale - YAPFA - last tick time
 
                 try {
                     Profiler.Scope profiler_a = Profiler.use(this.createProfiler());
@@ -1331,6 +1348,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                         this.tickServer(flag ? () -> {
                             return false;
                         } : this::haveTime);
+                        lastTickProperTime = (System.nanoTime() - tickProperStart) / 1000000L; // Gale - YAPFA - last tick time
                         // Paper start - rewrite chunk system
                         final Throwable crash = this.chunkSystemCrash;
                         if (crash != null) {
@@ -1506,6 +1524,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.runAllTasks();
         this.waitingForNextTick = true;
 
+        long tickOversleepStart = System.nanoTime(); // Gale - YAPFA - last tick time
         try {
             this.managedBlock(() -> {
                 return !this.haveTime();
@@ -1513,6 +1532,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         } finally {
             this.waitingForNextTick = false;
         }
+        lastTickOversleepTime = (System.nanoTime() - tickOversleepStart) / 1000000L; // Gale - YAPFA - last tick time
 
     }
 
diff --git a/src/main/java/net/minecraft/server/PlayerAdvancements.java b/src/main/java/net/minecraft/server/PlayerAdvancements.java
index 8e2eb7b61421ceb063654826941f1a81f6f50bdf..66e7fa8a01d5364f7a82ed36f41edc6735b0b5ef 100644
--- a/src/main/java/net/minecraft/server/PlayerAdvancements.java
+++ b/src/main/java/net/minecraft/server/PlayerAdvancements.java
@@ -199,7 +199,7 @@ public class PlayerAdvancements {
 
             if (advancementholder == null) {
                 if (!minecraftkey.getNamespace().equals("minecraft")) return; // CraftBukkit
-                PlayerAdvancements.LOGGER.warn("Ignored advancement '{}' in progress file {} - it doesn't exist anymore?", minecraftkey, this.playerSavePath);
+                if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.ignoredAdvancements) PlayerAdvancements.LOGGER.warn("Ignored advancement '{}' in progress file {} - it doesn't exist anymore?", minecraftkey, this.playerSavePath); // Gale - Purpur - do not log ignored advancements
             } else {
                 this.startProgress(advancementholder, advancementprogress);
                 this.progressChanged.add(advancementholder);
diff --git a/src/main/java/net/minecraft/server/Services.java b/src/main/java/net/minecraft/server/Services.java
index 33e3815a0c979609d4c7ab83ad91e87ac07a556d..a79aca2677527e86d66383887fe3a787c25bab1d 100644
--- a/src/main/java/net/minecraft/server/Services.java
+++ b/src/main/java/net/minecraft/server/Services.java
@@ -12,11 +12,11 @@ import net.minecraft.util.SignatureValidator;
 
 
 public record Services(
-    MinecraftSessionService sessionService, ServicesKeySet servicesKeySet, GameProfileRepository profileRepository, GameProfileCache profileCache, @javax.annotation.Nullable io.papermc.paper.configuration.PaperConfigurations paperConfigurations // Paper - add paper configuration files
+    MinecraftSessionService sessionService, ServicesKeySet servicesKeySet, GameProfileRepository profileRepository, GameProfileCache profileCache, @javax.annotation.Nullable io.papermc.paper.configuration.PaperConfigurations paperConfigurations, @javax.annotation.Nullable org.galemc.gale.configuration.GaleConfigurations galeConfigurations // Paper - add paper configuration files // Gale - Gale configuration
 ) {
     // Paper start - add paper configuration files
     public Services(MinecraftSessionService sessionService, ServicesKeySet servicesKeySet, GameProfileRepository profileRepository, GameProfileCache profileCache) {
-        this(sessionService, servicesKeySet, profileRepository, profileCache, null);
+        this(sessionService, servicesKeySet, profileRepository, profileCache, null, null); // Gale - Gale configuration
     }
 
     @Override
@@ -24,6 +24,11 @@ public record Services(
         return java.util.Objects.requireNonNull(this.paperConfigurations);
     }
     // Paper end - add paper configuration files
+    // Gale start - Gale configuration
+    public org.galemc.gale.configuration.GaleConfigurations galeConfigurations() {
+        return java.util.Objects.requireNonNull(this.galeConfigurations);
+    }
+    // Gale end - Gale configuration
     public static final String USERID_CACHE_FILE = "usercache.json"; // Paper - private -> public
 
     public static Services create(YggdrasilAuthenticationService authenticationService, File rootDirectory, File userCacheFile, joptsimple.OptionSet optionSet) throws Exception { // Paper - add optionset to load paper config files; add userCacheFile parameter
@@ -34,7 +39,10 @@ public record Services(
         final java.nio.file.Path legacyConfigPath = ((File) optionSet.valueOf("paper-settings")).toPath();
         final java.nio.file.Path configDirPath = ((File) optionSet.valueOf("paper-settings-directory")).toPath();
         io.papermc.paper.configuration.PaperConfigurations paperConfigurations = io.papermc.paper.configuration.PaperConfigurations.setup(legacyConfigPath, configDirPath, rootDirectory.toPath(), (File) optionSet.valueOf("spigot-settings"));
-        return new Services(minecraftSessionService, authenticationService.getServicesKeySet(), gameProfileRepository, gameProfileCache, paperConfigurations);
+        // Gale start - Gale configuration
+        org.galemc.gale.configuration.GaleConfigurations galeConfigurations = org.galemc.gale.configuration.GaleConfigurations.setup(configDirPath);
+        return new Services(minecraftSessionService, authenticationService.getServicesKeySet(), gameProfileRepository, gameProfileCache, paperConfigurations, galeConfigurations);
+        // Gale end - Gale configuration
         // Paper end - load paper config files from cli options
     }
 
diff --git a/src/main/java/net/minecraft/server/commands/SpreadPlayersCommand.java b/src/main/java/net/minecraft/server/commands/SpreadPlayersCommand.java
index 6f69e74d8662025c4148b36de7a35e789abcd1d2..8c18763ff74a6fbc87eafa1170c4ad9d5f1de22f 100644
--- a/src/main/java/net/minecraft/server/commands/SpreadPlayersCommand.java
+++ b/src/main/java/net/minecraft/server/commands/SpreadPlayersCommand.java
@@ -66,7 +66,7 @@ public class SpreadPlayersCommand {
         if (maxY < j) {
             throw SpreadPlayersCommand.ERROR_INVALID_MAX_HEIGHT.create(maxY, j);
         } else {
-            RandomSource randomsource = RandomSource.create();
+            RandomSource randomsource = source.getLevel().random; // Gale - Patina - reduce RandomSource instances
             double d0 = (double) (center.x - maxRange);
             double d1 = (double) (center.y - maxRange);
             double d2 = (double) (center.x + maxRange);
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index 17a158ff6ce6520b69a5a0032ba4c05449dd0cf8..19a8670004e5e6391c9fe16d491446e72029e1b8 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -194,7 +194,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         }
 
         // Paper start - detect running as root
-        if (io.papermc.paper.util.ServerEnvironment.userIsRootOrAdmin()) {
+        if (!"false".equalsIgnoreCase(System.getProperty("gale.log.warning.root")) && io.papermc.paper.util.ServerEnvironment.userIsRootOrAdmin()) { // Gale - KeYi - do not log run as root warning
             DedicatedServer.LOGGER.warn("****************************");
             DedicatedServer.LOGGER.warn("YOU ARE RUNNING THIS SERVER AS AN ADMINISTRATIVE OR ROOT USER. THIS IS NOT ADVISED.");
             DedicatedServer.LOGGER.warn("YOU ARE OPENING YOURSELF UP TO POTENTIAL RISKS WHEN DOING THIS.");
@@ -223,6 +223,10 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         this.paperConfigurations.initializeGlobalConfiguration(this.registryAccess());
         this.paperConfigurations.initializeWorldDefaultsConfiguration(this.registryAccess());
         // Paper end - initialize global and world-defaults configuration
+        // Gale start - Gale configuration
+        galeConfigurations.initializeGlobalConfiguration(this.registryAccess());
+        galeConfigurations.initializeWorldDefaultsConfiguration(this.registryAccess());
+        // Gale end - Gale configuration
         this.server.spark.enableEarlyIfRequested(); // Paper - spark
         // Paper start - fix converting txt to json file; convert old users earlier after PlayerList creation but before file load/save
         if (this.convertOldUsers()) {
@@ -233,6 +237,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         org.spigotmc.WatchdogThread.doStart(org.spigotmc.SpigotConfig.timeoutTime, org.spigotmc.SpigotConfig.restartOnCrash); // Paper - start watchdog thread
         thread.start(); // Paper - Enhance console tab completions for brigadier commands; start console thread after MinecraftServer.console & PaperConfig are initialized
         io.papermc.paper.command.PaperCommands.registerCommands(this); // Paper - setup /paper command
+        org.galemc.gale.command.GaleCommands.registerCommands(this); // Gale - Gale commands - register commands
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
@@ -295,7 +300,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         String proxyFlavor = (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.velocity.enabled) ? "Velocity" : "BungeeCord";
         String proxyLink = (io.papermc.paper.configuration.GlobalConfiguration.get().proxies.velocity.enabled) ? "https://docs.papermc.io/velocity/security" : "http://www.spigotmc.org/wiki/firewall-guide/";
         // Paper end - Add Velocity IP Forwarding Support
-        if (!this.usesAuthentication()) {
+        if (!"false".equalsIgnoreCase(System.getProperty("gale.log.warning.offline.mode")) && !this.usesAuthentication()) { // Gale - KeYi - do not log offline mode warning
             DedicatedServer.LOGGER.warn("**** SERVER IS RUNNING IN OFFLINE/INSECURE MODE!");
             DedicatedServer.LOGGER.warn("The server will make no attempt to authenticate usernames. Beware.");
             // Spigot start
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index cfeeddf2cb4ff50dbc29c6913e78ca1dee076790..f3acf31655273fa7061809e98d96b2303c882870 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -186,7 +186,7 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         this.toDrop = new LongOpenHashSet();
         this.tickingGenerated = new AtomicInteger();
         this.playerMap = new PlayerMap();
-        this.entityMap = new Int2ObjectOpenHashMap();
+        this.entityMap = new it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap(); // Gale - VMP - use linked map for entity trackers - provides faster iteration
         this.chunkTypeCache = new Long2ByteOpenHashMap();
         // Paper - rewrite chunk system
         Path path = session.getDimensionPath(world.dimension());
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index 1f898500d0e9b18a880645ceb0a8ff0fe75f4e48..76167ee4b86573659c0ac5c85ac80f888e2bc864 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -598,7 +598,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     // Add env and gen to constructor, IWorldDataServer -> WorldDataServer
     public ServerLevel(MinecraftServer minecraftserver, Executor executor, LevelStorageSource.LevelStorageAccess convertable_conversionsession, PrimaryLevelData iworlddataserver, ResourceKey<Level> resourcekey, LevelStem worlddimension, ChunkProgressListener worldloadlistener, boolean flag, long i, List<CustomSpawner> list, boolean flag1, @Nullable RandomSequences randomsequences, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider) {
-        super(iworlddataserver, resourcekey, minecraftserver.registryAccess(), worlddimension.type(), false, flag, i, minecraftserver.getMaxChainedNeighborUpdates(), gen, biomeProvider, env, spigotConfig -> minecraftserver.paperConfigurations.createWorldConfig(io.papermc.paper.configuration.PaperConfigurations.createWorldContextMap(convertable_conversionsession.levelDirectory.path(), iworlddataserver.getLevelName(), resourcekey.location(), spigotConfig, minecraftserver.registryAccess(), iworlddataserver.getGameRules())), executor); // Paper - create paper world configs; Async-Anti-Xray: Pass executor
+        super(iworlddataserver, resourcekey, minecraftserver.registryAccess(), worlddimension.type(), false, flag, i, minecraftserver.getMaxChainedNeighborUpdates(), gen, biomeProvider, env, spigotConfig -> minecraftserver.paperConfigurations.createWorldConfig(io.papermc.paper.configuration.PaperConfigurations.createWorldContextMap(convertable_conversionsession.levelDirectory.path(), iworlddataserver.getLevelName(), resourcekey.location(), spigotConfig, minecraftserver.registryAccess(), iworlddataserver.getGameRules())), spigotConfig -> minecraftserver.galeConfigurations.createWorldConfig(io.papermc.paper.configuration.PaperConfigurations.createWorldContextMap(convertable_conversionsession.levelDirectory.path(), iworlddataserver.getLevelName(), resourcekey.location(), spigotConfig, minecraftserver.registryAccess(), iworlddataserver.getGameRules())), executor); // Paper - create paper world configs; Async-Anti-Xray: Pass executor // Gale - Gale configuration
         this.pvpMode = minecraftserver.isPvpAllowed();
         this.convertable = convertable_conversionsession;
         this.uuid = WorldUUID.getUUID(convertable_conversionsession.levelDirectory.path().toFile());
@@ -1651,7 +1651,17 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     @Override
     public void destroyBlockProgress(int entityId, BlockPos pos, int progress) {
-        Iterator iterator = this.server.getPlayerList().getPlayers().iterator();
+
+        // Gale start - SportPaper - reduce block destruction packet allocations
+        var players = this.server.getPlayerList().getPlayers();
+        if (players.isEmpty()) {
+            return;
+        }
+
+        ClientboundBlockDestructionPacket packet = new ClientboundBlockDestructionPacket(entityId, pos, progress);
+
+        Iterator iterator = players.iterator();
+        // Gale end - SportPaper - reduce block destruction packet allocations
 
         // CraftBukkit start
         Player entityhuman = null;
@@ -1685,7 +1695,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 // CraftBukkit end
 
                 if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
-                    entityplayer.connection.send(new ClientboundBlockDestructionPacket(entityId, pos, progress));
+                    entityplayer.connection.send(packet); // Gale - SportPaper - reduce block destruction packet allocations
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index fc7f7a34babd095a51b5321f600aef65a2a9d123..c446cabe12c2a3347a976f3d9e41413e8fb45068 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -322,6 +322,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
     public boolean joining = true;
     public boolean sentListPacket = false;
     public boolean supressTrackerForLogin = false; // Paper - Fire PlayerJoinEvent when Player is actually ready
+    public boolean didPlayerJoinEvent = false; // Gale - EMC - do not process chat/commands before player has joined
     // CraftBukkit end
     public boolean isRealPlayer; // Paper
     public com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent playerNaturallySpawnedEvent; // Paper - PlayerNaturallySpawnCreaturesEvent
@@ -523,7 +524,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
             long l = k * k;
             int i1 = l > 2147483647L ? Integer.MAX_VALUE : (int) l;
             int j1 = this.getCoprime(i1);
-            int k1 = RandomSource.create().nextInt(i1);
+            int k1 = worldserver.random.nextInt(i1); // Gale - Patina - reduce RandomSource instances
 
             for (int l1 = 0; l1 < i1; ++l1) {
                 int i2 = (k1 + j1 * l1) % i1;
@@ -562,7 +563,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
             long l = k * k;
             int i1 = l > 2147483647L ? Integer.MAX_VALUE : (int) l;
             int j1 = this.getCoprime(i1);
-            int k1 = RandomSource.create().nextInt(i1);
+            int k1 = world.random.nextInt(i1); // Gale - Patina - reduce RandomSource instances
 
             for (int l1 = 0; l1 < i1; ++l1) {
                 int i2 = (k1 + j1 * l1) % i1;
@@ -2386,12 +2387,18 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
 
     @Override
     public void crit(Entity target) {
-        this.serverLevel().getChunkSource().broadcastAndSend(this, new ClientboundAnimatePacket(target, 4));
+        // Gale start - MultiPaper - broadcast crit animations as the entity being critted
+        var level = this.serverLevel();
+        level.getChunkSource().broadcastAndSend(level.galeConfig().gameplayMechanics.fixes.broadcastCritAnimationsAsTheEntityBeingCritted ? target : this, new ClientboundAnimatePacket(target, 4));
+        // Gale end - MultiPaper - broadcast crit animations as the entity being critted
     }
 
     @Override
     public void magicCrit(Entity target) {
-        this.serverLevel().getChunkSource().broadcastAndSend(this, new ClientboundAnimatePacket(target, 5));
+        // Gale start - MultiPaper - broadcast crit animations as the entity being critted
+        var level = this.serverLevel();
+        level.getChunkSource().broadcastAndSend(level.galeConfig().gameplayMechanics.fixes.broadcastCritAnimationsAsTheEntityBeingCritted ? target : this, new ClientboundAnimatePacket(target, 5));
+        // Gale end - MultiPaper - broadcast crit animations as the entity being critted
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/level/WorldGenRegion.java b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
index e4b0dc3121101d54394a0c3a413dabf8103b2ea6..4212d2522a0619267902c8230d424495378ee743 100644
--- a/src/main/java/net/minecraft/server/level/WorldGenRegion.java
+++ b/src/main/java/net/minecraft/server/level/WorldGenRegion.java
@@ -336,6 +336,7 @@ public class WorldGenRegion implements WorldGenLevel {
             return true;
         } else {
             // Paper start - Buffer OOB setBlock calls
+            if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.setBlockInFarChunk) // Gale - Purpur - do not log setBlock in far chunks
             if (!hasSetFarWarned) {
             Util.logAndPauseIfInIde("Detected setBlock in a far chunk [" + i + ", " + j + "], pos: " + String.valueOf(pos) + ", status: " + String.valueOf(this.generatingStep.targetStatus()) + (this.currentlyGenerating == null ? "" : ", currently generating: " + (String) this.currentlyGenerating.get()));
                 hasSetFarWarned = true;
diff --git a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index b0bc66dc7248aae691dcab68b925b52a1695e63f..ea1134a5c91766c431f00137aa4a0684156b2cc2 100644
--- a/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -80,10 +80,14 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     private long keepAliveChallenge;
     private long closedListenerTime;
     private boolean closed = false;
+    private it.unimi.dsi.fastutil.longs.LongList keepAlives = new it.unimi.dsi.fastutil.longs.LongArrayList(); // Gale - Purpur - send multiple keep-alive packets
     private int latency;
     private volatile boolean suspendFlushingOnServerThread = false;
     public final java.util.Map<java.util.UUID, net.kyori.adventure.resource.ResourcePackCallback> packCallbacks = new java.util.concurrent.ConcurrentHashMap<>(); // Paper - adventure resource pack callbacks
-    private static final long KEEPALIVE_LIMIT = Long.getLong("paper.playerconnection.keepalive", 30) * 1000; // Paper - provide property to set keepalive limit
+    // Gale start - Purpur - send multiple keep-alive packets
+    private static final long KEEPALIVE_LIMIT_IN_SECONDS = Long.getLong("paper.playerconnection.keepalive", 30); // Paper - provide property to set keepalive limit
+    private static final long KEEPALIVE_LIMIT = KEEPALIVE_LIMIT_IN_SECONDS * 1000;
+    // Gale end - Purpur - send multiple keep-alive packets
     protected static final ResourceLocation MINECRAFT_BRAND = ResourceLocation.withDefaultNamespace("brand"); // Paper - Brand support
 
     public ServerCommonPacketListenerImpl(MinecraftServer minecraftserver, Connection networkmanager, CommonListenerCookie commonlistenercookie, ServerPlayer player) { // CraftBukkit
@@ -137,6 +141,16 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     @Override
     public void handleKeepAlive(ServerboundKeepAlivePacket packet) {
         //PacketUtils.ensureRunningOnSameThread(packet, this, this.player.serverLevel()); // CraftBukkit // Paper - handle ServerboundKeepAlivePacket async
+        // Gale start - Purpur - send multiple keep-alive packets
+        if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().misc.keepalive.sendMultiple) {
+            if (this.keepAlivePending && !keepAlives.isEmpty() && keepAlives.contains(packet.getId())) {
+                int ping = (int) (Util.getMillis() - packet.getId());
+                this.latency = (this.latency * 3 + ping) / 4;
+                this.keepAlivePending = false;
+                this.keepAlives.clear(); // We got a valid response, let's roll with it and forget the rest
+            }
+        } else {
+            // Gale end - Purpur - send multiple keep-alive packets
         if (this.keepAlivePending && packet.getId() == this.keepAliveChallenge) {
             int i = (int) (Util.getMillis() - this.keepAliveTime);
 
@@ -145,6 +159,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         } else if (!this.isSingleplayerOwner()) {
             this.disconnectAsync(ServerCommonPacketListenerImpl.TIMEOUT_DISCONNECTION_MESSAGE, PlayerKickEvent.Cause.TIMEOUT); // Paper - add proper async disconnect
         }
+        } // Gale - Purpur - send multiple keep-alive packets
 
     }
 
@@ -261,6 +276,21 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         long currentTime = Util.getMillis();
         long elapsedTime = currentTime - this.keepAliveTime;
 
+        // Gale start - Purpur - send multiple keep-alive packets
+        if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().misc.keepalive.sendMultiple) {
+            if (elapsedTime >= 1000L) { // 1 second
+                if (this.keepAlivePending && !this.processedDisconnect && this.keepAlives.size() >= KEEPALIVE_LIMIT_IN_SECONDS) {
+                    LOGGER.warn("{} was kicked due to keepalive timeout!", this.player.getScoreboardName());
+                    this.disconnect(ServerCommonPacketListenerImpl.TIMEOUT_DISCONNECTION_MESSAGE, org.bukkit.event.player.PlayerKickEvent.Cause.TIMEOUT);
+                } else if (this.checkIfClosed(currentTime)) {
+                    this.keepAlivePending = true;
+                    this.keepAliveTime = currentTime; // hijack this field for 1 second intervals
+                    this.keepAlives.add(currentTime); // currentTime is ID
+                    this.send(new ClientboundKeepAlivePacket(currentTime));
+                }
+            }
+        } else {
+            // Gale end - Purpur - send multiple keep-alive packets
         if (!this.isSingleplayerOwner() && elapsedTime >= 15000L) { // Paper - use vanilla's 15000L between keep alive packets
             if (this.keepAlivePending && !this.processedDisconnect && elapsedTime >= KEEPALIVE_LIMIT) { // Paper - check keepalive limit, don't fire if already disconnected
                 this.disconnect(ServerCommonPacketListenerImpl.TIMEOUT_DISCONNECTION_MESSAGE, PlayerKickEvent.Cause.TIMEOUT); // Paper - kick event cause
@@ -271,6 +301,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
                 this.send(new ClientboundKeepAlivePacket(this.keepAliveChallenge));
             }
         }
+        } // Gale - Purpur - send multiple keep-alive packets
         // Paper end - give clients a longer time to respond to pings as per pre 1.12.2 timings
 
         Profiler.get().pop();
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 84fa24880d02dc7ba1ec8bda3575be38447fd4b2..80ae9b0b14eb0bb38ffe4d7bf1e17ccf3bf0ed35 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1226,6 +1226,11 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     @Override
     public void handleEditBook(ServerboundEditBookPacket packet) {
+        // Gale start - Pufferfish - make book writing configurable
+        if (!(org.galemc.gale.configuration.GaleGlobalConfiguration.get().gameplayMechanics.enableBookWriting || this.player.getBukkitEntity().hasPermission(org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions.writeBooks) || this.player.getBukkitEntity().hasPermission("pufferfish.usebooks"))) {
+            return;
+        }
+        // Gale end - Pufferfish - make book writing configurable
         // Paper start - Book size limits
         final io.papermc.paper.configuration.type.number.IntOr.Disabled pageMax = io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.bookSize.pageMax;
         if (!this.cserver.isPrimaryThread() && pageMax.enabled()) {
@@ -2440,7 +2445,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
             this.disconnectAsync((Component) Component.translatable("multiplayer.disconnect.illegal_characters"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_CHARACTERS); // Paper // Paper - add proper async disconnect
         } else if (this.player.isRemoved() || this.player.getChatVisibility() == ChatVisiblity.HIDDEN) { // CraftBukkit - dead men tell no tales
             this.send(new ClientboundSystemChatPacket(Component.translatable("chat.disabled.options").withStyle(ChatFormatting.RED), false));
-        } else {
+        } else if (player.didPlayerJoinEvent) { // Gale - EMC - do not process chat/commands before player has joined
             this.player.resetLastActionTime();
             // CraftBukkit start
             if (sync) {
@@ -2598,7 +2603,7 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
         // CraftBukkit start
         String s = message.signedContent();
         if (s.isEmpty()) {
-            ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send an empty message");
+            if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.chat.emptyMessageWarning) ServerGamePacketListenerImpl.LOGGER.warn(this.player.getScoreboardName() + " tried to send an empty message"); // Gale - do not log empty message warnings
         } else if (this.getCraftPlayer().isConversing()) {
             final String conversationInput = s;
             this.server.processQueue.add(new Runnable() {
diff --git a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
index ddf42645402afefc0f5caebc684b191eef9d6ec2..a1e39d4476e932da3d4e0c363ce22eb5be2b8e6c 100644
--- a/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerHandshakePacketListenerImpl.java
@@ -26,7 +26,7 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
     static final java.util.regex.Pattern PROP_PATTERN = java.util.regex.Pattern.compile("\\w{0,16}");
     // Spigot end
     // CraftBukkit start - add fields
-    private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
+    private static final it.unimi.dsi.fastutil.objects.Object2LongMap<InetAddress> throttleTracker = new it.unimi.dsi.fastutil.objects.Object2LongOpenHashMap<>(); // Gale - Dionysus - replace throttle tracker map with optimized collection
     private static int throttleCounter = 0;
     // CraftBukkit end
     private static final Component IGNORE_STATUS_REASON = Component.translatable("disconnect.ignoring_status_request");
@@ -87,7 +87,7 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
             InetAddress address = ((java.net.InetSocketAddress) this.connection.getRemoteAddress()).getAddress();
 
             synchronized (ServerHandshakePacketListenerImpl.throttleTracker) {
-                if (ServerHandshakePacketListenerImpl.throttleTracker.containsKey(address) && !"127.0.0.1".equals(address.getHostAddress()) && currentTime - ServerHandshakePacketListenerImpl.throttleTracker.get(address) < connectionThrottle) {
+                        if (ServerHandshakePacketListenerImpl.throttleTracker.containsKey(address) && !"127.0.0.1".equals(address.getHostAddress()) && currentTime - ServerHandshakePacketListenerImpl.throttleTracker.getLong(address) < connectionThrottle) { // Gale - Dionysus - replace throttle tracker map with optimized collection
                     ServerHandshakePacketListenerImpl.throttleTracker.put(address, currentTime);
                             Component chatmessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(io.papermc.paper.configuration.GlobalConfiguration.get().messages.kick.connectionThrottle); // Paper - Configurable connection throttle kick message
                     this.connection.send(new ClientboundLoginDisconnectPacket(chatmessage));
@@ -101,13 +101,7 @@ public class ServerHandshakePacketListenerImpl implements ServerHandshakePacketL
                     ServerHandshakePacketListenerImpl.throttleCounter = 0;
 
                     // Cleanup stale entries
-                    java.util.Iterator iter = ServerHandshakePacketListenerImpl.throttleTracker.entrySet().iterator();
-                    while (iter.hasNext()) {
-                        java.util.Map.Entry<InetAddress, Long> entry = (java.util.Map.Entry) iter.next();
-                        if (entry.getValue() > connectionThrottle) {
-                            iter.remove();
-                        }
-                    }
+                            throttleTracker.object2LongEntrySet().removeIf(entry -> entry.getLongValue() > connectionThrottle); // Gale - Dionysus - replace throttle tracker map with optimized collection
                 }
             }
             } // Paper - Unix domain socket support
diff --git a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 033755682c61c889723c3669b5cff4de147f637e..ae7dbd99c84548acf2058560f275c678969eb317 100644
--- a/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -126,7 +126,10 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
             this.finishLoginAndWaitForClient(this.authenticatedProfile);
         }
 
-        if (this.tick++ == 600) {
+        // Gale start - make slow login timeout configurable
+        int slowLoginTimeout = org.galemc.gale.configuration.GaleGlobalConfiguration.get().misc.premiumAccountSlowLoginTimeout;
+        if (this.tick++ >= (slowLoginTimeout < 1 ? MAX_TICKS_BEFORE_LOGIN : slowLoginTimeout)) {
+            // Gale end - make slow login timeout configurable
             this.disconnect(Component.translatable("multiplayer.disconnect.slow_login"));
         }
 
@@ -146,6 +149,14 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
 
     public void disconnect(Component reason) {
         try {
+            // Gale start - Pufferfish - do not log disconnections with null id
+            if (!org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.nullIdDisconnections && this.authenticatedProfile != null && this.authenticatedProfile.getId() == null) {
+                var reasonString = reason.getString();
+                if ("Disconnected".equals(reasonString) || Component.translatable("multiplayer.disconnect.generic").getString().equals(reasonString)) {
+                    return;
+                }
+            }
+            // Gale end - Pufferfish - do not log disconnections with null id
             ServerLoginPacketListenerImpl.LOGGER.info("Disconnecting {}: {}", this.getUserName(), reason.getString());
             this.connection.send(new ClientboundLoginDisconnectPacket(reason));
             this.connection.disconnect(reason);
diff --git a/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
index 532f09089b8d6798999cf3f83e852df7479e450e..ae31c667ece5a84772d9c9009d3e66fd37d38908 100644
--- a/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
@@ -154,6 +154,10 @@ public class ServerStatusPacketListenerImpl implements ServerStatusPacketListene
             this.connection.send(new ClientboundStatusResponsePacket(ping));
             // CraftBukkit end
             */
+            // Gale start - Purpur - fix 'outdated server' showing in ping before server fully boots - do not respond to pings before we know the protocol version
+            var version = MinecraftServer.getServer().getStatus().version();
+            if (version == null || version.isEmpty()) return;
+            // Gale end - Purpur - fix 'outdated server' showing in ping before server fully boots - do not respond to pings before we know the protocol version
             com.destroystokyo.paper.network.StandardPaperServerListPingEventImpl.processRequest(MinecraftServer.getServer(), this.connection);
             // Paper end
         }
diff --git a/src/main/java/net/minecraft/server/players/PlayerList.java b/src/main/java/net/minecraft/server/players/PlayerList.java
index 9b71655a425356132afb786eff623f558e1e3498..2f0f7a2a866d4cf1054a48a8949c471fb517b6c5 100644
--- a/src/main/java/net/minecraft/server/players/PlayerList.java
+++ b/src/main/java/net/minecraft/server/players/PlayerList.java
@@ -133,10 +133,11 @@ public abstract class PlayerList {
     public static final Component CHAT_FILTERED_FULL = Component.translatable("chat.filtered_full");
     public static final Component DUPLICATE_LOGIN_DISCONNECT_MESSAGE = Component.translatable("multiplayer.disconnect.duplicate_login");
     private static final Logger LOGGER = LogUtils.getLogger();
-    private static final int SEND_PLAYER_INFO_INTERVAL = 600;
+    public static final int SEND_PLAYER_INFO_INTERVAL = 600; // Gale - Purpur - spread out sending all player info - private -> public
     private static final SimpleDateFormat BAN_DATE_FORMAT = new SimpleDateFormat("yyyy-MM-dd 'at' HH:mm:ss z");
     private final MinecraftServer server;
     public final List<ServerPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    private final ServerPlayer[][] sendAllPlayerInfoBuckets = new ServerPlayer[SEND_PLAYER_INFO_INTERVAL][]; // Gale - Purpur - spread out sending all player info
     private final Map<UUID, ServerPlayer> playersByUUID = Maps.newHashMap();
     private final UserBanList bans;
     private final IpBanList ipBans;
@@ -271,6 +272,13 @@ public abstract class PlayerList {
         org.spigotmc.event.player.PlayerSpawnLocationEvent ev = new org.spigotmc.event.player.PlayerSpawnLocationEvent(spawnPlayer, spawnPlayer.getLocation());
         this.cserver.getPluginManager().callEvent(ev);
 
+        // Gale start - MultiPaper - do not place player in world if kicked before being spawned in
+        if (!connection.isConnected() || player.quitReason != null) {
+            /*pendingPlayers.remove(player.getUUID(), player);*/ // Gale - MultiPaper - do not place player in world if kicked before being spawned in - this patch was removed from Paper but might be useful later
+            return;
+        }
+        // Gale end - MultiPaper - do not place player in world if kicked before being spawned in
+
         Location loc = ev.getSpawnLocation();
         worldserver1 = ((CraftWorld) loc.getWorld()).getHandle();
 
@@ -329,6 +337,7 @@ public abstract class PlayerList {
 
         // entityplayer.connection.send(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(this.players)); // CraftBukkit - replaced with loop below
         this.players.add(player);
+        this.addToSendAllPlayerInfoBuckets(player); // Gale - Purpur - spread out sending all player info
         this.playersByName.put(player.getScoreboardName().toLowerCase(java.util.Locale.ROOT), player); // Spigot
         this.playersByUUID.put(player.getUUID(), player);
         // this.broadcastAll(ClientboundPlayerInfoUpdatePacket.createPlayerInitializing(List.of(entityplayer))); // CraftBukkit - replaced with loop below
@@ -353,6 +362,8 @@ public abstract class PlayerList {
             return;
         }
 
+        player.didPlayerJoinEvent = true; // Gale - EMC - do not process chat/commands before player has joined
+
         final net.kyori.adventure.text.Component jm = playerJoinEvent.joinMessage();
 
         if (jm != null && !jm.equals(net.kyori.adventure.text.Component.empty())) { // Paper - Adventure
@@ -419,7 +430,13 @@ public abstract class PlayerList {
             scoreboard.addPlayerToTeam(player.getScoreboardName(), collideRuleTeam);
         }
         // Paper end - Configurable player collision
+        if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.playerLoginLocations) { // Gale - JettPack - make logging login location configurable
         PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), s1, player.getId(), worldserver1.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
+            // Gale start - JettPack - make logging login location configurable
+        } else {
+            PlayerList.LOGGER.info("{}[{}] logged in with entity id {}", player.getName().getString(), s1, player.getId());
+        }
+        // Gale end - JettPack - make logging login location configurable
         // Paper start - Send empty chunk, so players aren't stuck in the world loading screen with our chunk system not sending chunks when dead
         if (player.isDeadOrDying()) {
             net.minecraft.core.Holder<net.minecraft.world.level.biome.Biome> plains = worldserver1.registryAccess().lookupOrThrow(net.minecraft.core.registries.Registries.BIOME)
@@ -615,6 +632,7 @@ public abstract class PlayerList {
         entityplayer.retireScheduler(); // Paper - Folia schedulers
         entityplayer.getAdvancements().stopListening();
         this.players.remove(entityplayer);
+        this.removeFromSendAllPlayerInfoBuckets(entityplayer); // Gale - Purpur - spread out sending all player info
         this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         this.server.getCustomBossEvents().onPlayerDisconnect(entityplayer);
         UUID uuid = entityplayer.getUUID();
@@ -771,6 +789,7 @@ public abstract class PlayerList {
     public ServerPlayer respawn(ServerPlayer entityplayer, boolean flag, Entity.RemovalReason entity_removalreason, RespawnReason reason, Location location) {
         entityplayer.stopRiding(); // CraftBukkit
         this.players.remove(entityplayer);
+        this.removeFromSendAllPlayerInfoBuckets(entityplayer); // Gale - Purpur - spread out sending all player info
         this.playersByName.remove(entityplayer.getScoreboardName().toLowerCase(java.util.Locale.ROOT)); // Spigot
         entityplayer.serverLevel().removePlayerImmediately(entityplayer, entity_removalreason);
         /* CraftBukkit start
@@ -857,6 +876,7 @@ public abstract class PlayerList {
         if (!entityplayer.connection.isDisconnected()) {
             worldserver.addRespawnedPlayer(entityplayer1);
             this.players.add(entityplayer1);
+            this.addToSendAllPlayerInfoBuckets(entityplayer1); // Gale - Purpur - spread out sending all player info
             this.playersByName.put(entityplayer1.getScoreboardName().toLowerCase(java.util.Locale.ROOT), entityplayer1); // Spigot
             this.playersByUUID.put(entityplayer1.getUUID(), entityplayer1);
         }
@@ -942,20 +962,59 @@ public abstract class PlayerList {
         this.sendPlayerPermissionLevel(player, i, recalculatePermissions); // Paper - avoid recalculating permissions if possible
     }
 
-    public void tick() {
-        if (++this.sendAllPlayerInfoIn > 600) {
-            // CraftBukkit start
-            for (int i = 0; i < this.players.size(); ++i) {
-                final ServerPlayer target = (ServerPlayer) this.players.get(i);
+    // Gale start - Purpur - spread out sending all player info
+
+    private void addToSendAllPlayerInfoBuckets(ServerPlayer player) {
+        ServerPlayer[] sendAllPlayerInfoBucket = this.sendAllPlayerInfoBuckets[player.sendAllPlayerInfoBucketIndex];
+        if (sendAllPlayerInfoBucket == null) {
+            this.sendAllPlayerInfoBuckets[player.sendAllPlayerInfoBucketIndex] = new ServerPlayer[]{player};
+        } else {
+            this.sendAllPlayerInfoBuckets[player.sendAllPlayerInfoBucketIndex] = sendAllPlayerInfoBucket = java.util.Arrays.copyOf(sendAllPlayerInfoBucket, sendAllPlayerInfoBucket.length + 1);
+            sendAllPlayerInfoBucket[sendAllPlayerInfoBucket.length - 1] = player;
+        }
+    }
 
-                target.connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), this.players.stream().filter(new Predicate<ServerPlayer>() {
-                    @Override
-                    public boolean test(ServerPlayer input) {
-                        return target.getBukkitEntity().canSee(input.getBukkitEntity());
+    private void removeFromSendAllPlayerInfoBuckets(ServerPlayer player) {
+        ServerPlayer[] sendAllPlayerInfoBucket = this.sendAllPlayerInfoBuckets[player.sendAllPlayerInfoBucketIndex];
+        if (sendAllPlayerInfoBucket != null) {
+            if (sendAllPlayerInfoBucket.length == 1) {
+                if (sendAllPlayerInfoBucket[0] == player) {
+                    this.sendAllPlayerInfoBuckets[player.sendAllPlayerInfoBucketIndex] = null;
+                }
+                return;
+            }
+            for (int i = 0; i < sendAllPlayerInfoBucket.length; i++) {
+                if (sendAllPlayerInfoBucket[i] == player) {
+                    sendAllPlayerInfoBucket[i] = sendAllPlayerInfoBucket[sendAllPlayerInfoBucket.length - 1];
+                    this.sendAllPlayerInfoBuckets[player.sendAllPlayerInfoBucketIndex] = java.util.Arrays.copyOf(sendAllPlayerInfoBucket, sendAllPlayerInfoBucket.length - 1);
+                }
+            }
+        }
+    }
+
+    // Gale end - Purpur - spread out sending all player info
+
+    public void tick() {
+        // Gale start - Purpur - spread out sending all player info
+        ServerPlayer[] sendAllPlayerInfoBucket = this.sendAllPlayerInfoBuckets[this.sendAllPlayerInfoIn];
+        if (sendAllPlayerInfoBucket != null) {
+            // Gale start - Purpur - optimize player list for sending player info
+            for (ServerPlayer targetPlayer : sendAllPlayerInfoBucket) {
+                // Gale end - Purpur - spread out sending all player info
+                var target = targetPlayer.getBukkitEntity();;
+                final List<ServerPlayer> list = new java.util.ArrayList<>(this.players.size());
+                for (ServerPlayer player : this.players) {
+                    if (target.canSeePlayer(player.getUUID())) {
+                        list.add(player);
                     }
-                }).collect(Collectors.toList())));
+                }
+                target.getHandle().connection.send(new ClientboundPlayerInfoUpdatePacket(EnumSet.of(ClientboundPlayerInfoUpdatePacket.Action.UPDATE_LATENCY), list));
+                // Gale end - Purpur - optimize player list for sending player info
+                // Gale start - Purpur - spread out sending all player info
             }
-            // CraftBukkit end
+        }
+        if (++this.sendAllPlayerInfoIn >= SEND_PLAYER_INFO_INTERVAL) {
+            // Gale end - Purpur - spread out sending all player info
             this.sendAllPlayerInfoIn = 0;
         }
 
@@ -1359,7 +1418,7 @@ public abstract class PlayerList {
         // Paper end
         boolean flag = this.verifyChatTrusted(message);
 
-        this.server.logChatMessage((unsignedFunction == null ? message.decoratedContent() : unsignedFunction.apply(this.server.console)), params, flag ? null : "Not Secure"); // Paper
+        this.server.logChatMessage((unsignedFunction == null ? message.decoratedContent() : unsignedFunction.apply(this.server.console)), params, flag || !org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.chat.notSecureMarker ? null : "Not Secure"); // Paper // Gale - do not log Not Secure marker
         OutgoingChatMessage outgoingchatmessage = OutgoingChatMessage.create(message);
         boolean flag1 = false;
 
diff --git a/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java b/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java
index 0e0867d7add9a024bbe9471f8ff92bbb25996a3d..94ffa65fa99c4c713936f7004d9f46ac94a9fe7a 100644
--- a/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java
+++ b/src/main/java/net/minecraft/server/rcon/thread/QueryThreadGs4.java
@@ -341,7 +341,7 @@ public class QueryThreadGs4 extends GenericThread {
             this.identBytes[2] = bs[5];
             this.identBytes[3] = bs[6];
             this.ident = new String(this.identBytes, StandardCharsets.UTF_8);
-            this.challenge = RandomSource.create().nextInt(16777216);
+            this.challenge = java.util.concurrent.ThreadLocalRandom.current().nextInt(16777216); // Gale - Patina - reduce RandomSource instances
             this.challengeBytes = String.format(Locale.ROOT, "\t%s%d\u0000", this.ident, this.challenge).getBytes(StandardCharsets.UTF_8);
         }
 
diff --git a/src/main/java/net/minecraft/stats/ServerRecipeBook.java b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
index 5c7484ce2850a2eb698a2183b81134b89b0bbcc7..deab78ef1a751d4d01e1ab45864e5ead3a320ad7 100644
--- a/src/main/java/net/minecraft/stats/ServerRecipeBook.java
+++ b/src/main/java/net/minecraft/stats/ServerRecipeBook.java
@@ -159,7 +159,7 @@ public class ServerRecipeBook extends RecipeBook {
                 ResourceKey<Recipe<?>> resourcekey = ResourceKey.create(Registries.RECIPE, ResourceLocation.parse(s));
 
                 if (!validPredicate.test(resourcekey)) {
-                    ServerRecipeBook.LOGGER.error("Tried to load unrecognized recipe: {} removed now.", resourcekey);
+                    if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.unrecognizedRecipes) ServerRecipeBook.LOGGER.error("Tried to load unrecognized recipe: {} removed now.", resourcekey); // Gale - Purpur - do not log unrecognized recipes
                 } else {
                     handler.accept(resourcekey);
                 }
diff --git a/src/main/java/net/minecraft/stats/ServerStatsCounter.java b/src/main/java/net/minecraft/stats/ServerStatsCounter.java
index da7e1a69ecb4e6b3be2d8544ac406aa519bd196e..b51fb5f1f20ef709f1f741044746eef034230c5d 100644
--- a/src/main/java/net/minecraft/stats/ServerStatsCounter.java
+++ b/src/main/java/net/minecraft/stats/ServerStatsCounter.java
@@ -137,15 +137,15 @@ public class ServerStatsCounter extends StatsCounter {
                                             Util.ifElse(this.getStat(statisticwrapper, s2), (statistic) -> {
                                                 this.stats.put(statistic, nbttagcompound2.getInt(s2));
                                             }, () -> {
-                                                ServerStatsCounter.LOGGER.warn("Invalid statistic in {}: Don't know what {} is", this.file, s2);
+                                                if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.invalidStatistics) ServerStatsCounter.LOGGER.warn("Invalid statistic in {}: Don't know what {} is", this.file, s2); // Gale - EMC - do not log invalid statistics
                                             });
                                         } else {
-                                            ServerStatsCounter.LOGGER.warn("Invalid statistic value in {}: Don't know what {} is for key {}", new Object[]{this.file, nbttagcompound2.get(s2), s2});
+                                            if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.invalidStatistics) ServerStatsCounter.LOGGER.warn("Invalid statistic value in {}: Don't know what {} is for key {}", new Object[]{this.file, nbttagcompound2.get(s2), s2}); // Gale - EMC - do not log invalid statistics
                                         }
                                     }
 
                                 }, () -> {
-                                    ServerStatsCounter.LOGGER.warn("Invalid statistic type in {}: Don't know what {} is", this.file, s1);
+                                    if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.invalidStatistics) ServerStatsCounter.LOGGER.warn("Invalid statistic type in {}: Don't know what {} is", this.file, s1); // Gale - EMC - do not log invalid statistics
                                 });
                             }
                         }
diff --git a/src/main/java/net/minecraft/util/BitStorage.java b/src/main/java/net/minecraft/util/BitStorage.java
index e4e153cb8899e70273aa150b8ea26907cf68b15c..ddb0d2f47e2a598431802bf21259715fd845f453 100644
--- a/src/main/java/net/minecraft/util/BitStorage.java
+++ b/src/main/java/net/minecraft/util/BitStorage.java
@@ -38,4 +38,6 @@ public interface BitStorage extends ca.spottedleaf.moonrise.patches.block_counti
         return ret;
     }
     // Paper end - block counting
+
+    <T> void compact(net.minecraft.world.level.chunk.Palette<T> srcPalette, net.minecraft.world.level.chunk.Palette<T> dstPalette, short[] out); // Gale - Lithium - faster chunk serialization
 }
diff --git a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
index 038710ba934a9a57815dfe9f414b98223b848385..ff545f6d36c265d70c79fc1acc7a279f10fbfcfd 100644
--- a/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
+++ b/src/main/java/net/minecraft/util/ClassInstanceMultiMap.java
@@ -14,9 +14,9 @@ import java.util.Map.Entry;
 import net.minecraft.Util;
 
 public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
-    private final Map<Class<?>, List<T>> byClass = Maps.newHashMap();
+    private final Map<Class<?>, List<T>> byClass = new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>(2); // Gale - Lithium - replace class map with optimized collection
     private final Class<T> baseClass;
-    private final List<T> allInstances = Lists.newArrayList();
+    private final List<T> allInstances = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Gale - VMP - replace instance map with optimized collection
 
     public ClassInstanceMultiMap(Class<T> elementType) {
         this.baseClass = elementType;
@@ -56,18 +56,41 @@ public class ClassInstanceMultiMap<T> extends AbstractCollection<T> {
     }
 
     public <S> Collection<S> find(Class<S> type) {
-        if (!this.baseClass.isAssignableFrom(type)) {
-            throw new IllegalArgumentException("Don't know how to search for " + type);
-        } else {
-            List<? extends T> list = this.byClass
-                .computeIfAbsent(type, typeClass -> this.allInstances.stream().filter(typeClass::isInstance).collect(Util.toMutableList()));
-            return (Collection<S>)Collections.unmodifiableCollection(list);
+        // Gale start - VMP - avoid Class#isAssignableFrom call in ClassInstanceMultiMap
+        /*
+        Only perform the slow Class#isAssignableFrom(Class) if a list doesn't exist for the type, otherwise
+        we can assume it's already valid. The slow-path code is moved to a separate method to help the JVM inline this.
+         */
+        Collection<T> collection = this.byClass.get(type);
+
+        if (collection == null) {
+            collection = this.createAllOfType(type);
         }
+
+        return (Collection<S>) collection;
+    }
+
+    private <S> Collection<T> createAllOfType(Class<S> type) {
+        return this.byClass.computeIfAbsent(
+            type,
+            typeClass -> {
+                it.unimi.dsi.fastutil.objects.ObjectArrayList<T> ts = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(this.allInstances.size());
+
+                for (T _allElement : ((it.unimi.dsi.fastutil.objects.ObjectArrayList<T>) this.allInstances).elements()) {
+                    if (typeClass.isInstance(_allElement)) {
+                        ts.add(_allElement);
+                    }
+                }
+
+                return ts;
+            }
+        );
+        // Gale end - VMP - avoid Class#isAssignableFrom call in ClassInstanceMultiMap
     }
 
     @Override
     public Iterator<T> iterator() {
-        return (Iterator<T>)(this.allInstances.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.allInstances.iterator()));
+        return this.allInstances.isEmpty() ? Collections.emptyIterator() : Iterators.unmodifiableIterator(this.allInstances.iterator());
     }
 
     public List<T> getAllInstances() {
diff --git a/src/main/java/net/minecraft/util/ExtraCodecs.java b/src/main/java/net/minecraft/util/ExtraCodecs.java
index c0a54a8006c18f12fdb2173ca247b0810ffc1c59..3a35d266f69ec4a0806dc419e3d683a266860750 100644
--- a/src/main/java/net/minecraft/util/ExtraCodecs.java
+++ b/src/main/java/net/minecraft/util/ExtraCodecs.java
@@ -228,7 +228,7 @@ public class ExtraCodecs {
                 P object2 = listx.get(1);
                 return combineFunction.apply(object, object2);
             }), pair -> ImmutableList.of(leftFunction.apply((I)pair), rightFunction.apply((I)pair)));
-        Codec<I> codec3 = RecordCodecBuilder.<Pair>create(
+        Codec<I> codec3 = RecordCodecBuilder.<Pair<P, P>>create( // Gale - dev import deobfuscation fixes
                 instance -> instance.group(codec.fieldOf(leftFieldName).forGetter(Pair::getFirst), codec.fieldOf(rightFieldName).forGetter(Pair::getSecond))
                         .apply(instance, Pair::of)
             )
@@ -245,14 +245,14 @@ public class ExtraCodecs {
             });
     }
 
-    public static <A> ResultFunction<A> orElsePartial(A object) {
+    public static <A> ResultFunction<A> orElsePartial(A objectA) { // Gale - dev import deobfuscation fixes
         return new ResultFunction<A>() {
             public <T> DataResult<Pair<A, T>> apply(DynamicOps<T> dynamicOps, T object, DataResult<Pair<A, T>> dataResult) {
                 MutableObject<String> mutableObject = new MutableObject<>();
                 Optional<Pair<A, T>> optional = dataResult.resultOrPartial(mutableObject::setValue);
                 return optional.isPresent()
                     ? dataResult
-                    : DataResult.error(() -> "(" + mutableObject.getValue() + " -> using default)", Pair.of(object, object));
+                    : DataResult.error(() -> "(" + mutableObject.getValue() + " -> using default)", Pair.of(objectA, object)); // Gale - dev import deobfuscation fixes
             }
 
             public <T> DataResult<T> coApply(DynamicOps<T> dynamicOps, A object, DataResult<T> dataResult) {
@@ -261,7 +261,7 @@ public class ExtraCodecs {
 
             @Override
             public String toString() {
-                return "OrElsePartial[" + object + "]";
+                return "OrElsePartial[" + objectA + "]"; // Gale - dev import deobfuscation fixes
             }
         };
     }
diff --git a/src/main/java/net/minecraft/util/Mth.java b/src/main/java/net/minecraft/util/Mth.java
index ef93fc37759e0b54387c8a59adc2b19258cfeb7d..34bfbbabe3dfbf033f4a4e22a049323213fb23f3 100644
--- a/src/main/java/net/minecraft/util/Mth.java
+++ b/src/main/java/net/minecraft/util/Mth.java
@@ -58,18 +58,15 @@ public class Mth {
     }
 
     public static int floor(float value) {
-        int i = (int)value;
-        return value < (float)i ? i - 1 : i;
+        return (int) Math.floor(value); // Gale - use platform math functions
     }
 
     public static int floor(double value) {
-        int i = (int)value;
-        return value < (double)i ? i - 1 : i;
+        return (int) Math.floor(value); // Gale - use platform math functions
     }
 
     public static long lfloor(double value) {
-        long l = (long)value;
-        return value < (double)l ? l - 1L : l;
+        return (long) Math.floor(value); // Gale - use platform math functions
     }
 
     public static float abs(float value) {
@@ -81,13 +78,11 @@ public class Mth {
     }
 
     public static int ceil(float value) {
-        int i = (int)value;
-        return value > (float)i ? i + 1 : i;
+        return (int) Math.ceil(value); // Gale - use platform math functions
     }
 
     public static int ceil(double value) {
-        int i = (int)value;
-        return value > (double)i ? i + 1 : i;
+        return (int) Math.ceil(value); // Gale - use platform math functions
     }
 
     public static int clamp(int value, int min, int max) {
@@ -123,15 +118,7 @@ public class Mth {
     }
 
     public static double absMax(double a, double b) {
-        if (a < 0.0) {
-            a = -a;
-        }
-
-        if (b < 0.0) {
-            b = -b;
-        }
-
-        return Math.max(a, b);
+        return Math.max(Math.abs(a), Math.abs(b)); // Gale - use platform math functions
     }
 
     public static int floorDiv(int dividend, int divisor) {
@@ -162,14 +149,26 @@ public class Mth {
         return Math.floorMod(dividend, divisor);
     }
 
-    public static float positiveModulo(float dividend, float divisor) {
+    public static float positiveModuloForAnyDivisor(float dividend, float divisor) { // Gale - faster floating-point positive modulo
         return (dividend % divisor + divisor) % divisor;
     }
 
-    public static double positiveModulo(double dividend, double divisor) {
+    public static double positiveModuloForAnyDivisor(double dividend, double divisor) { // Gale - faster floating-point positive modulo
         return (dividend % divisor + divisor) % divisor;
     }
 
+    // Gale start - faster floating-point positive modulo
+    public static float positiveModuloForPositiveIntegerDivisor(float dividend, float divisor) {
+        var modulo = dividend % divisor;
+        return modulo < 0 ? modulo + divisor : modulo;
+    }
+
+    public static double positiveModuloForPositiveIntegerDivisor(double dividend, double divisor) {
+        var modulo = dividend % divisor;
+        return modulo < 0 ? modulo + divisor : modulo;
+    }
+    // Gale end - faster floating-point positive modulo
+
     public static boolean isMultipleOf(int a, int b) {
         return a % b == 0;
     }
diff --git a/src/main/java/net/minecraft/util/SimpleBitStorage.java b/src/main/java/net/minecraft/util/SimpleBitStorage.java
index d99ec470b4653beab630999a5b2c1a6428b20c38..f8640b8cce9018d877ec69bbba241d5d9e89b8d8 100644
--- a/src/main/java/net/minecraft/util/SimpleBitStorage.java
+++ b/src/main/java/net/minecraft/util/SimpleBitStorage.java
@@ -472,4 +472,45 @@ public class SimpleBitStorage implements BitStorage {
             super(message);
         }
     }
+
+    // Gale start - Lithium - faster chunk serialization
+    @Override
+    public <T> void compact(net.minecraft.world.level.chunk.Palette<T> srcPalette, net.minecraft.world.level.chunk.Palette<T> dstPalette, short[] out) {
+        if (this.size >= Short.MAX_VALUE) {
+            throw new IllegalStateException("Array too large");
+        }
+
+        if (this.size != out.length) {
+            throw new IllegalStateException("Array size mismatch");
+        }
+
+        short[] mappings = new short[(int) (this.mask + 1)];
+
+        int idx = 0;
+
+        for (long word : this.data) {
+            long bits = word;
+
+            for (int elementIdx = 0; elementIdx < this.valuesPerLong; ++elementIdx) {
+                int value = (int) (bits & this.mask);
+                int remappedId = mappings[value];
+
+                if (remappedId == 0) {
+                    remappedId = dstPalette.idFor(srcPalette.valueFor(value)) + 1;
+                    mappings[value] = (short) remappedId;
+                }
+
+                out[idx] = (short) (remappedId - 1);
+                bits >>= this.bits;
+
+                ++idx;
+
+                if (idx >= this.size) {
+                    return;
+                }
+            }
+        }
+    }
+    // Gale end - Lithium - faster chunk serialization
+
 }
diff --git a/src/main/java/net/minecraft/util/ZeroBitStorage.java b/src/main/java/net/minecraft/util/ZeroBitStorage.java
index 1f9c436a632e4f110be61cf76fcfc3b7eb80334e..138b9802ea8e6933a1295c4116784d98e68dc8a1 100644
--- a/src/main/java/net/minecraft/util/ZeroBitStorage.java
+++ b/src/main/java/net/minecraft/util/ZeroBitStorage.java
@@ -80,4 +80,6 @@ public class ZeroBitStorage implements BitStorage {
         return ret;
     }
     // Paper end - block counting
+
+    @Override public <T> void compact(net.minecraft.world.level.chunk.Palette<T> srcPalette, net.minecraft.world.level.chunk.Palette<T> dstPalette, short[] out) {}  // Gale - Lithium - faster chunk serialization
 }
diff --git a/src/main/java/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java b/src/main/java/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java
index 2942534d265416a3693848d76538c04735bc14fa..3f48037d5d6a4965b895fde69825d3b2a74770e8 100644
--- a/src/main/java/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java
+++ b/src/main/java/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java
@@ -186,7 +186,7 @@ public class ChunkProtoTickListFix extends DataFix {
         int k = packedLocalPos >>> 8 & 15;
         String string = blockIdGetter.apply(sectionSupplier != null ? sectionSupplier.get().get(i, j, k) : null);
         return levelDynamic.createMap(
-            ImmutableMap.builder()
+            ImmutableMap.<Dynamic<?>, Dynamic<?>>builder() // Gale - dev import deobfuscation fixes
                 .put(levelDynamic.createString("i"), levelDynamic.createString(string))
                 .put(levelDynamic.createString("x"), levelDynamic.createInt(sectionX * 16 + i))
                 .put(levelDynamic.createString("y"), levelDynamic.createInt(sectionY * 16 + j))
diff --git a/src/main/java/net/minecraft/world/Container.java b/src/main/java/net/minecraft/world/Container.java
index 5db5ba026462ca642dcee718af732f80fadabef5..cd380ceb40d38acc7eef289ded11259388becabd 100644
--- a/src/main/java/net/minecraft/world/Container.java
+++ b/src/main/java/net/minecraft/world/Container.java
@@ -71,6 +71,20 @@ public interface Container extends Clearable {
         });
     }
 
+    // Gale start - optimize villager data storage
+    default boolean hasAnyOf(Item[] items) {
+        for (int i = 0; i < this.getContainerSize(); ++i) {
+            ItemStack itemstack = this.getItem(i);
+            for (Item item : items) {
+                if (itemstack.is(item)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+    // Gale end - optimize villager data storage
+
     default boolean hasAnyMatching(Predicate<ItemStack> predicate) {
         for (int i = 0; i < this.getContainerSize(); ++i) {
             ItemStack itemstack = this.getItem(i);
diff --git a/src/main/java/net/minecraft/world/damagesource/DamageSource.java b/src/main/java/net/minecraft/world/damagesource/DamageSource.java
index bb1a60180e58c1333e7bb33e8acf1b0225eda8a8..4d037e899e0b5548be406ad55acd2062603b7da1 100644
--- a/src/main/java/net/minecraft/world/damagesource/DamageSource.java
+++ b/src/main/java/net/minecraft/world/damagesource/DamageSource.java
@@ -67,7 +67,7 @@ public class DamageSource {
 
     public DamageSource customEventDamager(Entity entity) {
         if (this.directEntity != null) {
-            throw new IllegalStateException("Cannot set custom event damager when direct entity is already set (report a bug to Paper)");
+            throw new IllegalStateException("Cannot set custom event damager when direct entity is already set (report a bug to Paper, if you think this is a Gale bug, please report it at https://github.com/GaleMC/Gale/issues)"); // Gale - branding changes
         }
         DamageSource damageSource = this.cloneInstance();
         damageSource.customEventDamager = entity;
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 1b547be0fe97119edf4f29666cfe0037e0c778e0..2c3900edb2cd19297a812abad0c0c4e82abae755 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -273,8 +273,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public double xo;
     public double yo;
     public double zo;
-    private Vec3 position;
-    private BlockPos blockPosition;
+    public Vec3 position; // Gale - JettPack - optimize sun burn tick - private -> public
+    public BlockPos blockPosition; // Gale - Pufferfish - optimize entity coordinate key - private -> public
     private ChunkPos chunkPosition;
     private Vec3 deltaMovement;
     private float yRot;
@@ -282,6 +282,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public float yRotO;
     public float xRotO;
     private AABB bb;
+    private boolean boundingBoxChanged = false; // Gale - VMP - skip entity move if movement is zero
     public boolean onGround;
     public boolean horizontalCollision;
     public boolean verticalCollision;
@@ -405,6 +406,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return this.originWorld;
     }
     // Paper end - Entity origin API
+
     public float getBukkitYaw() {
         return this.yRot;
     }
@@ -953,7 +955,13 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
         this.checkBelowWorld();
         if (!this.level().isClientSide) {
+            // Gale start - Slice - hide flames on entities with fire resistance
+            if (this instanceof net.minecraft.world.entity.LivingEntity livingEntity) {
+                this.setSharedFlagOnFire(this.remainingFireTicks > 0 && (!this.level.galeConfig().gameplayMechanics.hideFlamesOnEntitiesWithFireResistance || !livingEntity.hasEffect(net.minecraft.world.effect.MobEffects.FIRE_RESISTANCE)));
+            } else {
+            // Gale end - Slice - hide flames on entities with fire resistance
             this.setSharedFlagOnFire(this.remainingFireTicks > 0);
+            } // Gale - Slice - hide flames on entities with fire resistance
         }
 
         this.firstTick = false;
@@ -1170,6 +1178,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // Paper end - detailed watchdog information
 
     public void move(MoverType type, Vec3 movement) {
+        // Gale start - VMP - skip entity move if movement is zero
+        if (!this.boundingBoxChanged && movement.equals(Vec3.ZERO)) {
+            return;
+        }
+        // Gale end - VMP - skip entity move if movement is zero
         final Vec3 originalMovement = movement; // Paper - Expose pre-collision velocity
         // Paper start - detailed watchdog information
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main");
@@ -2182,8 +2195,18 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     /** @deprecated */
     @Deprecated
     public float getLightLevelDependentMagicValue() {
-        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level().getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())) : 0.0F;
+        return this.getLightLevelDependentMagicValue(BlockPos.containing(this.getX(), this.getEyeY(), this.getZ())); // Gale - JettPack - optimize sun burn tick - allow passing BlockPos to getLightLevelDependentMagicValue
+    }
+
+    // Gale start - JettPack - optimize sun burn tick - allow passing BlockPos to getLightLevelDependentMagicValue
+    /**
+     * @deprecated
+     */
+    @Deprecated
+    public float getLightLevelDependentMagicValue(BlockPos pos) {
+        return this.level().hasChunkAt(this.getBlockX(), this.getBlockZ()) ? this.level.getLightLevelDependentMagicValue(pos) : 0.0F;
     }
+    // Gale end - JettPack - optimize sun burn tick - allow passing BlockPos to getLightLevelDependentMagicValue
 
     public void absMoveTo(double x, double y, double z, float yaw, float pitch) {
         this.absMoveTo(x, y, z);
@@ -2305,8 +2328,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public void playerTouch(Player player) {}
 
     public void push(Entity entity) {
+        if (!entity.noPhysics && !this.noPhysics) { // Gale - Akarin - collision physics check before vehicle check
         if (!this.isPassengerOfSameVehicle(entity)) {
-            if (!entity.noPhysics && !this.noPhysics) {
                 if (this.level.paperConfig().collisions.onlyPlayersCollide && !(entity instanceof ServerPlayer || this instanceof ServerPlayer)) return; // Paper - Collision option for requiring a player participant
                 double d0 = entity.getX() - this.getX();
                 double d1 = entity.getZ() - this.getZ();
@@ -4061,6 +4084,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
 
                 entity2.startRiding(entity, true);
             }
+            // Gale end - MultiPaper - load portal destination chunk before entity teleport
 
             world.resetEmptyTime();
             teleportTarget.postTeleportTransition().onTransition(entity);
@@ -4427,6 +4451,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public final void setBoundingBox(AABB boundingBox) {
+        // Gale start - VMP - skip entity move if movement is zero
+        if (!this.bb.equals(boundingBox)) {
+            this.boundingBoxChanged = true;
+        }
+        // Gale end - VMP - skip entity move if movement is zero
         // CraftBukkit start - block invalid bounding boxes
         double minX = boundingBox.minX,
                 minY = boundingBox.minY,
@@ -4943,6 +4972,16 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return this.inBlockState;
     }
 
+    // Gale start - don't load chunks to activate climbing entities
+    public @Nullable BlockState getInBlockStateIfLoaded() {
+        if (this.inBlockState == null) {
+            this.inBlockState = this.level.getBlockStateIfLoaded(this.blockPosition());
+        }
+
+        return this.inBlockState;
+    }
+    // Gale end - don't load chunks to activate climbing entities
+
     public ChunkPos chunkPosition() {
         return this.chunkPosition;
     }
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 96b4fbe4a4655777ff10b32e3257e2fac2aba12a..bea0fa6d9b841bab40f229be06d8e740667c1d84 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -581,11 +581,10 @@ public abstract class LivingEntity extends Entity implements Attackable {
     }
 
     protected void tryAddFrost() {
-        if (!this.getBlockStateOnLegacy().isAir()) {
             int i = this.getTicksFrozen();
 
             if (i > 0) {
-                AttributeInstance attributemodifiable = this.getAttribute(Attributes.MOVEMENT_SPEED);
+                AttributeInstance attributemodifiable = this.getBlockStateOnLegacy().isAir() ? null : this.getAttribute(Attributes.MOVEMENT_SPEED); // Gale - Lithium - check frozen ticks before landing block
 
                 if (attributemodifiable == null) {
                     return;
@@ -595,7 +594,6 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
                 attributemodifiable.addTransientModifier(new AttributeModifier(LivingEntity.SPEED_MODIFIER_POWDER_SNOW_ID, (double) f, AttributeModifier.Operation.ADD_VALUE));
             }
-        }
 
     }
 
@@ -1054,10 +1052,9 @@ public abstract class LivingEntity extends Entity implements Attackable {
         }
 
         if (entity != null) {
-            ItemStack itemstack = this.getItemBySlot(EquipmentSlot.HEAD);
             EntityType<?> entitytypes = entity.getType();
 
-            if (entitytypes == EntityType.SKELETON && itemstack.is(Items.SKELETON_SKULL) || entitytypes == EntityType.ZOMBIE && itemstack.is(Items.ZOMBIE_HEAD) || entitytypes == EntityType.PIGLIN && itemstack.is(Items.PIGLIN_HEAD) || entitytypes == EntityType.PIGLIN_BRUTE && itemstack.is(Items.PIGLIN_HEAD) || entitytypes == EntityType.CREEPER && itemstack.is(Items.CREEPER_HEAD)) {
+            if (entitytypes == EntityType.SKELETON && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.SKELETON_SKULL) || entitytypes == EntityType.ZOMBIE && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.ZOMBIE_HEAD) || entitytypes == EntityType.PIGLIN && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.PIGLIN_HEAD) || entitytypes == EntityType.PIGLIN_BRUTE && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.PIGLIN_HEAD) || entitytypes == EntityType.CREEPER && this.getItemBySlot(EquipmentSlot.HEAD).is(Items.CREEPER_HEAD)) { // Gale - Petal - reduce skull ItemStack lookups for reduced visibility
                 d0 *= 0.5D;
             }
         }
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 5a0b51342f4a646101f4588697bcae7d1ca8a010..683db2c58cf456d5824c5127fa9b2cd61d234b77 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -1743,13 +1743,29 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
 
     protected void playAttackSound() {}
 
+    // Gale start - JettPack - optimize sun burn tick - cache eye blockpos
+    private BlockPos cached_eye_blockpos;
+    private int cached_position_hashcode;
+    // Gale end - JettPack - optimize sun burn tick - cache eye blockpos
+
     public boolean isSunBurnTick() {
         if (this.level().isDay() && !this.level().isClientSide) {
-            float f = this.getLightLevelDependentMagicValue();
-            BlockPos blockposition = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+            // Gale start - JettPack - optimize sun burn tick - optimizations and cache eye blockpos
+            int positionHashCode = this.position.hashCode();
+            if (this.cached_position_hashcode != positionHashCode) {
+                this.cached_eye_blockpos = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+                this.cached_position_hashcode = positionHashCode;
+            }
+
+            float f = this.getLightLevelDependentMagicValue(cached_eye_blockpos); // Pass BlockPos to getBrightness
+
+            // Check brightness first
+            if (f <= 0.5F) return false;
+            if (this.random.nextFloat() * 30.0F >= (f - 0.4F) * 2.0F) return false;
+            // Gale end - JettPack - optimize sun burn tick - optimizations and cache eye blockpos
             boolean flag = this.isInWaterRainOrBubble() || this.isInPowderSnow || this.wasInPowderSnow;
 
-            if (f > 0.5F && this.random.nextFloat() * 30.0F < (f - 0.4F) * 2.0F && !flag && this.level().canSeeSky(blockposition)) {
+            if (!flag && this.level().canSeeSky(this.cached_eye_blockpos)) { // Gale - JettPack - optimize sun burn tick - optimizations and cache eye blockpos
                 return true;
             }
         }
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index fb967ac7b3e7828301f08a7fe9b039441cf7da30..ec124c33f40760c498b0b5f1eb791b6ae8536bf7 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -19,9 +19,11 @@ import org.slf4j.Logger;
 
 public class AttributeMap {
     private static final Logger LOGGER = LogUtils.getLogger();
-    private final Map<Holder<Attribute>, AttributeInstance> attributes = new Object2ObjectOpenHashMap<>();
-    private final Set<AttributeInstance> attributesToSync = new ObjectOpenHashSet<>();
-    private final Set<AttributeInstance> attributesToUpdate = new ObjectOpenHashSet<>();
+    // Gale start - Lithium - replace AI attributes with optimized collections
+    private final Map<Holder<Attribute>, AttributeInstance> attributes = new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>(0);
+    private final Set<AttributeInstance> attributesToSync = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(0);
+    private final Set<AttributeInstance> attributesToUpdate = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>(0);
+    // Gale end - Lithium - replace AI attributes with optimized collections
     private final AttributeSupplier supplier;
 
     public AttributeMap(AttributeSupplier defaultAttributes) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java b/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
index 0d177e828c2b338ce93c58aaef04df326e1eb0b2..fc0abe8a20d5457bb4f647b4454ef3f393b034f7 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
@@ -28,6 +28,13 @@ import org.apache.commons.lang3.mutable.MutableLong;
 public class AcquirePoi {
     public static final int SCAN_RANGE = 48;
 
+    // Gale start - Airplane - reduce acquire POI for stuck entities
+    public static void addAdditionalTimeToMutableLongIfEntityIsStuck(MutableLong mutableLong, net.minecraft.server.level.ServerLevel world, PathfinderMob entity) {
+        long stuckEntityAdditionalWaitTime = world.galeConfig().smallOptimizations.reducedIntervals.acquirePoiForStuckEntity;
+        mutableLong.add(stuckEntityAdditionalWaitTime <= 0L ? 0L : entity.getNavigation().isStuck() ? stuckEntityAdditionalWaitTime : 0L);
+    }
+    // Gale end - Airplane - reduce acquire POI for stuck entities
+
     public static BehaviorControl<PathfinderMob> create(
         Predicate<Holder<PoiType>> poiPredicate,
         MemoryModuleType<GlobalPos> poiPosModule,
@@ -65,12 +72,13 @@ public class AcquirePoi {
                                     return false;
                                 } else if (mutableLong.getValue() == 0L) {
                                     mutableLong.setValue(world.getGameTime() + (long)world.random.nextInt(20));
+                                    addAdditionalTimeToMutableLongIfEntityIsStuck(mutableLong, world, entity); // Gale - Airplane - reduce acquire POI for stuck entities
                                     return false;
                                 } else if (world.getGameTime() < mutableLong.getValue()) {
                                     return false;
                                 } else {
                                     mutableLong.setValue(time + 20L + (long)world.getRandom().nextInt(20));
-                                    if (entity.getNavigation().isStuck()) mutableLong.add(200); // Paper - Perf: Wait an additional 10s to check again if they're stuck
+                                    addAdditionalTimeToMutableLongIfEntityIsStuck(mutableLong, world, entity); // Paper - Perf: Wait an additional 10s to check again if they're stuck // Gale - Airplane - reduce acquire POI for stuck entities
                                     PoiManager poiManager = world.getPoiManager();
                                     long2ObjectMap.long2ObjectEntrySet().removeIf(entry -> !entry.getValue().isStillValid(time));
                                     Predicate<BlockPos> predicate2 = pos -> {
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorUtils.java b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorUtils.java
index d98b28e9488a5a7736719cf656736bb026ec8c7e..25dacd924f182d197bcbdcd7c1d8caa482fd8d37 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorUtils.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/BehaviorUtils.java
@@ -99,7 +99,16 @@ public class BehaviorUtils {
 
         vec3d2 = vec3d2.normalize().multiply(velocityFactor.x, velocityFactor.y, velocityFactor.z);
         entityitem.setDeltaMovement(vec3d2);
-        entityitem.setDefaultPickUpDelay();
+        // Gale start - EMC - reduce villager item re-pickup
+        if (entity instanceof net.minecraft.world.entity.npc.Villager) {
+            int repickupDelay = entity.level().galeConfig().smallOptimizations.reducedIntervals.villagerItemRepickup;
+            if (repickupDelay <= -1) {
+                entityitem.setDefaultPickUpDelay();
+            } else {
+                entityitem.pickupDelay = repickupDelay;
+            }
+        }
+        // Gale end - EMC - reduce villager item re-pickup
         // CraftBukkit start
         org.bukkit.event.entity.EntityDropItemEvent event = new org.bukkit.event.entity.EntityDropItemEvent(entity.getBukkitEntity(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
         entityitem.level().getCraftServer().getPluginManager().callEvent(event);
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java b/src/main/java/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
index 8508ac7de8cda3127b73e11ff4aee62502e65ead..73e20e1f7d2bb1cd3d08e6bdca50efac22c9d958 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
@@ -17,7 +17,10 @@ import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 
 public class TradeWithVillager extends Behavior<Villager> {
-    private Set<Item> trades = ImmutableSet.of();
+    // Gale start - optimize villager data storage
+    private static final Item[] WHEAT_SINGLETON_ARRAY = {Items.WHEAT};
+    private @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.Nullable [] trades = null;
+    // Gale end - optimize villager data storage
 
     public TradeWithVillager() {
         super(
@@ -51,16 +54,18 @@ public class TradeWithVillager extends Behavior<Villager> {
             BehaviorUtils.lockGazeAndWalkToEachOther(entity, villager, 0.5F, 2);
             entity.gossip(world, villager, time);
             if (entity.hasExcessFood() && (entity.getVillagerData().getProfession() == VillagerProfession.FARMER || villager.wantsMoreFood())) {
-                throwHalfStack(entity, Villager.FOOD_POINTS.keySet(), villager);
+                throwHalfStack(entity, Villager.FOOD_POINTS_KEY_ARRAY, villager); // Gale - optimize villager data storage
             }
 
             if (villager.getVillagerData().getProfession() == VillagerProfession.FARMER
                 && entity.getInventory().countItem(Items.WHEAT) > Items.WHEAT.getDefaultMaxStackSize() / 2) {
-                throwHalfStack(entity, ImmutableSet.of(Items.WHEAT), villager);
+                throwHalfStack(entity, Villager.FOOD_POINTS_KEY_ARRAY, villager); // Gale - optimize villager data storage
             }
 
-            if (!this.trades.isEmpty() && entity.getInventory().hasAnyOf(this.trades)) {
+            // Gale start - optimize villager data storage
+            if (this.trades != null && entity.getInventory().hasAnyOf(this.trades)) {
                 throwHalfStack(entity, this.trades, villager);
+                // Gale end - optimize villager data storage
             }
         }
     }
@@ -70,13 +75,36 @@ public class TradeWithVillager extends Behavior<Villager> {
         villager.getBrain().eraseMemory(MemoryModuleType.INTERACTION_TARGET);
     }
 
-    private static Set<Item> figureOutWhatIAmWillingToTrade(Villager entity, Villager target) {
-        ImmutableSet<Item> immutableSet = target.getVillagerData().getProfession().requestedItems();
-        ImmutableSet<Item> immutableSet2 = entity.getVillagerData().getProfession().requestedItems();
-        return immutableSet.stream().filter(item -> !immutableSet2.contains(item)).collect(Collectors.toSet());
+    // Gale start - optimize villager data storage
+    private static @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.Nullable [] figureOutWhatIAmWillingToTrade(Villager entity, Villager target) {
+        @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.Nullable [] immutableSet = target.getVillagerData().getProfession().requestedItems();
+        if (immutableSet == null) {
+            return null;
+        }
+        @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.Nullable [] immutableSet2 = entity.getVillagerData().getProfession().requestedItems();
+        if (immutableSet2 == null) {
+            return immutableSet;
+        }
+        if (immutableSet == immutableSet2) {
+            return null;
+        }
+        Item[] willingToTrade = new Item[immutableSet.length];
+        int willingToTradeSize = 0;
+        forImmutableSet:
+        for (Item item : immutableSet) {
+            for (Item item2 : immutableSet2) {
+                if (item == item2) {
+                    continue forImmutableSet;
+                }
+            }
+            willingToTrade[willingToTradeSize] = item;
+            willingToTradeSize++;
+        }
+        return java.util.Arrays.copyOf(willingToTrade, willingToTradeSize);
+        // Gale end - optimize villager data storage
     }
 
-    private static void throwHalfStack(Villager villager, Set<Item> validItems, LivingEntity target) {
+    private static void throwHalfStack(Villager villager, @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.NotNull [] validItems, LivingEntity target) { // Gale - optimize villager data storage
         SimpleContainer simpleContainer = villager.getInventory();
         ItemStack itemStack = ItemStack.EMPTY;
         int i = 0;
@@ -89,7 +117,16 @@ public class TradeWithVillager extends Behavior<Villager> {
                 itemStack2 = simpleContainer.getItem(i);
                 if (!itemStack2.isEmpty()) {
                     item = itemStack2.getItem();
-                    if (validItems.contains(item)) {
+                    // Gale start - optimize villager data storage
+                    boolean inValidItems = false;
+                    for (Item validItem : validItems) {
+                        if (validItem == item) {
+                            inValidItems = true;
+                            break;
+                        }
+                    }
+                    if (inValidItems) {
+                        // Gale end - optimize villager data storage
                         if (itemStack2.getCount() > itemStack2.getMaxStackSize() / 2) {
                             j = itemStack2.getCount() / 2;
                             break label28;
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java
index 676e1580849e8942eb41c7a3a80f464138b22764..9e4d0493aa814a392742c9ddc1815211e9b9b186 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/RandomStrollGoal.java
@@ -2,6 +2,9 @@ package net.minecraft.world.entity.ai.goal;
 
 import java.util.EnumSet;
 import javax.annotation.Nullable;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.server.level.ServerLevel;
 import net.minecraft.world.entity.PathfinderMob;
 import net.minecraft.world.entity.ai.util.DefaultRandomPos;
 import net.minecraft.world.phys.Vec3;
@@ -49,7 +52,7 @@ public class RandomStrollGoal extends Goal {
             }
 
             Vec3 vec3 = this.getPosition();
-            if (vec3 == null) {
+            if (vec3 == null || (!this.mob.level().galeConfig().gameplayMechanics.entitiesCanRandomStrollIntoNonTickingChunks && !((ServerLevel) this.mob.level()).isPositionEntityTicking(BlockPos.containing(vec3)))) { // Gale - MultiPaper - prevent entities random strolling into non-ticking chunks
                 return false;
             } else {
                 this.wantedX = vec3.x;
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java
index 515c1f671cb2c3a7cc23053aedf404bbbe77af3e..df002c7277a718dc156d2d5271fa4768b97f8d86 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java
@@ -103,7 +103,10 @@ public class RangedBowAttackGoal<T extends Monster & RangedAttackMob> extends Go
                 this.strafingTime = 0;
             }
 
-            if (this.strafingTime > -1) {
+            // Gale start - Purpur - fix MC-121706
+            boolean hasStrafingTime = this.strafingTime > -1;
+            if (hasStrafingTime) {
+                // Gale end - Purpur - fix MC-121706
                 if (d > (double)(this.attackRadiusSqr * 0.75F)) {
                     this.strafingBackwards = false;
                 } else if (d < (double)(this.attackRadiusSqr * 0.25F)) {
@@ -116,7 +119,10 @@ public class RangedBowAttackGoal<T extends Monster & RangedAttackMob> extends Go
                 }
 
                 this.mob.lookAt(livingEntity, 30.0F, 30.0F);
-            } else {
+                // Gale start - Purpur - fix MC-121706
+            }
+            if (!hasStrafingTime || this.mob.level().galeConfig().gameplayMechanics.fixes.mc121706) {
+            // Gale end - Purpur - fix MC-121706
                 this.mob.getLookControl().setLookAt(livingEntity, 30.0F, 30.0F);
             }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/target/HurtByTargetGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/target/HurtByTargetGoal.java
index edfc77ba9c5c7dc4cfe997faff7a34e9b9e9365e..6c72dd5774eccec68d29e04dfc344adb69840abf 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/target/HurtByTargetGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/target/HurtByTargetGoal.java
@@ -114,6 +114,11 @@ public class HurtByTargetGoal extends TargetGoal {
     }
 
     protected void alertOther(Mob mob, LivingEntity target) {
+        // Gale start - Mirai - fix MC-110386
+        if (mob == target && mob.level().galeConfig().gameplayMechanics.fixes.mc110386) {
+            return;
+        }
+        // Gale end - Mirai - fix MC-110386
         mob.setTarget(target, org.bukkit.event.entity.EntityTargetEvent.TargetReason.TARGET_ATTACKED_NEARBY_ENTITY, true); // CraftBukkit - reason
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
index a0e0692d17760f440fe81d52887284c787e562db..8bed5992f639f805ccdec56a90101004570dc265 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
@@ -22,16 +22,28 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
 
     @Override
     protected void doTick(ServerLevel world, Villager entity) {
+        // Gale start - Lithium - skip secondary POI sensor if absent
+        var secondaryPoi = entity.getVillagerData().getProfession().secondaryPoi();
+        if (secondaryPoi == null) { // Gale - optimize villager data storage
+            entity.getBrain().eraseMemory(MemoryModuleType.SECONDARY_JOB_SITE);
+            return;
+        }
+        // Gale end - Lithium - skip secondary POI sensor if absent
         ResourceKey<Level> resourceKey = world.dimension();
         BlockPos blockPos = entity.blockPosition();
-        List<GlobalPos> list = Lists.newArrayList();
+        @org.jetbrains.annotations.Nullable java.util.ArrayList<GlobalPos> list = null; // Gale - optimize villager data storage
         int i = 4;
 
         for (int j = -4; j <= 4; j++) {
             for (int k = -2; k <= 2; k++) {
                 for (int l = -4; l <= 4; l++) {
                     BlockPos blockPos2 = blockPos.offset(j, k, l);
-                    if (entity.getVillagerData().getProfession().secondaryPoi().contains(world.getBlockState(blockPos2).getBlock())) {
+                    // Gale start - optimize villager data storage
+                    if (secondaryPoi == world.getBlockState(blockPos2).getBlock()) {
+                        if (list == null) {
+                            list = Lists.newArrayList();
+                        }
+                        // Gale end - optimize villager data storage
                         list.add(GlobalPos.of(resourceKey, blockPos2));
                     }
                 }
@@ -39,7 +51,10 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
         }
 
         Brain<?> brain = entity.getBrain();
-        if (!list.isEmpty()) {
+        // Gale start - optimize villager data storage
+        if (list != null) {
+            list.trimToSize();
+            // Gale end - optimize villager data storage
             brain.setMemory(MemoryModuleType.SECONDARY_JOB_SITE, list);
         } else {
             brain.eraseMemory(MemoryModuleType.SECONDARY_JOB_SITE);
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
index 116b1e251ffe68bae5c404d0823c2bc7c1afddf6..2feb1f2eb35fcc0385ec9808e80aa2b556b58d30 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensing.java
@@ -9,23 +9,57 @@ import net.minecraft.world.entity.Mob;
 
 public class Sensing {
     private final Mob mob;
-    private final IntSet seen = new IntOpenHashSet();
-    private final IntSet unseen = new IntOpenHashSet();
+    private final it.unimi.dsi.fastutil.ints.Int2IntMap seen = new it.unimi.dsi.fastutil.ints.Int2IntOpenHashMap(2); // Gale end - initialize line of sight cache with low capacity // Gale - Petal - reduce line of sight cache lookups - merge sets
+
+    // Gale start - Petal - reduce line of sight updates - expiring entity id lists
+    private final @org.jetbrains.annotations.NotNull it.unimi.dsi.fastutil.ints.IntList @org.jetbrains.annotations.Nullable [] expiring;
+    private int currentCacheAddIndex = 0;
+    private int nextToExpireIndex = 1;
+    // Gale end - Petal - reduce line of sight updates - expiring entity id lists
 
     public Sensing(Mob owner) {
         this.mob = owner;
+        // Gale start - Petal - reduce line of sight updates - expiring entity id lists
+        int updateLineOfSightInterval = org.galemc.gale.configuration.GaleGlobalConfiguration.get().smallOptimizations.reducedIntervals.updateEntityLineOfSight;
+        if (updateLineOfSightInterval <= 1) {
+            this.expiring = null;
+        } else {
+            this.expiring = new it.unimi.dsi.fastutil.ints.IntList[updateLineOfSightInterval];
+            for (int i = 0; i < updateLineOfSightInterval; i++) {
+                this.expiring[i] = new it.unimi.dsi.fastutil.ints.IntArrayList(0);
+            }
+        }
+        // Gale end - Petal - reduce line of sight updates - expiring entity id lists
     }
 
     public void tick() {
+        if (this.expiring == null) { // Gale - Petal - reduce line of sight updates
         this.seen.clear();
-        this.unseen.clear();
+        // Gale start - Petal - reduce line of sight updates
+        } else {
+            var expiringNow = this.expiring[this.nextToExpireIndex];
+            expiringNow.forEach(this.seen::remove);
+            expiringNow.clear();
+            this.currentCacheAddIndex++;
+            if (this.currentCacheAddIndex == this.expiring.length) {
+                this.currentCacheAddIndex = 0;
+            }
+            this.nextToExpireIndex++;
+            if (this.nextToExpireIndex == this.expiring.length) {
+                this.nextToExpireIndex = 0;
+            }
+        }
+        // Gale end - Petal - reduce line of sight updates
     }
 
     public boolean hasLineOfSight(Entity entity) {
         int i = entity.getId();
-        if (this.seen.contains(i)) {
+        // Gale start - Petal - reduce line of sight cache lookups - merge sets
+        int cached = this.seen.get(i);
+        if (cached == 1) {
+            // Gale end - Petal - reduce line of sight cache lookups - merge sets
             return true;
-        } else if (this.unseen.contains(i)) {
+        } else if (cached == 2) { // Gale - Petal - reduce line of sight cache lookups - merge sets
             return false;
         } else {
             ProfilerFiller profilerFiller = Profiler.get();
@@ -33,10 +67,15 @@ public class Sensing {
             boolean bl = this.mob.hasLineOfSight(entity);
             profilerFiller.pop();
             if (bl) {
-                this.seen.add(i);
+                this.seen.put(i, 1); // Gale - Petal - reduce line of sight cache lookups - merge sets
             } else {
-                this.unseen.add(i);
+                this.seen.put(i, 2); // Gale - Petal - reduce line of sight cache lookups - merge sets
+            }
+            // Gale start - Petal - reduce line of sight updates
+            if (this.expiring != null) {
+                this.expiring[this.currentCacheAddIndex].add(i);
             }
+            // Gale end - Petal - reduce line of sight updates
 
             return bl;
         }
diff --git a/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java b/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java
index 8c4532a250f8679d729a35c17e9b5bd339264450..d2e65b6b06929c016aefb36de70391d25232e460 100644
--- a/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java
+++ b/src/main/java/net/minecraft/world/entity/animal/WaterAnimal.java
@@ -74,6 +74,6 @@ public abstract class WaterAnimal extends PathfinderMob {
         i = world.getMinecraftWorld().paperConfig().entities.spawning.wateranimalSpawnHeight.maximum.or(i);
         j = world.getMinecraftWorld().paperConfig().entities.spawning.wateranimalSpawnHeight.minimum.or(j);
         // Paper end - Make water animal spawn height configurable
-        return pos.getY() >= j && pos.getY() <= i && world.getFluidState(pos.below()).is(FluidTags.WATER) && world.getBlockState(pos.above()).is(Blocks.WATER);
+        return ((reason == EntitySpawnReason.SPAWNER && world.getMinecraftWorld().galeConfig().gameplayMechanics.fixes.mc238526) || (pos.getY() >= j && pos.getY() <= i)) && world.getFluidState(pos.below()).is(FluidTags.WATER) && world.getBlockState(pos.above()).is(Blocks.WATER); // Gale - Purpur - fix MC-238526
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
index 0f086af57a5ff08c264dcbf89a8c3931ec73a609..ca36be3c3189adc99ef04e4ce4307948adda1deb 100644
--- a/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
+++ b/src/main/java/net/minecraft/world/entity/item/ItemEntity.java
@@ -234,11 +234,31 @@ public class ItemEntity extends Entity implements TraceableEntity {
                 }
                 // CraftBukkit end
                 this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
+                return; // Gale - EMC - reduce hopper item checks
             }
+            this.markNearbyHopperCartsAsImmune(); // Gale - EMC - reduce hopper item checks
 
         }
     }
 
+    // Gale start - EMC - reduce hopper item checks
+    private void markNearbyHopperCartsAsImmune() {
+        var config = level().galeConfig().smallOptimizations.reducedIntervals.checkNearbyItem.hopper.minecart;
+        // No need to mark hopper minecarts as immune if they can pull every tick anyway
+        if (config.interval <= 1) {
+            return;
+        }
+        if (config.temporaryImmunity.duration > 0 && this.isAlive() && this.onGround && !this.isRemoved() && (config.temporaryImmunity.nearbyItemMaxAge == -1 || this.age <= config.temporaryImmunity.nearbyItemMaxAge) && this.age % Math.max(1, config.temporaryImmunity.checkForMinecartNearItemInterval) == 0 && config.temporaryImmunity.maxItemHorizontalDistance >= 0 && config.temporaryImmunity.maxItemVerticalDistance >= 0) {
+            net.minecraft.world.phys.AABB aabb = this.getBoundingBox().inflate(config.temporaryImmunity.maxItemHorizontalDistance, config.temporaryImmunity.maxItemVerticalDistance, config.temporaryImmunity.maxItemHorizontalDistance);
+            for (Entity entity : this.level().getEntities(this, aabb)) {
+                if (entity instanceof net.minecraft.world.entity.vehicle.MinecartHopper hopper) {
+                    hopper.pickupImmunity = MinecraftServer.currentTick + config.temporaryImmunity.duration;
+                }
+            }
+        }
+    }
+    // Gale end - EMC - reduce hopper item checks
+
     // Spigot start - copied from above
     @Override
     public void inactiveTick() {
@@ -259,7 +279,13 @@ public class ItemEntity extends Entity implements TraceableEntity {
             }
             // CraftBukkit end
             this.discard(EntityRemoveEvent.Cause.DESPAWN); // CraftBukkit - add Bukkit remove cause
+            return; // Gale - EMC - reduce hopper item checks
+        }
+        // Gale start - EMC - reduce hopper item checks
+        if (level().galeConfig().smallOptimizations.reducedIntervals.checkNearbyItem.hopper.minecart.temporaryImmunity.checkForMinecartNearItemWhileInactive) {
+            this.markNearbyHopperCartsAsImmune();
         }
+        // Gale end - EMC - reduce hopper item checks
     }
     // Spigot end
 
diff --git a/src/main/java/net/minecraft/world/entity/npc/Villager.java b/src/main/java/net/minecraft/world/entity/npc/Villager.java
index 2d8ba55906c8da16fde850e3412f4a6bda3d56e7..00d2741d33aa8e5947b44070075eaca4af572c71 100644
--- a/src/main/java/net/minecraft/world/entity/npc/Villager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/Villager.java
@@ -107,6 +107,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     private static final EntityDataAccessor<VillagerData> DATA_VILLAGER_DATA = SynchedEntityData.defineId(Villager.class, EntityDataSerializers.VILLAGER_DATA);
     public static final int BREEDING_FOOD_THRESHOLD = 12;
     public static final Map<Item, Integer> FOOD_POINTS = ImmutableMap.of(Items.BREAD, 4, Items.POTATO, 1, Items.CARROT, 1, Items.BEETROOT, 1);
+    public static final Item[] FOOD_POINTS_KEY_ARRAY = FOOD_POINTS.keySet().toArray(Item[]::new); // Gale - optimize villager data storage
     private static final int TRADES_PER_LEVEL = 2;
     private static final int MAX_GOSSIP_TOPICS = 10;
     private static final int GOSSIP_COOLDOWN = 1200;
@@ -884,7 +885,22 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     public boolean wantsToPickUp(ServerLevel world, ItemStack stack) {
         Item item = stack.getItem();
 
-        return (stack.is(ItemTags.VILLAGER_PICKS_UP) || this.getVillagerData().getProfession().requestedItems().contains(item)) && this.getInventory().canAddItem(stack);
+        // Gale start
+        if (stack.is(ItemTags.VILLAGER_PICKS_UP)) {
+            return this.getInventory().canAddItem(stack);
+        } else {
+            var a = this.getVillagerData().getProfession().requestedItems();
+            if (a == null) {
+                return false;
+            }
+            for (Item item1 : a) {
+                if (Objects.equals(item, item1)) {
+                    return this.getInventory().canAddItem(stack);
+                }
+            }
+            return false;
+        }
+        // Gale end
     }
 
     public boolean hasExcessFood() {
diff --git a/src/main/java/net/minecraft/world/entity/npc/VillagerProfession.java b/src/main/java/net/minecraft/world/entity/npc/VillagerProfession.java
index 8734ab1bd8299bbf43906d81a349c2a13e0981a7..fa84a4b23a52e60a61c2ee32c1ea449f6dbe0d2b 100644
--- a/src/main/java/net/minecraft/world/entity/npc/VillagerProfession.java
+++ b/src/main/java/net/minecraft/world/entity/npc/VillagerProfession.java
@@ -22,9 +22,9 @@ public record VillagerProfession(
     String name,
     Predicate<Holder<PoiType>> heldJobSite,
     Predicate<Holder<PoiType>> acquirableJobSite,
-    ImmutableSet<Item> requestedItems,
-    ImmutableSet<Block> secondaryPoi,
-    @Nullable SoundEvent workSound
+    @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.Nullable [] requestedItems, // Gale - optimize villager data storage
+    @org.jetbrains.annotations.Nullable Block secondaryPoi, // Gale - optimize villager data storage
+    @org.jetbrains.annotations.Nullable SoundEvent workSound // Gale - optimize villager data storage
 ) {
     public static final Predicate<Holder<PoiType>> ALL_ACQUIRABLE_JOBS = poiType -> poiType.is(PoiTypeTags.ACQUIRABLE_JOB_SITE);
     public static final VillagerProfession NONE = register("none", PoiType.NONE, ALL_ACQUIRABLE_JOBS, null);
@@ -35,8 +35,8 @@ public record VillagerProfession(
     public static final VillagerProfession FARMER = register(
         "farmer",
         PoiTypes.FARMER,
-        ImmutableSet.of(Items.WHEAT, Items.WHEAT_SEEDS, Items.BEETROOT_SEEDS, Items.BONE_MEAL),
-        ImmutableSet.of(Blocks.FARMLAND),
+        new Item[] {Items.WHEAT, Items.WHEAT_SEEDS, Items.BEETROOT_SEEDS, Items.BONE_MEAL}, // Gale - optimize villager data storage
+        Blocks.FARMLAND, // Gale - optimize villager data storage
         SoundEvents.VILLAGER_WORK_FARMER
     );
     public static final VillagerProfession FISHERMAN = register("fisherman", PoiTypes.FISHERMAN, SoundEvents.VILLAGER_WORK_FISHERMAN);
@@ -54,38 +54,40 @@ public record VillagerProfession(
         return this.name;
     }
 
-    private static VillagerProfession register(String id, ResourceKey<PoiType> heldWorkstation, @Nullable SoundEvent workSound) {
+    private static VillagerProfession register(String id, ResourceKey<PoiType> heldWorkstation, @org.jetbrains.annotations.Nullable SoundEvent workSound) {// Gale - optimize villager data storage
         return register(id, entry -> entry.is(heldWorkstation), entry -> entry.is(heldWorkstation), workSound);
     }
 
+    // Gale start - optimize villager data storage
     private static VillagerProfession register(
-        String id, Predicate<Holder<PoiType>> heldWorkstation, Predicate<Holder<PoiType>> acquirableWorkstation, @Nullable SoundEvent workSound
+        String id, Predicate<Holder<PoiType>> heldWorkstation, Predicate<Holder<PoiType>> acquirableWorkstation, @org.jetbrains.annotations.Nullable SoundEvent workSound
     ) {
-        return register(id, heldWorkstation, acquirableWorkstation, ImmutableSet.of(), ImmutableSet.of(), workSound);
+        return register(id, heldWorkstation, acquirableWorkstation, null, null, workSound);
     }
 
     private static VillagerProfession register(
         String id,
         ResourceKey<PoiType> heldWorkstation,
-        ImmutableSet<Item> gatherableItems,
-        ImmutableSet<Block> secondaryJobSites,
-        @Nullable SoundEvent workSound
+        @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.Nullable [] gatherableItems,
+        @org.jetbrains.annotations.Nullable Block secondaryJobSite,
+        @org.jetbrains.annotations.Nullable SoundEvent workSound
     ) {
-        return register(id, entry -> entry.is(heldWorkstation), entry -> entry.is(heldWorkstation), gatherableItems, secondaryJobSites, workSound);
+        return register(id, entry -> entry.is(heldWorkstation), entry -> entry.is(heldWorkstation), gatherableItems, secondaryJobSite, workSound);
     }
 
     private static VillagerProfession register(
         String id,
         Predicate<Holder<PoiType>> heldWorkstation,
         Predicate<Holder<PoiType>> acquirableWorkstation,
-        ImmutableSet<Item> gatherableItems,
-        ImmutableSet<Block> secondaryJobSites,
-        @Nullable SoundEvent workSound
+        @org.jetbrains.annotations.NotNull Item @org.jetbrains.annotations.Nullable [] gatherableItems,
+        @org.jetbrains.annotations.Nullable Block secondaryJobSite,
+        @org.jetbrains.annotations.Nullable SoundEvent workSound
     ) {
         return Registry.register(
             BuiltInRegistries.VILLAGER_PROFESSION,
             ResourceLocation.withDefaultNamespace(id),
-            new VillagerProfession(id, heldWorkstation, acquirableWorkstation, gatherableItems, secondaryJobSites, workSound)
+            new VillagerProfession(id, heldWorkstation, acquirableWorkstation, gatherableItems != null && gatherableItems.length == 0 ? null : gatherableItems, secondaryJobSite, workSound)
         );
+        // Gale end - optimize villager data storage
     }
 }
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index 110456deaa662bc1c0f6ba7878bb3074869a4350..3bb31e0da112f231c06c2577f5237d03a764333b 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -655,34 +655,25 @@ public class Inventory implements Container, Nameable {
     }
 
     public boolean contains(TagKey<Item> tag) {
-        Iterator iterator = this.compartments.iterator();
-
-        while (iterator.hasNext()) {
-            List<ItemStack> list = (List) iterator.next();
-            Iterator iterator1 = list.iterator();
-
-            while (iterator1.hasNext()) {
-                ItemStack itemstack = (ItemStack) iterator1.next();
-
+        // Leaf start
+        for (NonNullList<ItemStack> compartment : this.compartments) {
+            for (ItemStack itemstack : compartment) {
+        // Leaf end
                 if (!itemstack.isEmpty() && itemstack.is(tag)) {
                     return true;
                 }
             }
         }
 
+
         return false;
     }
 
     public boolean contains(Predicate<ItemStack> predicate) {
-        Iterator iterator = this.compartments.iterator();
-
-        while (iterator.hasNext()) {
-            List<ItemStack> list = (List) iterator.next();
-            Iterator iterator1 = list.iterator();
-
-            while (iterator1.hasNext()) {
-                ItemStack itemstack = (ItemStack) iterator1.next();
-
+        // Leaf start
+        for (NonNullList<ItemStack> compartment : this.compartments) {
+            for (ItemStack itemstack : compartment) {
+        // Leaf end
                 if (predicate.test(itemstack)) {
                     return true;
                 }
diff --git a/src/main/java/net/minecraft/world/entity/player/Player.java b/src/main/java/net/minecraft/world/entity/player/Player.java
index 5b8b85a295a08ae495f729c595b3a78778965342..c57e107a9f9ee03444a38c9bc56a1d4ab32274a9 100644
--- a/src/main/java/net/minecraft/world/entity/player/Player.java
+++ b/src/main/java/net/minecraft/world/entity/player/Player.java
@@ -210,6 +210,7 @@ public abstract class Player extends LivingEntity {
         return (CraftHumanEntity) super.getBukkitEntity();
     }
     // CraftBukkit end
+    public static int increaseTimeStatisticsInterval; // Gale - Hydrinity - increase time statistics in intervals - store as static field for fast access
 
     public Player(Level world, BlockPos pos, float yaw, GameProfile gameProfile) {
         super(EntityType.PLAYER, world);
@@ -297,19 +298,23 @@ public abstract class Player extends LivingEntity {
         this.moveCloak();
         if (this instanceof ServerPlayer entityplayer) {
             this.foodData.tick(entityplayer);
-            this.awardStat(Stats.PLAY_TIME);
-            this.awardStat(Stats.TOTAL_WORLD_TIME);
+            // Gale start - Hydrinity - increase time statistics in intervals
+            if (increaseTimeStatisticsInterval == 1 || this.tickCount % increaseTimeStatisticsInterval == 0) {
+            this.awardStat(Stats.PLAY_TIME, increaseTimeStatisticsInterval);
+            this.awardStat(Stats.TOTAL_WORLD_TIME, increaseTimeStatisticsInterval);
+            // Gale end - Hydrinity - increase time statistics in intervals
             if (this.isAlive()) {
-                this.awardStat(Stats.TIME_SINCE_DEATH);
+                this.awardStat(Stats.TIME_SINCE_DEATH, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
             }
 
             if (this.isDiscrete()) {
-                this.awardStat(Stats.CROUCH_TIME);
+                this.awardStat(Stats.CROUCH_TIME, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
             }
 
             if (!this.isSleeping()) {
-                this.awardStat(Stats.TIME_SINCE_REST);
+                this.awardStat(Stats.TIME_SINCE_REST, increaseTimeStatisticsInterval); // Gale - Hydrinity - increase time statistics in intervals
             }
+            } // Gale - Hydrinity - increase time statistics in intervals
         }
 
         int i = 29999999;
@@ -1856,6 +1861,11 @@ public abstract class Player extends LivingEntity {
     }
 
     public void causeFoodExhaustion(float f, EntityExhaustionEvent.ExhaustionReason reason) {
+        // Gale start - Mirai - fix MC-31819
+        if (this.level().galeConfig().gameplayMechanics.fixes.mc31819 && this.level().getDifficulty() == Difficulty.PEACEFUL) {
+            return;
+        }
+        // Gale end - Mirai - fix MC-31819
         // CraftBukkit end
         if (!this.abilities.invulnerable) {
             if (!this.level().isClientSide) {
diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
index f4513b1887f823b088dabe425be042b8fb2bde66..9cdb0d672a4de363d32646a22e567b9990a97dea 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -372,7 +372,7 @@ public abstract class AbstractArrow extends Projectile {
         Vec3 vec3d = this.getDeltaMovement();
 
         this.setDeltaMovement(vec3d.multiply((double) (this.random.nextFloat() * 0.2F), (double) (this.random.nextFloat() * 0.2F), (double) (this.random.nextFloat() * 0.2F)));
-        this.life = 0;
+        if (this.level().galeConfig().gameplayMechanics.arrowMovementResetsDespawnCounter) this.life = 0; // Gale - Purpur - make arrow movement resetting despawn counter configurable
     }
 
     public boolean isInGround() {
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java b/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
index 8a4e7e1c0c4919d2ee34121c14f9665b9ad95273..7bd7045128f1f55a687047eafd895971ec12e565 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FireworkRocketEntity.java
@@ -381,4 +381,11 @@ public class FireworkRocketEntity extends Projectile implements ItemSupplier {
 
         return DoubleDoubleImmutablePair.of(d0, d1);
     }
+
+    // Gale start - EMC - make saving fireworks configurable
+    @Override
+    public boolean shouldBeSaved() {
+        return this.level().galeConfig().smallOptimizations.saveFireworks;
+    }
+    // Gale end - EMC - make saving fireworks configurable
 }
diff --git a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
index 5e6ceb3c3728c0c08a516566c70a5c0d72d59196..2285a7de0833eae5689bea58851c5292b1471eb9 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/FishingHook.java
@@ -88,7 +88,7 @@ public class FishingHook extends Projectile {
 
     private FishingHook(EntityType<? extends FishingHook> type, Level world, int luckBonus, int waitTimeReductionTicks) {
         super(type, world);
-        this.syncronizedRandom = RandomSource.create();
+        this.syncronizedRandom = world.random; // Gale - Patina - reduce RandomSource instances
         this.openWater = true;
         this.currentState = FishingHook.FishHookState.FLYING;
         this.luck = Math.max(0, luckBonus);
diff --git a/src/main/java/net/minecraft/world/entity/raid/Raid.java b/src/main/java/net/minecraft/world/entity/raid/Raid.java
index 11cf2d9def087b0898c828eaa21eb5f7b8811d5f..3618bbf30d61d7d2c18b9da69125a5f7fefab939 100644
--- a/src/main/java/net/minecraft/world/entity/raid/Raid.java
+++ b/src/main/java/net/minecraft/world/entity/raid/Raid.java
@@ -112,10 +112,11 @@ public class Raid {
     private static final org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry PDC_TYPE_REGISTRY = new org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry();
     public final org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer persistentDataContainer = new org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer(PDC_TYPE_REGISTRY);
     // Paper end
+    private boolean isBarDirty; // Gale - Lithium - update boss bar within tick
 
     public Raid(int id, ServerLevel world, BlockPos pos) {
         this.raidEvent = new ServerBossEvent(Raid.RAID_NAME_COMPONENT, BossEvent.BossBarColor.RED, BossEvent.BossBarOverlay.NOTCHED_10);
-        this.random = RandomSource.create();
+        this.random = world.random; // Gale - Patina - reduce RandomSource instances
         this.waveSpawnPos = Optional.empty();
         this.id = id;
         this.level = world;
@@ -129,7 +130,7 @@ public class Raid {
 
     public Raid(ServerLevel world, CompoundTag nbt) {
         this.raidEvent = new ServerBossEvent(Raid.RAID_NAME_COMPONENT, BossEvent.BossBarColor.RED, BossEvent.BossBarOverlay.NOTCHED_10);
-        this.random = RandomSource.create();
+        this.random = world.random; // Gale - Patina - reduce RandomSource instances
         this.waveSpawnPos = Optional.empty();
         this.level = world;
         this.id = nbt.getInt("Id");
@@ -291,6 +292,12 @@ public class Raid {
     }
 
     public void tick() {
+        // Gale start - Lithium - update boss bar within tick
+        if (this.isBarDirty) {
+            this.updateBossbarInternal();
+            this.isBarDirty = false;
+        }
+        // Gale end - Lithium - update boss bar within tick
         if (!this.isStopped()) {
             if (this.status == Raid.RaidStatus.ONGOING) {
                 boolean flag = this.active;
@@ -652,6 +659,12 @@ public class Raid {
     }
 
     public void updateBossbar() {
+        // Gale start - Lithium - update boss bar within tick
+        this.isBarDirty = true;
+    }
+
+    private void updateBossbarInternal() {
+        // Gale end - Lithium - update boss bar within tick
         this.raidEvent.setProgress(Mth.clamp(this.getHealthOfLivingRaiders() / this.totalHealth, 0.0F, 1.0F));
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/MinecartHopper.java b/src/main/java/net/minecraft/world/entity/vehicle/MinecartHopper.java
index d81a6874e8b25f098df619f84c359e146c7f64de..7e262a1f960bfdca67042e4cf5eb131dd7dbfd55 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/MinecartHopper.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/MinecartHopper.java
@@ -20,6 +20,8 @@ import net.minecraft.world.level.block.state.properties.RailShape;
 
 public class MinecartHopper extends AbstractMinecartContainer implements Hopper {
     private boolean enabled = true;
+    public int pickupImmunity = 0; // Gale - EMC - reduce hopper item checks
+
     private boolean consumedItemThisFrame = false;
 
     public MinecartHopper(EntityType<? extends MinecartHopper> type, Level world) {
@@ -149,4 +151,12 @@ public class MinecartHopper extends AbstractMinecartContainer implements Hopper
     }
     // Paper end
 
+    // Gale start - EMC - reduce hopper item checks
+    private long tickAttempts = 0;
+    @Override
+    public long getAndIncrementAttemptCounter() {
+        return tickAttempts++;
+    }
+    // Gale end EMC - - reduce hopper item checks
+
 }
diff --git a/src/main/java/net/minecraft/world/item/EndCrystalItem.java b/src/main/java/net/minecraft/world/item/EndCrystalItem.java
index b62db8c7c8c57e43869ee239ebf4b02f112355d9..9f92b9addaedb4bae06b32226a74c8e5ddc6c2a2 100644
--- a/src/main/java/net/minecraft/world/item/EndCrystalItem.java
+++ b/src/main/java/net/minecraft/world/item/EndCrystalItem.java
@@ -55,11 +55,13 @@ public class EndCrystalItem extends Item {
                         // CraftBukkit end
                         world.addFreshEntity(entityendercrystal);
                         world.gameEvent((Entity) context.getPlayer(), (Holder) GameEvent.ENTITY_PLACE, blockposition1);
+                        if (world.galeConfig().gameplayMechanics.tryRespawnEnderDragonAfterEndCrystalPlace) { // Gale - Pufferfish - make ender dragon respawn attempt after placing end crystals configurable
                         EndDragonFight enderdragonbattle = ((ServerLevel) world).getDragonFight();
 
                         if (enderdragonbattle != null) {
                             enderdragonbattle.tryRespawn(aboveBlockPosition); // Paper - Perf: Do crystal-portal proximity check before entity lookup
                         }
+                        } // Gale - Pufferfish - make ender dragon respawn attempt after placing end crystals configurable
                     }
 
                     context.getItemInHand().shrink(1);
diff --git a/src/main/java/net/minecraft/world/item/ItemStack.java b/src/main/java/net/minecraft/world/item/ItemStack.java
index f29415b8dff7d17328e159b56ae4ad46452f018e..d72c312562c42695536e377228474ee69152a2aa 100644
--- a/src/main/java/net/minecraft/world/item/ItemStack.java
+++ b/src/main/java/net/minecraft/world/item/ItemStack.java
@@ -926,7 +926,7 @@ public final class ItemStack implements DataComponentHolder {
     }
 
     public static boolean matches(ItemStack left, ItemStack right) {
-        return left == right ? true : (left.getCount() != right.getCount() ? false : ItemStack.isSameItemSameComponents(left, right));
+        return left == right || (left.getCount() == right.getCount() && ItemStack.isSameItemSameComponents(left, right)); // Gale - optimize identical item checks
     }
 
     /** @deprecated */
@@ -946,11 +946,11 @@ public final class ItemStack implements DataComponentHolder {
     }
 
     public static boolean isSameItem(ItemStack left, ItemStack right) {
-        return left.is(right.getItem());
+        return left == right || left.is(right.getItem()); // Gale - optimize identical item checks
     }
 
     public static boolean isSameItemSameComponents(ItemStack stack, ItemStack otherStack) {
-        return !stack.is(otherStack.getItem()) ? false : (stack.isEmpty() && otherStack.isEmpty() ? true : Objects.equals(stack.components, otherStack.components));
+        return stack == otherStack || (stack.is(otherStack.getItem()) && (stack.isEmpty() && otherStack.isEmpty() || Objects.equals(stack.components, otherStack.components))); // Gale - optimize identical item checks
     }
 
     public static MapCodec<ItemStack> lenientOptionalFieldOf(String fieldName) {
diff --git a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
index 3527f1621ef9b4f3f8d8bbb93379f13ff141c3be..4e4dfb72d5a0b46917999b709c655ccfdae27183 100644
--- a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
+++ b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
@@ -15,8 +15,17 @@ public class EntityBasedExplosionDamageCalculator extends ExplosionDamageCalcula
 
     @Override
     public Optional<Float> getBlockExplosionResistance(Explosion explosion, BlockGetter world, BlockPos pos, BlockState blockState, FluidState fluidState) {
-        return super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState)
-            .map(max -> this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, max));
+        // Gale start - Lithium - reduce lambda and Optional allocation in EntityBasedExplosionDamageCalculator
+        Optional<Float> optionalBlastResistance = super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState);
+        if (optionalBlastResistance.isPresent()) {
+            float blastResistance = optionalBlastResistance.get();
+            float effectiveExplosionResistance = this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, blastResistance);
+            if (effectiveExplosionResistance != blastResistance) {
+                return Optional.of(effectiveExplosionResistance);
+            }
+        }
+        return optionalBlastResistance;
+        // Gale end - Lithium - reduce lambda and Optional allocation in EntityBasedExplosionDamageCalculator
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/GameRules.java b/src/main/java/net/minecraft/world/level/GameRules.java
index 7c363d59c6567cae8e6caf213be51804efa5a96d..43d31e45f47f390a87be66a6fc8c95eb0d17a87f 100644
--- a/src/main/java/net/minecraft/world/level/GameRules.java
+++ b/src/main/java/net/minecraft/world/level/GameRules.java
@@ -168,7 +168,7 @@ public class GameRules {
     }
 
     private GameRules(Map<GameRules.Key<?>, GameRules.Value<?>> rules, FeatureFlagSet enabledFeatures) {
-        this.rules = rules;
+        this.rules = new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(rules); // Gale - Lithium - replace game rules map with optimized collection
         this.enabledFeatures = enabledFeatures;
 
         // Paper start - Perf: Use array for gamerule storage
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 27f9d167b5ae9ce5117798ea44324107df59425f..9ff1eb693eddf5c9994b2f9ebee74073a95c0e8c 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -173,6 +173,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return this.paperConfig;
     }
     // Paper end - add paper world config
+    // Gale start - Gale configuration
+    private final org.galemc.gale.configuration.GaleWorldConfiguration galeConfig;
+    public org.galemc.gale.configuration.GaleWorldConfiguration galeConfig() {
+        return this.galeConfig;
+    }
+    // Gale end - Gale configuration
 
     public final com.destroystokyo.paper.antixray.ChunkPacketBlockController chunkPacketBlockController; // Paper - Anti-Xray
     public static BlockPos lastPhysicsProblem; // Spigot
@@ -831,7 +837,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
     // Paper end - optimise random ticking
 
-    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - create paper world config & Anti-Xray
+    protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator,java.util.function.Function<org.spigotmc.SpigotWorldConfig, org.galemc.gale.configuration.GaleWorldConfiguration> galeWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - create paper world config & Anti-Xray // Gale - Gale configuration
         // Paper start - getblock optimisations - cache world height/sections
         final DimensionType dimType = holder.value();
         this.minY = dimType.minY();
@@ -843,6 +849,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         // Paper end - getblock optimisations - cache world height/sections
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper - create paper world config
+        this.galeConfig = galeWorldConfigCreator.apply(this.spigotConfig); // Gale - Gale configuration
         this.generator = gen;
         this.world = new CraftWorld((ServerLevel) this, gen, biomeProvider, env);
 
diff --git a/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java b/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
index 2039b16e5e9bc0797b3f31081d221bb8b34a4dc7..ceab64ea37f69c254680a8bdd6d2a596d94cb7dc 100644
--- a/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
+++ b/src/main/java/net/minecraft/world/level/LocalMobCapCalculator.java
@@ -42,14 +42,14 @@ public class LocalMobCapCalculator {
     }
 
     static class MobCounts {
-        private final Object2IntMap<MobCategory> counts = new Object2IntOpenHashMap<>(MobCategory.values().length);
+        public final int[] counts = new int[MobCategory.values().length]; // Gale - VMP - store mob counts in an array
 
         public void add(MobCategory spawnGroup) {
-            this.counts.computeInt(spawnGroup, (group, density) -> density == null ? 1 : density + 1);
+            this.counts[spawnGroup.ordinal()]++; // Gale - VMP - store mob counts in an array
         }
 
         public boolean canSpawn(MobCategory spawnGroup) {
-            return this.counts.getOrDefault(spawnGroup, 0) < spawnGroup.getMaxInstancesPerChunk();
+            return this.counts[spawnGroup.ordinal()] < spawnGroup.getMaxInstancesPerChunk(); // Gale - VMP - store mob counts in an array
         }
     }
 }
diff --git a/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
index 02fc9ce21c7d367055da350d21be4870d4242f3a..29a3e1dc6dd7b48345ba950a0cdc9a7e89c55806 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/BrewingStandBlockEntity.java
@@ -48,6 +48,7 @@ public class BrewingStandBlockEntity extends BaseContainerBlockEntity implements
     public static final int DATA_BREW_TIME = 0;
     public static final int DATA_FUEL_USES = 1;
     public static final int NUM_DATA_VALUES = 2;
+    private static final String[] INGREDIENT_NBT_KEYS = {"Gale.Ingredient", "Mirai.ingredient"}; // Gale - Mirai - fix MC-26304
     private NonNullList<ItemStack> items;
     public int brewTime;
     public int recipeBrewTime = 400; // Paper - Add recipeBrewTime
@@ -314,6 +315,26 @@ public class BrewingStandBlockEntity extends BaseContainerBlockEntity implements
         }
 
         this.fuel = nbt.getByte("Fuel");
+        // Gale start - Mirai - fix MC-26304
+        if (this.ingredient == null || this.ingredient == Items.AIR) {
+            for (String nbtKey : INGREDIENT_NBT_KEYS) {
+                try {
+                    if (nbt.contains(nbtKey)) {
+                        var x = net.minecraft.core.registries.BuiltInRegistries.ITEM.get(net.minecraft.resources.ResourceLocation.parse(nbt.getString(nbtKey)));
+
+                        if (x.isPresent()) {
+                            this.ingredient = x.get().value();
+                            if (this.ingredient != Items.AIR) {
+                                break;
+                            }
+                        }
+                    }
+                } catch (Throwable ignored) {
+                    // Cannot be helped
+                }
+            }
+        }
+        // Gale end - Mirai - fix MC-26304
     }
 
     @Override
@@ -322,6 +343,18 @@ public class BrewingStandBlockEntity extends BaseContainerBlockEntity implements
         nbt.putShort("BrewTime", (short) this.brewTime);
         ContainerHelper.saveAllItems(nbt, this.items, registries);
         nbt.putByte("Fuel", (byte) this.fuel);
+        // Gale start - Mirai - fix MC-26304
+        if (this.ingredient != null && this.ingredient != Items.AIR) {
+            try {
+                String value = net.minecraft.core.registries.BuiltInRegistries.ITEM.getKey(this.ingredient).toString();
+                for (String nbtKey : INGREDIENT_NBT_KEYS) {
+                    nbt.putString(nbtKey, value);
+                }
+            } catch (Throwable ignored) {
+                // Cannot be helped
+            }
+        }
+        // Gale end - Mirai - fix MC-26304
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/entity/Hopper.java b/src/main/java/net/minecraft/world/level/block/entity/Hopper.java
index 5f042e294db605827000123252b0df646968f897..e1cc15f28fe8da23b74ff4504c5b2da2236fda3f 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/Hopper.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/Hopper.java
@@ -11,6 +11,8 @@ public interface Hopper extends Container {
         return SUCK_AABB;
     }
 
+    long getAndIncrementAttemptCounter(); // Gale - EMC - reduce hopper item checks
+
     double getLevelX();
 
     double getLevelY();
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index 5ebbdb94d9b91c442ff60eb6872f740ebd790fa0..aa55698303f7ffc6542f34311234be6c6b400a9d 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -568,7 +568,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
         } else {
             boolean flag = hopper.isGridAligned() && iblockdata.isCollisionShapeFullBlock(world, blockposition) && !iblockdata.is(BlockTags.DOES_NOT_BLOCK_HOPPERS);
 
-            if (!flag) {
+            if (!flag && shouldSuckIn(world, hopper)) { // Gale - EMC - reduce hopper item checks
                 Iterator iterator = HopperBlockEntity.getItemsAtAndAbove(world, hopper).iterator();
 
                 while (iterator.hasNext()) {
@@ -882,6 +882,31 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
         return first.getCount() < first.getMaxStackSize() && ItemStack.isSameItemSameComponents(first, second); // Paper - Perf: Optimize Hoppers; used to return true for full itemstacks?!
     }
 
+    // Gale start - EMC - reduce hopper item checks
+    private long tickAttempts = 0;
+    @Override
+    public long getAndIncrementAttemptCounter() {
+        return tickAttempts++;
+    }
+    private static boolean shouldSuckIn(Level world, Hopper hopper) {
+        int suckInterval;
+        if (hopper instanceof net.minecraft.world.entity.vehicle.MinecartHopper minecartHopper) {
+            if (minecartHopper.pickupImmunity > net.minecraft.server.MinecraftServer.currentTick) {
+                return true;
+            }
+            suckInterval = world.galeConfig().smallOptimizations.reducedIntervals.checkNearbyItem.hopper.minecart.interval;
+        } else {
+            suckInterval = world.galeConfig().smallOptimizations.reducedIntervals.checkNearbyItem.hopper.interval;
+        }
+        if (suckInterval <= 1) {
+            return true;
+        }
+
+        final int hopperId = (int) hopper.getLevelX() + (int) hopper.getLevelY() + (int) hopper.getLevelZ();
+        return (hopper.getAndIncrementAttemptCounter() + hopperId) % suckInterval == 0;
+    }
+    // Gale end - EMC - reduce hopper item checks
+
     @Override
     public double getLevelX() {
         return (double) this.worldPosition.getX() + 0.5D;
diff --git a/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
index 68fd5d3f6553af8af867e34946cb8b3f852da985..c8d2a0ae9da26fb5a3c73ec3388ec503122b4af3 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
@@ -268,7 +268,7 @@ public class TheEndGatewayBlockEntity extends TheEndPortalBlockEntity {
     }
 
     private static void spawnGatewayPortal(ServerLevel world, BlockPos pos, EndGatewayConfiguration config) {
-        Feature.END_GATEWAY.place(config, world, world.getChunkSource().getGenerator(), RandomSource.create(), pos);
+        Feature.END_GATEWAY.place(config, world, world.getChunkSource().getGenerator(), world.random, pos); // Gale - Patina - reduce RandomSource instances
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java b/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
index acae3eb30e0689048937f479dc3070f0688abdad..4b79f0474a9013dd4fdb68c6363ca1942ba8b007 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PaletteResize.java
@@ -1,5 +1,5 @@
 package net.minecraft.world.level.chunk;
 
-interface PaletteResize<T> {
+public interface PaletteResize<T> {  // Gale - Lithium - faster chunk serialization - package -> public
     int onResize(int newBits, T object);
 }
diff --git a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
index 8b84bf2272556ac3321cbf16361d7f48a1cc6873..5dfce8eb4d5a3cc6e8564d648e1cd86bfc7feeee 100644
--- a/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
+++ b/src/main/java/net/minecraft/world/level/chunk/PalettedContainer.java
@@ -25,6 +25,22 @@ import net.minecraft.util.ThreadingDetector;
 import net.minecraft.util.ZeroBitStorage;
 
 public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainerRO<T> {
+
+    // Gale start - Lithium - faster chunk serialization
+    private static final ThreadLocal<short[]> CACHED_ARRAY_4096 = ThreadLocal.withInitial(() -> new short[4096]);
+    private static final ThreadLocal<short[]> CACHED_ARRAY_64 = ThreadLocal.withInitial(() -> new short[64]);
+    private Optional<LongStream> asOptional(long[] data) {
+        return Optional.of(Arrays.stream(data));
+    }
+    private short[] getOrCreate(int size) {
+        return switch (size) {
+            case 64 -> CACHED_ARRAY_64.get();
+            case 4096 -> CACHED_ARRAY_4096.get();
+            default -> new short[size];
+        };
+    }
+    // Gale end - Lithium - faster chunk serialization
+
     private static final int MIN_PALETTE_BITS = 0;
     private final PaletteResize<T> dummyPaletteResize = (newSize, added) -> 0;
     public final IdMap<T> registry;
@@ -348,28 +364,54 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
     public synchronized PalettedContainerRO.PackedData<T> pack(IdMap<T> idList, PalettedContainer.Strategy paletteProvider) { // Paper - synchronize
         this.acquire();
 
-        PalettedContainerRO.PackedData var12;
+        // Gale start - Lithium - faster chunk serialization
+        Optional<LongStream> data = Optional.empty();
+        List<T> elements = null;
         try {
-            HashMapPalette<T> hashMapPalette = new HashMapPalette<>(idList, this.data.storage.getBits(), this.dummyPaletteResize);
-            int i = paletteProvider.size();
-            int[] is = new int[i];
-            this.data.storage.unpack(is);
-            swapPalette(is, id -> hashMapPalette.idFor(this.data.palette.valueFor(id)));
-            int j = paletteProvider.calculateBitsForSerialization(idList, hashMapPalette.getSize());
-            Optional<LongStream> optional;
-            if (j != 0) {
-                SimpleBitStorage simpleBitStorage = new SimpleBitStorage(j, i, is);
-                optional = Optional.of(Arrays.stream(simpleBitStorage.getRaw()));
-            } else {
-                optional = Optional.empty();
+            // The palette that will be serialized
+            net.caffeinemc.mods.lithium.common.world.chunk.LithiumHashPalette<T> hashPalette = null;
+
+            final Palette<T> palette = this.data.palette();
+            final BitStorage storage = this.data.storage();
+            if (storage instanceof ZeroBitStorage || palette.getSize() == 1) {
+                // If the palette only contains one entry, don't attempt to repack it.
+                elements = List.of(palette.valueFor(0));
+            } else if (palette instanceof net.caffeinemc.mods.lithium.common.world.chunk.LithiumHashPalette<T> lithiumHashPalette) {
+                hashPalette = lithiumHashPalette;
             }
 
-            var12 = new PalettedContainerRO.PackedData<>(hashMapPalette.getEntries(), optional);
+            if (elements == null) {
+                net.caffeinemc.mods.lithium.common.world.chunk.LithiumHashPalette<T> compactedPalette = new net.caffeinemc.mods.lithium.common.world.chunk.LithiumHashPalette<>(idList, storage.getBits(), this.dummyPaletteResize);
+                short[] array = this.getOrCreate(paletteProvider.size());
+
+                storage.compact(this.data.palette(), compactedPalette, array);
+
+                // If the palette didn't change during compaction, do a simple copy of the data array
+                if (hashPalette != null && hashPalette.getSize() == compactedPalette.getSize() && storage.getBits() == paletteProvider.calculateBitsForSerialization(idList, hashPalette.getSize())) { // paletteSize can de-sync from palette - see https://github.com/CaffeineMC/lithium-fabric/issues/279
+                    data = this.asOptional(storage.getRaw().clone());
+                    elements = hashPalette.getElements();
+                } else {
+                    int bits = paletteProvider.calculateBitsForSerialization(idList, compactedPalette.getSize());
+                    if (bits != 0) {
+                        // Re-pack the integer array as the palette has changed size
+                        SimpleBitStorage copy = new SimpleBitStorage(bits, array.length);
+                        for (int i = 0; i < array.length; ++i) {
+                            copy.set(i, array[i]);
+                        }
+
+                        // We don't need to clone the data array as we are the sole owner of it
+                        data = this.asOptional(copy.getRaw());
+                    }
+
+                    elements = compactedPalette.getElements();
+                }
+            }
         } finally {
             this.release();
         }
 
-        return var12;
+        return new PalettedContainerRO.PackedData<>(elements, data);
+        // Gale end - Lithium - faster chunk serialization
     }
 
     private static <T> void swapPalette(int[] is, IntUnaryOperator applier) {
@@ -409,13 +451,35 @@ public class PalettedContainer<T> implements PaletteResize<T>, PalettedContainer
 
     @Override
     public void count(PalettedContainer.CountConsumer<T> counter) {
-        if (this.data.palette.getSize() == 1) {
-            counter.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
-        } else {
-            Int2IntOpenHashMap int2IntOpenHashMap = new Int2IntOpenHashMap();
-            this.data.storage.getAll(key -> int2IntOpenHashMap.addTo(key, 1));
-            int2IntOpenHashMap.int2IntEntrySet().forEach(entry -> counter.accept(this.data.palette.valueFor(entry.getIntKey()), entry.getIntValue()));
+        // Gale start - Lithium - faster chunk serialization
+        int len = this.data.palette().getSize();
+
+        // Do not allocate huge arrays if we're using a large palette
+        if (len > 4096) {
+            // VanillaCopy
+            if (this.data.palette.getSize() == 1) {
+                counter.accept(this.data.palette.valueFor(0), this.data.storage.getSize());
+            } else {
+                Int2IntOpenHashMap int2IntOpenHashMap = new Int2IntOpenHashMap();
+                this.data.storage.getAll((key) -> {
+                    int2IntOpenHashMap.addTo(key, 1);
+                });
+                int2IntOpenHashMap.int2IntEntrySet().forEach((entry) -> counter.accept(this.data.palette.valueFor(entry.getIntKey()), entry.getIntValue()));
+            }
+        }
+
+        short[] counts = new short[len];
+
+        this.data.storage().getAll(i -> counts[i]++);
+
+        for (int i = 0; i < counts.length; i++) {
+            T obj = this.data.palette().valueFor(i);
+
+            if (obj != null) {
+                counter.accept(obj, counts[i]);
+            }
         }
+        // Gale end - Lithium - faster chunk serialization
     }
 
     static record Configuration<T>(Palette.Factory factory, int bits) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
index 16f07007a0f73ec0c6f421c9b082518e87e8cc7b..b26a5b76cd30c96ce15ced5ac51222a8333bde52 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFile.java
@@ -109,7 +109,7 @@ public class RegionFile implements AutoCloseable, ca.spottedleaf.moonrise.patche
     }
 
     private void backupRegionFile() {
-        Path backup = this.path.getParent().resolve(this.path.getFileName() + "." + new java.util.Random().nextLong() + ".backup");
+        Path backup = this.path.getParent().resolve(this.path.getFileName() + "." + new org.galemc.gale.random.XorShiftRandom().nextLong() + ".backup"); // Gale - xor-shift random
         this.backupRegionFile(backup);
     }
 
diff --git a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index e40665cead218502b44dd49051a53326ed94f061..cbeebb98622025d35557125e784cd8f0b4fbb751 100644
--- a/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/src/main/java/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -289,7 +289,13 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
 
     // Paper start
     private static void printOversizedLog(String msg, Path file, int x, int z) {
-        org.apache.logging.log4j.LogManager.getLogger().fatal(msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PAPER - You may ask for help on Discord, but do not file an issue. These error messages can not be removed.");
+        // Gale start - branding changes
+        /*
+        We do not want people to report thread issues to Paper,
+        but we do want people to report thread issues to Gale.
+        */
+        org.apache.logging.log4j.LogManager.getLogger().fatal(msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PAPER OR GALE - You may ask for help on Discord, but do not file an issue. These error messages can not be removed. - If you think this is a Gale bug, please report it at https://github.com/GaleMC/Gale/issues)");
+        // Gale end - branding changes
     }
 
     private static CompoundTag readOversizedChunk(RegionFile regionfile, ChunkPos chunkCoordinate) throws IOException {
diff --git a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
index b331c93c82c27f9456fec208a0c008c5bedfa8c4..3a015cc92b3d9cf869bd1e4c48e0831d40e41b85 100644
--- a/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
+++ b/src/main/java/net/minecraft/world/level/dimension/end/EndDragonFight.java
@@ -475,7 +475,7 @@ public class EndDragonFight {
         this.level.registryAccess().lookup(Registries.CONFIGURED_FEATURE).flatMap((iregistry) -> {
             return iregistry.get(EndFeatures.END_GATEWAY_DELAYED);
         }).ifPresent((holder_c) -> {
-            ((ConfiguredFeature) holder_c.value()).place(this.level, this.level.getChunkSource().getGenerator(), RandomSource.create(), pos);
+            ((ConfiguredFeature) holder_c.value()).place(this.level, this.level.getChunkSource().getGenerator(), this.level.random, pos); // Gale - Patina - reduce RandomSource instances
         });
     }
 
@@ -493,7 +493,7 @@ public class EndDragonFight {
             this.portalLocation = this.portalLocation.atY(this.level.getMinY() + 1);
         }
         // Paper end - Prevent "softlocked" exit portal generation
-        if (worldgenendtrophy.place(FeatureConfiguration.NONE, this.level, this.level.getChunkSource().getGenerator(), RandomSource.create(), this.portalLocation)) {
+        if (worldgenendtrophy.place(FeatureConfiguration.NONE, this.level, this.level.getChunkSource().getGenerator(), this.level.random, this.portalLocation)) { // Gale - Patina - reduce RandomSource instances
             int i = Mth.positiveCeilDiv(4, 16);
 
             this.level.getChunkSource().chunkMap.waitForLightBeforeSending(new ChunkPos(this.portalLocation), i);
diff --git a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
index 3f39d6c786d9dfdd9ad591e08ff05fcbb41a1df6..aa63b49738ef42122e7cd0f9dbec0d019c9b97b0 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/NoiseBasedChunkGenerator.java
@@ -61,12 +61,17 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
     private static final BlockState AIR = Blocks.AIR.defaultBlockState();
     public final Holder<NoiseGeneratorSettings> settings;
     private final Supplier<Aquifer.FluidPicker> globalFluidPicker;
+    private int cachedSeaLevel; // Gale - Lithium - cache world generator sea level
 
     public NoiseBasedChunkGenerator(BiomeSource biomeSource, Holder<NoiseGeneratorSettings> settings) {
         super(biomeSource);
         this.settings = settings;
         this.globalFluidPicker = Suppliers.memoize(() -> {
-            return NoiseBasedChunkGenerator.createFluidPicker((NoiseGeneratorSettings) settings.value());
+            // Gale start - Lithium - cache world generator sea level
+            var fluidPicker = NoiseBasedChunkGenerator.createFluidPicker((NoiseGeneratorSettings) settings.value());
+            this.cachedSeaLevel = settings.value().seaLevel();
+            return fluidPicker;
+            // Gale end - Lithium - cache world generator sea level
         });
     }
 
@@ -409,7 +414,7 @@ public final class NoiseBasedChunkGenerator extends ChunkGenerator {
 
     @Override
     public int getSeaLevel() {
-        return ((NoiseGeneratorSettings) this.settings.value()).seaLevel();
+        return this.cachedSeaLevel; // Gale - Lithium - cache world generator sea level
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java b/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java
index 021221da5d0315f6e371380a705ac6b3f6ac18d3..997f80d332b95bb011cbbc27c065b2811a2dddc7 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/PhantomSpawner.java
@@ -70,7 +70,15 @@ public class PhantomSpawner implements CustomSpawner {
 
                                     if (randomsource.nextInt(j) >= world.paperConfig().entities.behavior.playerInsomniaStartTicks) { // Paper - Ability to control player's insomnia and phantoms
                                         BlockPos blockposition1 = blockposition.above(20 + randomsource.nextInt(15)).east(-10 + randomsource.nextInt(21)).south(-10 + randomsource.nextInt(21));
-                                        BlockState iblockdata = world.getBlockState(blockposition1);
+                                        // Gale start - MultiPaper - don't load chunks to spawn phantoms
+                                        BlockState iblockdata;
+                                        if (world.galeConfig().smallOptimizations.loadChunks.toSpawnPhantoms) {
+                                            iblockdata = world.getBlockState(blockposition1);
+                                        } else {
+                                            iblockdata = world.getBlockStateIfLoaded(blockposition1);
+                                            if (iblockdata == null) continue;
+                                        }
+                                        // Gale end - MultiPaper - don't load chunks to spawn phantoms
                                         FluidState fluid = world.getFluidState(blockposition1);
 
                                         if (NaturalSpawner.isValidEmptySpawnBlock(world, blockposition1, iblockdata, fluid, EntityType.PHANTOM)) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/SurfaceRules.java b/src/main/java/net/minecraft/world/level/levelgen/SurfaceRules.java
index 7174613ef2cac0f27c72dcfa2f822199ffbc79e5..38428ba2c522108f4f9f7986bc3535d1232ac1f8 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/SurfaceRules.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/SurfaceRules.java
@@ -177,10 +177,10 @@ public class SurfaceRules {
         }
 
         @Override
-        public SurfaceRules.Condition apply(SurfaceRules.Context context) {
+        public SurfaceRules.Condition apply(SurfaceRules.Context givenContext) { // Gale - dev import deobfuscation fixes
             class BiomeCondition extends SurfaceRules.LazyYCondition {
                 BiomeCondition() {
-                    super(context);
+                    super(givenContext); // Gale - dev import deobfuscation fixes
                 }
 
                 @Override
@@ -522,12 +522,14 @@ public class SurfaceRules {
         }
 
         @Override
-        public SurfaceRules.Condition apply(SurfaceRules.Context context) {
-            final NormalNoise normalNoise = context.randomState.getOrCreateNoise(this.noise);
+        // Gale start - dev import deobfuscation fixes
+        public SurfaceRules.Condition apply(SurfaceRules.Context givenContext) {
+            final NormalNoise normalNoise = givenContext.randomState.getOrCreateNoise(this.noise);
+            // Gale end - dev import deobfuscation fixes
 
             class NoiseThresholdCondition extends SurfaceRules.LazyXZCondition {
                 NoiseThresholdCondition() {
-                    super(context);
+                    super(givenContext); // Gale - dev import deobfuscation fixes
                 }
 
                 @Override
@@ -663,12 +665,12 @@ public class SurfaceRules {
         }
 
         @Override
-        public SurfaceRules.Condition apply(SurfaceRules.Context context) {
+        public SurfaceRules.Condition apply(SurfaceRules.Context givenContext) { // Gale - dev import deobfuscation fixes
             final boolean bl = this.surfaceType == CaveSurface.CEILING;
 
             class StoneDepthCondition extends SurfaceRules.LazyYCondition {
                 StoneDepthCondition() {
-                    super(context);
+                    super(givenContext); // Gale - dev import deobfuscation fixes
                 }
 
                 @Override
@@ -756,26 +758,32 @@ public class SurfaceRules {
         }
 
         @Override
-        public SurfaceRules.Condition apply(SurfaceRules.Context context) {
-            final int i = this.trueAtAndBelow().resolveY(context.context);
-            final int j = this.falseAtAndAbove().resolveY(context.context);
-            final PositionalRandomFactory positionalRandomFactory = context.randomState.getOrCreateRandomFactory(this.randomName());
+        // Gale start - dev import deobfuscation fixes
+        public SurfaceRules.Condition apply(SurfaceRules.Context givenContext) {
+            final int i = this.trueAtAndBelow().resolveY(givenContext.context);
+            final int j = this.falseAtAndAbove().resolveY(givenContext.context);
+            final PositionalRandomFactory positionalRandomFactory = givenContext.randomState.getOrCreateRandomFactory(this.randomName());
+            // Gale end - dev import deobfuscation fixes
 
             class VerticalGradientCondition extends SurfaceRules.LazyYCondition {
                 VerticalGradientCondition() {
-                    super(context);
+                    super(givenContext); // Gale - dev import deobfuscation fixes
                 }
 
                 @Override
                 protected boolean compute() {
-                    int i = this.context.blockY;
-                    if (i <= i) {
+                    // Gale start - dev import deobfuscation fixes
+                    int i2 = this.context.blockY;
+                    if (i2 <= i) {
+                        // Gale end - dev import deobfuscation fixes
                         return true;
-                    } else if (i >= j) {
+                    } else if (i2 >= j) { // Gale - dev import deobfuscation fixes
                         return false;
                     } else {
-                        double d = Mth.map((double)i, (double)i, (double)j, 1.0, 0.0);
-                        RandomSource randomSource = positionalRandomFactory.at(this.context.blockX, i, this.context.blockZ);
+                        // Gale start - dev import deobfuscation fixes
+                        double d = Mth.map((double)i2, (double)i, (double)j, 1.0, 0.0);
+                        RandomSource randomSource = positionalRandomFactory.at(this.context.blockX, i2, this.context.blockZ);
+                        // Gale end - dev import deobfuscation fixes
                         return (double)randomSource.nextFloat() < d;
                     }
                 }
@@ -803,10 +811,10 @@ public class SurfaceRules {
         }
 
         @Override
-        public SurfaceRules.Condition apply(SurfaceRules.Context context) {
+        public SurfaceRules.Condition apply(SurfaceRules.Context givenContext) { // Gale - dev import deobfuscation fixes
             class WaterCondition extends SurfaceRules.LazyYCondition {
                 WaterCondition() {
-                    super(context);
+                    super(givenContext); // Gale - dev import deobfuscation fixes
                 }
 
                 @Override
@@ -841,10 +849,10 @@ public class SurfaceRules {
         }
 
         @Override
-        public SurfaceRules.Condition apply(SurfaceRules.Context context) {
+        public SurfaceRules.Condition apply(SurfaceRules.Context givenContext) { // Gale - dev import deobfuscation fixes
             class YCondition extends SurfaceRules.LazyYCondition {
                 YCondition() {
-                    super(context);
+                    super(givenContext); // Gale - dev import deobfuscation fixes
                 }
 
                 @Override
diff --git a/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java b/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java
index d058e71d6047bbd9256f6c71bb21966cfc056a7d..079edef073e751f38063b42515df893cecd2fcc4 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/blending/Blender.java
@@ -146,7 +146,7 @@ public class Blender {
     private static double heightToOffset(double height) {
         double d = 1.0;
         double e = height + 0.5;
-        double f = Mth.positiveModulo(e, 8.0);
+        double f = Mth.positiveModuloForPositiveIntegerDivisor(e, 8.0); // Gale - faster floating-point positive modulo
         return 1.0 * (32.0 * (e - 128.0) - 3.0 * (e - 120.0) * f + 3.0 * f * f) / (128.0 * (32.0 - 3.0 * f));
     }
 
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/LegacyStructureDataHandler.java b/src/main/java/net/minecraft/world/level/levelgen/structure/LegacyStructureDataHandler.java
index 12ec1def8a100aa8400f9ef183b5ef744e2b11aa..9e44bb3d5553392ffcda4ecb81a2eb0fdfa71d48 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/LegacyStructureDataHandler.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/LegacyStructureDataHandler.java
@@ -171,6 +171,7 @@ public class LegacyStructureDataHandler {
 
     private void populateCaches(@Nullable DimensionDataStorage persistentStateManager) {
         if (persistentStateManager != null) {
+            boolean ignoreNullLegacyStructureData = org.galemc.gale.configuration.GaleGlobalConfiguration.get().misc.ignoreNullLegacyStructureData; // Gale - MultiPaper - ignore null legacy structure data
             Iterator iterator = this.legacyKeys.iterator();
 
             while (iterator.hasNext()) {
@@ -178,7 +179,11 @@ public class LegacyStructureDataHandler {
                 CompoundTag nbttagcompound = new CompoundTag();
 
                 try {
-                    nbttagcompound = persistentStateManager.readTagFromDisk(s, DataFixTypes.SAVED_DATA_STRUCTURE_FEATURE_INDICES, 1493).getCompound("data").getCompound("Features");
+                    // Gale start - MultiPaper - ignore null legacy structure data
+                    CompoundTag tag = persistentStateManager.readTagFromDisk(s, DataFixTypes.SAVED_DATA_STRUCTURE_FEATURE_INDICES, 1493);
+                    if (ignoreNullLegacyStructureData && tag == null) continue;
+                    nbttagcompound = tag.getCompound("data").getCompound("Features");
+                    // Gale end - MultiPaper - ignore null legacy structure data
                     if (nbttagcompound.isEmpty()) {
                         continue;
                     }
diff --git a/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java b/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java
index 0977cd0d65dd1c2dde04d318759458abe452847e..ee5b317e87c4d403b6d7f5ab1d493e446f9278f6 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/structure/PoolElementStructurePiece.java
@@ -27,7 +27,7 @@ import net.minecraft.world.level.levelgen.structure.templatesystem.StructureTemp
 import org.slf4j.Logger;
 
 public class PoolElementStructurePiece extends StructurePiece {
-    private static final Logger LOGGER = LogUtils.getLogger();
+    public static final Logger LOGGER = LogUtils.getLogger(); // Gale - EMC - softly log invalid pool element errors - private -> public
     protected final StructurePoolElement element;
     protected BlockPos position;
     private final int groundLevelDelta;
@@ -80,7 +80,7 @@ public class PoolElementStructurePiece extends StructurePiece {
         DynamicOps<Tag> dynamicOps = context.registryAccess().createSerializationContext(NbtOps.INSTANCE);
         StructurePoolElement.CODEC
             .encodeStart(dynamicOps, this.element)
-            .resultOrPartial(LOGGER::error)
+            .resultOrPartial(org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.invalidPoolElementErrorStringConsumer) // Gale - EMC - softly log invalid pool element errors
             .ifPresent(poolElement -> nbt.put("pool_element", poolElement));
         nbt.putString("rotation", this.rotation.name());
         ListTag listTag = new ListTag();
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
index 9a97e5cd23d839183ac4d243d28df92af3119fe7..0da2d816f0497eae0c055f3929b8194a3473a221 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/ImprovedNoise.java
@@ -11,6 +11,27 @@ public final class ImprovedNoise {
     public final double yo;
     public final double zo;
 
+    // Gale start - C2ME - optimize noise generation
+    private static final double[] FLAT_SIMPLEX_GRAD = new double[]{
+        1, 1, 0, 0,
+        -1, 1, 0, 0,
+        1, -1, 0, 0,
+        -1, -1, 0, 0,
+        1, 0, 1, 0,
+        -1, 0, 1, 0,
+        1, 0, -1, 0,
+        -1, 0, -1, 0,
+        0, 1, 1, 0,
+        0, -1, 1, 0,
+        0, 1, -1, 0,
+        0, -1, -1, 0,
+        1, 1, 0, 0,
+        0, -1, 1, 0,
+        -1, 1, 0, 0,
+        0, -1, -1, 0,
+    };
+    // Gale end - C2ME - optimize noise generation
+
     public ImprovedNoise(RandomSource random) {
         this.xo = random.nextDouble() * 256.0;
         this.yo = random.nextDouble() * 256.0;
@@ -38,12 +59,14 @@ public final class ImprovedNoise {
         double d = x + this.xo;
         double e = y + this.yo;
         double f = z + this.zo;
-        int i = Mth.floor(d);
-        int j = Mth.floor(e);
-        int k = Mth.floor(f);
-        double g = d - (double)i;
-        double h = e - (double)j;
-        double l = f - (double)k;
+        // Gale start - C2ME - optimize noise generation - optimize: remove frequent type conversions
+        double i = Math.floor(d);
+        double j = Math.floor(e);
+        double k = Math.floor(f);
+        double g = d - i;
+        double h = e - j;
+        double l = f - k;
+        // Gale end - C2ME - optimize noise generation - optimize: remove frequent type conversions
         double o;
         if (yScale != 0.0) {
             double m;
@@ -53,25 +76,27 @@ public final class ImprovedNoise {
                 m = h;
             }
 
-            o = (double)Mth.floor(m / yScale + 1.0E-7F) * yScale;
+            o = Math.floor(m / yScale + (double)1.0E-7F) * yScale; // Gale - C2ME - optimize noise generation - optimize: remove frequent type conversions
         } else {
             o = 0.0;
         }
 
-        return this.sampleAndLerp(i, j, k, g, h - o, l, h);
+        return this.sampleAndLerp((int) i, (int) j, (int) k, g, h - o, l, h); // Gale - C2ME - optimize noise generation - optimize: remove frequent type conversions
     }
 
     public double noiseWithDerivative(double x, double y, double z, double[] ds) {
         double d = x + this.xo;
         double e = y + this.yo;
         double f = z + this.zo;
-        int i = Mth.floor(d);
-        int j = Mth.floor(e);
-        int k = Mth.floor(f);
-        double g = d - (double)i;
-        double h = e - (double)j;
-        double l = f - (double)k;
-        return this.sampleWithDerivative(i, j, k, g, h, l, ds);
+        // Gale start - C2ME - optimize noise generation - optimize: remove frequent type conversions
+        double i = Math.floor(d);
+        double j = Math.floor(e);
+        double k = Math.floor(f);
+        double g = d - i;
+        double h = e - j;
+        double l = f - k;
+        return this.sampleWithDerivative((int) i, (int) j, (int) k, g, h, l, ds);
+        // Gale end - C2ME - optimize noise generation - optimize: remove frequent type conversions
     }
 
     private static double gradDot(int hash, double x, double y, double z) {
@@ -83,24 +108,69 @@ public final class ImprovedNoise {
     }
 
     private double sampleAndLerp(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double fadeLocalY) {
-        int i = this.p(sectionX);
-        int j = this.p(sectionX + 1);
-        int k = this.p(i + sectionY);
-        int l = this.p(i + sectionY + 1);
-        int m = this.p(j + sectionY);
-        int n = this.p(j + sectionY + 1);
-        double d = gradDot(this.p(k + sectionZ), localX, localY, localZ);
-        double e = gradDot(this.p(m + sectionZ), localX - 1.0, localY, localZ);
-        double f = gradDot(this.p(l + sectionZ), localX, localY - 1.0, localZ);
-        double g = gradDot(this.p(n + sectionZ), localX - 1.0, localY - 1.0, localZ);
-        double h = gradDot(this.p(k + sectionZ + 1), localX, localY, localZ - 1.0);
-        double o = gradDot(this.p(m + sectionZ + 1), localX - 1.0, localY, localZ - 1.0);
-        double p = gradDot(this.p(l + sectionZ + 1), localX, localY - 1.0, localZ - 1.0);
-        double q = gradDot(this.p(n + sectionZ + 1), localX - 1.0, localY - 1.0, localZ - 1.0);
-        double r = Mth.smoothstep(localX);
-        double s = Mth.smoothstep(fadeLocalY);
-        double t = Mth.smoothstep(localZ);
-        return Mth.lerp3(r, s, t, d, e, f, g, h, o, p, q);
+        // Gale start - C2ME - optimize noise generation - inline math & small optimization: remove frequent type conversions and redundant ops
+        final int var0 = sectionX & 0xFF;
+        final int var1 = (sectionX + 1) & 0xFF;
+        final int var2 = this.p[var0] & 0xFF;
+        final int var3 = this.p[var1] & 0xFF;
+        final int var4 = (var2 + sectionY) & 0xFF;
+        final int var5 = (var3 + sectionY) & 0xFF;
+        final int var6 = (var2 + sectionY + 1) & 0xFF;
+        final int var7 = (var3 + sectionY + 1) & 0xFF;
+        final int var8 = this.p[var4] & 0xFF;
+        final int var9 = this.p[var5] & 0xFF;
+        final int var10 = this.p[var6] & 0xFF;
+        final int var11 = this.p[var7] & 0xFF;
+
+        final int var12 = (var8 + sectionZ) & 0xFF;
+        final int var13 = (var9 + sectionZ) & 0xFF;
+        final int var14 = (var10 + sectionZ) & 0xFF;
+        final int var15 = (var11 + sectionZ) & 0xFF;
+        final int var16 = (var8 + sectionZ + 1) & 0xFF;
+        final int var17 = (var9 + sectionZ + 1) & 0xFF;
+        final int var18 = (var10 + sectionZ + 1) & 0xFF;
+        final int var19 = (var11 + sectionZ + 1) & 0xFF;
+        final int var20 = (this.p[var12] & 15) << 2;
+        final int var21 = (this.p[var13] & 15) << 2;
+        final int var22 = (this.p[var14] & 15) << 2;
+        final int var23 = (this.p[var15] & 15) << 2;
+        final int var24 = (this.p[var16] & 15) << 2;
+        final int var25 = (this.p[var17] & 15) << 2;
+        final int var26 = (this.p[var18] & 15) << 2;
+        final int var27 = (this.p[var19] & 15) << 2;
+        final double var60 = localX - 1.0;
+        final double var61 = localY - 1.0;
+        final double var62 = localZ - 1.0;
+        final double var87 = FLAT_SIMPLEX_GRAD[(var20) | 0] * localX + FLAT_SIMPLEX_GRAD[(var20) | 1] * localY + FLAT_SIMPLEX_GRAD[(var20) | 2] * localZ;
+        final double var88 = FLAT_SIMPLEX_GRAD[(var21) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var21) | 1] * localY + FLAT_SIMPLEX_GRAD[(var21) | 2] * localZ;
+        final double var89 = FLAT_SIMPLEX_GRAD[(var22) | 0] * localX + FLAT_SIMPLEX_GRAD[(var22) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var22) | 2] * localZ;
+        final double var90 = FLAT_SIMPLEX_GRAD[(var23) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var23) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var23) | 2] * localZ;
+        final double var91 = FLAT_SIMPLEX_GRAD[(var24) | 0] * localX + FLAT_SIMPLEX_GRAD[(var24) | 1] * localY + FLAT_SIMPLEX_GRAD[(var24) | 2] * var62;
+        final double var92 = FLAT_SIMPLEX_GRAD[(var25) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var25) | 1] * localY + FLAT_SIMPLEX_GRAD[(var25) | 2] * var62;
+        final double var93 = FLAT_SIMPLEX_GRAD[(var26) | 0] * localX + FLAT_SIMPLEX_GRAD[(var26) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var26) | 2] * var62;
+        final double var94 = FLAT_SIMPLEX_GRAD[(var27) | 0] * var60 + FLAT_SIMPLEX_GRAD[(var27) | 1] * var61 + FLAT_SIMPLEX_GRAD[(var27) | 2] * var62;
+
+        final double var95 = localX * 6.0 - 15.0;
+        final double var96 = fadeLocalY * 6.0 - 15.0;
+        final double var97 = localZ * 6.0 - 15.0;
+        final double var98 = localX * var95 + 10.0;
+        final double var99 = fadeLocalY * var96 + 10.0;
+        final double var100 = localZ * var97 + 10.0;
+        final double var101 = localX * localX * localX * var98;
+        final double var102 = fadeLocalY * fadeLocalY * fadeLocalY * var99;
+        final double var103 = localZ * localZ * localZ * var100;
+
+        final double var113 = var87 + var101 * (var88 - var87);
+        final double var114 = var93 + var101 * (var94 - var93);
+        final double var115 = var91 + var101 * (var92 - var91);
+        final double var116 = var89 + var101 * (var90 - var89);
+        final double var117 = var114 - var115;
+        final double var118 = var102 * (var116 - var113);
+        final double var119 = var102 * var117;
+        final double var120 = var113 + var118;
+        final double var121 = var115 + var119;
+        return var120 + (var103 * (var121 - var120));
+        // Gale end - C2ME - optimize noise generation - inline math & small optimization: remove frequent type conversions and redundant ops
     }
 
     private double sampleWithDerivative(int sectionX, int sectionY, int sectionZ, double localX, double localY, double localZ, double[] ds) {
diff --git a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
index 35820670837376bcad8891241724d5b946fbd31f..022dda9dded1bd96dcaf377b1d1a9711ea9c49e7 100644
--- a/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
+++ b/src/main/java/net/minecraft/world/level/levelgen/synth/PerlinNoise.java
@@ -26,6 +26,10 @@ public class PerlinNoise {
     private final double lowestFreqValueFactor;
     private final double lowestFreqInputFactor;
     private final double maxValue;
+    // Gale start - C2ME - optimize noise generation
+    private final int octaveSamplersCount;
+    private final double [] amplitudesArray;
+    // Gale end - C2ME - optimize noise generation
 
     @Deprecated
     public static PerlinNoise createLegacyForBlendedNoise(RandomSource random, IntStream octaves) {
@@ -127,6 +131,10 @@ public class PerlinNoise {
         this.lowestFreqInputFactor = Math.pow(2.0, (double)(-j));
         this.lowestFreqValueFactor = Math.pow(2.0, (double)(i - 1)) / (Math.pow(2.0, (double)i) - 1.0);
         this.maxValue = this.edgeValue(2.0);
+        // Gale start - C2ME - optimize noise generation
+        this.octaveSamplersCount = this.noiseLevels.length;
+        this.amplitudesArray = this.amplitudes.toDoubleArray();
+        // Gale end - C2ME - optimize noise generation
     }
 
     protected double maxValue() {
@@ -138,7 +146,27 @@ public class PerlinNoise {
     }
 
     public double getValue(double x, double y, double z) {
-        return this.getValue(x, y, z, 0.0, 0.0, false);
+        // Gale start - C2ME - optimize noise generation - optimize for common cases
+        double d = 0.0;
+        double e = this.lowestFreqInputFactor;
+        double f = this.lowestFreqValueFactor;
+
+        for (int i = 0; i < this.octaveSamplersCount; ++i) {
+            ImprovedNoise perlinNoiseSampler = this.noiseLevels[i];
+            if (perlinNoiseSampler != null) {
+                @SuppressWarnings("deprecation")
+                double g = perlinNoiseSampler.noise(
+                    wrap(x * e), wrap(y * e), wrap(z * e), 0.0, 0.0
+                );
+                d += this.amplitudesArray[i] * g * f;
+            }
+
+            e *= 2.0;
+            f /= 2.0;
+        }
+
+        return d;
+        // Gale end - C2ME - optimize noise generation - optimize for common cases
     }
 
     @Deprecated
diff --git a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
index ad02cdb00360165f6405eb3044bd8320f01a7ef1..2ac87dfb3d9756c0bf63d5a81470efad5b826371 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/CubePointRange.java
@@ -3,21 +3,23 @@ package net.minecraft.world.phys.shapes;
 import it.unimi.dsi.fastutil.doubles.AbstractDoubleList;
 
 public class CubePointRange extends AbstractDoubleList {
-    private final int parts;
+    private final int size; // Gale - replace parts by size in CubePointRange
+    private final double scale; // Gale - Lithium - replace division by multiplication in CubePointRange
 
     public CubePointRange(int sectionCount) {
         if (sectionCount <= 0) {
             throw new IllegalArgumentException("Need at least 1 part");
         } else {
-            this.parts = sectionCount;
+            this.size = sectionCount + 1; // Gale - replace parts by size in CubePointRange
         }
+        this.scale = 1.0D / sectionCount; // Gale - Lithium - replace division by multiplication in CubePointRange
     }
 
     public double getDouble(int i) {
-        return (double)i / (double)this.parts;
+        return i * this.scale; // Gale - Lithium - replace division by multiplication in CubePointRange
     }
 
     public int size() {
-        return this.parts + 1;
+        return this.size; // Gale - replace parts by size in CubePointRange
     }
 }
diff --git a/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java b/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
index a94fbedaf0297c006c561a145913bb91f2d0a817..121d155be5213cb4d9a4258b4b9a27ca3f335209 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
@@ -19,23 +19,33 @@ public class EntityCollisionContext implements CollisionContext {
             return defaultValue;
         }
     };
+    // Gale start - Airplane - make EntityCollisionContext a live representation - remove these and pray no plugin uses them
+    /*
     private final boolean descending;
     private final double entityBottom;
     private final ItemStack heldItem;
     private final Predicate<FluidState> canStandOnFluid;
+     */
+    // Gale end - Airplane - make EntityCollisionContext a live representation - remove these and pray no plugin uses them
     @Nullable
     private final Entity entity;
 
     protected EntityCollisionContext(boolean descending, double minY, ItemStack heldItem, Predicate<FluidState> walkOnFluidPredicate, @Nullable Entity entity) {
+        // Gale start - Airplane - make EntityCollisionContext a live representation - remove these and pray no plugin uses them
+        /*
         this.descending = descending;
         this.entityBottom = minY;
         this.heldItem = heldItem;
         this.canStandOnFluid = walkOnFluidPredicate;
+         */
+        // Gale end - Airplane - make EntityCollisionContext a live representation - remove these and pray no plugin uses them
         this.entity = entity;
     }
 
     @Deprecated
     protected EntityCollisionContext(Entity entity, boolean collidesWithFluid) {
+        // Gale start - Airplane - make EntityCollisionContext a live representation - remove unneeded things
+        /*
         this(
             entity.isDescending(),
             entity.getY(),
@@ -43,16 +53,31 @@ public class EntityCollisionContext implements CollisionContext {
             collidesWithFluid ? state -> true : (entity instanceof LivingEntity ? ((LivingEntity)entity)::canStandOnFluid : state -> false),
             entity
         );
+        */
+        this.entity = entity;
+        // Gale end - Airplane - make EntityCollisionContext a live representation - remove unneeded things
     }
 
     @Override
     public boolean isHoldingItem(Item item) {
-        return this.heldItem.is(item);
+        // Gale start - Airplane - make EntityCollisionContext a live representation
+        Entity entity = this.entity;
+        if (entity instanceof LivingEntity livingEntity) {
+            return livingEntity.getMainHandItem().is(item);
+        }
+        return ItemStack.EMPTY.is(item);
+        // Gale end - Airplane - make EntityCollisionContext a live representation
     }
 
     @Override
     public boolean canStandOnFluid(FluidState stateAbove, FluidState state) {
-        return this.canStandOnFluid.test(state) && !stateAbove.getType().isSame(state.getType());
+        // Gale start - Airplane - make EntityCollisionContext a live representation
+        Entity entity = this.entity;
+        if (entity instanceof LivingEntity livingEntity) {
+            return livingEntity.canStandOnFluid(state) && !stateAbove.getType().isSame(state.getType());
+        }
+        return false;
+        // Gale end - Airplane - make EntityCollisionContext a live representation
     }
 
     @Override
@@ -62,12 +87,12 @@ public class EntityCollisionContext implements CollisionContext {
 
     @Override
     public boolean isDescending() {
-        return this.descending;
+        return this.entity != null && this.entity.isDescending(); // Gale - Airplane - make EntityCollisionContext a live representation
     }
 
     @Override
     public boolean isAbove(VoxelShape shape, BlockPos pos, boolean defaultValue) {
-        return this.entityBottom > (double)pos.getY() + shape.max(Direction.Axis.Y) - 1.0E-5F;
+        return (this.entity == null ? -Double.MAX_VALUE : entity.getY()) > (double) pos.getY() + shape.max(Direction.Axis.Y) - (double) 1.0E-5F; // Gale - Airplane - make EntityCollisionContext a live representation
     }
 
     @Nullable
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 97b5d6ba2b19a7c730730c74175a29157aed1840..5feff1f32d1ed02cab9add080f305324e02c41d3 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -284,6 +284,7 @@ public final class CraftServer implements Server {
     protected final DedicatedServer console;
     protected final DedicatedPlayerList playerList;
     private final Map<String, World> worlds = new LinkedHashMap<String, World>();
+    private final it.unimi.dsi.fastutil.objects.Object2ObjectMap<UUID, World> worldsByUUID = new it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap<>(); // Gale - MultiPaper - CraftBukkit UUID to world map
     // private final Map<Class<?>, Registry<?>> registries = new HashMap<>(); // Paper - replace with RegistryAccess
     private YamlConfiguration configuration;
     private YamlConfiguration commandsConfiguration;
@@ -1086,6 +1087,7 @@ public final class CraftServer implements Server {
 
         org.spigotmc.SpigotConfig.init((File) this.console.options.valueOf("spigot-settings")); // Spigot
         this.console.paperConfigurations.reloadConfigs(this.console);
+        this.console.galeConfigurations.reloadConfigs(this.console); // Gale - Gale configuration
         for (ServerLevel world : this.console.getAllLevels()) {
             // world.serverLevelData.setDifficulty(config.difficulty); // Paper - per level difficulty
             world.setSpawnSettings(world.serverLevelData.getDifficulty() != Difficulty.PEACEFUL && config.spawnMonsters); // Paper - per level difficulty (from MinecraftServer#setDifficulty(ServerLevel, Difficulty, boolean))
@@ -1179,6 +1181,13 @@ public final class CraftServer implements Server {
                 plugin.getPluginMeta().getDisplayName(),
                 "This plugin is not properly shutting down its async tasks when it is being shut down. This task may throw errors during the final shutdown logs and might not complete before process dies."
             ));
+            // Gale start - Airplane - print stack trace for plugins not shutting down tasks
+            getLogger().log(Level.SEVERE, String.format("%s Stacktrace", worker.getThread().getName()));
+            StackTraceElement[] stackTrace = worker.getThread().getStackTrace();
+            for (StackTraceElement element : stackTrace) {
+                getLogger().log(Level.SEVERE, "  " + element.toString());
+            }
+            // Gale end - Airplane - print stack trace for plugins not shutting down tasks
             if (console.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper - Debugging
         }
     }
@@ -1499,6 +1508,7 @@ public final class CraftServer implements Server {
             this.getLogger().log(Level.SEVERE, null, ex);
         }
 
+        this.worldsByUUID.remove(world.getUID()); // Gale - MultiPaper - CraftBukkit UUID to world map
         this.worlds.remove(world.getName().toLowerCase(Locale.ROOT));
         this.console.removeLevel(handle);
         return true;
@@ -1517,12 +1527,7 @@ public final class CraftServer implements Server {
 
     @Override
     public World getWorld(UUID uid) {
-        for (World world : this.worlds.values()) {
-            if (world.getUID().equals(uid)) {
-                return world;
-            }
-        }
-        return null;
+        return this.worldsByUUID.get(uid); // Gale - MultiPaper - CraftBukkit UUID to world map
     }
 
     // Paper start
@@ -1540,6 +1545,7 @@ public final class CraftServer implements Server {
             System.out.println("World " + world.getName() + " is a duplicate of another world and has been prevented from loading. Please delete the uid.dat file from " + world.getName() + "'s world directory if you want to be able to load the duplicate world.");
             return;
         }
+        this.worldsByUUID.put(world.getUID(), world); // Gale - MultiPaper - CraftBukkit UUID to world map
         this.worlds.put(world.getName().toLowerCase(Locale.ROOT), world);
     }
 
@@ -3031,6 +3037,14 @@ public final class CraftServer implements Server {
             return CraftServer.this.console.paperConfigurations.createLegacyObject(CraftServer.this.console);
         }
 
+        // Gale start - Gale configuration - API
+        @Override
+        public YamlConfiguration getGaleConfig()
+        {
+            return CraftServer.this.console.galeConfigurations.createLegacyObject(CraftServer.this.console);
+        }
+        // Gale end - Gale configuration - API
+
         @Override
         public void restart() {
             org.spigotmc.RestartCommand.restart();
@@ -3066,6 +3080,43 @@ public final class CraftServer implements Server {
         };
     }
 
+    // Gale start - Purpur - 5 second TPS average
+    @Override
+    public double[] getTPSIncluding5SecondAverage() {
+        return new double[] {
+            net.minecraft.server.MinecraftServer.getServer().tps5s.getAverage(),
+            net.minecraft.server.MinecraftServer.getServer().tps1.getAverage(),
+            net.minecraft.server.MinecraftServer.getServer().tps5.getAverage(),
+            net.minecraft.server.MinecraftServer.getServer().tps15.getAverage()
+        };
+    }
+    // Gale end - Purpur - 5 second TPS average
+
+    // Gale start - specific interval TPS API
+
+    // Gale start - Purpur - 5 second TPS average
+    @Override
+    public double get5SecondTPSAverage() {
+        return net.minecraft.server.MinecraftServer.getServer().tps5s.getAverage();
+    }
+    // Gale end - Purpur - 5 second TPS average
+
+    @Override
+    public double get1MinuteTPSAverage() {
+        return net.minecraft.server.MinecraftServer.getServer().tps1.getAverage();
+    }
+
+    @Override
+    public double get5MinuteTPSAverage() {
+        return net.minecraft.server.MinecraftServer.getServer().tps5.getAverage();
+    }
+
+    @Override
+    public double get15MinuteTPSAverage() {
+        return net.minecraft.server.MinecraftServer.getServer().tps15.getAverage();
+    }
+    // Gale end - specific interval TPS API
+
     // Paper start - adventure sounds
     @Override
     public void playSound(final net.kyori.adventure.sound.Sound sound) {
@@ -3270,4 +3321,22 @@ public final class CraftServer implements Server {
         this.console.addPluginAllowingSleep(plugin.getName(), value);
     }
     // Paper end - API to check if the server is sleeping
+
+
+    // Gale start - YAPFA - last tick time - API
+    @Override
+    public long getLastTickTotalTime() {
+        return MinecraftServer.lastTickProperTime + MinecraftServer.lastTickOversleepTime;
+    }
+
+    @Override
+    public long getLastTickProperTime() {
+        return MinecraftServer.lastTickProperTime;
+    }
+
+    @Override
+    public long getLastTickOversleepTime() {
+        return MinecraftServer.lastTickOversleepTime;
+    }
+    // Gale end - YAPFA - last tick time - API
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 92d9f0ea8f7810ae20d3996f49aefa539b4bcb69..48132bf8e5456beee5a94b4232e9d7c58f706e7d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -289,7 +289,7 @@ public class CraftWorld extends CraftRegionAccessor implements World {
     }
     // Paper end
 
-    private static final Random rand = new Random();
+    public static Random rand; // Gale - xor-shift random - set in GaleGlobalConfiguration
 
     public CraftWorld(ServerLevel world, ChunkGenerator gen, BiomeProvider biomeProvider, Environment env) {
         this.world = world;
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftFirework.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftFirework.java
index 759b6e54db93792c9862b1f1625118ac6fa49d7a..4b5e9bc33c25ac98c32aff1bd13788edf0eeee8c 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftFirework.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftFirework.java
@@ -14,7 +14,7 @@ import org.bukkit.inventory.meta.FireworkMeta;
 
 public class CraftFirework extends CraftProjectile implements Firework {
 
-    private final Random random = new Random();
+    private final Random random = org.galemc.gale.configuration.GaleGlobalConfiguration.get().smallOptimizations.useXorShiftRandom.elytraFireworkSpeed ? new org.galemc.gale.random.XorShiftRandom() : new Random(); // Gale - xor-shift random - not thread-safe but it is not really a concern here
     //private CraftItemStack item; // Paper - Remove usage, not accurate representation of current item.
 
     public CraftFirework(CraftServer server, FireworkRocketEntity entity) {
diff --git a/src/main/java/org/bukkit/craftbukkit/legacy/CraftLegacy.java b/src/main/java/org/bukkit/craftbukkit/legacy/CraftLegacy.java
index 51ae8eddadc87b143b93521a3cef374f1e3a24dc..eed2d01c4f884c3aafdef21741fc1a2e2d610199 100644
--- a/src/main/java/org/bukkit/craftbukkit/legacy/CraftLegacy.java
+++ b/src/main/java/org/bukkit/craftbukkit/legacy/CraftLegacy.java
@@ -265,7 +265,7 @@ public final class CraftLegacy {
     }
 
     static {
-        LOGGER.warn("Initializing Legacy Material Support. Unless you have legacy plugins and/or data this is a bug!"); // Paper - Improve logging and errors; doesn't need to be an error
+        if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().logToConsole.legacyMaterialInitialization) LOGGER.warn("Initializing Legacy Material Support. Unless you have legacy plugins and/or data this is a bug!"); // Paper - Improve logging and errors; doesn't need to be an error // Gale - Purpur - do not log legacy Material initialization
         if (MinecraftServer.getServer() != null && MinecraftServer.getServer().isDebugging()) {
             new Exception().printStackTrace();
         }
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
index 1354ccfbf525e5e64483ac5f443cc2325ba63850..f6bc955c3496b52cda1a20aabd78769803ef471f 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/CraftScheduler.java
@@ -491,7 +491,7 @@ public class CraftScheduler implements BukkitScheduler {
                 this.parsePending();
             } else {
                 // this.debugTail = this.debugTail.setNext(new CraftAsyncDebugger(this.currentTick + CraftScheduler.RECENT_TICKS, task.getOwner(), task.getTaskClass())); // Paper
-                task.getOwner().getLogger().log(Level.SEVERE, "Unexpected Async Task in the Sync Scheduler. Report this to Paper"); // Paper
+                task.getOwner().getLogger().log(Level.SEVERE, "Unexpected Async Task in the Sync Scheduler. Report this to Gale"); // Paper // Gale - branding changes
                 // We don't need to parse pending
                 // (async tasks must live with race-conditions if they attempt to cancel between these few lines of code)
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
index 15892c7769caa15f3d52a1ee2147cf9615aa0e25..9eb6b4b210f9361c19366960d31c25edd063f2ca 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/CraftMagicNumbers.java
@@ -505,7 +505,7 @@ public final class CraftMagicNumbers implements UnsafeValues {
     // Paper start
     @Override
     public com.destroystokyo.paper.util.VersionFetcher getVersionFetcher() {
-        return new com.destroystokyo.paper.PaperVersionFetcher();
+        return new org.galemc.gale.version.GaleVersionFetcher(); // Gale - branding changes - version fetcher
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 774556a62eb240da42e84db4502e2ed43495be17..0b5979723bb30f9011ac64c36d894aa41713ec9b 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -11,7 +11,7 @@ public final class Versioning {
     public static String getBukkitVersion() {
         String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/io.papermc.paper/paper-api/pom.properties");
+        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/org.galemc.gale/gale-api/pom.properties"); // Gale - branding changes
         Properties properties = new Properties();
 
         if (stream != null) {
diff --git a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
index e0e61115ada9a49d4c528c5d4e02a1ca571d9531..7d66126c1f5957c109a2426d53f5d0072886309b 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/permissions/CraftDefaultPermissions.java
@@ -5,6 +5,9 @@ import org.bukkit.util.permissions.DefaultPermissions;
 
 public final class CraftDefaultPermissions {
     private static final String ROOT = "minecraft";
+    public static final String GALE_ROOT = "gale"; // Gale - set Gale permissions root
+
+    public static final String writeBooks = GALE_ROOT + ".writebooks"; // Gale - Pufferfish - make book writing configurable
 
     private CraftDefaultPermissions() {}
 
@@ -18,6 +21,7 @@ public final class CraftDefaultPermissions {
         DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".debugstick.always", "Gives the user the ability to use the debug stick in all game modes", org.bukkit.permissions.PermissionDefault.FALSE/* , parent */); // Paper - should not have this parent, as it's not a "vanilla" utility
         DefaultPermissions.registerPermission(CraftDefaultPermissions.ROOT + ".commandblock", "Gives the user the ability to use command blocks.", org.bukkit.permissions.PermissionDefault.OP, parent); // Paper
         // Spigot end
+        DefaultPermissions.registerPermission(writeBooks, "Gives the user the ability to write books even when writing books is disabled in the Gale configuration", org.bukkit.permissions.PermissionDefault.OP); // Gale - Pufferfish - make book writing configurable
         parent.recalculatePermissibles();
     }
 }
diff --git a/src/main/java/org/galemc/gale/command/GaleCommand.java b/src/main/java/org/galemc/gale/command/GaleCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..87d3aed35341dfa9358af064dd54d7de95078269
--- /dev/null
+++ b/src/main/java/org/galemc/gale/command/GaleCommand.java
@@ -0,0 +1,179 @@
+// Gale - Gale commands - /gale command
+
+package org.galemc.gale.command;
+
+import io.papermc.paper.command.CommandUtil;
+import it.unimi.dsi.fastutil.Pair;
+import net.minecraft.Util;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginManager;
+import org.galemc.gale.command.subcommands.InfoCommand;
+import org.galemc.gale.command.subcommands.ReloadCommand;
+import org.galemc.gale.command.subcommands.VersionCommand;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+import static net.kyori.adventure.text.Component.newline;
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+import static net.kyori.adventure.text.format.NamedTextColor.GRAY;
+
+public final class GaleCommand extends Command {
+    public static final String COMMAND_LABEL = "gale";
+    public static final String BASE_PERM = GaleCommands.COMMAND_BASE_PERM + "." + COMMAND_LABEL;
+    private static final Permission basePermission = new Permission(BASE_PERM, PermissionDefault.TRUE);
+    // subcommand label -> subcommand
+    private static final GaleSubcommand RELOAD_SUBCOMMAND = new ReloadCommand();
+    private static final GaleSubcommand VERSION_SUBCOMMAND = new VersionCommand();
+    private static final GaleSubcommand INFO_SUBCOMMAND = new InfoCommand();
+    private static final Map<String, GaleSubcommand> SUBCOMMANDS = Util.make(() -> {
+        final Map<Set<String>, GaleSubcommand> commands = new HashMap<>();
+
+        commands.put(Set.of(ReloadCommand.LITERAL_ARGUMENT), RELOAD_SUBCOMMAND);
+        commands.put(Set.of(VersionCommand.LITERAL_ARGUMENT), VERSION_SUBCOMMAND);
+        commands.put(Set.of(InfoCommand.LITERAL_ARGUMENT), INFO_SUBCOMMAND);
+
+        return commands.entrySet().stream()
+            .flatMap(entry -> entry.getKey().stream().map(s -> Map.entry(s, entry.getValue())))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+    // alias -> subcommand label
+    private static final Map<String, String> ALIASES = Util.make(() -> {
+        final Map<String, Set<String>> aliases = new HashMap<>();
+
+        aliases.put(VersionCommand.LITERAL_ARGUMENT, Set.of("ver"));
+        aliases.put(InfoCommand.LITERAL_ARGUMENT, Set.of("about"));
+
+        return aliases.entrySet().stream()
+            .flatMap(entry -> entry.getValue().stream().map(s -> Map.entry(s, entry.getKey())))
+            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+    });
+
+    private String createUsageMessage(Collection<String> arguments) {
+        return "/" + COMMAND_LABEL + " [" + String.join(" | ", arguments) + "]";
+    }
+
+    public GaleCommand() {
+        super(COMMAND_LABEL);
+        this.description = "Gale related commands";
+        this.usageMessage = this.createUsageMessage(SUBCOMMANDS.keySet());
+        final List<Permission> permissions = SUBCOMMANDS.values().stream().map(GaleSubcommand::getPermission).filter(Objects::nonNull).toList();
+        this.setPermission(BASE_PERM);
+        final PluginManager pluginManager = Bukkit.getServer().getPluginManager();
+        pluginManager.addPermission(basePermission);
+        for (final Permission permission : permissions) {
+            pluginManager.addPermission(permission);
+        }
+    }
+
+    @Override
+    public List<String> tabComplete(
+        final CommandSender sender,
+        final String alias,
+        final String[] args,
+        final @Nullable Location location
+    ) throws IllegalArgumentException {
+        if (args.length <= 1) {
+            List<String> subCommandArguments = new ArrayList<>(SUBCOMMANDS.size());
+            for (Map.Entry<String, GaleSubcommand> subCommandEntry : SUBCOMMANDS.entrySet()) {
+                if (subCommandEntry.getValue().testPermission(sender)) {
+                    subCommandArguments.add(subCommandEntry.getKey());
+                }
+            }
+            return CommandUtil.getListMatchingLast(sender, args, subCommandArguments);
+        }
+
+        final @Nullable Pair<String, GaleSubcommand> subCommand = resolveCommand(args[0]);
+        if (subCommand != null && subCommand.second().testPermission(sender)) {
+            return subCommand.second().tabComplete(sender, subCommand.first(), Arrays.copyOfRange(args, 1, args.length));
+        }
+
+        return Collections.emptyList();
+    }
+
+    private boolean testHasOnePermission(CommandSender sender) {
+        for (Map.Entry<String, GaleSubcommand> subCommandEntry : SUBCOMMANDS.entrySet()) {
+            if (subCommandEntry.getValue().testPermission(sender)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    @Override
+    public boolean execute(
+        final CommandSender sender,
+        final String commandLabel,
+        final String[] args
+    ) {
+
+        // Check if the sender has the base permission and at least one specific permission
+        if (!sender.hasPermission(basePermission) || !this.testHasOnePermission(sender)) {
+            sender.sendMessage(Bukkit.permissionMessage());
+            return true;
+        }
+
+        // Determine the usage message with the subcommands they can perform
+        List<String> subCommandArguments = new ArrayList<>(SUBCOMMANDS.size());
+        for (Map.Entry<String, GaleSubcommand> subCommandEntry : SUBCOMMANDS.entrySet()) {
+            if (subCommandEntry.getValue().testPermission(sender)) {
+                subCommandArguments.add(subCommandEntry.getKey());
+            }
+        }
+        String specificUsageMessage = this.createUsageMessage(subCommandArguments);
+
+        // If they did not give a subcommand
+        if (args.length == 0) {
+            INFO_SUBCOMMAND.execute(sender, InfoCommand.LITERAL_ARGUMENT, new String[0]);
+            sender.sendMessage(newline().append(text("Command usage: " + specificUsageMessage, GRAY)));
+            return false;
+        }
+
+        // If they do not have permission for the subcommand they gave, or the argument is not a valid subcommand
+        final @Nullable Pair<String, GaleSubcommand> subCommand = resolveCommand(args[0]);
+        if (subCommand == null || !subCommand.second().testPermission(sender)) {
+            sender.sendMessage(text("Usage: " + specificUsageMessage, RED));
+            return false;
+        }
+
+        // Execute the subcommand
+        final String[] choppedArgs = Arrays.copyOfRange(args, 1, args.length);
+        return subCommand.second().execute(sender, subCommand.first(), choppedArgs);
+
+    }
+
+    private static @Nullable Pair<String, GaleSubcommand> resolveCommand(String label) {
+        label = label.toLowerCase(Locale.ENGLISH);
+        @Nullable GaleSubcommand subCommand = SUBCOMMANDS.get(label);
+        if (subCommand == null) {
+            final @Nullable String command = ALIASES.get(label);
+            if (command != null) {
+                label = command;
+                subCommand = SUBCOMMANDS.get(command);
+            }
+        }
+
+        if (subCommand != null) {
+            return Pair.of(label, subCommand);
+        }
+
+        return null;
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/command/GaleCommands.java b/src/main/java/org/galemc/gale/command/GaleCommands.java
new file mode 100644
index 0000000000000000000000000000000000000000..b729f2c778e6158f1cb3aecc7f0ed0a746ff6339
--- /dev/null
+++ b/src/main/java/org/galemc/gale/command/GaleCommands.java
@@ -0,0 +1,31 @@
+// Gale - Gale commands
+
+package org.galemc.gale.command;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+import java.util.HashMap;
+import java.util.Map;
+
+@DefaultQualifier(NonNull.class)
+public final class GaleCommands {
+
+    public static final String COMMAND_BASE_PERM = CraftDefaultPermissions.GALE_ROOT + ".command";
+
+    private GaleCommands() {}
+
+    private static final Map<String, Command> COMMANDS = new HashMap<>();
+    static {
+        COMMANDS.put(GaleCommand.COMMAND_LABEL, new GaleCommand());
+    }
+
+    public static void registerCommands(final MinecraftServer server) {
+        COMMANDS.forEach((s, command) -> {
+            server.server.getCommandMap().register(s, "Gale", command);
+        });
+    }
+}
diff --git a/src/main/java/org/galemc/gale/command/GaleSubcommand.java b/src/main/java/org/galemc/gale/command/GaleSubcommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..7bcf875f91f5018daa06ef3280c4cdd7e8df4fd5
--- /dev/null
+++ b/src/main/java/org/galemc/gale/command/GaleSubcommand.java
@@ -0,0 +1,27 @@
+// Gale - Gale commands
+
+package org.galemc.gale.command;
+
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collections;
+import java.util.List;
+
+@DefaultQualifier(NonNull.class)
+public interface GaleSubcommand {
+
+    boolean execute(CommandSender sender, String subCommand, String[] args);
+
+    default List<String> tabComplete(final CommandSender sender, final String subCommand, final String[] args) {
+        return Collections.emptyList();
+    }
+
+    boolean testPermission(CommandSender sender);
+
+    @Nullable Permission getPermission();
+
+}
diff --git a/src/main/java/org/galemc/gale/command/PermissionedGaleSubcommand.java b/src/main/java/org/galemc/gale/command/PermissionedGaleSubcommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..35ffa5f1bb682ac962ab9466e682a461efa65e7b
--- /dev/null
+++ b/src/main/java/org/galemc/gale/command/PermissionedGaleSubcommand.java
@@ -0,0 +1,32 @@
+// Gale - Gale commands
+
+package org.galemc.gale.command;
+
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.jetbrains.annotations.Nullable;
+
+public abstract class PermissionedGaleSubcommand implements GaleSubcommand {
+
+    public final Permission permission;
+
+    protected PermissionedGaleSubcommand(Permission permission) {
+        this.permission = permission;
+    }
+
+    protected PermissionedGaleSubcommand(String permission, PermissionDefault permissionDefault) {
+        this(new Permission(permission, permissionDefault));
+    }
+
+    @Override
+    public boolean testPermission(CommandSender sender) {
+        return sender.hasPermission(this.permission);
+    }
+
+    @Override
+    public @Nullable Permission getPermission() {
+        return this.permission;
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/command/subcommands/InfoCommand.java b/src/main/java/org/galemc/gale/command/subcommands/InfoCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..a781afaf6821a4b7bd770b33eaf65527bfbed04e
--- /dev/null
+++ b/src/main/java/org/galemc/gale/command/subcommands/InfoCommand.java
@@ -0,0 +1,42 @@
+// Gale - Gale commands - /gale info command
+
+package org.galemc.gale.command.subcommands;
+
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.format.TextDecoration;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.Permission;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.galemc.gale.command.GaleSubcommand;
+import org.jetbrains.annotations.Nullable;
+
+import static net.kyori.adventure.text.Component.text;
+
+@DefaultQualifier(NonNull.class)
+public final class InfoCommand implements GaleSubcommand {
+
+    public final static String LITERAL_ARGUMENT = "info";
+
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        sender.sendMessage(
+            text("Gale is a performant Minecraft server system. Find us on: ")
+            .append(text("https://github.com/GaleMC/Gale")
+                .decorate(TextDecoration.UNDERLINED)
+                .clickEvent(ClickEvent.openUrl("https://github.com/GaleMC/Gale")))
+        );
+        return true;
+    }
+
+    @Override
+    public boolean testPermission(CommandSender sender) {
+        return true;
+    }
+
+    @Override
+    public @Nullable Permission getPermission() {
+        return null;
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/command/subcommands/ReloadCommand.java b/src/main/java/org/galemc/gale/command/subcommands/ReloadCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..c6ca5d3cf7e709f59f68ccd28db378e9e6303fdd
--- /dev/null
+++ b/src/main/java/org/galemc/gale/command/subcommands/ReloadCommand.java
@@ -0,0 +1,46 @@
+// Gale - Gale commands - /gale reload command
+
+package org.galemc.gale.command.subcommands;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.permissions.PermissionDefault;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.galemc.gale.command.GaleCommand;
+import org.galemc.gale.command.PermissionedGaleSubcommand;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.NamedTextColor.GREEN;
+import static net.kyori.adventure.text.format.NamedTextColor.RED;
+
+@DefaultQualifier(NonNull.class)
+public final class ReloadCommand extends PermissionedGaleSubcommand {
+
+    public final static String LITERAL_ARGUMENT = "reload";
+    public static final String PERM = GaleCommand.BASE_PERM + "." + LITERAL_ARGUMENT;
+
+    public ReloadCommand() {
+        super(PERM, PermissionDefault.OP);
+    }
+
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        this.doReload(sender);
+        return true;
+    }
+
+    private void doReload(final CommandSender sender) {
+        Command.broadcastCommandMessage(sender, text("Please note that this command is not supported and may cause issues.", RED));
+        Command.broadcastCommandMessage(sender, text("If you encounter any issues please use the /stop command to restart your server.", RED));
+
+        MinecraftServer server = ((CraftServer) sender.getServer()).getServer();
+        server.galeConfigurations.reloadConfigs(server);
+        server.server.reloadCount++;
+
+        Command.broadcastCommandMessage(sender, text("Gale config reload complete.", GREEN));
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/command/subcommands/VersionCommand.java b/src/main/java/org/galemc/gale/command/subcommands/VersionCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..675cd4295dabfade1b9cc5473010b5b20dc32039
--- /dev/null
+++ b/src/main/java/org/galemc/gale/command/subcommands/VersionCommand.java
@@ -0,0 +1,39 @@
+// Gale - Gale commands - /gale version command
+
+package org.galemc.gale.command.subcommands;
+
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.permissions.PermissionDefault;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.checkerframework.framework.qual.DefaultQualifier;
+import org.galemc.gale.command.GaleCommand;
+import org.galemc.gale.command.PermissionedGaleSubcommand;
+
+@DefaultQualifier(NonNull.class)
+public final class VersionCommand extends PermissionedGaleSubcommand {
+
+    public final static String LITERAL_ARGUMENT = "version";
+    public static final String PERM = GaleCommand.BASE_PERM + "." + LITERAL_ARGUMENT;
+
+    public VersionCommand() {
+        super(PERM, PermissionDefault.TRUE);
+    }
+
+    @Override
+    public boolean execute(final CommandSender sender, final String subCommand, final String[] args) {
+        final @Nullable Command ver = MinecraftServer.getServer().server.getCommandMap().getCommand("version");
+        if (ver != null) {
+            ver.execute(sender, GaleCommand.COMMAND_LABEL, new String[0]);
+        }
+        return true;
+    }
+
+    @Override
+    public boolean testPermission(CommandSender sender) {
+        return super.testPermission(sender) && sender.hasPermission("bukkit.command.version");
+    }
+    
+}
diff --git a/src/main/java/org/galemc/gale/configuration/GaleConfigurations.java b/src/main/java/org/galemc/gale/configuration/GaleConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..de25d0b4001363e63873af8f0f2165e5449786df
--- /dev/null
+++ b/src/main/java/org/galemc/gale/configuration/GaleConfigurations.java
@@ -0,0 +1,304 @@
+// Gale - Gale configuration
+
+package org.galemc.gale.configuration;
+
+import com.google.common.collect.Table;
+import com.mojang.logging.LogUtils;
+import io.leangen.geantyref.TypeToken;
+import io.papermc.paper.configuration.Configuration;
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.Configurations;
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.configuration.WorldConfiguration;
+import io.papermc.paper.configuration.mapping.InnerClassFieldDiscoverer;
+import io.papermc.paper.configuration.NestedSetting;
+import io.papermc.paper.configuration.PaperConfigurations;
+import io.papermc.paper.configuration.legacy.RequiresSpigotInitialization;
+import io.papermc.paper.configuration.serializer.ComponentSerializer;
+import io.papermc.paper.configuration.serializer.EnumValueSerializer;
+import io.papermc.paper.configuration.serializer.collections.FastutilMapSerializer;
+import io.papermc.paper.configuration.serializer.PacketClassSerializer;
+import io.papermc.paper.configuration.serializer.StringRepresentableSerializer;
+import io.papermc.paper.configuration.serializer.collections.TableSerializer;
+import io.papermc.paper.configuration.serializer.collections.MapSerializer;
+import io.papermc.paper.configuration.serializer.registry.RegistryHolderSerializer;
+import io.papermc.paper.configuration.serializer.registry.RegistryValueSerializer;
+import io.papermc.paper.configuration.transformation.Transformations;
+import io.papermc.paper.configuration.type.BooleanOrDefault;
+import io.papermc.paper.configuration.type.number.DoubleOr;
+import io.papermc.paper.configuration.type.Duration;
+import io.papermc.paper.configuration.type.EngineMode;
+import io.papermc.paper.configuration.type.number.IntOr;
+import io.papermc.paper.configuration.type.fallback.FallbackValueSerializer;
+import it.unimi.dsi.fastutil.objects.Reference2IntMap;
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.Reference2LongMap;
+import it.unimi.dsi.fastutil.objects.Reference2LongOpenHashMap;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.levelgen.feature.ConfiguredFeature;
+import org.jetbrains.annotations.Nullable;
+import org.slf4j.Logger;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.NodePath;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.transformation.ConfigurationTransformation;
+import org.spongepowered.configurate.transformation.TransformAction;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.IOException;
+import java.lang.reflect.Type;
+import java.nio.file.Path;
+import java.util.Collections;
+import java.util.List;
+import java.util.function.Function;
+
+import static io.leangen.geantyref.GenericTypeReflector.erase;
+
+@SuppressWarnings("Convert2Diamond")
+public class GaleConfigurations extends Configurations<GaleGlobalConfiguration, GaleWorldConfiguration> {
+
+    private static final Logger LOGGER = LogUtils.getLogger();
+    static final String GLOBAL_CONFIG_FILE_NAME = "gale-global.yml";
+    static final String WORLD_DEFAULTS_CONFIG_FILE_NAME = "gale-world-defaults.yml";
+    static final String WORLD_CONFIG_FILE_NAME = "gale-world.yml";
+    public static final String CONFIG_DIR = "config";
+
+    private static final String GLOBAL_HEADER = String.format("""
+            This is the global configuration file for Gale.
+            As you can see, there's a lot to configure. Some options may impact gameplay, so use
+            with caution, and make sure you know what each option does before configuring.
+
+            If you need help with the configuration or have any questions related to Gale,
+            join us in our Discord, or check the GitHub Wiki pages.
+
+            The world configuration options are inside
+            their respective world folder. The files are named %s
+
+            Wiki: https://github.com/GaleMC/Gale/wiki
+            Discord: https://discord.gg/gwezNT8c24""", WORLD_CONFIG_FILE_NAME);
+
+    private static final String WORLD_DEFAULTS_HEADER = """
+            This is the world defaults configuration file for Gale.
+            As you can see, there's a lot to configure. Some options may impact gameplay, so use
+            with caution, and make sure you know what each option does before configuring.
+
+            If you need help with the configuration or have any questions related to Gale,
+            join us in our Discord, or check the GitHub Wiki pages.
+
+            Configuration options here apply to all worlds, unless you specify overrides inside
+            the world-specific config file inside each world folder.
+
+            Wiki: https://github.com/GaleMC/Gale/wiki
+            Discord: https://discord.gg/gwezNT8c24""";
+
+    private static final Function<ContextMap, String> WORLD_HEADER = map -> String.format("""
+        This is a world configuration file for Gale.
+        This file may start empty but can be filled with settings to override ones in the %s/%s
+        
+        World: %s (%s)""",
+        CONFIG_DIR,
+        WORLD_DEFAULTS_CONFIG_FILE_NAME,
+        map.require(WORLD_NAME),
+        map.require(WORLD_KEY)
+    );
+
+    private static final String MOVED_NOTICE = """
+        The global and world default configuration files have moved to %s
+        and the world-specific configuration file has been moved inside
+        the respective world folder.
+        
+        See https://github.com/GaleMC/Gale/wiki for more information.
+        """;
+
+    public GaleConfigurations(final Path globalFolder) {
+        super(globalFolder, GaleGlobalConfiguration.class, GaleWorldConfiguration.class, GLOBAL_CONFIG_FILE_NAME, WORLD_DEFAULTS_CONFIG_FILE_NAME, WORLD_CONFIG_FILE_NAME);
+    }
+
+    @Override
+    protected YamlConfigurationLoader.Builder createLoaderBuilder() {
+        return super.createLoaderBuilder()
+            .defaultOptions(GaleConfigurations::defaultOptions);
+    }
+
+    private static ConfigurationOptions defaultOptions(ConfigurationOptions options) {
+        return options.serializers(builder -> builder
+            .register(MapSerializer.TYPE, new MapSerializer(false))
+            .register(new EnumValueSerializer())
+            .register(new ComponentSerializer())
+        );
+    }
+
+    @Override
+    protected ObjectMapper.Factory.Builder createGlobalObjectMapperFactoryBuilder() {
+        return defaultGlobalFactoryBuilder(super.createGlobalObjectMapperFactoryBuilder());
+    }
+
+    private static ObjectMapper.Factory.Builder defaultGlobalFactoryBuilder(ObjectMapper.Factory.Builder builder) {
+        return builder.addDiscoverer(InnerClassFieldDiscoverer.globalConfig());
+    }
+
+    @Override
+    protected YamlConfigurationLoader.Builder createGlobalLoaderBuilder() {
+        return super.createGlobalLoaderBuilder()
+            .defaultOptions(GaleConfigurations::defaultGlobalOptions);
+    }
+
+    private static ConfigurationOptions defaultGlobalOptions(ConfigurationOptions options) {
+        return options
+            .header(GLOBAL_HEADER)
+            .serializers(builder -> builder.register(new PacketClassSerializer()));
+    }
+
+    @Override
+    public GaleGlobalConfiguration initializeGlobalConfiguration(final RegistryAccess registryAccess) throws ConfigurateException {
+        GaleGlobalConfiguration configuration = super.initializeGlobalConfiguration(registryAccess);
+        GaleGlobalConfiguration.set(configuration);
+        return configuration;
+    }
+
+    @Override
+    protected ContextMap.Builder createDefaultContextMap(final RegistryAccess registryAccess) {
+        return super.createDefaultContextMap(registryAccess)
+            .put(PaperConfigurations.SPIGOT_WORLD_CONFIG_CONTEXT_KEY, PaperConfigurations.SPIGOT_WORLD_DEFAULTS);
+    }
+
+    @Override
+    protected ObjectMapper.Factory.Builder createWorldObjectMapperFactoryBuilder(final ContextMap contextMap) {
+        return super.createWorldObjectMapperFactoryBuilder(contextMap)
+            .addNodeResolver(new RequiresSpigotInitialization.Factory(contextMap.require(PaperConfigurations.SPIGOT_WORLD_CONFIG_CONTEXT_KEY).get()))
+            .addNodeResolver(new NestedSetting.Factory())
+            .addDiscoverer(InnerClassFieldDiscoverer.galeWorldConfig(contextMap));
+    }
+
+    @Override
+    protected YamlConfigurationLoader.Builder createWorldConfigLoaderBuilder(final ContextMap contextMap) {
+        final RegistryAccess access = contextMap.require(REGISTRY_ACCESS);
+        return super.createWorldConfigLoaderBuilder(contextMap)
+            .defaultOptions(options -> options
+                .header(contextMap.require(WORLD_NAME).equals(WORLD_DEFAULTS) ? WORLD_DEFAULTS_HEADER : WORLD_HEADER.apply(contextMap))
+                .serializers(serializers -> serializers
+                    .register(new TypeToken<Reference2IntMap<?>>() {}, new FastutilMapSerializer.SomethingToPrimitive<Reference2IntMap<?>>(Reference2IntOpenHashMap::new, Integer.TYPE))
+                    .register(new TypeToken<Reference2LongMap<?>>() {}, new FastutilMapSerializer.SomethingToPrimitive<Reference2LongMap<?>>(Reference2LongOpenHashMap::new, Long.TYPE))
+                    .register(new TypeToken<Table<?, ?, ?>>() {}, new TableSerializer())
+                    .register(new StringRepresentableSerializer())
+                    .register(IntOr.Default.SERIALIZER)
+                    .register(IntOr.Disabled.SERIALIZER)
+                    .register(DoubleOr.Default.SERIALIZER)
+                    .register(BooleanOrDefault.SERIALIZER)
+                    .register(Duration.SERIALIZER)
+                    .register(EngineMode.SERIALIZER)
+                    .register(FallbackValueSerializer.create(contextMap.require(PaperConfigurations.SPIGOT_WORLD_CONFIG_CONTEXT_KEY).get(), MinecraftServer::getServer))
+                    .register(new RegistryValueSerializer<>(new TypeToken<EntityType<?>>() {}, access, Registries.ENTITY_TYPE, true))
+                    .register(new RegistryValueSerializer<>(Item.class, access, Registries.ITEM, true))
+                    .register(new RegistryHolderSerializer<>(new TypeToken<ConfiguredFeature<?, ?>>() {}, access, Registries.CONFIGURED_FEATURE, false))
+                    .register(new RegistryHolderSerializer<>(Item.class, access, Registries.ITEM, true))
+                )
+            );
+    }
+
+    @Override
+    protected void applyWorldConfigTransformations(final ContextMap contextMap, final ConfigurationNode node, final @Nullable ConfigurationNode defaultsNode) throws ConfigurateException {
+        final ConfigurationNode version = node.node(Configuration.VERSION_FIELD);
+        final String world = contextMap.require(WORLD_NAME);
+        if (version.virtual()) {
+            LOGGER.warn("The Gale world config file for " + world + " didn't have a version set, assuming latest");
+            version.raw(GaleWorldConfiguration.CURRENT_VERSION);
+        }
+        if (GaleRemovedConfigurations.REMOVED_WORLD_PATHS.length > 0) {
+            ConfigurationTransformation.Builder builder = ConfigurationTransformation.builder();
+            for (NodePath path : GaleRemovedConfigurations.REMOVED_WORLD_PATHS) {
+                builder.addAction(path, TransformAction.remove());
+            }
+            builder.build().apply(node);
+        }
+        // ADD FUTURE TRANSFORMS HERE
+    }
+
+    @Override
+    protected void applyGlobalConfigTransformations(ConfigurationNode node) throws ConfigurateException {
+        if (GaleRemovedConfigurations.REMOVED_GLOBAL_PATHS.length > 0) {
+            ConfigurationTransformation.Builder builder = ConfigurationTransformation.builder();
+            for (NodePath path : GaleRemovedConfigurations.REMOVED_GLOBAL_PATHS) {
+                builder.addAction(path, TransformAction.remove());
+            }
+            builder.build().apply(node);
+        }
+        // ADD FUTURE TRANSFORMS HERE
+    }
+
+    private static final List<Transformations.DefaultsAware> DEFAULT_AWARE_TRANSFORMATIONS = Collections.emptyList();
+
+    @Override
+    protected void applyDefaultsAwareWorldConfigTransformations(final ContextMap contextMap, final ConfigurationNode worldNode, final ConfigurationNode defaultsNode) throws ConfigurateException {
+        final ConfigurationTransformation.Builder builder = ConfigurationTransformation.builder();
+        // ADD FUTURE TRANSFORMS HERE (these transforms run after the defaults have been merged into the node)
+        DEFAULT_AWARE_TRANSFORMATIONS.forEach(transform -> transform.apply(builder, contextMap, defaultsNode));
+
+        ConfigurationTransformation transformation;
+        try {
+            transformation = builder.build(); // build throws IAE if no actions were provided (bad zml)
+        } catch (IllegalArgumentException ignored) {
+            return;
+        }
+        transformation.apply(worldNode);
+    }
+
+    @Override
+    public GaleWorldConfiguration createWorldConfig(final ContextMap contextMap) {
+        final String levelName = contextMap.require(WORLD_NAME);
+        try {
+            return super.createWorldConfig(contextMap);
+        } catch (IOException exception) {
+            throw new RuntimeException("Could not create Gale world config for " + levelName, exception);
+        }
+    }
+
+    @Override
+    protected boolean isConfigType(final Type type) {
+        return ConfigurationPart.class.isAssignableFrom(erase(type));
+    }
+
+    public void reloadConfigs(MinecraftServer server) {
+        try {
+            this.initializeGlobalConfiguration(reloader(this.globalConfigClass, GaleGlobalConfiguration.get()));
+            this.initializeWorldDefaultsConfiguration(server.registryAccess());
+            for (ServerLevel level : server.getAllLevels()) {
+                this.createWorldConfig(PaperConfigurations.createWorldContextMap(level), reloader(this.worldConfigClass, level.galeConfig()));
+            }
+        } catch (Exception ex) {
+            throw new RuntimeException("Could not reload Gale configuration files", ex);
+        }
+    }
+
+    public static GaleConfigurations setup(final Path configDir) throws Exception {
+        try {
+            PaperConfigurations.createDirectoriesSymlinkAware(configDir);
+            return new GaleConfigurations(configDir);
+        } catch (final IOException ex) {
+            throw new RuntimeException("Could not setup GaleConfigurations", ex);
+        }
+    }
+
+    @Override
+    protected int globalConfigVersion() {
+        return GaleGlobalConfiguration.CURRENT_VERSION;
+    }
+
+    @Override
+    protected int worldConfigVersion() {
+        return getWorldConfigurationCurrentVersion();
+    }
+
+    @Override
+    public int getWorldConfigurationCurrentVersion() {
+        return GaleWorldConfiguration.CURRENT_VERSION;
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/configuration/GaleGlobalConfiguration.java b/src/main/java/org/galemc/gale/configuration/GaleGlobalConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..37dbe70589328d64e7a6307d5ec3def8c08da9ea
--- /dev/null
+++ b/src/main/java/org/galemc/gale/configuration/GaleGlobalConfiguration.java
@@ -0,0 +1,139 @@
+// Gale - Gale configuration
+
+package org.galemc.gale.configuration;
+
+import io.papermc.paper.configuration.Configuration;
+import io.papermc.paper.configuration.ConfigurationPart;
+import net.minecraft.world.level.levelgen.structure.PoolElementStructurePiece;
+import org.bukkit.plugin.java.JavaPluginLoader;
+import org.spongepowered.configurate.objectmapping.meta.PostProcess;
+import org.spongepowered.configurate.objectmapping.meta.Setting;
+
+import java.util.Locale;
+import java.util.Random;
+import java.util.function.Consumer;
+
+@SuppressWarnings({"CanBeFinal", "FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
+public class GaleGlobalConfiguration extends ConfigurationPart {
+    static final int CURRENT_VERSION = 1;
+    private static GaleGlobalConfiguration instance;
+    public static GaleGlobalConfiguration get() {
+        return instance;
+    }
+    static void set(GaleGlobalConfiguration instance) {
+        GaleGlobalConfiguration.instance = instance;
+    }
+
+    @Setting(Configuration.VERSION_FIELD)
+    public int version = CURRENT_VERSION;
+
+    public SmallOptimizations smallOptimizations;
+    public class SmallOptimizations extends ConfigurationPart {
+
+        public ReducedIntervals reducedIntervals;
+        public class ReducedIntervals extends ConfigurationPart {
+
+            public int increaseTimeStatistics = 20; // Gale - Hydrinity - increase time statistics in intervals
+            public int updateEntityLineOfSight = 4; // Gale - Petal - reduce line of sight updates
+
+            @PostProcess
+            public void postProcess() {
+                net.minecraft.world.entity.player.Player.increaseTimeStatisticsInterval = Math.max(1, increaseTimeStatistics); // Gale - Hydrinity - increase time statistics in intervals - store as static field for fast access
+            }
+
+        }
+
+        // Gale start - xor-shift random
+        public UseXorShiftRandom useXorShiftRandom;
+        public class UseXorShiftRandom extends ConfigurationPart {
+
+            public boolean autoReplenishLootableRefill = true;
+            public boolean elytraFireworkSpeed = true;
+            public boolean entityWakeUpDuration = true;
+
+            @Setting("generate-tree-with-bukkit-api")
+            public boolean generateTreeWithBukkitAPI = true;
+
+            @PostProcess
+            public void postProcess() {
+                com.destroystokyo.paper.loottable.PaperLootableInventoryData.RANDOM = autoReplenishLootableRefill ? new org.galemc.gale.random.XorShiftRandom() : new Random();
+                org.spigotmc.ActivationRange.wakeUpDurationRandom = entityWakeUpDuration ? new org.galemc.gale.random.XorShiftRandom() : new java.util.Random();
+                org.bukkit.craftbukkit.CraftWorld.rand = generateTreeWithBukkitAPI ? new org.galemc.gale.random.XorShiftRandom() : new Random();
+            }
+
+        }
+        // Gale end - xor-shift random
+
+    }
+
+    public GameplayMechanics gameplayMechanics;
+    public class GameplayMechanics extends ConfigurationPart {
+
+        public boolean enableBookWriting = true; // Gale - Pufferfish - make book writing configurable
+
+    }
+
+    public Misc misc;
+    public class Misc extends ConfigurationPart {
+
+        public int premiumAccountSlowLoginTimeout = -1; // Gale - make slow login timeout configurable
+        public boolean ignoreNullLegacyStructureData = false; // Gale - MultiPaper - ignore null legacy structure data
+
+        // Gale start - YAPFA - last tick time - in TPS command
+        public LastTickTimeInTpsCommand lastTickTimeInTpsCommand;
+        public class LastTickTimeInTpsCommand extends ConfigurationPart {
+            public boolean enabled = false;
+            public boolean addOversleep = false;
+        }
+        // Gale end - YAPFA - last tick time - in TPS command
+
+    }
+
+    public LogToConsole logToConsole;
+    public class LogToConsole extends ConfigurationPart { // Gale - EMC - softly log invalid pool element errors
+
+        public boolean invalidStatistics = true; // Gale - EMC - do not log invalid statistics
+        public boolean nullIdDisconnections = true; // Gale - Pufferfish - do not log disconnections with null id
+        public boolean playerLoginLocations = true; // Gale - JettPack - make logging login location configurable
+
+        public Chat chat;
+        public class Chat extends ConfigurationPart {
+            public boolean emptyMessageWarning = false; // Gale - do not log empty message warnings
+            public boolean notSecureMarker = true; // Gale - do not log Not Secure marker
+        }
+
+        // Gale start - Purpur - do not log plugin library loads
+        public PluginLibraryLoader pluginLibraryLoader;
+        public class PluginLibraryLoader extends ConfigurationPart {
+
+            public boolean downloads = true;
+            public boolean startLoadLibrariesForPlugin = true;
+            public boolean libraryLoaded = true;
+
+            @PostProcess
+            public void postProcess() {
+                JavaPluginLoader.logDownloads = this.downloads;
+                JavaPluginLoader.logStartLoadLibrariesForPlugin = this.startLoadLibrariesForPlugin;
+                JavaPluginLoader.logLibraryLoaded = this.libraryLoaded;
+            }
+
+        }
+        // Gale end - Purpur - do not log plugin library loads
+
+        // Gale start - EMC - softly log invalid pool element errors
+        public String invalidPoolElementErrorLogLevel = "info";
+        public transient Consumer<String> invalidPoolElementErrorStringConsumer;
+
+        @PostProcess
+        public void postProcess() {
+            this.invalidPoolElementErrorStringConsumer = switch (this.invalidPoolElementErrorLogLevel.toLowerCase(Locale.ROOT)) {
+                case "none" -> $ -> {};
+                case "info", "log" -> PoolElementStructurePiece.LOGGER::info;
+                case "warn", "warning" -> PoolElementStructurePiece.LOGGER::warn;
+                default -> PoolElementStructurePiece.LOGGER::error;
+            };
+        }
+        // Gale end - EMC - softly log invalid pool element errors
+
+    }
+}
diff --git a/src/main/java/org/galemc/gale/configuration/GaleRemovedConfigurations.java b/src/main/java/org/galemc/gale/configuration/GaleRemovedConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..9db322100dacbf2343fbb86e3e83d99febfa9d9d
--- /dev/null
+++ b/src/main/java/org/galemc/gale/configuration/GaleRemovedConfigurations.java
@@ -0,0 +1,13 @@
+// Gale - Gale configuration
+
+package org.galemc.gale.configuration;
+
+import org.spongepowered.configurate.NodePath;
+
+interface GaleRemovedConfigurations {
+
+    NodePath[] REMOVED_WORLD_PATHS = {};
+
+    NodePath[] REMOVED_GLOBAL_PATHS = {};
+
+}
diff --git a/src/main/java/org/galemc/gale/configuration/GaleWorldConfiguration.java b/src/main/java/org/galemc/gale/configuration/GaleWorldConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..bf971f07037c19bbce3c261349203f3dc76accb5
--- /dev/null
+++ b/src/main/java/org/galemc/gale/configuration/GaleWorldConfiguration.java
@@ -0,0 +1,112 @@
+// Gale - Gale configuration
+
+package org.galemc.gale.configuration;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.configuration.Configuration;
+import io.papermc.paper.configuration.ConfigurationPart;
+import io.papermc.paper.configuration.PaperConfigurations;
+import net.minecraft.resources.ResourceLocation;
+import org.slf4j.Logger;
+import org.spigotmc.SpigotWorldConfig;
+import org.spongepowered.configurate.objectmapping.meta.Setting;
+
+@SuppressWarnings({"FieldCanBeLocal", "FieldMayBeFinal", "NotNullFieldNotInitialized", "InnerClassMayBeStatic"})
+public class GaleWorldConfiguration extends ConfigurationPart {
+    private static final Logger LOGGER = LogUtils.getLogger();
+    public static final int CURRENT_VERSION = 1;
+
+    private transient final SpigotWorldConfig spigotConfig;
+    private transient final ResourceLocation worldKey;
+    public GaleWorldConfiguration(SpigotWorldConfig spigotConfig, ResourceLocation worldKey) {
+        this.spigotConfig = spigotConfig;
+        this.worldKey = worldKey;
+    }
+
+    public boolean isDefault() {
+        return this.worldKey.equals(PaperConfigurations.WORLD_DEFAULTS_KEY);
+    }
+
+    @Setting(Configuration.VERSION_FIELD)
+    public int version = CURRENT_VERSION;
+
+    public SmallOptimizations smallOptimizations;
+    public class SmallOptimizations extends ConfigurationPart {
+
+        public boolean saveFireworks = true; // Gale - EMC - make saving fireworks configurable
+
+        public ReducedIntervals reducedIntervals;
+        public class ReducedIntervals extends ConfigurationPart {
+
+            public int acquirePoiForStuckEntity = 60; // Gale - Airplane - reduce acquire POI for stuck entities
+            public int villagerItemRepickup = 100; // Gale - EMC - reduce villager item re-pickup
+
+            public CheckNearbyItem checkNearbyItem;
+            public class CheckNearbyItem extends ConfigurationPart {
+
+                // Gale start - EMC - reduce hopper item checks
+                public Hopper hopper;
+                public class Hopper extends ConfigurationPart {
+
+                    public int interval = 1;
+
+                    public Minecart minecart;
+                    public class Minecart extends ConfigurationPart {
+
+                        public int interval = 1;
+
+                        public TemporaryImmunity temporaryImmunity;
+                        public class TemporaryImmunity extends ConfigurationPart {
+                            public int duration = 100;
+                            public int nearbyItemMaxAge = 1200;
+                            public int checkForMinecartNearItemInterval = 20;
+                            public boolean checkForMinecartNearItemWhileInactive = true;
+                            public double maxItemHorizontalDistance = 24.0;
+                            public double maxItemVerticalDistance = 4.0;
+                        }
+
+                    }
+
+                }
+                // Gale end - EMC - reduce hopper item checks
+
+            }
+
+        }
+
+        public LoadChunks loadChunks;
+        public class LoadChunks extends ConfigurationPart {
+            public boolean toSpawnPhantoms = false; // Gale - MultiPaper - don't load chunks to spawn phantoms
+        }
+
+    }
+
+    public GameplayMechanics gameplayMechanics;
+    public class GameplayMechanics extends ConfigurationPart {
+
+        public Fixes fixes;
+        public class Fixes extends ConfigurationPart {
+
+            public boolean broadcastCritAnimationsAsTheEntityBeingCritted = false; // Gale - MultiPaper - broadcast crit animations as the entity being critted
+
+            // Gale start - Mirai - fix MC-110386
+            @Setting("mc-110386")
+            public boolean mc110386 = true;
+            // Gale end - Mirai - fix MC-110386
+
+            // Gale start - Mirai - fix MC-31819
+            @Setting("mc-31819")
+            public boolean mc31819 = true;
+            // Gale end - Mirai - fix MC-31819
+
+        }
+
+        public boolean arrowMovementResetsDespawnCounter = true; // Gale - Purpur - make arrow movement resetting despawn counter configurable
+        public boolean entitiesCanRandomStrollIntoNonTickingChunks = true; // Gale - MultiPaper - prevent entities random strolling into non-ticking chunks
+        public double entityWakeUpDurationRatioStandardDeviation = 0.2; // Gale - variable entity wake-up duration
+        public boolean hideFlamesOnEntitiesWithFireResistance = false; // Gale - Slice - hide flames on entities with fire resistance
+        public boolean tryRespawnEnderDragonAfterEndCrystalPlace = true; // Gale - Pufferfish - make ender dragon respawn attempt after placing end crystals configurable
+
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/random/XorShiftRandom.java b/src/main/java/org/galemc/gale/random/XorShiftRandom.java
new file mode 100644
index 0000000000000000000000000000000000000000..60dc2c1deb0749168d03c5d94136e613b09ce534
--- /dev/null
+++ b/src/main/java/org/galemc/gale/random/XorShiftRandom.java
@@ -0,0 +1,404 @@
+// Gale - xor-shift random
+
+package org.galemc.gale.random;
+
+import java.util.Random;
+
+/**
+ * A random number generator based on the simple and fast xor-shift pseudo
+ * random number generator (RNG) specified in:
+ * <br>
+ * &nbsp;&nbsp;&nbsp;&nbsp;Marsaglia, George. (2003).
+ * <a href="https://www.researchgate.net/publication/5142825_Xorshift_RNGs">Xorshift RNGs</a>.
+ * <br>
+ * Code from:
+ * <br>
+ * &nbsp;&nbsp;&nbsp;&nbsp;<a href="https://gist.github.com/Xyene/4637619">Random.java</a>
+ * by <a href="https://gist.github.com/Xyene">Xyene</a>.
+ * <br>
+ * Translated from:
+ * <br>
+ * &nbsp;&nbsp;&nbsp;&nbsp;<a href="http://www.codeproject.com/Articles/9187/A-fast-equivalent-for-System-Random">
+ * A fast equivalent for System.Random</a> by <a href="https://www.codeproject.com/Members/colgreen">colgreen</a>.
+ * <br>
+ * Licensed under <a href="https://www.gnu.org/licenses/lgpl-3.0.html">GNU Lesser General Public License version 3</a>.
+ */
+public final class XorShiftRandom extends Random {
+    final double REAL_UNIT_INT = 1.0 / (0x7FFFFFFFL);
+    final double REAL_UNIT_UINT = 1.0 / (0xFFFFFFFFL);
+    final long Y = 842502087L, Z = 3579807591L, W = 273326509L;
+    long x, y, z, w;
+
+    public XorShiftRandom() {
+        seed((int) System.currentTimeMillis());
+    }
+
+    @Override
+    public void setSeed(long seed) {
+        seed((int) seed);
+    }
+
+    public void seed(int seed) {
+        // The only stipulation stated for the xorshift RNG is that at least one of
+        // the seeds x,y,z,w is non-zero. We fulfill that requirement by only allowing
+        // resetting of the x seed
+        x = seed;
+        y = Y;
+        z = Z;
+        w = W;
+    }
+
+    long boolBuffer;
+    int boolBufferBits = 0;
+
+    @Override
+    public boolean nextBoolean() {
+        if (boolBufferBits == 0) {
+            boolBuffer = nextUInt();
+            boolBufferBits = 32;
+        }
+        boolBuffer >>= 1;
+        boolean bit = (boolBuffer & 1) == 0;
+        --boolBufferBits;
+        return bit;
+    }
+
+    @Override
+    public void nextBytes(byte[] buffer) {
+        // Fill up the bulk of the buffer in chunks of 4 bytes at a time.
+        long x = this.x, y = this.y, z = this.z, w = this.w;
+        int i = 0;
+        long t;
+        for (int bound = buffer.length - 3; i < bound; ) {
+            // Generate 4 bytes.
+            // Increased performance is achieved by generating 4 random bytes per loop.
+            // Also note that no mask needs to be applied to zero out the higher order bytes before
+            // casting because the cast ignores thos bytes. Thanks to Stefan Trosch黷z for pointing this out.
+            t = (x ^ (x << 11));
+            x = y;
+            y = z;
+            z = w;
+            w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
+
+            buffer[i++] = (byte) w;
+            buffer[i++] = (byte) (w >> 8);
+            buffer[i++] = (byte) (w >> 16);
+            buffer[i++] = (byte) (w >> 24);
+        }
+
+        // Fill up any remaining bytes in the buffer.
+        if (i < buffer.length) {
+            // Generate 4 bytes.
+            t = (x ^ (x << 11));
+            x = y;
+            y = z;
+            z = w;
+            w = (w ^ (w >> 19)) ^ (t ^ (t >> 8));
+
+            buffer[i++] = (byte) w;
+            if (i < buffer.length) {
+                buffer[i++] = (byte) (w >> 8);
+                if (i < buffer.length) {
+                    buffer[i++] = (byte) (w >> 16);
+                    if (i < buffer.length) {
+                        buffer[i] = (byte) (w >> 24);
+                    }
+                }
+            }
+        }
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        this.w = w;
+    }
+
+    @Override
+    public double nextDouble() {
+        long t = (x ^ (x << 11));
+        x = y;
+        y = z;
+        z = w;
+
+        // Here we can gain a 2x speed improvement by generating a value that can be cast to
+        // an int instead of the more easily available uint. If we then explicitly cast to an
+        // int the compiler will then cast the int to a double to perform the multiplication,
+        // this final cast is a lot faster than casting from a uint to a double. The extra cast
+        // to an int is very fast (the allocated bits remain the same) and so the overall effect
+        // of the extra cast is a significant performance improvement.
+        //
+        // Also note that the loss of one bit of precision is equivalent to what occurs within
+        // System.Random.
+        return (REAL_UNIT_INT * (int) (0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))));
+    }
+
+    public double random() {
+        return nextDouble();
+    }
+
+    @Override
+    public float nextFloat() {
+        return (float) nextDouble();
+    }
+
+    @Override
+    public int nextInt() {
+        long t = (x ^ (x << 11));
+        x = y;
+        y = z;
+        z = w;
+        return (int) (0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))));
+    }
+
+    @Override
+    public int nextInt(int upperBound) {
+        if (upperBound < 0)
+            throw new IllegalArgumentException("upperBound must be >=0");
+
+        long t = (x ^ (x << 11));
+        x = y;
+        y = z;
+        z = w;
+
+        return (int) ((REAL_UNIT_INT * (int) (0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * upperBound);
+    }
+
+    public int nextInt(int lowerBound, int upperBound) {
+        if (lowerBound > upperBound)
+            throw new IllegalArgumentException("upperBound must be >=lowerBound");
+
+        long t = (x ^ (x << 11));
+        x = y;
+        y = z;
+        z = w;
+
+        // The explicit int cast before the first multiplication gives better performance.
+        // See comments in NextDouble.
+        int range = upperBound - lowerBound;
+        if (range < 0) {
+            // If range is <0 then an overflow has occured and must resort to using long integer arithmetic instead (slower).
+            // We also must use all 32 bits of precision, instead of the normal 31, which again is slower.
+            return lowerBound + (int) ((REAL_UNIT_UINT * (double) (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)))) * (double) ((long) upperBound - (long) lowerBound));
+        }
+        // 31 bits of precision will suffice if range<=int.MaxValue. This allows us to cast to an int and gain
+        // a little more performance.
+        return lowerBound + (int) ((REAL_UNIT_INT * (double) (int) (0x7FFFFFFF & (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))))) * (double) range);
+    }
+
+    public long nextUInt() {
+        long t = (x ^ (x << 11));
+        x = y;
+        y = z;
+        z = w;
+        return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8))) & (0xFFFFFFFFL);
+    }
+
+    @Override
+    public long nextLong() {
+        return nextUInt() << 32 + nextUInt();
+    }
+
+    double gaussNext;
+    boolean hasGaussNext;
+    final double TWOPI = Math.PI * 2;
+
+    /**
+     * Get a random number in the range [min, max) or [min, max] depending on rounding.
+     *
+     * @param min Low bound
+     * @param max High bound
+     * @return A uniformly distributed double
+     */
+    public double uniform(double min, double max) {
+        return min + (max - min) * nextDouble();
+    }
+
+    /**
+     * Triangular distribution.
+     * <p/>
+     * Continuous distribution bounded by given lower and upper limits,
+     * and having a given mode value in-between.
+     * http://en.wikipedia.org/wiki/Triangular_distribution
+     *
+     * @param low  Low bound
+     * @param high High bound
+     * @param mode Mode
+     * @return A number from the triangular distribution specified
+     */
+    public double triangular(int low, int high, int mode) {
+        double u = nextDouble();
+        double c = (mode - low) / (high - low);
+        if (u > c) {
+            u = 1.0 - u;
+            c = 1.0 - c;
+            int k = low;
+            low = high;
+            high = k;
+        }
+        return low + (high - low) * Math.sqrt(u * c);
+    }
+
+    /**
+     * Gaussian distribution, mean is 0 and standard deviation is 1.
+     * <p/>
+     * mu is the mean, and sigma is the standard deviation.
+     *
+     * @return A double in Gaussian distribution
+     */
+    public double gauss() {
+        return nextGaussian();
+    }
+
+    /**
+     * Gaussian distribution, with user-specified mean and standard deviation.
+     * <p/>
+     * mu is the mean, and sigma is the standard deviation.
+     *
+     * @return A double in Gaussian distribution
+     */
+    public double gauss(double mu, double sigma) {
+        return mu + sigma * nextGaussian();
+    }
+
+    public double gaussUnsigned(double mu, double sigma) {
+        double out = gauss(mu, sigma);
+        return out > 1 ? out : 1;
+    }
+
+    /**
+     * Log normal distribution.
+     * <p/>
+     * If you take the natural logarithm of this distribution, you'll get a
+     * normal distribution with mean mu and standard deviation sigma.
+     * mu can have any value, and sigma must be greater than zero.
+     *
+     * @param mu    Mean
+     * @param sigma Standard deviation
+     * @return A number from the log normal distribution specified
+     */
+    public double logNormal(double mu, double sigma) {
+        return Math.exp(gauss(mu, sigma));
+    }
+
+    /**
+     * Exponential distribution.
+     * <p/>
+     * lambda is 1.0 divided by the desired mean.  It should be
+     * nonzero. Returned values range from 0 to positive infinity
+     * if lambda is positive, and from negative infinity to 0
+     * if lambda is negative.
+     *
+     * @param lambda A non-zero value
+     */
+    public double exponential(double lambda) {
+        return -Math.log(1.0 - random()) / lambda;
+    }
+
+    /**
+     * Circular data distribution.
+     * <p/>
+     * If kappa is equal to zero, this distribution reduces
+     * to a uniform random angle over the range 0 to 2*pi.
+     *
+     * @param mu    the mean angle, expressed in radians between 0 and 2*pi.
+     * @param kappa the concentration parameter, which must be greater than or
+     *              equal to zero.
+     * @return A number from the circular data distribution specified
+     */
+    public double circularData(double mu, double kappa) {
+        if (kappa <= 1e-6)
+            return TWOPI * nextDouble();
+
+        double a = 1.0 + Math.sqrt(1.0 + 4.0 * kappa * kappa);
+        double b = (a - Math.sqrt(2.0 * a)) / (2.0 * kappa);
+        double r = (1.0 + b * b) / (2.0 * b);
+        double u1, u2, u3, f, c, z, theta = 0;
+
+        while (true) {
+            u1 = nextDouble();
+
+            z = Math.cos(Math.PI * u1);
+            f = (1.0 + r * z) / (r + z);
+            c = kappa * (r - f);
+
+            u2 = nextDouble();
+
+            if (u2 < c * (2.0 - c) || u2 <= c * Math.exp(1.0 - c))
+                break;
+
+            u3 = nextDouble();
+            if (u3 > 0.5)
+                theta = (mu % TWOPI) + Math.acos(f);
+            else
+                theta = (mu % TWOPI) - Math.acos(f);
+        }
+        return theta;
+    }
+
+
+    final double LOG4 = Math.log(4);
+    final double SG_MAGICCONST = 1.0 + Math.log(4.5);
+
+    /**
+     * Gamma distribution.  Not the gamma function!
+     * Conditions on the parameters are alpha > 0 and beta > 0.
+     * <p/>
+     * The probability distribution function is:
+     * pdf(x) = (x ** (alpha - 1) * math.exp(-x / beta)) / (math.gamma(alpha) * beta ** alpha)
+     *
+     * @param alpha Alpha
+     * @param beta  Beta
+     * @return A number from the gamma distribution specified
+     */
+    public double gamma(double alpha, double beta) {
+        if (alpha <= 0.0 || beta <= 0.0)
+            throw new IllegalArgumentException("alpha and beta must be > 0.0");
+
+        if (alpha > 1.0) {
+            double ainv = Math.sqrt(2.0 * alpha - 1.0);
+            double bbb = alpha - LOG4;
+            double ccc = alpha + ainv;
+            double u1, u2, v, x, z, r;
+
+            while (true) {
+                u1 = random();
+                if (!(1e-7 < u1 && u1 < .9999999))
+                    continue;
+                u2 = 1.0 - random();
+                v = Math.log(u1 / (1.0 - u1)) / ainv;
+                x = alpha * Math.exp(v);
+                z = u1 * u1 * u2;
+                r = bbb + ccc * v - x;
+                if (r + SG_MAGICCONST - 4.5 * z >= 0.0 || r >= Math.log(z))
+                    return x * beta;
+            }
+        } else if (alpha == 1.0) {
+            // exponential(1)
+            double u;
+            u = random();
+            while (u <= 1e-7)
+                u = random();
+            return -Math.log(u) * beta;
+        } else {
+            // alpha is between 0 and 1 (exclusive)
+            // Uses ALGORITHM GS of Statistical Computing -Kennedy & Gentle
+
+            double u, b, p, x, u1;
+            while (true) {
+                u = random();
+                b = (Math.E + alpha) / Math.E;
+                p = b * u;
+                if (p <= 1.0)
+                    x = Math.pow(p, (1.0 / alpha));
+                else
+                    x = -Math.log((b - p) / alpha);
+                u1 = random();
+                if (p > 1.0) {
+                    if (u1 <= Math.pow(x, (alpha - 1.0)))
+                        break;
+                } else if (u1 <= Math.exp(-x))
+                    break;
+            }
+            return x * beta;
+        }
+    }
+}
diff --git a/src/main/java/org/galemc/gale/version/AbstractPaperVersionFetcher.java b/src/main/java/org/galemc/gale/version/AbstractPaperVersionFetcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..fab5d5af9ec6a20810ce5e437dd617684cc5768f
--- /dev/null
+++ b/src/main/java/org/galemc/gale/version/AbstractPaperVersionFetcher.java
@@ -0,0 +1,154 @@
+// Gale - branding changes - version fetcher
+
+package org.galemc.gale.version;
+
+import com.destroystokyo.paper.PaperVersionFetcher;
+import com.destroystokyo.paper.VersionHistoryManager;
+import com.destroystokyo.paper.util.VersionFetcher;
+import com.google.common.base.Charsets;
+import com.google.gson.Gson;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonSyntaxException;
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.ServerBuildInfo;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+
+import javax.annotation.Nullable;
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.HttpURLConnection;
+import java.net.URI;
+import java.util.Optional;
+
+import static net.kyori.adventure.text.Component.text;
+import static net.kyori.adventure.text.format.TextColor.color;
+
+/**
+ * An abstract version fetcher, derived from {@link PaperVersionFetcher}.
+ * This class was then made to be a superclass of both {@link PaperVersionFetcher}
+ * and {@link GaleVersionFetcher}.
+ * <br>
+ * Changes to {@link PaperVersionFetcher} are indicated by Gale marker comments.
+ */
+public abstract class AbstractPaperVersionFetcher implements VersionFetcher {
+    protected static final Logger LOGGER = LogUtils.getClassLogger();
+    protected static final int DISTANCE_ERROR = -1;
+    protected static final int DISTANCE_UNKNOWN = -2;
+    protected static final ServerBuildInfo BUILD_INFO = ServerBuildInfo.buildInfo();
+
+    // Gale start - branding changes - version fetcher
+    protected final String gitHubBranchName;
+    protected final String downloadPage;
+    protected final String organizationDisplayName;
+    protected final String projectDisplayName;
+    protected final String gitHubOrganizationName;
+    protected final String gitHubRepoName;
+
+    protected AbstractPaperVersionFetcher(String githubBranchName, String downloadPage, String organizationDisplayName, String projectDisplayName, String gitHubOrganizationName, String gitHubRepoName) {
+        this.gitHubBranchName = githubBranchName;
+        this.downloadPage = downloadPage;
+        this.organizationDisplayName = organizationDisplayName;
+        this.projectDisplayName = projectDisplayName;
+        this.gitHubOrganizationName = gitHubOrganizationName;
+        this.gitHubRepoName = gitHubRepoName;
+    }
+    // Gale end - branding changes - version fetcher
+
+    @Override
+    public long getCacheTime() {
+        return 720000;
+    }
+
+    @Override
+    public @NotNull Component getVersionMessage(final @NotNull String serverVersion) {
+        final Component updateMessage;
+        final ServerBuildInfo build = ServerBuildInfo.buildInfo();
+        if (build.buildNumber().isEmpty() && build.gitCommit().isEmpty()) {
+            updateMessage = text("You are running a development version without access to version information", color(0xFF5300));
+        } else {
+            updateMessage = getUpdateStatusMessage(this.gitHubOrganizationName + "/" + this.gitHubRepoName, build); // Gale - branding changes - version fetcher
+        }
+        final @Nullable Component history = this.getHistory();
+
+        return history != null ? Component.textOfChildren(updateMessage, Component.newline(), history) : updateMessage;
+    }
+
+    // Gale start - branding changes - version fetcher
+    protected boolean canFetchDistanceFromSiteApi() {
+        return false;
+    }
+
+    protected int fetchDistanceFromSiteApi(int jenkinsBuild) {
+        return -1;
+    }
+    // Gale end - branding changes - version fetcher
+
+    private Component getUpdateStatusMessage(final String repo, final ServerBuildInfo build) {
+        int distance = DISTANCE_ERROR;
+
+        // Gale start - branding changes - version fetcher
+        final Optional<String> gitBranch = build.gitBranch();
+        final Optional<String> gitCommit = build.gitCommit();
+        if (gitBranch.isPresent() && gitCommit.isPresent()) {
+            distance = fetchDistanceFromGitHub(repo, gitBranch.get(), gitCommit.get());
+        }
+        // Gale end - branding changes - version fetcher
+
+        return switch (distance) {
+            case DISTANCE_ERROR -> text("Error obtaining version information", NamedTextColor.YELLOW);
+            case 0 -> text("You are running the latest version", NamedTextColor.GREEN);
+            case DISTANCE_UNKNOWN -> text("Unknown version", NamedTextColor.YELLOW);
+            default -> text("You are " + distance + " version(s) behind", NamedTextColor.YELLOW)
+                    .append(Component.newline())
+                    .append(text("Download the new version at: ")
+                            .append(text(this.downloadPage, NamedTextColor.GOLD) // Gale - branding changes - version fetcher
+                                    .hoverEvent(text("Click to open", NamedTextColor.WHITE))
+                                    .clickEvent(ClickEvent.openUrl(this.downloadPage)))); // Gale - branding changes - version fetcher
+        };
+    }
+
+    // Contributed by Techcable <Techcable@outlook.com> in GH-65
+    private static int fetchDistanceFromGitHub(final String repo, final String branch, final String hash) {
+        try {
+            final HttpURLConnection connection = (HttpURLConnection) URI.create("https://api.github.com/repos/%s/compare/%s...%s".formatted(repo, branch, hash)).toURL().openConnection();
+            connection.connect();
+            if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND)
+                return DISTANCE_UNKNOWN; // Unknown commit
+            try (final BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), Charsets.UTF_8))) {
+                final JsonObject obj = new Gson().fromJson(reader, JsonObject.class);
+                final String status = obj.get("status").getAsString();
+                return switch (status) {
+                    case "identical" -> 0;
+                    case "behind" -> obj.get("behind_by").getAsInt();
+                    default -> DISTANCE_ERROR;
+                };
+            } catch (final JsonSyntaxException | NumberFormatException e) {
+                LOGGER.error("Error parsing json from GitHub's API", e);
+                return DISTANCE_ERROR;
+            }
+        } catch (final IOException e) {
+            LOGGER.error("Error while parsing version", e);
+            return DISTANCE_ERROR;
+        }
+    }
+
+    private @Nullable Component getHistory() {
+        final VersionHistoryManager.VersionData data = VersionHistoryManager.INSTANCE.getVersionData();
+        if (data == null) {
+            return null;
+        }
+
+        final @Nullable String oldVersion = data.getOldVersion();
+        if (oldVersion == null) {
+            return null;
+        }
+
+        return text("Previous version: " + oldVersion, NamedTextColor.GRAY, TextDecoration.ITALIC);
+    }
+}
diff --git a/src/main/java/org/galemc/gale/version/GaleSemanticVersion.java b/src/main/java/org/galemc/gale/version/GaleSemanticVersion.java
new file mode 100644
index 0000000000000000000000000000000000000000..f873cac7566e1951fc2977d6f7c4ba3cefa1a9f1
--- /dev/null
+++ b/src/main/java/org/galemc/gale/version/GaleSemanticVersion.java
@@ -0,0 +1,37 @@
+// Gale - semantic version
+
+package org.galemc.gale.version;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A holder for the Gale semantic version.
+ */
+public final class GaleSemanticVersion {
+
+    private GaleSemanticVersion() {
+        throw new RuntimeException();
+    }
+
+    /**
+     * A semantic version in the format "<code>major.minor.patch</code>", for example "<code>1.5.1</code>".
+     * The <code>major</code> version is incremented when a large and overarching set of features, with a large
+     * and overarching common goal or effect, has been added compared to the first release with that major version.
+     * The <code>minor</code> version is incremented for each build that has a different intended feature set
+     * (for example, some features or part of them were added or removed).
+     * The <code>patch</code> version is incremented for small changes that do not affect the goal of any feature,
+     * such as bug fixes, performance improvements or changes in wording.
+     */
+    public static final @NotNull String version = "0.6.15";
+
+    /**
+     * The "<code>major.minor</code>" portion of the {@link #version}.
+     */
+    public static final @NotNull String majorMinorVersion;
+    static {
+        int firstDotIndex = version.indexOf('.');
+        int secondDotIndex = version.indexOf('.', firstDotIndex + 1);
+        majorMinorVersion = version.substring(0, secondDotIndex);
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/version/GaleVersionFetcher.java b/src/main/java/org/galemc/gale/version/GaleVersionFetcher.java
new file mode 100644
index 0000000000000000000000000000000000000000..de2d223b0fb51d2feff5450950d2889dac3bc83c
--- /dev/null
+++ b/src/main/java/org/galemc/gale/version/GaleVersionFetcher.java
@@ -0,0 +1,17 @@
+// Gale - branding changes - version fetcher
+
+package org.galemc.gale.version;
+
+public class GaleVersionFetcher extends AbstractPaperVersionFetcher {
+
+    public GaleVersionFetcher() {
+        super(
+            "ver/1.21.1",
+            "https://github.com/Dreeam-qwq/Gale",
+            "GaleMC",
+            "Gale",
+            "GaleMC",
+            "Gale");
+    }
+
+}
diff --git a/src/main/java/org/galemc/gale/virtualthread/DirectVirtualThreadService.java b/src/main/java/org/galemc/gale/virtualthread/DirectVirtualThreadService.java
new file mode 100644
index 0000000000000000000000000000000000000000..38d3b77f3f8d582ce6732afab7e6787d6d0a0ead
--- /dev/null
+++ b/src/main/java/org/galemc/gale/virtualthread/DirectVirtualThreadService.java
@@ -0,0 +1,50 @@
+// Gale - virtual thread support
+
+package org.galemc.gale.virtualthread;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Objects;
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * An implementation of {@link VirtualThreadService} that can create virtual threads directly.
+ *
+ * @author Martijn Muijsers
+ */
+final class DirectVirtualThreadService extends VirtualThreadService {
+
+    private DirectVirtualThreadService() {
+        super();
+    }
+
+    @Override
+    public @NotNull ThreadFactory createFactory() {
+        // Disabled until Minecraft requires servers to have a Java version that can read class files compiled with functionality from Java 19+ on preview / Java 21+ on stable
+        //throw new UnsupportedOperationException();
+        return Thread.ofVirtual().factory();
+    }
+
+    @Override
+    public @NotNull Thread start(@NotNull Runnable task) {
+        // Disabled until Minecraft requires servers to have a Java version that can read class files compiled with functionality from Java 19+ on preview / Java 21+ on stable
+        //throw new UnsupportedOperationException();
+        Objects.requireNonNull(task, "The task to start a virtual thread cannot be null");
+        return Thread.ofVirtual().start(task);
+    }
+
+    /**
+     * @return A functional {@link DirectVirtualThreadService}.
+     * @throws Throwable If creating virtual threads directly is not supported by the current runtime.
+     * This could be any {@link Throwable}, including an {@link Exception} or an {@link Error}.
+     */
+    static @NotNull DirectVirtualThreadService create() throws Throwable {
+        // Disabled until Minecraft requires servers to have a Java version that can read class files compiled with functionality from Java 19+ on preview / Java 21+ on stable
+        //throw new UnsupportedOperationException();
+        var service = new DirectVirtualThreadService();
+        // Run some tests to verify
+        service.runTest();
+        // If we end up here, it works
+        return service;
+    }
+}
diff --git a/src/main/java/org/galemc/gale/virtualthread/ReflectionVirtualThreadService.java b/src/main/java/org/galemc/gale/virtualthread/ReflectionVirtualThreadService.java
new file mode 100644
index 0000000000000000000000000000000000000000..19b83cf45034be57d11413361b1b0c8756b12a29
--- /dev/null
+++ b/src/main/java/org/galemc/gale/virtualthread/ReflectionVirtualThreadService.java
@@ -0,0 +1,75 @@
+// Gale - virtual thread support
+
+package org.galemc.gale.virtualthread;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.lang.reflect.Method;
+import java.util.Objects;
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * An implementation of {@link VirtualThreadService} that can create virtual threads using Java reflection.
+ *
+ * @author Martijn Muijsers
+ */
+final class ReflectionVirtualThreadService extends VirtualThreadService {
+
+    /**
+     * The {@link Thread}<code>#ofVirtual()</code> method.
+     */
+    private final @NotNull Method Thread_ofVirtual_method;
+
+    /**
+     * The {@link Thread}<code>.Builder#factory()</code> method.
+     */
+    private final @NotNull Method Thread_Builder_factory_method;
+
+    /**
+     * The {@link Thread}<code>.Builder#start(Runnable)</code> method.
+     */
+    private final @NotNull Method Thread_Builder_start_method;
+
+    private ReflectionVirtualThreadService() throws Throwable {
+        this.Thread_ofVirtual_method = Objects.requireNonNull(Thread.class.getMethod("ofVirtual"));
+        // The Thread.Builder class
+        var Thread_Builder_class = Objects.requireNonNull(Class.forName("java.lang.Thread$Builder"));
+        this.Thread_Builder_factory_method = Objects.requireNonNull(Thread_Builder_class.getMethod("factory"));
+        this.Thread_Builder_start_method = Objects.requireNonNull(Thread_Builder_class.getMethod("start", Runnable.class));
+    }
+
+    @Override
+    public @NotNull ThreadFactory createFactory() {
+        try {
+            return (ThreadFactory) this.Thread_Builder_factory_method.invoke(this.Thread_ofVirtual_method.invoke(null));
+        } catch (Exception e) {
+            // This should not be possible because it was tested in create()
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public @NotNull Thread start(@NotNull Runnable task) {
+        Objects.requireNonNull(task, "The task to start a virtual thread cannot be null");
+        try {
+            return (Thread) this.Thread_Builder_start_method.invoke(this.Thread_ofVirtual_method.invoke(null), task);
+        } catch (Exception e) {
+            // This should not be possible because it was tested in create()
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * @return A functional {@link ReflectionVirtualThreadService}.
+     * @throws Throwable If creating virtual threads via reflection is not supported by the current runtime.
+     * This could be any {@link Throwable}, including an {@link Exception} or an {@link Error}.
+     */
+    static @NotNull ReflectionVirtualThreadService create() throws Throwable {
+        // This will already throw something if the reflection fails
+        var service = new ReflectionVirtualThreadService();
+        // Run some tests to verify
+        service.runTest();
+        // If we end up here, it works
+        return service;
+    }
+}
diff --git a/src/main/java/org/galemc/gale/virtualthread/VirtualThreadService.java b/src/main/java/org/galemc/gale/virtualthread/VirtualThreadService.java
new file mode 100644
index 0000000000000000000000000000000000000000..e9757e8ade7198accb7cf34390ed70628a0f7e33
--- /dev/null
+++ b/src/main/java/org/galemc/gale/virtualthread/VirtualThreadService.java
@@ -0,0 +1,104 @@
+// Gale - virtual thread support
+
+package org.galemc.gale.virtualthread;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.concurrent.ThreadFactory;
+
+/**
+ * An abstract service to create virtual threads.
+ *
+ * @author Martijn Muijsers
+ */
+public sealed abstract class VirtualThreadService permits ReflectionVirtualThreadService, DirectVirtualThreadService {
+
+    /**
+     * @return A {@link ThreadFactory} that produces virtual threads.
+     */
+    public abstract @NotNull ThreadFactory createFactory();
+
+    /**
+     * @param task The runnable for the thread to execute.
+     * @return A virtual thread that has been started with the given task.
+     */
+    public abstract @NotNull Thread start(Runnable task);
+
+    /**
+     * Runs a test on the {@link #createFactory} and {@link #start} methods,
+     * which certainly throws some {@link Throwable} if something goes wrong.
+     */
+    protected void runTest() throws Throwable {
+        // This will definitely throw something if it doesn't work
+        try {
+            this.start(() -> {}).join();
+        } catch (InterruptedException ignored) {} // Except InterruptedException, we don't care about that one
+        try {
+            var thread = this.createFactory().newThread(() -> {});
+            thread.start();
+            thread.join();
+        } catch (InterruptedException ignored) {} // Except InterruptedException, we don't care about that one
+        // If we end up here, it works
+    }
+
+    private static boolean initialized = false;
+
+    /**
+     * The {@link VirtualThreadService} for the current runtime,
+     * or null if virtual threads are not supported, or if not {@link #initialized} yet.
+     */
+    private static @Nullable VirtualThreadService implementation;
+
+    /**
+     * @return Whether virtual threads are supported on the current runtime.
+     */
+    public static boolean isSupported() {
+        return get() != null;
+    }
+
+    /**
+     * @return The {@link VirtualThreadService} for the current runtime,
+     * or null if virtual threads are not {@linkplain #isSupported() supported}.
+     *
+     * This method is thread-safe only after the first time it has been fully run.
+     */
+    public static @Nullable VirtualThreadService get() {
+        if (!initialized) {
+            initialized = true;
+            try {
+                implementation = DirectVirtualThreadService.create();
+            } catch (Throwable ignored) {
+                try {
+                    implementation = ReflectionVirtualThreadService.create();
+                } catch (Throwable ignored2) {}
+            }
+        }
+        return implementation;
+    }
+
+    /**
+     * The minimum major version of Java that is known to support using virtual threads
+     * (although possibly behind a feature preview flag).
+     */
+    public static final int minimumJavaMajorVersionWithFeaturePreview = 19;
+
+    /**
+     * The minimum major version of Java that is known to support using virtual threads
+     * even without any feature preview flags.
+     */
+    public static final int minimumJavaMajorVersionWithoutFeaturePreview = 21;
+
+    public static int getJavaMajorVersion() {
+        var version = System.getProperty("java.version");
+        if (version.startsWith("1.")) {
+            return version.charAt(2) - '0';
+        }
+        if (version.contains("-")) {
+            version = version.substring(0, version.indexOf("-"));
+        }
+
+        int dotIndex = version.indexOf(".");
+        return Integer.parseInt(dotIndex == -1 ? version : version.substring(0, dotIndex));
+    }
+}
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index 1d438ef44cbe4d1eedfba36d8fe5d2ad53464921..cf6fafa8371b910c3b56b0a2fad89b4b2c03f621 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -69,28 +69,40 @@ public class ActivationRange
         if (entity.activationType == ActivationType.VILLAGER) {
             if (inactiveFor > config.wakeUpInactiveVillagersEvery && world.wakeupInactiveRemainingVillagers > 0) {
                 world.wakeupInactiveRemainingVillagers--;
-                return config.wakeUpInactiveVillagersFor;
+                return getWakeUpDurationWithVariance(entity, config.wakeUpInactiveVillagersFor); // Gale - variable entity wake-up duration
             }
         } else if (entity.activationType == ActivationType.ANIMAL) {
             if (inactiveFor > config.wakeUpInactiveAnimalsEvery && world.wakeupInactiveRemainingAnimals > 0) {
                 world.wakeupInactiveRemainingAnimals--;
-                return config.wakeUpInactiveAnimalsFor;
+                return getWakeUpDurationWithVariance(entity, config.wakeUpInactiveAnimalsFor); // Gale - variable entity wake-up duration
             }
         } else if (entity.activationType == ActivationType.FLYING_MONSTER) {
             if (inactiveFor > config.wakeUpInactiveFlyingEvery && world.wakeupInactiveRemainingFlying > 0) {
                 world.wakeupInactiveRemainingFlying--;
-                return config.wakeUpInactiveFlyingFor;
+                return getWakeUpDurationWithVariance(entity, config.wakeUpInactiveFlyingFor); // Gale - variable entity wake-up duration
             }
         } else if (entity.activationType == ActivationType.MONSTER || entity.activationType == ActivationType.RAIDER) {
             if (inactiveFor > config.wakeUpInactiveMonstersEvery && world.wakeupInactiveRemainingMonsters > 0) {
                 world.wakeupInactiveRemainingMonsters--;
-                return config.wakeUpInactiveMonstersFor;
+                return getWakeUpDurationWithVariance(entity, config.wakeUpInactiveMonstersFor); // Gale - variable entity wake-up duration
             }
         }
         return -1;
     }
     // Paper end
 
+    // Gale start - variable entity wake-up duration
+    public static java.util.Random wakeUpDurationRandom; // Gale - xor-shift random - set in GaleGlobalConfiguration
+
+    private static int getWakeUpDurationWithVariance(Entity entity, int wakeUpDuration) {
+        double deviation = entity.level().galeConfig().gameplayMechanics.entityWakeUpDurationRatioStandardDeviation;
+        if (deviation <= 0) {
+            return wakeUpDuration;
+        }
+        return (int) Math.min(Integer.MAX_VALUE, Math.max(1, Math.round(wakeUpDuration * wakeUpDurationRandom.nextGaussian(1, deviation))));
+    }
+    // Gale end - variable entity wake-up duration
+
     static AABB maxBB = new AABB( 0, 0, 0, 0, 0, 0 );
 
     /**
diff --git a/src/main/java/org/spigotmc/TicksPerSecondCommand.java b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
index 9eb2823cc8f83bad2626fc77578b0162d9ed5782..f98325ac69f62ed576c5ec6b1edeb5e5f038f996 100644
--- a/src/main/java/org/spigotmc/TicksPerSecondCommand.java
+++ b/src/main/java/org/spigotmc/TicksPerSecondCommand.java
@@ -31,7 +31,7 @@ public class TicksPerSecondCommand extends Command
         }
 
         // Paper start - Further improve tick handling
-        double[] tps = org.bukkit.Bukkit.getTPS();
+        double[] tps = org.bukkit.Bukkit.getTPSIncluding5SecondAverage(); // Gale - Purpur - 5 second TPS average
         net.kyori.adventure.text.Component[] tpsAvg = new net.kyori.adventure.text.Component[tps.length];
 
         for ( int i = 0; i < tps.length; i++) {
@@ -39,9 +39,27 @@ public class TicksPerSecondCommand extends Command
         }
 
         net.kyori.adventure.text.TextComponent.Builder builder = net.kyori.adventure.text.Component.text();
-        builder.append(net.kyori.adventure.text.Component.text("TPS from last 1m, 5m, 15m: ", net.kyori.adventure.text.format.NamedTextColor.GOLD));
+        builder.append(net.kyori.adventure.text.Component.text("TPS from last 5s, 1m, 5m, 15m: ", net.kyori.adventure.text.format.NamedTextColor.GOLD)); // Gale - Purpur - 5 second TPS average
         builder.append(net.kyori.adventure.text.Component.join(net.kyori.adventure.text.JoinConfiguration.commas(true), tpsAvg));
         sender.sendMessage(builder.asComponent());
+        // Gale start - YAPFA - last tick time - in TPS command
+        if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().misc.lastTickTimeInTpsCommand.enabled) {
+            long lastTickProperTime = MinecraftServer.lastTickProperTime;
+            long lastTickOversleepTime = MinecraftServer.lastTickOversleepTime;
+            var lastTickTimeMessage = net.kyori.adventure.text.Component.text("Last tick: ")
+                .append(formatTickTimeDuration(lastTickProperTime, 44, 50, 51));
+            if (org.galemc.gale.configuration.GaleGlobalConfiguration.get().misc.lastTickTimeInTpsCommand.addOversleep) {
+                lastTickTimeMessage = lastTickTimeMessage.append(net.kyori.adventure.text.Component.text(" self + "))
+                    .append(formatTickTimeDuration(lastTickOversleepTime, Math.max(1, 51 - lastTickProperTime), Math.max(2, 52 - lastTickProperTime), Math.max(3, 53 - lastTickProperTime)))
+                    .append(net.kyori.adventure.text.Component.text(" oversleep = "))
+                    .append(formatTickTimeDuration(lastTickProperTime + lastTickOversleepTime, 51, 52, 53));
+            }
+            lastTickTimeMessage = lastTickTimeMessage.color(net.kyori.adventure.text.format.NamedTextColor.GOLD);
+            sender.sendMessage(
+                lastTickTimeMessage
+            );
+        }
+        // Gale end - YAPFA - last tick time - in TPS command
         if (args.length > 0 && args[0].equals("mem") && sender.hasPermission("bukkit.command.tpsmemory")) {
             sender.sendMessage(net.kyori.adventure.text.Component.text()
                 .append(net.kyori.adventure.text.Component.text("Current Memory Usage: ", net.kyori.adventure.text.format.NamedTextColor.GOLD))
@@ -66,4 +84,16 @@ public class TicksPerSecondCommand extends Command
         return net.kyori.adventure.text.Component.text(amount, color);
         // Paper end
     }
+
+    // Gale start - YAPFA - last tick time - in TPS command
+    private static final net.kyori.adventure.text.format.TextColor safeColor = net.kyori.adventure.text.format.NamedTextColor.GREEN;
+    private static final net.kyori.adventure.text.format.TextColor closeColor = net.kyori.adventure.text.format.NamedTextColor.YELLOW;
+    private static final net.kyori.adventure.text.format.TextColor problematicColor = net.kyori.adventure.text.format.TextColor.color(0xf77c1e);
+    private static final net.kyori.adventure.text.format.TextColor severeColor = net.kyori.adventure.text.format.NamedTextColor.RED;
+    public static net.kyori.adventure.text.Component formatTickTimeDuration(long ms, long safeLimit, long closeLimit, long nonSevereLimit) {
+        return net.kyori.adventure.text.Component.text(ms + " ", ms <= safeLimit ? safeColor : ms <= closeLimit ? closeColor : ms <= nonSevereLimit ? problematicColor : severeColor)
+            .append(net.kyori.adventure.text.Component.text("ms", net.kyori.adventure.text.format.NamedTextColor.GOLD));
+    }
+    // Gale end - YAPFA - last tick time - in TPS command
+
 }
diff --git a/src/main/java/org/spigotmc/WatchdogThread.java b/src/main/java/org/spigotmc/WatchdogThread.java
index f7a4fee9bb25ff256dc2e5ea26bfbceca6a49167..08fa6018bcab38d8c9ca05c84e229d69184ce01b 100644
--- a/src/main/java/org/spigotmc/WatchdogThread.java
+++ b/src/main/java/org/spigotmc/WatchdogThread.java
@@ -155,14 +155,20 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
                 if (isLongTimeout) {
                 // Paper end
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "The server has stopped responding! This is (probably) not a Paper bug." ); // Paper
+                // Gale start - branding changes
+                /*
+                We do not want people to report thread issues to Paper,
+                but we do want people to report thread issues to Gale.
+                 */
+                log.log( Level.SEVERE, "The server has stopped responding! This is (probably) not a Paper bug. This could be a Gale bug." ); // Paper
+                // Gale end - branding changes
                 log.log( Level.SEVERE, "If you see a plugin in the Server thread dump below, then please report it to that author" );
                 log.log( Level.SEVERE, "\t *Especially* if it looks like HTTP or MySQL operations are occurring" );
                 log.log( Level.SEVERE, "If you see a world save or edit, then it means you did far more than your server can handle at once" );
                 log.log( Level.SEVERE, "\t If this is the case, consider increasing timeout-time in spigot.yml but note that this will replace the crash with LARGE lag spikes" );
-                log.log( Level.SEVERE, "If you are unsure or still think this is a Paper bug, please report this to https://github.com/PaperMC/Paper/issues" );
+                log.log( Level.SEVERE, "If you are unsure or think this is a Gale bug, please report this to https://github.com/GaleMC/Gale/issues - and if you think this is a Paper bug, please report this to https://github.com/PaperMC/Paper/issues" ); // Gale - branding changes
                 log.log( Level.SEVERE, "Be sure to include ALL relevant console errors and Minecraft crash reports" );
-                log.log( Level.SEVERE, "Paper version: " + Bukkit.getServer().getVersion() );
+                log.log( Level.SEVERE, "Gale version: " + Bukkit.getServer().getVersion() ); // Gale - branding changes
                 //
                 if ( net.minecraft.world.level.Level.lastPhysicsProblem != null )
                 {
@@ -184,12 +190,18 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
                 // Paper end
                 } else
                 {
-                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH  - " + Bukkit.getServer().getVersion() + " ---");
+                    // Gale start - branding changes
+                    /*
+                    We do not want people to report thread issues to Paper,
+                    but we do want people to report thread issues to Gale.
+                    */
+                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - If you think this is a Gale bug, please report it at https://github.com/GaleMC/Gale/issues - THIS IS NOT A PAPER BUG OR CRASH - " + Bukkit.getServer().getVersion() + " ---");
+                    // Gale end - branding changes
                     log.log(Level.SEVERE, "The server has not responded for " + (currentTime - lastTick) / 1000 + " seconds! Creating thread dump");
                 }
                 // Paper end - Different message for short timeout
                 log.log( Level.SEVERE, "------------------------------" );
-                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Paper!):" ); // Paper
+                log.log( Level.SEVERE, "Server thread dump (Look for plugins here before reporting to Gale!):" ); // Paper // Gale - branding changes
                 ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkTaskScheduler.dumpAllChunkLoadInfo(MinecraftServer.getServer(), isLongTimeout); // Paper - rewrite chunk system
                 this.dumpTickingInfo(); // Paper - log detailed tick information
                 WatchdogThread.dumpThread( ManagementFactory.getThreadMXBean().getThreadInfo( MinecraftServer.getServer().serverThread.getId(), Integer.MAX_VALUE ), log );
@@ -205,7 +217,13 @@ public class WatchdogThread extends ca.spottedleaf.moonrise.common.util.TickThre
                     WatchdogThread.dumpThread( thread, log );
                 }
                 } else {
-                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - THIS IS NOT A BUG OR A CRASH ---");
+                    // Gale start - branding changes
+                    /*
+                    We do not want people to report thread issues to Paper,
+                    but we do want people to report thread issues to Gale.
+                     */
+                    log.log(Level.SEVERE, "--- DO NOT REPORT THIS TO PAPER - If you think this is a Gale bug, please report it at https://github.com/GaleMC/Gale/issues - THIS IS NOT A PAPER BUG OR CRASH ---");
+                    // Gale end - branding changes
                 }
 
                 log.log( Level.SEVERE, "------------------------------" );
diff --git a/src/main/resources/logo.png b/src/main/resources/logo.png
index 8b924977b7886df9ab8790b1e4ff9b1c04a2af45..e7e9fd9a6077535b89c6c9d7b0164e8b87c54bed 100644
GIT binary patch
literal 8324
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

literal 16900
zcmaicV|1Ng^k&Q(Hn!T>_Kj`Zc4OO48rwD-G<MS1Mq@Vi-2P_Pf6b?v4@vGy-W=|C
zpS_>w*(Xv_UIGaL4*?7e3`t5-R2lSh^xqd84Cs4}W^FDQn9zijsF13M{zVR~<`0dB
z;hww3Rk_uLO*yyZ^N(arMN#SjFcHEi60E_fZug<B-Z(hc9|bGkSKT99oyHP$K-u|n
zr9jc`PyX#|q=B419>`IjtJ^LVtno=lKj+Jze{_WszRIN1X*HUTCH>C_wc;+D)6YYT
z*RWmTUi`Puu_Uwkj<o$pPrusj%r}Dj%{SY7MbnC{1HmJy;yKgqG6L^Ez8~9WV_rtC
zkBu))Zv;Ih0AviFcp(<NpM4Iud9PHSRtyW*Q9aG$D&A6MQR80UdQHb@G&*iYdL;l6
z&*F~9IaLf)qv{I13YG3pb-Q9r9@Z>6-qwu_Ue*kO&$%=o%J?6*rej_Ock3znkGIb6
zWm&yS2Z9LS7slFgUx+?ilDgQBdj7`ruw|IVzJ@wV{&tD)G@SPTMW@9Wl5lcsuU~6`
z7raw|%Or|@P<iuewhar*LG$fv{PV-rumN!^YF+sriw!F(vXddsdC8crID6#HGQV_Y
zQNMQwU{~ee<Y?4p>nlh`7!!rA1H$`p;<B)P>zz}+92Tp2bFmKDAL`nrC>)<{qBHso
zvJ6|o^vMxL?frh4XZ`3WdH7<mM;zSn%>s_NI0p@{EElbnX*!yp;Vtx&K&w$&to`sW
z79>enm;xWhu;ZKKIN}-h!eBK<r?3Weu&JNQ#rPT>ZM6j$9~*Q(SlE*i_bHS0o#tPY
z5-j+ww|x>h9%`RLUixM!e%f<G!vp5vXXFX8kGG@oBs1697je+0Nx}#TpoAWD*|IYb
z-Ssx&KBQO74>0qVAe5GH83X6?!#^_j-M@lO@*-aD%NMF2;Hg^Wgh@}elrPA3o_&(-
zeNyws4es~%;K1o+pfG(Z!G-nFWzl7)ejRNxY?M~uI=I&MYuz@4>GLH*ptjlQJ`LYr
z*KIIVzBhKHIDwe`X2hc@gsdjzXxX%b<_#kc$vIHFi2)-XM1=fs(`g?0)M{lcJXwp<
zBgIdDXM&n-=+_%;1a?sE$oeN{r%w=8tFfAl<Qy{<_vK)o%n;sjWBhI?x8=90Lxkg`
zxkx20^#e}g0<LSzIxbF{Tmco72&OwY!+=|%_J|fBLX?~-X)wN)AGYA$bh|T>QopAk
z%wrVN=r>)oZ0w7^M~Xi~qp6lEaABgF<Z2SwJ{3&bce8KBXsfF_q3EEvBsuR{Xk!fV
z#)f;iYiQ^(Y|-yJ2)^R36EIGnWJP5LR`fjt>(ck7V3Un;@cg|ODuD7@fw~OZ;^TQV
z$&4AiUj}-4;o`6JV$Y4C<S!r5P|PN44CIQ+sDKy+`zUdEn?bMs=B=5}O}j~Et~>2G
z8hVweUdzl78hW<t^KJYb^Pi*-y`5~j=yosxBRqeq6FN})Y2R*>zD|&J_)oRr2JdJP
zA&lca);^P(q@hQb9-kqN<EgkX9B1Lg0x!^RwSp0@(*X;oZOCftvUGI4_lBx=xUhLb
zo3nPmzU-m&+)f%w8l)wW0-YsCBels@kMfp_Lh9??mD=nZ*zvU*Wd{-d!a#GMo*nMA
z=lqHGJ=0_2?8Y-csf@Z852{7hrkD&)J1n#!Wx(38*yZz}JzrCxB@jR9tG6LU{M;p+
zwQ)kSjO%)r1@%(I`<3J)ARrMR`c8)=f1Lt6$3>XVo9An7Q3NoAtyRQw-@JUDD$o<f
znMRf7r(dF(J|Ki=lKXJy=}$IiE1fIb0^Ym|0TW#X<*B86mU(PHgf6oWN~L>luryjE
z3{zzbZhStP-K;xw@Yxf-B=4h(p=4f`k8p2DH$>qQLPR!szD!2|vJ}J`C6=EoRwG^+
z;`ZDv1SGVO+?IqSxpxSM^_V~@2E+~dZQdl+oz;TP1MX+XXwugMy?Z5AoZ7#R33Y@T
zM)w4;9L0szO3>6i#4fV3q49@wu&`zcvQ!d8!m*dpn&7pp0Y=;QbiyOzhC7)Ki7tDt
zXaIqysWqx53ZgHlO)|YRDG**$7&F{0a8VEECY`3;yx)F>2;4Xr&gC;Iqiqx;orWkF
z8xk0Ty-mK&z`^~Fbs#S;;Qd@1ZFJh4R`+H>Wx$xgn>^oka;w9~QfR>rS7lYHG?D#o
z6Jo`Qg<Muls%8W(@Bn4~pcP6}Gk0gmCKDnOK3h(_4kg0j6MLXiCxDBi%<rTP>_-DP
zX@kdURs~L5?afF*73QF!=HQ?vIysP;FNCMBfA*}*&%$eDHh5L|y~D=C^v8(wdtcYZ
z)8Q|56BuZ~3~KpF-oKg|5Uf@Ac15Z>sP<9hpm(E>^cgr8dMxGhn7mnWA+JPK+EGR;
zCfK+V1&Xi1M6CUFIA+oJqr(aF3W_=ph7h;IVlqq&xJ=d(CqczQwL>f*A$gJW_|iZw
z&>!^cGyI)UH(_%jFMta0ci8K;?^D#C4_`@%@wP6R4qvs8y@ecdj|*ia7Exg3*BpG4
z%Dqav(-_hWolzv04-3Ygs)Z~U$`R?hQq2Is2`RWS%z4?!GF2CryzMjCEFg_Y%K+yz
zG8tm;0X{;XG5?BBT|pMZ296(fGUtoF_$Ryrso&s;Cc!g3a;pYOn-tjPvW+1)iAQ)I
zaPyG(wl0MZUqz_Z!4+oEh$t>QIaiZ+J1|fQdfugliOCAg+6D!~3<-k#gA8N#Rk3@5
z&u3Yevetsi3m`sm2Ntt>FV(PfME~wR=LFu+2@Noy&wr###hgP3mjy&H03re#97OQ%
zsZ;NtktNoC?s@G44<dmW{f5jWvTyiJLH^yQs|kPo;mUvH?YAxCAg|ea`1SCn%9nW+
zAtbqiTV^rUI1*#_DYehL-JvZU|HMeqE-qAdM%s9}lUT3VidcPhzcs{J{1Pbv9kWhq
zc>Num-@G1zw*?jMf)<DEgHaOi16Tc_GG^ay^ID~7jj9}99V+-ffa!?g&F0&L_z(A~
zM}JT5(~DuP{Yy+if=%fxqzfhy4MOrHp2A$WEHs?v`3DSZv0AY|>dA`SWJHyI-Lp=m
zyv8V97L8$~?>Sf(&Ee27TQvEf=-_%~EL56_n`*ZRVS`=4Ka4&HGjr9P8e3rf;8BK&
z&0s~H!Z|V-mPt9vUj?5&%Sa@;XK~`TS$ylgW4|1h&I!<9c6_zoDdR2)FLErHw%Sow
zwc_2ZKizcAMchMvZ^6OY8)<qG>uiUt&RwA(`3@dzgihQ1MSrNi;ruq-C+?oVa@U0x
z(>^4ei3Bedg+!LX52G(u@W4P&3sdv45%OawU(*aQat~OuEf?Hi6Zi>__qCd)nw0_j
zvUwA_6WQ5tnFsl_AZNz8L8L*=L4?0A>inj9l&C`<n8!WYp@GJJsV7VD2F>AC71u=H
z?bu{Q_=al@1+|F&El|te2eQB@?#+g(D(LjFx>w=0X;CJ|CQc@tuin_)Rd$KH$Y9P9
z${MAq+Ns2`>_SLAfKm9~%?U2bK6><zn<Ur6w>hiDEbdUD#NMd$hR*wFx8TxWVY3Za
zM&tRPhR$htT-*KlZT-SGBy4YD;6aZfAz^Jt1`=ABifztn#D_;u)2WTa-Bo^EKL;=o
zDc6Ov2x3y<odK`qKZ@d;Abc>bU1B6gkFjv-UvyFl^(EFkIb4ht2Z<LM*J8D=dG^q^
zMkYxOjCGDOM{O^I*O5+BWk`rv1mWOE@+P54krJ^tP#<l=ckM4=+6h&OIU&z>(*io4
zW(6^Rp7OMxVh73mYH?bkbxgXB=+<qd2^f6f<36>TL>U^8OY>=P$oXPkGAmF?6#80T
z+e?24uzuJC8?nCu`7)ef&Nu8x+`0%wOB9wmZ^(+|&$!T80~3uj?NRH)aNhf~#vN9e
zem1VW#bKd$SZ4ufS0-pzoJ%P7UWdT@8yg`1+kpYLV153t;UJy~P8@7sO+#<ky&oE2
zaTRY)D<ZM)m%mo_4}){09c-QN`>{ePIXcSgw}v2XayA<>Jxh}D)tMOGRgJY0QEJs`
z{>aB;ssVeqKi-6L#(PnBpPuOu<4Rf*GWVk8BdM<!bAw+)5FLpck)j0P;g-XUo>Cd}
zc^_!LU3n2YWBEk1?0<%f@MkB;t#h0%&cixNCZn@Lft$eDVl6z=l@Ga}k<7cF5n!!o
zXet^Q3;AyG!j)+$=3U>7D5c<q^S#x_L*FxCE%0h8`d^(!P9b1&)aUD8>Ef)=<q!3`
zEx>YMZ)jSZ?)!6EoSa3kU!<iV+p|9{t1Yog7AUs!^759kl+_ECQKgKtv<Me0u){xU
zvNK4lG5Lj18W*ZXoYw+7Q{~Io3%NJQ!=lyM&XLM?;1=x9;!=Y@!qr8739mD3ld??W
zk}v8<+^du4Lfdz_gYEgeF&99Myp%KlUPme7^F^!q+sB0B0C>3W2Xn`K`Pq<Ha|d)N
z;q~h1DC+D-+Dz}H`Ee}lrc`+QC0$^;y5!2lQxMKotyYaHh3Dh`k6e%Q%VuYLdoeFJ
zH~ZfHz~PX7I>R|ML`Ju!A)|K2`l1><Ha2;a0S_c>ErJG>o*qIC72B&jHYe36od@P!
zi)qQ9Y7g*>N;Y4;sSLlPxvM;q-Tzw2m;Zx=x>{mk0;Ed5zA?Hb1FrDGc6-;m+iSFU
zc22aC&R^-iyw5vE$D?GWWo7A5o@@>d3_uD92sGM_-tlsdQ?ZbAnF4LsSxDj&0TFgO
zFbB*@;0<;Y0es>tB&~M12_up)gRS(Ce{seFR$9$~MC8~S%gCTV+2AIiH`gndEW2~H
z`z|RK5KuxIccy|<V?aP`0WazqQSmO_S2;aqzDxX>!;Bkm8puw0EcWFE{ij71G*o4(
z0~y!3%z_nq1kdh3x<;XVQS{_v?Q3|H1so1Z#CL|Zm2Z&7-mTO?&1?U-oogOAE4Cm{
z`d4o(XCnWH-J^hx&?7X^xHns&B`u2*skUy`s~w=0252bVaZy(}U?e5?u>fG!UbYaS
z4Gz$YBX|~|U$??YUR+zxw2g5F_OJB7viI^}qx|ouEswnc0o{D4T~~|912EVr9)4P&
zS=*@uBmgy>GC)sz_8A$Iga2y-R#LKP$zyVe7P=4Vrn@Q)Fp6mG;Nall=^07<{OPT~
zPDD~5M}Py>^H&ikOMCrXaXjFMyNuyNg$gXaPOE4z3=$o3<OMi7)&qF(4hc$VL&fJj
z1E&LS!gpH;axN~M{o&Ywv1H1dv$~$Wx93|NHp>Jt(guFuvAQbA?*MR;Dx}r~+zsgJ
zzCtQ*$r?UAKNl$E39K|(pdcV17*;zU{VtG7{)QDicnC&XAit07AxkJs2xbNxkEh-l
ztI=-hZ#0{5e0{huHk5pMKFXUdk-_HT=8j~#**>ze%L-Vq--ELbc7OqlEqqgfDL$7|
z^zia3^m~7il#>&4bK{s6W!C%o9eQ_nw_LRXoq&)qk2e`~Carh!_+@C+^?4E@nB?8v
zrP(B~aF_-3_5wx4#3EgX2f|T2iDX6dBot9e+}zxz-+7y;fop?^#LWumnJ%(ER<|F>
z44(0)x_-m7iZI17bV#w5<;|{V>IZ-R+z|XI2d!L0M$z{_<K@~dl`C(tpC1Y)Szw}R
zq&}HG+Lrj-8Y`=$N~2}?8b|l9dGHv+zjnS*Kq`-?mfB^p+k|=E9!9dNC=>~PzI|b}
z_>I9TkwT-USfkDE<T3o2UFH-DLvho7UH5}kxNU*8zhI%MKhH(OJ-i?BY$W~-^|55)
zWa=r&p}q^d3PUbX_6!#<7Dh`;%jaA$@p7{>yuoB7YJe7^SUeW*JCd>d31w)Viag>w
zE)Hcnu_U(A@CEh^w;UM0IVsDf+yNUB)lCpiM=a>2dMS<By}F7IgoNFjDG)Kn@=#YA
zK3S^4|Mhywi<Y3>Vx95URpuHBLGh>h8fgM&77%eeba~6*@>lA8=;7iEw2QP4d^IvP
z8fpiWc?lq5kxp*C)nS|HY^i2ov(x?A!{1u(mk%xyJ_nmAsx{Zt=LV=Ta0-O}2|y4O
z5yIAhMw5|xp<jAS{T1goL&?&tBz5keV*#2g$~m*;O60P60)&DePvpc$(-fJzJYIL@
zMljJ}1>3lvw|Ps$0W*KZd^Wlj=W@{AaG=^es3_){Y~Jis`IYYiWN~ho|DLil1qRD5
zN6xAlvXG=U-8`VKVHr!k-;5Bi)EfnJRTtvY$;jR$#e%~lxMV?xboY;JA{IT_^y}D0
zw1mJ8tVoSO-(}a<iGU($L_s!qHr~lX-p3`LpC;{qQD>bsB6M8b$Zqe)Ok0$OkaA#I
z48@e8TAlv;PmB6dbP|{7<%qt@Ea>I;PRL4)=M`_G!A40Y$Xy1Mum)I0#!3<77H4)u
zI6c{)TUsy&o^*@2H9Bp>QJA#S8$`zN?+@z^IIQL|VxYEQfVw~Oc}Wq!FS`G2T=aDu
z-DMYe(1$x=331oN(i#yV%?Q)lcY`}FpGRp*74@@$fX%pE+dAGOh5QRhJ&mcaXOhk4
zLi_pirw^Zws;d9n^#IE8T1ypZDX|crNABquU?iL2;Ql%<xZgIthm*+Me<Sv144IQh
z+y#X35h0I(f?Jn7vV3}cbE`r@p<fw1A#t1bZc1YTd?oNP`S~O<1l*vNz*T7GKk&TY
z>4Vg5cNBt}OJdbLKnEi|`g2q%v70%e<MWo{Z54-bRg#0&`qxlWo}1oq$2e7Jg~<kZ
zzW&tUlrY9b8!wMZ!)FG}oq-Cgt7G(fIFBUcbt4fJ%!@avinPuQhDC|WkXbV}j>M&7
z5gdFef<yi8=NIQs=cn8~Fk<)<8{fRekO|}3F~KUG-K#19**0R4d)JJ>u8Ix3n54MC
zW40SGT11ajrrm5AI24T?-2$|VMsU%VX}AMmt>Pr~B}#An{>%QG>_1FQYV^)CExzx2
z&7E_9c!fpiCLci|F3H*eM2DQQRtQp4>V2&#1RP=KX3ZVw#OXuFxj$VDmM<G<u~~j<
zr)S^na7COim80bdHj8W`F@;C%2>&HQD{*dc7301976VQyI69%EFvxxn>qC&L<E!j`
zIHGshQ9G04HH3kRXKn^}+y*oVrx5jxdh0M60xK|Sd)@G1l7$%@oa4CL9SGkajQnDZ
zq^Mqq7mh3yOT@pX=+DK)rD+NiZ3~dhN|m0JtBX_NP2nRs2(SK@;dIooJ>o-`%ImvM
zCv>AXKPcD26Z_;m`1pw)uF6Mp=RnShU^yM81!?jbl!v#-kSa#RLhSOG0?yp1YB6Jr
zW=GrO|0zIRSHiH?DYiO+$EpdMkwz#4I6V(J12-W0+dAo4J*?nDQrFI<*}a92Y%1bU
z`RC_4<V2ee4eMNw8s%FkpJh5UxnvQ!odmE*L6UqK9@Z+6xHczFTyw(v>tyg7>R(8{
zA8*g?PWv##WoF+p0bJe>whg#+(1_+A+<aAEfj?>)9HS$|n?k;(r=Le*vR;57rn)2&
zEkD8KBSZm#3Drt?t!*#s#>0+yUNysIKRg=t`KSOcSHieiUP0z8F_$tZ(ciPnq_o~@
z%-{zh<J*Veq)ewvHPIm<P)@9do?q;~Z}j;4gSzD8<V-%gspfzg<TvK(YEGM>bs{i7
zt~8q8%WO|MF(FE_y<dA>e*bl_-@NcA!S9$IMb6x0`e_oNF!hy5a)<B9TQy2D<cFAc
zF?41xX{OMZmefU3+w>H^H)5)t(}ek4a1Nc~FF4@f;5aO%aB&3O%B8NuMWWCzYb`d>
zQ-&3)G|5M|pzcLy>pA(p=?3&XKn+v0^`HNsS?M0eb+60BxF|&Y{?>MI^x``)Vp}1V
z;<0N$BUc(0=p=y>zD3k<q}Y8+AcCcIhZE%FEx<NLcJ~PH4f57sm^|KipT6?7YhrO<
z5n4J2NHz)P@VNF5$KnrBFZ`vUnel)AgDsoGqc%y9n%hT)4PFSW=~V|s-Gnq#m>_I~
zMC>T|r<IzMPZsUpMmccM`~7q^-gBxE8n1Uoi@@k@#WI2$Y*f#I7`5xI_*1MgU2N2@
z^eG)oSYCiMe_2*N+|r=0Vu@%7?B{{Xx;a?lDd3cv9kkEP*W;ZaA8JRpl=-jMJ%r^M
zCe<r8%uD7nt!zE<kwG@ud2YkLV(WH~-pw~fnJZrqo`&ZGr=v%-HmRL^lg5w%)?Xdf
z8GyHmjcJ}p(SA=9aPzv&i8wZs^1@?kH(d$pau473%lc-?eyx*})9B>n!T!wN%lqT@
z&Afsj|04$m&CH2M?F|6yeqb+e`&JWTP^~~z(;c>5;z6RuFKe)%3j|YzeZB9c)5E08
zvX9?L9%?PT7Vu(RAIXR}s*=I<uRwy_BSL{QL;Eu-Qa(o`mnTNne9Sa30EPPEJt+@<
zp#ohDc&Gd*U!MV!j5B~M)TLn{`N4eLPTO+kv$bEVK;t!H(BsE%ztuJNxvUZm<n?`V
zX;2AC&F&+U382#5nDIK+u;g9D2ceKb>*@Qp<*vA{&7B2uwdBH$_I`33U5di9weG|3
zx-Iy`1L`R>G-q<+w-{f5qc<7ls}^cT4Y^Qi+meHXFIDgqkt0wpdBZGY?LB+q9&o`T
zd18L5%R+44Ml^UNbEw58BXP#{+I#J1$;VGO`#6Grd<=RWgP+T+ktE6H^>C;%(}szj
zK;wt^oW<tgof(@F90Mq+=n&8JLg&8fAC)T&bMQR|%m&TaFS`11YvCXVKCa{ZL8~Bl
zX!HfBiRXgv4WYI!Z!S^;rJig#<C+@{PjVn61MRZd6~tP@hcr-a@OEY_3Jo#X{yUxB
zCbb<x53jHQ<07TdnY6iL20clAriMFMj02|lPk!CdidDvC{5bvm4$t3wF6Em!UD54g
zDwqgD^Rl(wYb>!yG4Fz=zm4zKw@$Wdo`VJm=879kp$F&$uMP_qiKSB4L@SV)<o?t!
z@b8}I9N>g55F9Rb=3ocrK>iqIRR9n!X0Do*Ldi{9M&^sg&T_TZz~>`tbXc$p%%BI%
z#MahUA?U0t#2ZA4_41*w&52#TXU^_G4)$#uGOnpIb{Gs?Bge_xP|beH;cUSBec^gk
zu;a`And#3j5LZ)LAL<cm7Q+mP2=~Fd!STmi<e5Z8e4wG<pEWU}FV0~dCjlgckVACH
zq9q6%IKSam)`{4|E{#}*z9J$;s9GrM5PCf_#PW!sFXBVO08lMbOJy_uZixMCC|@VD
zV`k3ntJG>L9lQ0{$A?tzx&K6M(;#M))7n&`7KTkT>KvjI7O4?mTa;X`81yn7WAir6
z^Dv#2{~#3{X=5gyP*2v`3yoLJl)--n2rC2}*3n8(L~4ohHzT6QbyEu{!K3q#&p9Lp
z?3#RrZR0JWoh5V%Au%m2?uSB&R<iQA92+*Y@+cI6j44t_h023EBCpi<I5`60E*hIL
z>O!i99khjDd#7P;NaxJ<_f>mYXQOtXqBZif<x5V;e8$sJ4ucprdS6=76OH3DIx00;
zr@?!2AN?pOs)?RY{8}AkNKVZJa%;%y+M^NF<4tc9%D-iY`=)tTYcBWKE<%Yiw9%%D
zS*EjFv(hfL)a~iYFgm5X_PF5~>oWn1d5WC&hmG;&Gv(>!l)|)selJ-m-pz9Og@*rA
z%Xl~n+gHI_Rjy513U_dEaq-~ZLm%H7RpV<IR0p~J+;&2?kV82msqT8fkP1sSj2%4`
z1)^UjAV%_(0=dQf^t|3Rqv$6qMVAAHX%%m(_6P>bREoW=Zu*D?n%JFyy6(v}{RCOy
z>_wu--o5bv-4rRuWG0oN3a2+(f)C6nR0%>9HdI1mB`d{jE6Q4vSf>>{@~N-bGMc6~
zn=1MB2?XIjZuOC!s@-pN5{60UUw-L4f1L-3Ohud?4)I$4Y&#w^A*ij(1$$3|Vskv}
z#YKCOBnHKh5QN8fd|k)wI{^HZj_1!`{L&>R(m@P^tYk*J)5>eCrio9{j>kWLDCGrM
z*O<)utCbjQiH>aHzD!~>S<PU3pyI^|2H^|uA8K8K@16lp(bU!op*y#_y`x#B*bbDc
z7LCa{Z6vjY3|g#Hj9@0vV=JdXah1mvnC-C=(k%WxIkMjH1PFK%C1_nf?QEs`jYDCF
zUTUHpRm64A3!+5iuiW+nnU1zIUP;N%T?I<%OK~d}&sT$agrSxf=YC~O3^hi4ze58t
zYrh*M$%Mt*g#V6dL?bm7a==9py)xK`hVB_Ta-nZ_kJFQw=~*NkZ)SVx&6coZl;7FQ
zN4qWzPH870+<`J%9aos>NyzV|B?uyizaR*!v`(g6N5ks=aSqWHk#wzbQOx2Ehc(>s
zfl`oSK+EzLOKDeK?n<u>#pu;5qF1g-8bXyN##%K`x2R14CxOh8w&P-kz4U}>3Q=A&
zwAa>sCXe?|fR^Y+S9_jW;=!_GK`1Bc2HY6Y)*s}A##+#}239~LV&Q~wL&4n_6^@vW
z;nGUYJ$5-C#kJr2EtD&Ty$t-H)#GyT->}39LWB1gdo%LwqR8{YbRBL*-FCEc5iY{;
z#TpZ~y8yolNKuWi&enqz%<*)Y)j#ff)9q1ezkI|N7|zr3<o?*+;JRvZ-Y?YN3nrDc
z<Onp!j9Mf+5A2NRh3|Az8KhKm@KH&niH`ddg;Z;SxUyCP16j;Grz-FV0d?P3g)Le|
zos7y#E&CJ+9vSa&X1`JVNHhrwj&NnqqCPt(M^2wsW(6k!Uf|=Y$zG%w@JT7|R|gxi
zr3+j8jJ3EnSpUKST|4`Vq!l90IE9{SoFqR+GHa1EC1bt2R5F5fF*>b=T|b>+m?)d%
zKJ;1@L~w8ZQn0MxZS*{ew-;Ohn^Jl!+U{m|QvgB~tai**t#d>0E=CMjN*SZ+36QnO
z4NrSN!Cd>9SLf?=!Hjh+ek}c}ND_U`vvi9(MS>7nGZ*l<Hmq_}pg^NoxPAelAVczK
z+9v-jKscGR%3D?J^Xp3qcvM>Pm%4(7(bhfuTHod8y%;N{YO_KMV}N<7D)x5snD;XG
zzCOH#WK2$4mAvQWFCCZW#F8TRInJ+=$6eR`V~dES6+!6-=6lkVCHyCW^Bb-$@=b%3
zi%hxQwAp^EOp|zR61~UikJsM89qE@P3@X5J>+K)hO6K`Z$80UqhLV&|mVt3wQ#G4H
zi4>T}s*jr9pkN+B@=LbuMW8^kzEFQde*yOdnXiUws9u#OD8dYzm?0F`qCm7pBCNNz
zOJB@PR!5?2&9Zw_Jg~i=TwmStKiYq<aCxk}5?tZbG5<T2QE@w{`v9b{e*GpE>1_@$
zZKB*^u}y2o({7rV#Nl+8<Rdkl0a@$MpN!_-&_Ccw-kxLT);QIY%C|Au!%Igfx^3nY
zqQW?uNhGyO*g%79wi{Xl<pL%^<L*Ucm}hQ29FcEt&?fH3+ltiY=y5&ppGG-@oEz4J
z7QH5KxK71nNG<)%_=$zL><i?GEBH?(B40WD(*2LZ1LB`N{Ao5PmAglN&FZpl>$2T5
zthMF3X`+*;4Q-~<qaR}9Th9vMz1AXL>&-*4NzrU=7>#}h=jB}<^tsAch7Ac~Vq;V7
ziknpCHOP}_P8F&VE%6e`WG~EVa?$ra`knKZrYWbIZ_w@4vO+{B!(Pb&!YhY8pCfe=
zjxF8x>Zh3;#gw`fu})grVJcf=Ohg_<xsdZ&$;Db2&61EKPttRh=b4(sN_y`B$-^iU
zbaR-Yb11Loh#pK7^C%^llk_r#NFww#waCKFozWylT7w{l+sUF-C2bd{Wnaa2cZe^u
zn|G4%4HN4LI(1E&Cy+D;QqbqgF=GjrLR+E06_dwL=4wv4Tj*+|*(R0fY_3G+nX##|
z9LQLMOV`Lu0>Xc9m?(57$!NXQ#N%;Q{V}EjtmA$m<@Ie2(h2j9T2Xq=0<2R#daW&$
z85=lCIqjn+?h$SF4u|?#DOOKg9>2c{9GSdlh{<(WR;Mb+bxH>u95roevUiqSmcdG*
zEL`{Qv+mA#hjLxuC*l?ROBgDsPYkDNU%;m09$2^ni=SVA=kS_<QrbUz1Y8%cg`w>)
z_h->URCbhQr89T-a-Gg9Dk?P`CT8-=f%@A28AYMmma&Ks#DNDsr^|eI%nHBQ0Nps*
z<{@u^G-9krSD|^{Vm?_nRkW_T!;E*n95To#4sxn;9FH2W%&T043S^Vg_Bk^^&J9*H
z=-^Zd6GYUG(CMkA?hy<&4Tc5fn4$3ys+ZiGw!07qHH1zPDzAJY;{8Oj#B1-LTAZ>D
zKqX)c%j0#o|H%z2zdkxYKaV6<&nEMgP`q%2&v+2dsa++rFeWoOnf$VkCAY6|8|kw{
zdwe(maC?oeGlx#HVClH?)W&QZ`+=l3PIeQ%9cb~nWxJ9)YD|MPt`v?0-3bMcbZ<2Z
zG7xSnH{QoOr#C@?R{C$168|JMfCxcPAVuEhewgQpYO@AfbP3Fw+|Vi7h~L@$6ydj5
zyf7_h9Rp$0Gii0mkT9xddqw>hIVCXV203~$D~swIj_)TV=zX)@-tK6Hb66mM;EywH
zsMV;{!i^8fva<OFy6>e3b)iz7_f6$4yU2i-b%Bh|o@eU2$RD^G(AtWlyl0^8dxd<9
zCi_xU0%&wFugtmc%-uOk=xMY?lR%{7BQRZ~b8}1<=DQI)v2*#3|70VNVV*?SK4O}0
z-HEICfCoyTwy@{F=Ac>4KISQEgQLDcj|>j}h<?bSz+1B0{-w9kD!eM3*<Z37%?4E*
zkA{ZE<$MVE{8K_UuE}NuEQ7P^4<ITksnw<(11+kf3MpfIy*u6n*}`3yO2>zn(*RSn
zZw&u6!^Z2~7ae&u`+{IHYm_vxJJ@RRZ!LoCjQ2ecK6E;Aqey<dg6j^l0`!YnxYi9$
zM6LAhrXuv}BqgdM(}PZ8CZas7EFSpef@p;1<$!_e)*`_#yxN-Rs6oNz6|Hvb!y~|q
zh|&aXdTokY2g!RF%s;~-*j|$hW4@1<n{R1pndLxAptQ|@z=;7T$_-oy6r5g`(6WW7
z0~Lg5P%%i9;@gCpDpoF$H4@@H)CjjK;d~ijGr8!04az5G=lEzh!m;dMSOO20Zv`}Y
zr-iB|ED^!%pcBHh?<gu=GhyRLC1tsuIE(YJXUH?a_pCjE<xhHzrjd&pxx`;jQzh5;
zl9Q4KN4`!eE6v~vYIt=mO!=-hn!UAAu}eYoAW6h3plLh*H$37JSU(h+uGkpx@7+$Q
zFHJlY-*f#a+nGt2y#)horiF~LDlif$em(#7hPWT7k)?Nq{j<MPS$NS8i1>JZxfuAC
zaFBgBIQO4DawgA~vN)BCS%`;S38kn@9kWOTMq)$V$+z&4nDQvH*{(1#N58$C)v2#;
zJW|ch#FaXRBNNj6mX)HNV{_ScADWB7#Jn(Th}B15lvrI|-2<dL5!1=&wWue31zOTq
zw^i}lLoabQhZfQf?iUFP9Z5m3!A3{9j?q)ToPigJcwL-KMw|?59r7;lq=EA1Xyn|3
zKQFEpiW@9}A<zAO?vr_<V%};_IxKbySSVeCdLh1TCD(W}kZUFmMeb{5>fj-=SL1AY
zQrI&y#`tyxRIyenc$G7)m}|d;5&h;8q8?ap1~7v{vEXIAhojO|^XI$6=K!f+>;5yx
zJJXiq*Z?mW;Ak{?4<=)9$$a@6Q*<UTmpguGcnDIPC0WEYN#Q;#Yxy$|D3``2G%7BN
z0Yu^RQ7okX8CBPqG!lDN%^_d=COePPay&UYI#6#@B{KaL`8fF_auJMF1vvL@@Ng<C
zI<Vd6`Flf-AW}D7j+&*Un2E<)hp>=1_%}Nx&bGA3oqS%{I)k3y{#DALAzrPw)h(FU
zj}8a8Xte($dBp<ijg|@?5L~1^;NP*a?DW~(Zh!0u1DnIboQI)1jmk@=vdiYoethVK
z2VA2EQv@N8+$L;v?}g`7We;lAQ0N7Cs45%8&+P5um4~~FV_#?}YNMf!&GB+#_IG>T
z_ZLeg50aO#<yc2n3)}HjIAy6<VTQX8SM42|2g1dr((CMP{B(Y6qxk|d#EXAUaxXkM
zwUwD<6NhB^T_hSjX`KSqm$ECgHu=6Ocle)oFKYFN8Tma6BWbCWiB;waOh;6`(c*u4
zqG$he^u#%iy<Uw`Ct;c4{~nZS%#WV4@bfxg(X2g|KN3$5q}$mfwzscUhZSWBB*Pr~
zM-+k3z<RHH>zhmy?M*+dS#c4NyP>CZSyS+OOi>@2;)lr;&A$)(OEO;kV+bz6O57by
zyW>9>Ij2^Du|A83(r~$46%S7?Ancv<t1a_}DOz@l5HE6yFlo?8Jw?4@@8O%XR>(6R
zJK?TL+k$9p$KMJgY}hdrTzyS}0it==hvU?8YM**7M}l@-<ok|B?D9J>W{&s26~NM6
z#U8(RCX-=6Lw%{$D&=aKSfE%aJ<__RASP1DaZcJPva<-yi3NH#t$OuNk6wlp&CD~1
zanJ|7AhF;l{a^)Qhr<C0*mv)OH?=aSzsFD-;L^+K4SEaqsYLqhx9tkX_6ia?J#83$
z`$z06sIM{&fPSt1-%z9uNqIz!!`X7AZNbDv=pR>_9Bo;2ZG8=}0whx#r7zZ6W`Fs5
zJEbvhZVJVsORu$w4Y1HyT1E4?Vka&kS*mSpBuKM>OAT~3W;g7KLGzfQWF~QJ1)H6S
zFCOXwP_auqzKSygLBPB}EH;Q1gXb@Wm*lZWfM<8NWGZM_*$8Ze)0+^IpqCyco5T+P
z>!edzc-RMsx%H6~4%a*u{&6!V2Xf)f8oOKEEtBAhvI#TkSv+Ago-TMSQ(2q}=S0FP
zL(1v}1vp6Ya1@zfO!}Dq3ke|~@mmFXu2dHEQWpO$6X$;c8V@V*w>NACSkmSKF-THX
zXc85Wu2(uhx0b@}vaeA-YhO(oJ!8ZlugSxzOn{tnI7h@dCB`UVE~EEY_ww_|qDlb|
zQh0>qvDy{uar91x0J$!N&ch{3*B*?y730`NAZJT0IXU?T1Oo1Zc+QnB&!+ZYLh%_v
zV;)6DQs1sEzvoxu0r{lou-yG%CgwotYzFK>vqr!e>KRehvaz@y)fTge`_wgV2*|2H
zVl|vbxEx$3ymn~uGqN65%FYqJ<_)*Uqs49;KY2h*(Xa?Tk7AFfl-xf>irJoUyL*;0
z19&1GQV*5Ni~#kTnaq0ymCiLjk_=0q&=&|cG{r57n*6NwV6zJl<AE{?uiy^?^PFEl
zHL69trWdxghat&0+%;d3D%)bwcJp!RtqFvYL{}8g0Q6YuQRDUcg4GskLUHlFezjgb
z%oGcmW{c;iGpDCy?cU95%R+Qk73F1uDmg--Py0a;zrr32XFHuef2iiC4FRw~6D^mv
zgMdY9dT?<uc8v)5UGd`0_-us5eL?}U1d|_P=m;QXl76{#yY>5K*ED&DsZy8iEL_rr
zgsLXr6cN9-S7dCo0TeKI3ByoGNNBIG{4b4m4=LB^FstU0B?!6TBZ1v~zn%e*Xk=B)
z@_rySE6i<YPde}>HcIxSfbe^sRAkjZKFfR!7A5uNa|Q%HSV{);)`X_I$=Rz#g9)RV
zjIuDE+A6IDHt@No<L%X=db;Hw`M7lZ{F)`q!D5Htt7nHrf@-5e-`j-vV+h{^xhA8s
z$s-;kt^*QI)B|UnrciuVNlIMmjGIErd$4j48G;5;lAAA$Ev}+q;LPGdoNB5SegP#K
z{r5Q+H?7HkfTtUE_k9@xH;}4o67QOQ?Hl585(7w&`EOai?w1T9lK$xN+LxkuSRGel
zqy!S_YM9)(Tp?r#S;~dB<|bI?1gcloG<=?UibWT`0kG_<eKrPzOC}*3Hy088)4@Z+
zv_SccFl?&OC^;g&?yV!ni}*NhUvPXkw)lcuC^*Zf0?cUPiE6Ma9gu1!C^&e?-3+~^
zXl50oV>y^%sCnU|?kL3tCMU12QN7688MFeYr;%^{CT)BqX<4rY8gFNo(^2<+x6~@>
z0Y;8%xJK3sk3si!JoTyNPRqf>i>%mkw_b{g-~}-aAljQww_S1L53kdn=uMD<c17D#
z?H*+c=osa2w*s-S4Z~_SUsrKZwWYR;6)|&Y4rFt<B;x%HbWu)tqyir54O=xC@8VBz
zgT4^EGyVX(hb0g9pv%V|#R4Op=lH^tCrs~K9#Hm6!z@M3QY`N@z7d4`-v-z^-t=yw
zgL!IF60pMfQRkwZjPjYEk%wzZ^3xZK3Q^@$Emwcl&{&RZg@DVEDLYS0N>ZM5$#ndk
z&22o*u=b&^trc3UMGkzzrL*~$;t?gd{w8WCC+z$)6{fY`v4CL%;?|JZtR3}&oLz8*
zT?G#HsX)xAYvWho@h=pJpzsjcWp0%LD4s08onG)Nb4)MY=8K^XfVvcKVvP||0{idF
zr>Wx=dX&);ID@-|u5Y#BAa0c8rW_t)Xfo<vlc#AAL?V;xK!(VoUOQfwYKLZS&i<-9
z;;vFoDu&qH04x=`k?XASkyK@GT+_OrFRio<oEjgbKi&<{<pem1Bh|_{rd}3b6M_~k
z#ug2gX33LeGUF6ujY8^-+NBC3N3Fo!SH?DlQ(x%FqF&l0I?|LVAq9|-_ZAzs`MtE0
zz6|*#9u5wvDGZ0bong!tha)Mz6I;9$ZWQF+WC+Z02hfO#<HL~fql9E=*Ih)@0t$FV
z%W2<l>4c@By|jKCCPsr7DjJ6t;eTIrmF;CpM`~(ysWB=S@seY-cC;IYp7eGp3%$l}
z)oc?3j<N+0i5LM!Lg2p)9=a<RaaY_xwy2ck^!-q?ggIYnFfpFqE!+Gptg``+3UZ&B
z|G7`opGD})?f*>DrN<0qs>+yfj#><OZl7$l^xn+cudeRjEGbCoGdi+?_*DlwButhM
z2c4jyp#csao|(;WM}d0ov1}Oihu(2H(;^$M+d1l4WRg4(PiAdTKH$e65RXehqGcYp
ziS@I=L*)Cyiu;g}I&7*~m`bn>o^%eHp8`K^wUK{qUM_Xl#K;;VHK+>&$DqLQV1~<L
zJDOoVC28%&(mauG>BoxLuBrt&0}DAhEKn_^ER<H!yx{%QhA9tM0kEdHkOyS`=c%lV
zq{%S;|CVPO-A_h<n$FyCVaW`RarknRGNlHhU*Qp*V8JL9k4MsRCTKGmV-lT;?XB>`
zz-29QNvC|8F%an87xNYKcn*LCu89T8nVkc&?~&O83)5GbY)slt*#=)i7s;A<N)hyx
zwh^cOb?iKU)IbRP=ka+qf+JT_=N|faOQrq_JH^K1`TFgfF^F{DYfaT@vyY6ISleTm
zGL!<vL!F>_C=2r7N7+fk`X1KngTDCyUEafq@X5m_z1=DeiD@Q38P{+Ou8AdwgrjC5
zajlbj!7Ae^jZ~9GGnmvF%|dV*Siz7~1$lG}zFHP5%BV8TD09lQN!w79WRZ;`=PM(z
z0;YT`0PcRb5SM~SQ_OKjwTc~?W_G_IPe||U$;Um2U%fe+7X>%Nvy!xcXUbbT1miw0
z=$X7_W&m0ay!h~`ae>C68mu@al*ia7R0saqO=sn$tE@ww372nWLhU^>%{WE>Eoln8
zaeH(5Zly+xlW1Z@B{Z2HqS52V*oh`BC}k&quf19RS}N6$l#0qGWzl9DQkZ@85<PA+
zldE}FJS4PxXhbzMsRmrwaRz~V3QLN=WqdEEvulNbgjbr&&1P5w4PCwA3{?jrWGCM~
zX0DmWj<kYm`dP~kIl-=0KWu`Jc;838I{cbhtw0szBJu5{7M^n&!<`QEsTb#X9`$lT
z57Hwj9Ps0kuw}6a#aAGdM8Uyjl-gC)G1hP^b}DQCDLs;KR8(o5(@&tS<A5C%$Hu%&
zajcvfB#m7XUTidGKu@9pZHG2y*-%G$Ih9jXO6!k#h<t!VB52|u)nv~y!>(#UMH4E)
z!&hPrOmR$HRF*}2C{e3A#U3h9d)gN68^|>O9=TO4Ga~u#5kl0}_*QP9IxEl~Ce;Vj
zS3zvyQ+p-TKYiV8z>J$akDBH=i$W7}&)8|aN%_17$7$H|;eKWRKgAtrMwoyE;#kJp
z>iJ{R+d4p$2q2;Y5EBQ7>@E&mk*MzVW>!EDsQ9Pd1Icl|=0d^U2HU!hP6MLe0bwp2
zA=U!|OQM?{{^8dU?o^&w|I~Y5fw~zw)IT&*mzBRUy1Ljo^-=Z`fvN|N_J<BBAdS~k
z!ALu4Q%-z*R{oO&4hJxm{nHfwfAoO3sOznOQIr1~0QZdfH=zHAn6N<6r7+IV)Vf=N
z-qCbD?!=wp{X>gxG~k*Hc%03VftQZkoi*AD{-11-bt2%}_=-R;7ZY`jOzsFyAEWb!
zVJNLPL#@4|8iv-c@m4Lu!^Uc7?VOsDWty>@T6^QN67|~9P?w&boWVpR2)d)gI@s*$
zT0uPct)H#x^_Y(_q2El&g2<(pF8niAzCde(;c)XAp3awn@Z)3{qMO$l1?#O_cXL+a
zB+yS96Q;w{xIBw9%-h2xp$%a(D0`Noi$$31BbukCM_lu$4sG_+rWsH9U`eD0eY3t3
z@`vkyB5OW$_NhyNPE(&_JPvYO1XVd%SiaJPVza|ZguGogD*p`OzJ!Odk4wR7o=G7;
zQFEN*_9WQcO`Vliy5G@VCnZ;Qb~fJ44e1$o^Tw=L_lA;Z-8Dw0CC}X_m5Q_J*xP61
z2tVQGAnU9PA@k;{9QL{c=-~c_joC`W*8qxTI)7}foE-)SU;g6SD;S1P5oGCta0DrC
zGXz?khB$Fn{Ycwuk%t&RTyJ!Mz8mnC0U+AYu}PkaA-t-gE*25%;RVKNKyWz!scpu6
zZDKFBX5S4#lCQK!Ip%UxMsP%cC4T!8d`;mo#M{(B)h;Ilk3UVA`-O^+JuQDuUnt-K
z=jEH2NuzvVs7mGT0rJ;Nz54;;pVk-{O`o<8h5~yAG9cx)%sJ+#d0-B8j!9{+{>1@9
zYiz-m^g@6wE8^*umZD0JhIN!|&Ok-?2XhJ@B|oI&FfS^$rs90JhlZBoJW`e5b9j^-
zWO>uD9oB-o4QKEBn$akVeT1MeUX-s%#m~lP<b&9IWGgbi$*OIzpK_3n^}!I)WVooa
z#6_PWZ8QA$W_OwNhR51iZ{AQ8gp5IC_qMYoKTO<wW7Lxu951+0Q*<Z_wU3?^MX!Qs
zKFIi5(!_vxR?8&ce&YV47mZ8#83_LZ{o>XZR!_h7SU~%Y_rx{QlrO<RbvccdJya54
zEx3&41--x^p6UqQ4-K0v<iu-hD(5Xrz}`FaganW<;qBVLd$lhu5Wn*9nE3U4nha#d
zqjK-c{nPa2P{JRx8UPnyz`s1eOA2Taz`!T`m}fLvc<|5nl(qw*BvH~+UyPRhKzyrh
zxOKlLj5wBR=EU`4w)nCr{hTY!q<lpX5(s|w3QJ3;mfaaus{2>`$o+{oUb!PIS+x5N
z+{O+YLa6?IE1#&A?RMZ&J}!O!vj>Os^y>J_BMi^Cu8;>FP)!5eagStg`4k8`f<9)s
zLv>uniXJHc5tD}2a*xO+UycHT8lGykAS#<PAVxm$cbPxfCa|;$;o~~iE+XVlgHCw7
zC#7nl^r~{M*TsmN95D{cIk!IhJ_X-wC?{Y<`4dUpmRY}yVmTSPk&p-vIF$+M=~`b#
z6Xw_$9|qJhncu-46MlAh5ITV>tq7H&?$Q|yXO#aH{77;M;}%#Rn*u_i#Q#=kFoCjB
zxM)O)sW@_wx=K{lJ|iyESH0iv9Nr111eP3eEA!SenTb%U12{RS*7qj0=;%^Kd#QiJ
ziYTEU=jFY{zWsSqmqmw<7L@5T1o7NxWhht`9gu$(b|QZnjVAE)D;lyC=><hR)|0rK
z4G=-Wk9u*;^2!F@ZPDmuT=Fj`zK22q4P|a@naT2k6OIr&5bt7mM+Zi{1dh<!#Q+MV
zNV$%grklh|8>~hv=8piE3T9#-QVKCSaq-q&xr*zuRbfKtru+;Kkp5Si5+<6{tz}rp
zigZWmiiYYR#xdxCbhhJz=wN$k9zPcR8H;AJErv2><3*Bm51h&CEJlpT9yo<pH&s}f
zXzYb2r<w#K%?wiq#0>5`<Zq9U!x1gwEv^qA_gUtKoaUH|F#B+-I$;m;h@imuPKwTl
zn58Fdpf)L2vT#)zU+}?#P)g7lir`yLqN5l4uSh3fGa;S@>1`w{pnaAJ%0k=ISmg0E
zo$J6^H1-w0!^WV5w|yx36dtal`WN}DGpD-gqYjDTfjIaLtR}xxCDSo6v=}KHRM^9@
z&T;nw5x5ee(K3%Z3QQF%sMId_cIRpr&3g$f><9ZoX7X_c7g4f{y)mf(?;`TLI@jLv
z?N)ryzDJ)LsBZU+VnRH0X1E}KJ!}%#n_-<YL8nvAJG1pi@pQ)DNORI)b_#$>hEY9w
z`8(=7Fd9^wGY;{_ggJK@ZR?yW!1!^^d;F^x%}=DG(7K8XMm$L~K*Np|t>vZmA5%Y|
zINrWxnZFq_J7&ksTGEluekfNRCX$8u^xk+?w8Q1iII^7LA8Wc=uh=>E34C14fN(+~
zjb&LKSzG|ur8^cG=n*d|U)DK;5`-D7c>o{;1qb8{cYdL5^ll*Y29ag^ZWs(}{Dq?&
z7Vt6fu%BVSoqvD;RYW!I!KS^e-kCz_2@FvAByt<`2mpv<fkZr|^`JQiBI_`lhGk(!
z_N*Sb+Ln<Xn})Qgi4eM-7qPD_UOjLAm9k+61#g=VRLjj+Bq9RB{*-?aNH;_9hvInV
z1PSqXdP+6AuCc1VrYiH#W?-)Rn#1F?YJ)<4bv{8UexqS@(f!Bn_=kD5>xlE{aWp)%
z7->KZs4&!M+Z9|_;(Qr<M|^-9J`VLlA0T%cdqRyI>bPRGNC2zLU&;bq*v@zaDlNR7
zR!OB(0w7?XvMI3w1tc_A&fY$=RO&K>9q)K{?KeL9#X2nl`k!ouFF)XFC@Tui*%L4~
zwNvTu3}=K5TH;uDS!^k3d+!l_hx$f?(hkYU(6NBYx@mz*Y6dZ7D@JF^5^p{aiT5zv
z;Xjc--#|sw407DGZz<4^FBXBq5F)zwTQ|65$~FTfyft2wOiY&QG(ydKoz#wa?YKny
z)9C@EX0c#XN}}K5dNFdMNo^+Os>0sS^c;E5Ky4zm)q;>J{J+z3sdUj)7tN@@gZSf7
zJ|wiD$oI`e{Xe-gDV9P_(x}i7AaPVJn&m~NMi(84-RGbXy6@{lY?h66ze7!6Ee=i!
zInre-6PCHrI9+8v4+)Zge*esLVEy0*)t)o|)801Zf98hgQ=EZH2bpZ=)5NN_2yjw#
zP8Ewr(5WN{8DJpt*e!|G(gvZ5Pxywag$Agdns%%4+I<chK&;6@52mh48>H>|FMw9b
zKb<-v)*Cb*Ao~hb;B*`Ee&trZYBi`{$ru%gmKbuXcPNb3lD3H3Jimki7;BEFp{bxX
zFJ7Rk<~$d5(AGs1%w=$DDrj&3=?C4wX`U{m8^^=Z8R3YTB_A>ZA<nn`Er>OkmldWl
zwo0ZyTNCB`dfUZA+chm*()HWtA2!JQ3>g${<ZEUqmU&IH*$?ZzOs2IhHpYEix|NPQ
zJ-Pi715VXGJVDjN><!w*tid~hXaqgXjMCinP(wu6AN~G*C5MrlRjoO?J1hQ>8%Vr%
zasf==&095e)fG}M%iIsk{PaQ>2|D59ppz^2pExvb9Ou9EI^`kN!0aXr*u3p0ex0b4
z=AnHH#@v>`#o*LjN-yB0^^l)H2Nm=yD3|>1aNigv$f`s680kxF8B%d>SUG)YF0R~W
z$TI5rvll2~&q4RSwu3})*@1!~z4l}@NsY#MwV(2<h@*@k1>Y=hbLZh-ce*Eq3<#rZ
zxra}au9h@`-JaCDeW|)St?N40z`g~4rjZ?xu=?#W;cJyHNPXCV2DuxD%N1A2hAlFH
zwTJm(6XPn#dA&{dq>&yd{5Lp=pa<%$*em=~TdQ%rn_v#5`><qe0k3yPzhk;_7^Ch6
z``4jh8^vb#=_?9Hh_)q6T)5{?KdaF@G)h>I!IS>M^uNpl#N|wC@HMBcRTMT#SL;d7
z<(&BuA6dLkkx|8fWw@PXzCeCBgDx@HJs@)L+j8y~gZ<df6K`wk{>)7)${p-|O7{G?
z&|M6FI|A*^d_U+Of-3`+w(c~-YsQby|NH)g|G7xv|Nek^|Jex)g~z+)I0xPC0460S
LFIp>X81%mY^Bg|U

diff --git a/src/test/java/net/minecraft/network/VarIntLongTest.java b/src/test/java/net/minecraft/network/VarIntLongTest.java
new file mode 100644
index 0000000000000000000000000000000000000000..0c11670d8d7307307a7cd12be5d0dca40155829d
--- /dev/null
+++ b/src/test/java/net/minecraft/network/VarIntLongTest.java
@@ -0,0 +1,202 @@
+// Gale - Velocity - VarInt and VarLong optimizations
+
+package net.minecraft.network;
+
+import io.netty.buffer.Unpooled;
+import it.unimi.dsi.fastutil.ints.IntOpenHashSet;
+import it.unimi.dsi.fastutil.ints.IntSet;
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
+import it.unimi.dsi.fastutil.longs.LongSet;
+import org.junit.jupiter.api.Assertions;
+import org.junit.jupiter.api.Test;
+
+public class VarIntLongTest {
+
+    private static String padStringWithLeadingZeros(String string, int length) {
+        if (string.length() >= length) {
+            return string;
+        }
+        return "0".repeat(length - string.length()) + string;
+    }
+
+    private static final IntSet integerCases;
+    static {
+        integerCases = new IntOpenHashSet();
+        {
+            integerCases.add(0);
+            integerCases.add(-1);
+        }
+        {
+            for (int i = 0; i < 32; i++) {
+                integerCases.add(1 << i);
+            }
+        }
+        {
+            for (int factor = 1; factor <= 7; factor++) {
+                int all = 0;
+                for (int i = 0; i <= 4; i++) {
+                    int shifted = 1 << (i * factor);
+                    all |= shifted;
+                    integerCases.add(shifted);
+                    integerCases.add(shifted - 1);
+                    integerCases.add(~shifted);
+                    integerCases.add(-shifted);
+                    integerCases.add((~shifted) & (0x80000000));
+                    integerCases.add(all);
+                    integerCases.add(all - 1);
+                    integerCases.add(~all);
+                    integerCases.add(-all);
+                    integerCases.add((~all) & (0x80000000));
+                }
+            }
+        }
+        {
+            var newCases = new IntOpenHashSet();
+            for (int shiftSize = 2; shiftSize <= 6; shiftSize++) {
+                for (int offset = 0; offset < shiftSize; offset++) {
+                    int striped = 0;
+                    for (int i = offset; i < 32; i += shiftSize) {
+                        striped |= 1 << i;
+                    }
+                    final var finalStriped = striped;
+                    integerCases.forEach(existing -> {
+                        newCases.add(existing | finalStriped);
+                        newCases.add(existing | (~finalStriped));
+                        newCases.add(existing & finalStriped);
+                        newCases.add(existing & (~finalStriped));
+                        newCases.add(existing - finalStriped);
+                        newCases.add(existing - (~finalStriped));
+                    });
+                }
+            }
+            integerCases.addAll(newCases);
+        }
+    }
+
+    private static final LongSet longCases;
+    static {
+        longCases = new LongOpenHashSet();
+        {
+            longCases.add(0);
+            longCases.add(-1);
+        }
+        {
+            for (int i = 0; i < 64; i++) {
+                longCases.add(1L << i);
+            }
+        }
+        {
+            for (int factor = 1; factor <= 7; factor++) {
+                long all = 0;
+                for (int i = 0; i <= 9; i++) {
+                    long shifted = 1L << (i * factor);
+                    all |= shifted;
+                    longCases.add(shifted);
+                    longCases.add(shifted - 1);
+                    longCases.add(~shifted);
+                    longCases.add(-shifted);
+                    longCases.add((~shifted) & (0x8000000000000000L));
+                    longCases.add(all);
+                    longCases.add(all - 1);
+                    longCases.add(~all);
+                    longCases.add(-all);
+                    longCases.add((~all) & (0x8000000000000000L));
+                }
+            }
+        }
+        {
+            var newCases = new LongOpenHashSet();
+            for (int shiftSize = 2; shiftSize <= 6; shiftSize++) {
+                for (int offset = 0; offset < shiftSize; offset++) {
+                    long striped = 0;
+                    for (int i = offset; i < 64; i += shiftSize) {
+                        striped |= 1L << i;
+                    }
+                    final var finalStriped = striped;
+                    longCases.forEach(existing -> {
+                        newCases.add(existing | finalStriped);
+                        newCases.add(existing | (~finalStriped));
+                        newCases.add(existing & finalStriped);
+                        newCases.add(existing & (~finalStriped));
+                        newCases.add(existing - finalStriped);
+                        newCases.add(existing - (~finalStriped));
+                    });
+                }
+            }
+            longCases.addAll(newCases);
+        }
+    }
+
+    // Gale start - Velocity - pre-compute VarInt and VarLong sizes
+    @Test
+    public void testGetVarIntSizeComparedToOld() {
+        integerCases.forEach(value -> {
+            // given
+            int originalSize = VarInt.getByteSizeOld(value);
+
+            // when
+            int size = VarInt.getByteSize(value);
+
+            // then
+            Assertions.assertEquals(originalSize, size, "Optimized size (" + size + ") is not equal to original size (" + originalSize + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(value), 32) + ")");
+        });
+    }
+
+    @Test
+    public void testGetVarLongSizeComparedToOld() {
+        longCases.forEach(value -> {
+            // given
+            int originalSize = VarLong.getByteSizeOld(value);
+
+            // when
+            int size = VarLong.getByteSize(value);
+
+            // then
+            Assertions.assertEquals(originalSize, size, "Optimized size (" + size + ") is not equal to original size (" + originalSize + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Long.toBinaryString(value), 64) + ")");
+        });
+    }
+    // Gale end - Velocity - pre-compute VarInt and VarLong sizes
+
+    // Gale - Velocity - optimized VarInt#write and VarLong#write
+    @Test
+    public void testWriteVarIntComparedToOld() {
+        integerCases.forEach(value -> {
+            // given
+            int capacity = 5;
+            FriendlyByteBuf buf1 = new FriendlyByteBuf(Unpooled.buffer(capacity));
+            FriendlyByteBuf buf2 = new FriendlyByteBuf(Unpooled.buffer(capacity));
+            VarInt.writeOld(buf1, value);
+
+            // when
+            buf2.writeVarInt(value);
+
+            // then
+            Assertions.assertEquals(buf1.writerIndex(), buf2.writerIndex(), "Writer index of optimized buffer (" + buf2.writerIndex() + ") is not equal to writer index of original buffer (" + buf1.writerIndex() + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(value), 32) + ")");
+            for (int i = 0; i < capacity; i++) {
+                Assertions.assertEquals(buf1.getByte(i), buf2.getByte(i), "Buffer byte (at index " + i + ") in optimized buffer (" + buf2.getByte(i) + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(Byte.toUnsignedInt(buf2.getByte(i))), 8) + ")) is not equal to the same byte in original buffer (" + buf1.getByte(i) + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(Byte.toUnsignedInt(buf1.getByte(i))), 8) + ")) for test case value " + value + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(value), 32) + ")");
+            }
+        });
+    }
+
+    @Test
+    public void testWriteVarLongComparedToOld() {
+        longCases.forEach(value -> {
+            // given
+            int capacity = 10;
+            FriendlyByteBuf buf1 = new FriendlyByteBuf(Unpooled.buffer(capacity));
+            FriendlyByteBuf buf2 = new FriendlyByteBuf(Unpooled.buffer(capacity));
+            VarLong.writeOld(buf1, value);
+
+            // when
+            buf2.writeVarLong(value);
+
+            // then
+            Assertions.assertEquals(buf1.writerIndex(), buf2.writerIndex(), "Writer index of optimized buffer (" + buf2.writerIndex() + ") is not equal to writer index of original buffer (" + buf1.writerIndex() + ") for test case value " + value + " (binary: " + padStringWithLeadingZeros(Long.toBinaryString(value), 64) + ")");
+            for (int i = 0; i < capacity; i++) {
+                Assertions.assertEquals(buf1.getByte(i), buf2.getByte(i), "Buffer byte (at index " + i + ") in optimized buffer (" + buf2.getByte(i) + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(Byte.toUnsignedInt(buf2.getByte(i))), 8) + ")) is not equal to the same byte in original buffer (" + buf1.getByte(i) + " (binary: " + padStringWithLeadingZeros(Integer.toBinaryString(Byte.toUnsignedInt(buf1.getByte(i))), 8) + ")) for test case value " + value + " (binary: " + padStringWithLeadingZeros(Long.toBinaryString(value), 64) + ")");
+            }
+        });
+    }
+    // Gale end - Velocity - optimized VarInt#write and VarLong#write
+
+}
